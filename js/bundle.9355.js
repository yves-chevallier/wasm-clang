"use strict";(self.webpackChunksandbox=self.webpackChunksandbox||[]).push([[9355],{59355:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Adapter: () => (/* binding */ Adapter),\n/* harmony export */   CodeActionAdaptor: () => (/* binding */ CodeActionAdaptor),\n/* harmony export */   DefinitionAdapter: () => (/* binding */ DefinitionAdapter),\n/* harmony export */   DiagnosticsAdapter: () => (/* binding */ DiagnosticsAdapter),\n/* harmony export */   DocumentHighlightAdapter: () => (/* binding */ DocumentHighlightAdapter),\n/* harmony export */   FormatAdapter: () => (/* binding */ FormatAdapter),\n/* harmony export */   FormatHelper: () => (/* binding */ FormatHelper),\n/* harmony export */   FormatOnTypeAdapter: () => (/* binding */ FormatOnTypeAdapter),\n/* harmony export */   InlayHintsAdapter: () => (/* binding */ InlayHintsAdapter),\n/* harmony export */   Kind: () => (/* binding */ Kind),\n/* harmony export */   LibFiles: () => (/* binding */ LibFiles),\n/* harmony export */   OutlineAdapter: () => (/* binding */ OutlineAdapter),\n/* harmony export */   QuickInfoAdapter: () => (/* binding */ QuickInfoAdapter),\n/* harmony export */   ReferenceAdapter: () => (/* binding */ ReferenceAdapter),\n/* harmony export */   RenameAdapter: () => (/* binding */ RenameAdapter),\n/* harmony export */   SignatureHelpAdapter: () => (/* binding */ SignatureHelpAdapter),\n/* harmony export */   SuggestAdapter: () => (/* binding */ SuggestAdapter),\n/* harmony export */   WorkerManager: () => (/* binding */ WorkerManager),\n/* harmony export */   flattenDiagnosticMessageText: () => (/* binding */ flattenDiagnosticMessageText),\n/* harmony export */   getJavaScriptWorker: () => (/* binding */ getJavaScriptWorker),\n/* harmony export */   getTypeScriptWorker: () => (/* binding */ getTypeScriptWorker),\n/* harmony export */   setupJavaScript: () => (/* binding */ setupJavaScript),\n/* harmony export */   setupTypeScript: () => (/* binding */ setupTypeScript)\n/* harmony export */ });\n/* harmony import */ var _editor_editor_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41925);\n/* harmony import */ var _monaco_contribution_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19664);\n/*!-----------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Version: 0.50.0(c321d0fbecb50ab8a5365fa1965476b0ae63fc87)\n * Released under the MIT license\n * https://github.com/microsoft/monaco-editor/blob/main/LICENSE.txt\n *-----------------------------------------------------------------------------*/\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));\n\n// src/fillers/monaco-editor-core.ts\nvar monaco_editor_core_exports = {};\n__reExport(monaco_editor_core_exports, _editor_editor_api_js__WEBPACK_IMPORTED_MODULE_0__);\n\n\n// src/language/typescript/workerManager.ts\nvar WorkerManager = class {\n  constructor(_modeId, _defaults) {\n    this._modeId = _modeId;\n    this._defaults = _defaults;\n    this._worker = null;\n    this._client = null;\n    this._configChangeListener = this._defaults.onDidChange(() => this._stopWorker());\n    this._updateExtraLibsToken = 0;\n    this._extraLibsChangeListener = this._defaults.onDidExtraLibsChange(\n      () => this._updateExtraLibs()\n    );\n  }\n  dispose() {\n    this._configChangeListener.dispose();\n    this._extraLibsChangeListener.dispose();\n    this._stopWorker();\n  }\n  _stopWorker() {\n    if (this._worker) {\n      this._worker.dispose();\n      this._worker = null;\n    }\n    this._client = null;\n  }\n  async _updateExtraLibs() {\n    if (!this._worker) {\n      return;\n    }\n    const myToken = ++this._updateExtraLibsToken;\n    const proxy = await this._worker.getProxy();\n    if (this._updateExtraLibsToken !== myToken) {\n      return;\n    }\n    proxy.updateExtraLibs(this._defaults.getExtraLibs());\n  }\n  _getClient() {\n    if (!this._client) {\n      this._client = (async () => {\n        this._worker = monaco_editor_core_exports.editor.createWebWorker({\n          // module that exports the create() method and returns a `TypeScriptWorker` instance\n          moduleId: "vs/language/typescript/tsWorker",\n          label: this._modeId,\n          keepIdleModels: true,\n          // passed in to the create() method\n          createData: {\n            compilerOptions: this._defaults.getCompilerOptions(),\n            extraLibs: this._defaults.getExtraLibs(),\n            customWorkerPath: this._defaults.workerOptions.customWorkerPath,\n            inlayHintsOptions: this._defaults.inlayHintsOptions\n          }\n        });\n        if (this._defaults.getEagerModelSync()) {\n          return await this._worker.withSyncedResources(\n            monaco_editor_core_exports.editor.getModels().filter((model) => model.getLanguageId() === this._modeId).map((model) => model.uri)\n          );\n        }\n        return await this._worker.getProxy();\n      })();\n    }\n    return this._client;\n  }\n  async getLanguageServiceWorker(...resources) {\n    const client = await this._getClient();\n    if (this._worker) {\n      await this._worker.withSyncedResources(resources);\n    }\n    return client;\n  }\n};\n\n// src/language/typescript/languageFeatures.ts\n\n\n// src/language/typescript/lib/lib.index.ts\nvar libFileSet = {};\nlibFileSet["lib.d.ts"] = true;\nlibFileSet["lib.decorators.d.ts"] = true;\nlibFileSet["lib.decorators.legacy.d.ts"] = true;\nlibFileSet["lib.dom.asynciterable.d.ts"] = true;\nlibFileSet["lib.dom.d.ts"] = true;\nlibFileSet["lib.dom.iterable.d.ts"] = true;\nlibFileSet["lib.es2015.collection.d.ts"] = true;\nlibFileSet["lib.es2015.core.d.ts"] = true;\nlibFileSet["lib.es2015.d.ts"] = true;\nlibFileSet["lib.es2015.generator.d.ts"] = true;\nlibFileSet["lib.es2015.iterable.d.ts"] = true;\nlibFileSet["lib.es2015.promise.d.ts"] = true;\nlibFileSet["lib.es2015.proxy.d.ts"] = true;\nlibFileSet["lib.es2015.reflect.d.ts"] = true;\nlibFileSet["lib.es2015.symbol.d.ts"] = true;\nlibFileSet["lib.es2015.symbol.wellknown.d.ts"] = true;\nlibFileSet["lib.es2016.array.include.d.ts"] = true;\nlibFileSet["lib.es2016.d.ts"] = true;\nlibFileSet["lib.es2016.full.d.ts"] = true;\nlibFileSet["lib.es2016.intl.d.ts"] = true;\nlibFileSet["lib.es2017.d.ts"] = true;\nlibFileSet["lib.es2017.date.d.ts"] = true;\nlibFileSet["lib.es2017.full.d.ts"] = true;\nlibFileSet["lib.es2017.intl.d.ts"] = true;\nlibFileSet["lib.es2017.object.d.ts"] = true;\nlibFileSet["lib.es2017.sharedmemory.d.ts"] = true;\nlibFileSet["lib.es2017.string.d.ts"] = true;\nlibFileSet["lib.es2017.typedarrays.d.ts"] = true;\nlibFileSet["lib.es2018.asyncgenerator.d.ts"] = true;\nlibFileSet["lib.es2018.asynciterable.d.ts"] = true;\nlibFileSet["lib.es2018.d.ts"] = true;\nlibFileSet["lib.es2018.full.d.ts"] = true;\nlibFileSet["lib.es2018.intl.d.ts"] = true;\nlibFileSet["lib.es2018.promise.d.ts"] = true;\nlibFileSet["lib.es2018.regexp.d.ts"] = true;\nlibFileSet["lib.es2019.array.d.ts"] = true;\nlibFileSet["lib.es2019.d.ts"] = true;\nlibFileSet["lib.es2019.full.d.ts"] = true;\nlibFileSet["lib.es2019.intl.d.ts"] = true;\nlibFileSet["lib.es2019.object.d.ts"] = true;\nlibFileSet["lib.es2019.string.d.ts"] = true;\nlibFileSet["lib.es2019.symbol.d.ts"] = true;\nlibFileSet["lib.es2020.bigint.d.ts"] = true;\nlibFileSet["lib.es2020.d.ts"] = true;\nlibFileSet["lib.es2020.date.d.ts"] = true;\nlibFileSet["lib.es2020.full.d.ts"] = true;\nlibFileSet["lib.es2020.intl.d.ts"] = true;\nlibFileSet["lib.es2020.number.d.ts"] = true;\nlibFileSet["lib.es2020.promise.d.ts"] = true;\nlibFileSet["lib.es2020.sharedmemory.d.ts"] = true;\nlibFileSet["lib.es2020.string.d.ts"] = true;\nlibFileSet["lib.es2020.symbol.wellknown.d.ts"] = true;\nlibFileSet["lib.es2021.d.ts"] = true;\nlibFileSet["lib.es2021.full.d.ts"] = true;\nlibFileSet["lib.es2021.intl.d.ts"] = true;\nlibFileSet["lib.es2021.promise.d.ts"] = true;\nlibFileSet["lib.es2021.string.d.ts"] = true;\nlibFileSet["lib.es2021.weakref.d.ts"] = true;\nlibFileSet["lib.es2022.array.d.ts"] = true;\nlibFileSet["lib.es2022.d.ts"] = true;\nlibFileSet["lib.es2022.error.d.ts"] = true;\nlibFileSet["lib.es2022.full.d.ts"] = true;\nlibFileSet["lib.es2022.intl.d.ts"] = true;\nlibFileSet["lib.es2022.object.d.ts"] = true;\nlibFileSet["lib.es2022.regexp.d.ts"] = true;\nlibFileSet["lib.es2022.sharedmemory.d.ts"] = true;\nlibFileSet["lib.es2022.string.d.ts"] = true;\nlibFileSet["lib.es2023.array.d.ts"] = true;\nlibFileSet["lib.es2023.collection.d.ts"] = true;\nlibFileSet["lib.es2023.d.ts"] = true;\nlibFileSet["lib.es2023.full.d.ts"] = true;\nlibFileSet["lib.es5.d.ts"] = true;\nlibFileSet["lib.es6.d.ts"] = true;\nlibFileSet["lib.esnext.collection.d.ts"] = true;\nlibFileSet["lib.esnext.d.ts"] = true;\nlibFileSet["lib.esnext.decorators.d.ts"] = true;\nlibFileSet["lib.esnext.disposable.d.ts"] = true;\nlibFileSet["lib.esnext.full.d.ts"] = true;\nlibFileSet["lib.esnext.intl.d.ts"] = true;\nlibFileSet["lib.esnext.object.d.ts"] = true;\nlibFileSet["lib.esnext.promise.d.ts"] = true;\nlibFileSet["lib.scripthost.d.ts"] = true;\nlibFileSet["lib.webworker.asynciterable.d.ts"] = true;\nlibFileSet["lib.webworker.d.ts"] = true;\nlibFileSet["lib.webworker.importscripts.d.ts"] = true;\nlibFileSet["lib.webworker.iterable.d.ts"] = true;\n\n// src/language/typescript/languageFeatures.ts\nfunction flattenDiagnosticMessageText(diag, newLine, indent = 0) {\n  if (typeof diag === "string") {\n    return diag;\n  } else if (diag === void 0) {\n    return "";\n  }\n  let result = "";\n  if (indent) {\n    result += newLine;\n    for (let i = 0; i < indent; i++) {\n      result += "  ";\n    }\n  }\n  result += diag.messageText;\n  indent++;\n  if (diag.next) {\n    for (const kid of diag.next) {\n      result += flattenDiagnosticMessageText(kid, newLine, indent);\n    }\n  }\n  return result;\n}\nfunction displayPartsToString(displayParts) {\n  if (displayParts) {\n    return displayParts.map((displayPart) => displayPart.text).join("");\n  }\n  return "";\n}\nvar Adapter = class {\n  constructor(_worker) {\n    this._worker = _worker;\n  }\n  // protected _positionToOffset(model: editor.ITextModel, position: monaco.IPosition): number {\n  // \treturn model.getOffsetAt(position);\n  // }\n  // protected _offsetToPosition(model: editor.ITextModel, offset: number): monaco.IPosition {\n  // \treturn model.getPositionAt(offset);\n  // }\n  _textSpanToRange(model, span) {\n    let p1 = model.getPositionAt(span.start);\n    let p2 = model.getPositionAt(span.start + span.length);\n    let { lineNumber: startLineNumber, column: startColumn } = p1;\n    let { lineNumber: endLineNumber, column: endColumn } = p2;\n    return { startLineNumber, startColumn, endLineNumber, endColumn };\n  }\n};\nvar LibFiles = class {\n  constructor(_worker) {\n    this._worker = _worker;\n    this._libFiles = {};\n    this._hasFetchedLibFiles = false;\n    this._fetchLibFilesPromise = null;\n  }\n  isLibFile(uri) {\n    if (!uri) {\n      return false;\n    }\n    if (uri.path.indexOf("/lib.") === 0) {\n      return !!libFileSet[uri.path.slice(1)];\n    }\n    return false;\n  }\n  getOrCreateModel(fileName) {\n    const uri = monaco_editor_core_exports.Uri.parse(fileName);\n    const model = monaco_editor_core_exports.editor.getModel(uri);\n    if (model) {\n      return model;\n    }\n    if (this.isLibFile(uri) && this._hasFetchedLibFiles) {\n      return monaco_editor_core_exports.editor.createModel(this._libFiles[uri.path.slice(1)], "typescript", uri);\n    }\n    const matchedLibFile = _monaco_contribution_js__WEBPACK_IMPORTED_MODULE_1__/* .typescriptDefaults */ .IF.getExtraLibs()[fileName];\n    if (matchedLibFile) {\n      return monaco_editor_core_exports.editor.createModel(matchedLibFile.content, "typescript", uri);\n    }\n    return null;\n  }\n  _containsLibFile(uris) {\n    for (let uri of uris) {\n      if (this.isLibFile(uri)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async fetchLibFilesIfNecessary(uris) {\n    if (!this._containsLibFile(uris)) {\n      return;\n    }\n    await this._fetchLibFiles();\n  }\n  _fetchLibFiles() {\n    if (!this._fetchLibFilesPromise) {\n      this._fetchLibFilesPromise = this._worker().then((w) => w.getLibFiles()).then((libFiles) => {\n        this._hasFetchedLibFiles = true;\n        this._libFiles = libFiles;\n      });\n    }\n    return this._fetchLibFilesPromise;\n  }\n};\nvar DiagnosticsAdapter = class extends Adapter {\n  constructor(_libFiles, _defaults, _selector, worker) {\n    super(worker);\n    this._libFiles = _libFiles;\n    this._defaults = _defaults;\n    this._selector = _selector;\n    this._disposables = [];\n    this._listener = /* @__PURE__ */ Object.create(null);\n    const onModelAdd = (model) => {\n      if (model.getLanguageId() !== _selector) {\n        return;\n      }\n      const maybeValidate = () => {\n        const { onlyVisible } = this._defaults.getDiagnosticsOptions();\n        if (onlyVisible) {\n          if (model.isAttachedToEditor()) {\n            this._doValidate(model);\n          }\n        } else {\n          this._doValidate(model);\n        }\n      };\n      let handle;\n      const changeSubscription = model.onDidChangeContent(() => {\n        clearTimeout(handle);\n        handle = window.setTimeout(maybeValidate, 500);\n      });\n      const visibleSubscription = model.onDidChangeAttached(() => {\n        const { onlyVisible } = this._defaults.getDiagnosticsOptions();\n        if (onlyVisible) {\n          if (model.isAttachedToEditor()) {\n            maybeValidate();\n          } else {\n            monaco_editor_core_exports.editor.setModelMarkers(model, this._selector, []);\n          }\n        }\n      });\n      this._listener[model.uri.toString()] = {\n        dispose() {\n          changeSubscription.dispose();\n          visibleSubscription.dispose();\n          clearTimeout(handle);\n        }\n      };\n      maybeValidate();\n    };\n    const onModelRemoved = (model) => {\n      monaco_editor_core_exports.editor.setModelMarkers(model, this._selector, []);\n      const key = model.uri.toString();\n      if (this._listener[key]) {\n        this._listener[key].dispose();\n        delete this._listener[key];\n      }\n    };\n    this._disposables.push(\n      monaco_editor_core_exports.editor.onDidCreateModel((model) => onModelAdd(model))\n    );\n    this._disposables.push(monaco_editor_core_exports.editor.onWillDisposeModel(onModelRemoved));\n    this._disposables.push(\n      monaco_editor_core_exports.editor.onDidChangeModelLanguage((event) => {\n        onModelRemoved(event.model);\n        onModelAdd(event.model);\n      })\n    );\n    this._disposables.push({\n      dispose() {\n        for (const model of monaco_editor_core_exports.editor.getModels()) {\n          onModelRemoved(model);\n        }\n      }\n    });\n    const recomputeDiagostics = () => {\n      for (const model of monaco_editor_core_exports.editor.getModels()) {\n        onModelRemoved(model);\n        onModelAdd(model);\n      }\n    };\n    this._disposables.push(this._defaults.onDidChange(recomputeDiagostics));\n    this._disposables.push(this._defaults.onDidExtraLibsChange(recomputeDiagostics));\n    monaco_editor_core_exports.editor.getModels().forEach((model) => onModelAdd(model));\n  }\n  dispose() {\n    this._disposables.forEach((d) => d && d.dispose());\n    this._disposables = [];\n  }\n  async _doValidate(model) {\n    const worker = await this._worker(model.uri);\n    if (model.isDisposed()) {\n      return;\n    }\n    const promises = [];\n    const { noSyntaxValidation, noSemanticValidation, noSuggestionDiagnostics } = this._defaults.getDiagnosticsOptions();\n    if (!noSyntaxValidation) {\n      promises.push(worker.getSyntacticDiagnostics(model.uri.toString()));\n    }\n    if (!noSemanticValidation) {\n      promises.push(worker.getSemanticDiagnostics(model.uri.toString()));\n    }\n    if (!noSuggestionDiagnostics) {\n      promises.push(worker.getSuggestionDiagnostics(model.uri.toString()));\n    }\n    const allDiagnostics = await Promise.all(promises);\n    if (!allDiagnostics || model.isDisposed()) {\n      return;\n    }\n    const diagnostics = allDiagnostics.reduce((p, c) => c.concat(p), []).filter(\n      (d) => (this._defaults.getDiagnosticsOptions().diagnosticCodesToIgnore || []).indexOf(d.code) === -1\n    );\n    const relatedUris = diagnostics.map((d) => d.relatedInformation || []).reduce((p, c) => c.concat(p), []).map(\n      (relatedInformation) => relatedInformation.file ? monaco_editor_core_exports.Uri.parse(relatedInformation.file.fileName) : null\n    );\n    await this._libFiles.fetchLibFilesIfNecessary(relatedUris);\n    if (model.isDisposed()) {\n      return;\n    }\n    monaco_editor_core_exports.editor.setModelMarkers(\n      model,\n      this._selector,\n      diagnostics.map((d) => this._convertDiagnostics(model, d))\n    );\n  }\n  _convertDiagnostics(model, diag) {\n    const diagStart = diag.start || 0;\n    const diagLength = diag.length || 1;\n    const { lineNumber: startLineNumber, column: startColumn } = model.getPositionAt(diagStart);\n    const { lineNumber: endLineNumber, column: endColumn } = model.getPositionAt(\n      diagStart + diagLength\n    );\n    const tags = [];\n    if (diag.reportsUnnecessary) {\n      tags.push(monaco_editor_core_exports.MarkerTag.Unnecessary);\n    }\n    if (diag.reportsDeprecated) {\n      tags.push(monaco_editor_core_exports.MarkerTag.Deprecated);\n    }\n    return {\n      severity: this._tsDiagnosticCategoryToMarkerSeverity(diag.category),\n      startLineNumber,\n      startColumn,\n      endLineNumber,\n      endColumn,\n      message: flattenDiagnosticMessageText(diag.messageText, "\\n"),\n      code: diag.code.toString(),\n      tags,\n      relatedInformation: this._convertRelatedInformation(model, diag.relatedInformation)\n    };\n  }\n  _convertRelatedInformation(model, relatedInformation) {\n    if (!relatedInformation) {\n      return [];\n    }\n    const result = [];\n    relatedInformation.forEach((info) => {\n      let relatedResource = model;\n      if (info.file) {\n        relatedResource = this._libFiles.getOrCreateModel(info.file.fileName);\n      }\n      if (!relatedResource) {\n        return;\n      }\n      const infoStart = info.start || 0;\n      const infoLength = info.length || 1;\n      const { lineNumber: startLineNumber, column: startColumn } = relatedResource.getPositionAt(infoStart);\n      const { lineNumber: endLineNumber, column: endColumn } = relatedResource.getPositionAt(\n        infoStart + infoLength\n      );\n      result.push({\n        resource: relatedResource.uri,\n        startLineNumber,\n        startColumn,\n        endLineNumber,\n        endColumn,\n        message: flattenDiagnosticMessageText(info.messageText, "\\n")\n      });\n    });\n    return result;\n  }\n  _tsDiagnosticCategoryToMarkerSeverity(category) {\n    switch (category) {\n      case 1 /* Error */:\n        return monaco_editor_core_exports.MarkerSeverity.Error;\n      case 3 /* Message */:\n        return monaco_editor_core_exports.MarkerSeverity.Info;\n      case 0 /* Warning */:\n        return monaco_editor_core_exports.MarkerSeverity.Warning;\n      case 2 /* Suggestion */:\n        return monaco_editor_core_exports.MarkerSeverity.Hint;\n    }\n    return monaco_editor_core_exports.MarkerSeverity.Info;\n  }\n};\nvar SuggestAdapter = class _SuggestAdapter extends Adapter {\n  get triggerCharacters() {\n    return ["."];\n  }\n  async provideCompletionItems(model, position, _context, token) {\n    const wordInfo = model.getWordUntilPosition(position);\n    const wordRange = new monaco_editor_core_exports.Range(\n      position.lineNumber,\n      wordInfo.startColumn,\n      position.lineNumber,\n      wordInfo.endColumn\n    );\n    const resource = model.uri;\n    const offset = model.getOffsetAt(position);\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const info = await worker.getCompletionsAtPosition(resource.toString(), offset);\n    if (!info || model.isDisposed()) {\n      return;\n    }\n    const suggestions = info.entries.map((entry) => {\n      let range = wordRange;\n      if (entry.replacementSpan) {\n        const p1 = model.getPositionAt(entry.replacementSpan.start);\n        const p2 = model.getPositionAt(entry.replacementSpan.start + entry.replacementSpan.length);\n        range = new monaco_editor_core_exports.Range(p1.lineNumber, p1.column, p2.lineNumber, p2.column);\n      }\n      const tags = [];\n      if (entry.kindModifiers !== void 0 && entry.kindModifiers.indexOf("deprecated") !== -1) {\n        tags.push(monaco_editor_core_exports.languages.CompletionItemTag.Deprecated);\n      }\n      return {\n        uri: resource,\n        position,\n        offset,\n        range,\n        label: entry.name,\n        insertText: entry.name,\n        sortText: entry.sortText,\n        kind: _SuggestAdapter.convertKind(entry.kind),\n        tags\n      };\n    });\n    return {\n      suggestions\n    };\n  }\n  async resolveCompletionItem(item, token) {\n    const myItem = item;\n    const resource = myItem.uri;\n    const position = myItem.position;\n    const offset = myItem.offset;\n    const worker = await this._worker(resource);\n    const details = await worker.getCompletionEntryDetails(\n      resource.toString(),\n      offset,\n      myItem.label\n    );\n    if (!details) {\n      return myItem;\n    }\n    return {\n      uri: resource,\n      position,\n      label: details.name,\n      kind: _SuggestAdapter.convertKind(details.kind),\n      detail: displayPartsToString(details.displayParts),\n      documentation: {\n        value: _SuggestAdapter.createDocumentationString(details)\n      }\n    };\n  }\n  static convertKind(kind) {\n    switch (kind) {\n      case Kind.primitiveType:\n      case Kind.keyword:\n        return monaco_editor_core_exports.languages.CompletionItemKind.Keyword;\n      case Kind.variable:\n      case Kind.localVariable:\n        return monaco_editor_core_exports.languages.CompletionItemKind.Variable;\n      case Kind.memberVariable:\n      case Kind.memberGetAccessor:\n      case Kind.memberSetAccessor:\n        return monaco_editor_core_exports.languages.CompletionItemKind.Field;\n      case Kind.function:\n      case Kind.memberFunction:\n      case Kind.constructSignature:\n      case Kind.callSignature:\n      case Kind.indexSignature:\n        return monaco_editor_core_exports.languages.CompletionItemKind.Function;\n      case Kind.enum:\n        return monaco_editor_core_exports.languages.CompletionItemKind.Enum;\n      case Kind.module:\n        return monaco_editor_core_exports.languages.CompletionItemKind.Module;\n      case Kind.class:\n        return monaco_editor_core_exports.languages.CompletionItemKind.Class;\n      case Kind.interface:\n        return monaco_editor_core_exports.languages.CompletionItemKind.Interface;\n      case Kind.warning:\n        return monaco_editor_core_exports.languages.CompletionItemKind.File;\n    }\n    return monaco_editor_core_exports.languages.CompletionItemKind.Property;\n  }\n  static createDocumentationString(details) {\n    let documentationString = displayPartsToString(details.documentation);\n    if (details.tags) {\n      for (const tag of details.tags) {\n        documentationString += `\n\n${tagToString(tag)}`;\n      }\n    }\n    return documentationString;\n  }\n};\nfunction tagToString(tag) {\n  let tagLabel = `*@${tag.name}*`;\n  if (tag.name === "param" && tag.text) {\n    const [paramName, ...rest] = tag.text;\n    tagLabel += `\\`${paramName.text}\\``;\n    if (rest.length > 0)\n      tagLabel += ` \\u2014 ${rest.map((r) => r.text).join(" ")}`;\n  } else if (Array.isArray(tag.text)) {\n    tagLabel += ` \\u2014 ${tag.text.map((r) => r.text).join(" ")}`;\n  } else if (tag.text) {\n    tagLabel += ` \\u2014 ${tag.text}`;\n  }\n  return tagLabel;\n}\nvar SignatureHelpAdapter = class _SignatureHelpAdapter extends Adapter {\n  constructor() {\n    super(...arguments);\n    this.signatureHelpTriggerCharacters = ["(", ","];\n  }\n  static _toSignatureHelpTriggerReason(context) {\n    switch (context.triggerKind) {\n      case monaco_editor_core_exports.languages.SignatureHelpTriggerKind.TriggerCharacter:\n        if (context.triggerCharacter) {\n          if (context.isRetrigger) {\n            return { kind: "retrigger", triggerCharacter: context.triggerCharacter };\n          } else {\n            return { kind: "characterTyped", triggerCharacter: context.triggerCharacter };\n          }\n        } else {\n          return { kind: "invoked" };\n        }\n      case monaco_editor_core_exports.languages.SignatureHelpTriggerKind.ContentChange:\n        return context.isRetrigger ? { kind: "retrigger" } : { kind: "invoked" };\n      case monaco_editor_core_exports.languages.SignatureHelpTriggerKind.Invoke:\n      default:\n        return { kind: "invoked" };\n    }\n  }\n  async provideSignatureHelp(model, position, token, context) {\n    const resource = model.uri;\n    const offset = model.getOffsetAt(position);\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const info = await worker.getSignatureHelpItems(resource.toString(), offset, {\n      triggerReason: _SignatureHelpAdapter._toSignatureHelpTriggerReason(context)\n    });\n    if (!info || model.isDisposed()) {\n      return;\n    }\n    const ret = {\n      activeSignature: info.selectedItemIndex,\n      activeParameter: info.argumentIndex,\n      signatures: []\n    };\n    info.items.forEach((item) => {\n      const signature = {\n        label: "",\n        parameters: []\n      };\n      signature.documentation = {\n        value: displayPartsToString(item.documentation)\n      };\n      signature.label += displayPartsToString(item.prefixDisplayParts);\n      item.parameters.forEach((p, i, a) => {\n        const label = displayPartsToString(p.displayParts);\n        const parameter = {\n          label,\n          documentation: {\n            value: displayPartsToString(p.documentation)\n          }\n        };\n        signature.label += label;\n        signature.parameters.push(parameter);\n        if (i < a.length - 1) {\n          signature.label += displayPartsToString(item.separatorDisplayParts);\n        }\n      });\n      signature.label += displayPartsToString(item.suffixDisplayParts);\n      ret.signatures.push(signature);\n    });\n    return {\n      value: ret,\n      dispose() {\n      }\n    };\n  }\n};\nvar QuickInfoAdapter = class extends Adapter {\n  async provideHover(model, position, token) {\n    const resource = model.uri;\n    const offset = model.getOffsetAt(position);\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const info = await worker.getQuickInfoAtPosition(resource.toString(), offset);\n    if (!info || model.isDisposed()) {\n      return;\n    }\n    const documentation = displayPartsToString(info.documentation);\n    const tags = info.tags ? info.tags.map((tag) => tagToString(tag)).join("  \\n\\n") : "";\n    const contents = displayPartsToString(info.displayParts);\n    return {\n      range: this._textSpanToRange(model, info.textSpan),\n      contents: [\n        {\n          value: "```typescript\\n" + contents + "\\n```\\n"\n        },\n        {\n          value: documentation + (tags ? "\\n\\n" + tags : "")\n        }\n      ]\n    };\n  }\n};\nvar DocumentHighlightAdapter = class extends Adapter {\n  async provideDocumentHighlights(model, position, token) {\n    const resource = model.uri;\n    const offset = model.getOffsetAt(position);\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const entries = await worker.getDocumentHighlights(resource.toString(), offset, [\n      resource.toString()\n    ]);\n    if (!entries || model.isDisposed()) {\n      return;\n    }\n    return entries.flatMap((entry) => {\n      return entry.highlightSpans.map((highlightSpans) => {\n        return {\n          range: this._textSpanToRange(model, highlightSpans.textSpan),\n          kind: highlightSpans.kind === "writtenReference" ? monaco_editor_core_exports.languages.DocumentHighlightKind.Write : monaco_editor_core_exports.languages.DocumentHighlightKind.Text\n        };\n      });\n    });\n  }\n};\nvar DefinitionAdapter = class extends Adapter {\n  constructor(_libFiles, worker) {\n    super(worker);\n    this._libFiles = _libFiles;\n  }\n  async provideDefinition(model, position, token) {\n    const resource = model.uri;\n    const offset = model.getOffsetAt(position);\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const entries = await worker.getDefinitionAtPosition(resource.toString(), offset);\n    if (!entries || model.isDisposed()) {\n      return;\n    }\n    await this._libFiles.fetchLibFilesIfNecessary(\n      entries.map((entry) => monaco_editor_core_exports.Uri.parse(entry.fileName))\n    );\n    if (model.isDisposed()) {\n      return;\n    }\n    const result = [];\n    for (let entry of entries) {\n      const refModel = this._libFiles.getOrCreateModel(entry.fileName);\n      if (refModel) {\n        result.push({\n          uri: refModel.uri,\n          range: this._textSpanToRange(refModel, entry.textSpan)\n        });\n      }\n    }\n    return result;\n  }\n};\nvar ReferenceAdapter = class extends Adapter {\n  constructor(_libFiles, worker) {\n    super(worker);\n    this._libFiles = _libFiles;\n  }\n  async provideReferences(model, position, context, token) {\n    const resource = model.uri;\n    const offset = model.getOffsetAt(position);\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const entries = await worker.getReferencesAtPosition(resource.toString(), offset);\n    if (!entries || model.isDisposed()) {\n      return;\n    }\n    await this._libFiles.fetchLibFilesIfNecessary(\n      entries.map((entry) => monaco_editor_core_exports.Uri.parse(entry.fileName))\n    );\n    if (model.isDisposed()) {\n      return;\n    }\n    const result = [];\n    for (let entry of entries) {\n      const refModel = this._libFiles.getOrCreateModel(entry.fileName);\n      if (refModel) {\n        result.push({\n          uri: refModel.uri,\n          range: this._textSpanToRange(refModel, entry.textSpan)\n        });\n      }\n    }\n    return result;\n  }\n};\nvar OutlineAdapter = class extends Adapter {\n  async provideDocumentSymbols(model, token) {\n    const resource = model.uri;\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const root = await worker.getNavigationTree(resource.toString());\n    if (!root || model.isDisposed()) {\n      return;\n    }\n    const convert = (item, containerLabel) => {\n      const result2 = {\n        name: item.text,\n        detail: "",\n        kind: outlineTypeTable[item.kind] || monaco_editor_core_exports.languages.SymbolKind.Variable,\n        range: this._textSpanToRange(model, item.spans[0]),\n        selectionRange: this._textSpanToRange(model, item.spans[0]),\n        tags: [],\n        children: item.childItems?.map((child) => convert(child, item.text)),\n        containerName: containerLabel\n      };\n      return result2;\n    };\n    const result = root.childItems ? root.childItems.map((item) => convert(item)) : [];\n    return result;\n  }\n};\nvar Kind = class {\n  static {\n    this.unknown = "";\n  }\n  static {\n    this.keyword = "keyword";\n  }\n  static {\n    this.script = "script";\n  }\n  static {\n    this.module = "module";\n  }\n  static {\n    this.class = "class";\n  }\n  static {\n    this.interface = "interface";\n  }\n  static {\n    this.type = "type";\n  }\n  static {\n    this.enum = "enum";\n  }\n  static {\n    this.variable = "var";\n  }\n  static {\n    this.localVariable = "local var";\n  }\n  static {\n    this.function = "function";\n  }\n  static {\n    this.localFunction = "local function";\n  }\n  static {\n    this.memberFunction = "method";\n  }\n  static {\n    this.memberGetAccessor = "getter";\n  }\n  static {\n    this.memberSetAccessor = "setter";\n  }\n  static {\n    this.memberVariable = "property";\n  }\n  static {\n    this.constructorImplementation = "constructor";\n  }\n  static {\n    this.callSignature = "call";\n  }\n  static {\n    this.indexSignature = "index";\n  }\n  static {\n    this.constructSignature = "construct";\n  }\n  static {\n    this.parameter = "parameter";\n  }\n  static {\n    this.typeParameter = "type parameter";\n  }\n  static {\n    this.primitiveType = "primitive type";\n  }\n  static {\n    this.label = "label";\n  }\n  static {\n    this.alias = "alias";\n  }\n  static {\n    this.const = "const";\n  }\n  static {\n    this.let = "let";\n  }\n  static {\n    this.warning = "warning";\n  }\n};\nvar outlineTypeTable = /* @__PURE__ */ Object.create(null);\noutlineTypeTable[Kind.module] = monaco_editor_core_exports.languages.SymbolKind.Module;\noutlineTypeTable[Kind.class] = monaco_editor_core_exports.languages.SymbolKind.Class;\noutlineTypeTable[Kind.enum] = monaco_editor_core_exports.languages.SymbolKind.Enum;\noutlineTypeTable[Kind.interface] = monaco_editor_core_exports.languages.SymbolKind.Interface;\noutlineTypeTable[Kind.memberFunction] = monaco_editor_core_exports.languages.SymbolKind.Method;\noutlineTypeTable[Kind.memberVariable] = monaco_editor_core_exports.languages.SymbolKind.Property;\noutlineTypeTable[Kind.memberGetAccessor] = monaco_editor_core_exports.languages.SymbolKind.Property;\noutlineTypeTable[Kind.memberSetAccessor] = monaco_editor_core_exports.languages.SymbolKind.Property;\noutlineTypeTable[Kind.variable] = monaco_editor_core_exports.languages.SymbolKind.Variable;\noutlineTypeTable[Kind.const] = monaco_editor_core_exports.languages.SymbolKind.Variable;\noutlineTypeTable[Kind.localVariable] = monaco_editor_core_exports.languages.SymbolKind.Variable;\noutlineTypeTable[Kind.variable] = monaco_editor_core_exports.languages.SymbolKind.Variable;\noutlineTypeTable[Kind.function] = monaco_editor_core_exports.languages.SymbolKind.Function;\noutlineTypeTable[Kind.localFunction] = monaco_editor_core_exports.languages.SymbolKind.Function;\nvar FormatHelper = class extends Adapter {\n  static _convertOptions(options) {\n    return {\n      ConvertTabsToSpaces: options.insertSpaces,\n      TabSize: options.tabSize,\n      IndentSize: options.tabSize,\n      IndentStyle: 2 /* Smart */,\n      NewLineCharacter: "\\n",\n      InsertSpaceAfterCommaDelimiter: true,\n      InsertSpaceAfterSemicolonInForStatements: true,\n      InsertSpaceBeforeAndAfterBinaryOperators: true,\n      InsertSpaceAfterKeywordsInControlFlowStatements: true,\n      InsertSpaceAfterFunctionKeywordForAnonymousFunctions: true,\n      InsertSpaceAfterOpeningAndBeforeClosingNonemptyParenthesis: false,\n      InsertSpaceAfterOpeningAndBeforeClosingNonemptyBrackets: false,\n      InsertSpaceAfterOpeningAndBeforeClosingTemplateStringBraces: false,\n      PlaceOpenBraceOnNewLineForControlBlocks: false,\n      PlaceOpenBraceOnNewLineForFunctions: false\n    };\n  }\n  _convertTextChanges(model, change) {\n    return {\n      text: change.newText,\n      range: this._textSpanToRange(model, change.span)\n    };\n  }\n};\nvar FormatAdapter = class extends FormatHelper {\n  constructor() {\n    super(...arguments);\n    this.canFormatMultipleRanges = false;\n  }\n  async provideDocumentRangeFormattingEdits(model, range, options, token) {\n    const resource = model.uri;\n    const startOffset = model.getOffsetAt({\n      lineNumber: range.startLineNumber,\n      column: range.startColumn\n    });\n    const endOffset = model.getOffsetAt({\n      lineNumber: range.endLineNumber,\n      column: range.endColumn\n    });\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const edits = await worker.getFormattingEditsForRange(\n      resource.toString(),\n      startOffset,\n      endOffset,\n      FormatHelper._convertOptions(options)\n    );\n    if (!edits || model.isDisposed()) {\n      return;\n    }\n    return edits.map((edit) => this._convertTextChanges(model, edit));\n  }\n};\nvar FormatOnTypeAdapter = class extends FormatHelper {\n  get autoFormatTriggerCharacters() {\n    return [";", "}", "\\n"];\n  }\n  async provideOnTypeFormattingEdits(model, position, ch, options, token) {\n    const resource = model.uri;\n    const offset = model.getOffsetAt(position);\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const edits = await worker.getFormattingEditsAfterKeystroke(\n      resource.toString(),\n      offset,\n      ch,\n      FormatHelper._convertOptions(options)\n    );\n    if (!edits || model.isDisposed()) {\n      return;\n    }\n    return edits.map((edit) => this._convertTextChanges(model, edit));\n  }\n};\nvar CodeActionAdaptor = class extends FormatHelper {\n  async provideCodeActions(model, range, context, token) {\n    const resource = model.uri;\n    const start = model.getOffsetAt({\n      lineNumber: range.startLineNumber,\n      column: range.startColumn\n    });\n    const end = model.getOffsetAt({\n      lineNumber: range.endLineNumber,\n      column: range.endColumn\n    });\n    const formatOptions = FormatHelper._convertOptions(model.getOptions());\n    const errorCodes = context.markers.filter((m) => m.code).map((m) => m.code).map(Number);\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const codeFixes = await worker.getCodeFixesAtPosition(\n      resource.toString(),\n      start,\n      end,\n      errorCodes,\n      formatOptions\n    );\n    if (!codeFixes || model.isDisposed()) {\n      return { actions: [], dispose: () => {\n      } };\n    }\n    const actions = codeFixes.filter((fix) => {\n      return fix.changes.filter((change) => change.isNewFile).length === 0;\n    }).map((fix) => {\n      return this._tsCodeFixActionToMonacoCodeAction(model, context, fix);\n    });\n    return {\n      actions,\n      dispose: () => {\n      }\n    };\n  }\n  _tsCodeFixActionToMonacoCodeAction(model, context, codeFix) {\n    const edits = [];\n    for (const change of codeFix.changes) {\n      for (const textChange of change.textChanges) {\n        edits.push({\n          resource: model.uri,\n          versionId: void 0,\n          textEdit: {\n            range: this._textSpanToRange(model, textChange.span),\n            text: textChange.newText\n          }\n        });\n      }\n    }\n    const action = {\n      title: codeFix.description,\n      edit: { edits },\n      diagnostics: context.markers,\n      kind: "quickfix"\n    };\n    return action;\n  }\n};\nvar RenameAdapter = class extends Adapter {\n  constructor(_libFiles, worker) {\n    super(worker);\n    this._libFiles = _libFiles;\n  }\n  async provideRenameEdits(model, position, newName, token) {\n    const resource = model.uri;\n    const fileName = resource.toString();\n    const offset = model.getOffsetAt(position);\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return;\n    }\n    const renameInfo = await worker.getRenameInfo(fileName, offset, {\n      allowRenameOfImportPath: false\n    });\n    if (renameInfo.canRename === false) {\n      return {\n        edits: [],\n        rejectReason: renameInfo.localizedErrorMessage\n      };\n    }\n    if (renameInfo.fileToRename !== void 0) {\n      throw new Error("Renaming files is not supported.");\n    }\n    const renameLocations = await worker.findRenameLocations(\n      fileName,\n      offset,\n      /*strings*/\n      false,\n      /*comments*/\n      false,\n      /*prefixAndSuffix*/\n      false\n    );\n    if (!renameLocations || model.isDisposed()) {\n      return;\n    }\n    const edits = [];\n    for (const renameLocation of renameLocations) {\n      const model2 = this._libFiles.getOrCreateModel(renameLocation.fileName);\n      if (model2) {\n        edits.push({\n          resource: model2.uri,\n          versionId: void 0,\n          textEdit: {\n            range: this._textSpanToRange(model2, renameLocation.textSpan),\n            text: newName\n          }\n        });\n      } else {\n        throw new Error(`Unknown file ${renameLocation.fileName}.`);\n      }\n    }\n    return { edits };\n  }\n};\nvar InlayHintsAdapter = class extends Adapter {\n  async provideInlayHints(model, range, token) {\n    const resource = model.uri;\n    const fileName = resource.toString();\n    const start = model.getOffsetAt({\n      lineNumber: range.startLineNumber,\n      column: range.startColumn\n    });\n    const end = model.getOffsetAt({\n      lineNumber: range.endLineNumber,\n      column: range.endColumn\n    });\n    const worker = await this._worker(resource);\n    if (model.isDisposed()) {\n      return null;\n    }\n    const tsHints = await worker.provideInlayHints(fileName, start, end);\n    const hints = tsHints.map((hint) => {\n      return {\n        ...hint,\n        label: hint.text,\n        position: model.getPositionAt(hint.position),\n        kind: this._convertHintKind(hint.kind)\n      };\n    });\n    return { hints, dispose: () => {\n    } };\n  }\n  _convertHintKind(kind) {\n    switch (kind) {\n      case "Parameter":\n        return monaco_editor_core_exports.languages.InlayHintKind.Parameter;\n      case "Type":\n        return monaco_editor_core_exports.languages.InlayHintKind.Type;\n      default:\n        return monaco_editor_core_exports.languages.InlayHintKind.Type;\n    }\n  }\n};\n\n// src/language/typescript/tsMode.ts\nvar javaScriptWorker;\nvar typeScriptWorker;\nfunction setupTypeScript(defaults) {\n  typeScriptWorker = setupMode(defaults, "typescript");\n}\nfunction setupJavaScript(defaults) {\n  javaScriptWorker = setupMode(defaults, "javascript");\n}\nfunction getJavaScriptWorker() {\n  return new Promise((resolve, reject) => {\n    if (!javaScriptWorker) {\n      return reject("JavaScript not registered!");\n    }\n    resolve(javaScriptWorker);\n  });\n}\nfunction getTypeScriptWorker() {\n  return new Promise((resolve, reject) => {\n    if (!typeScriptWorker) {\n      return reject("TypeScript not registered!");\n    }\n    resolve(typeScriptWorker);\n  });\n}\nfunction setupMode(defaults, modeId) {\n  const disposables = [];\n  const providers = [];\n  const client = new WorkerManager(modeId, defaults);\n  disposables.push(client);\n  const worker = (...uris) => {\n    return client.getLanguageServiceWorker(...uris);\n  };\n  const libFiles = new LibFiles(worker);\n  function registerProviders() {\n    const { modeConfiguration } = defaults;\n    disposeAll(providers);\n    if (modeConfiguration.completionItems) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerCompletionItemProvider(\n          modeId,\n          new SuggestAdapter(worker)\n        )\n      );\n    }\n    if (modeConfiguration.signatureHelp) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerSignatureHelpProvider(\n          modeId,\n          new SignatureHelpAdapter(worker)\n        )\n      );\n    }\n    if (modeConfiguration.hovers) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerHoverProvider(modeId, new QuickInfoAdapter(worker))\n      );\n    }\n    if (modeConfiguration.documentHighlights) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerDocumentHighlightProvider(\n          modeId,\n          new DocumentHighlightAdapter(worker)\n        )\n      );\n    }\n    if (modeConfiguration.definitions) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerDefinitionProvider(\n          modeId,\n          new DefinitionAdapter(libFiles, worker)\n        )\n      );\n    }\n    if (modeConfiguration.references) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerReferenceProvider(\n          modeId,\n          new ReferenceAdapter(libFiles, worker)\n        )\n      );\n    }\n    if (modeConfiguration.documentSymbols) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerDocumentSymbolProvider(\n          modeId,\n          new OutlineAdapter(worker)\n        )\n      );\n    }\n    if (modeConfiguration.rename) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerRenameProvider(\n          modeId,\n          new RenameAdapter(libFiles, worker)\n        )\n      );\n    }\n    if (modeConfiguration.documentRangeFormattingEdits) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerDocumentRangeFormattingEditProvider(\n          modeId,\n          new FormatAdapter(worker)\n        )\n      );\n    }\n    if (modeConfiguration.onTypeFormattingEdits) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerOnTypeFormattingEditProvider(\n          modeId,\n          new FormatOnTypeAdapter(worker)\n        )\n      );\n    }\n    if (modeConfiguration.codeActions) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerCodeActionProvider(modeId, new CodeActionAdaptor(worker))\n      );\n    }\n    if (modeConfiguration.inlayHints) {\n      providers.push(\n        monaco_editor_core_exports.languages.registerInlayHintsProvider(modeId, new InlayHintsAdapter(worker))\n      );\n    }\n    if (modeConfiguration.diagnostics) {\n      providers.push(new DiagnosticsAdapter(libFiles, defaults, modeId, worker));\n    }\n  }\n  registerProviders();\n  disposables.push(asDisposable(providers));\n  return worker;\n}\nfunction asDisposable(disposables) {\n  return { dispose: () => disposeAll(disposables) };\n}\nfunction disposeAll(disposables) {\n  while (disposables.length) {\n    disposables.pop().dispose();\n  }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkzNTUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLGtEQUF1QjtBQUNROztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFHa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbURBQW1EO0FBQzdELFVBQVUsK0NBQStDO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUZBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG9FQUFvRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0QsWUFBWSwrQ0FBK0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtREFBbUQ7QUFDakUsY0FBYywrQ0FBK0M7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLGlCQUFpQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQSw2QkFBNkIsa0NBQWtDO0FBQy9ELElBQUk7QUFDSiwyQkFBMkIsc0NBQXNDO0FBQ2pFLElBQUk7QUFDSiwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixZQUFZO0FBQ1oscUJBQXFCO0FBQ3JCO0FBQ0EsVUFBVTtBQUNWLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsdUNBQXVDLG9CQUFvQixJQUFJO0FBQy9EO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1Isd0NBQXdDLHdCQUF3QjtBQUNoRTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXlCRSIsInNvdXJjZXMiOlsid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbGFuZ3VhZ2UvdHlwZXNjcmlwdC90c01vZGUuanM/ZTMyOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBWZXJzaW9uOiAwLjUwLjAoYzMyMWQwZmJlY2I1MGFiOGE1MzY1ZmExOTY1NDc2YjBhZTYzZmM4NylcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9tb25hY28tZWRpdG9yL2Jsb2IvbWFpbi9MSUNFTlNFLnR4dFxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbnZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19nZXRPd25Qcm9wRGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgX19nZXRPd25Qcm9wTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcbiAgaWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGZvciAobGV0IGtleSBvZiBfX2dldE93blByb3BOYW1lcyhmcm9tKSlcbiAgICAgIGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpXG4gICAgICAgIF9fZGVmUHJvcCh0bywga2V5LCB7IGdldDogKCkgPT4gZnJvbVtrZXldLCBlbnVtZXJhYmxlOiAhKGRlc2MgPSBfX2dldE93blByb3BEZXNjKGZyb20sIGtleSkpIHx8IGRlc2MuZW51bWVyYWJsZSB9KTtcbiAgfVxuICByZXR1cm4gdG87XG59O1xudmFyIF9fcmVFeHBvcnQgPSAodGFyZ2V0LCBtb2QsIHNlY29uZFRhcmdldCkgPT4gKF9fY29weVByb3BzKHRhcmdldCwgbW9kLCBcImRlZmF1bHRcIiksIHNlY29uZFRhcmdldCAmJiBfX2NvcHlQcm9wcyhzZWNvbmRUYXJnZXQsIG1vZCwgXCJkZWZhdWx0XCIpKTtcblxuLy8gc3JjL2ZpbGxlcnMvbW9uYWNvLWVkaXRvci1jb3JlLnRzXG52YXIgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMgPSB7fTtcbl9fcmVFeHBvcnQobW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMsIG1vbmFjb19lZGl0b3JfY29yZV9zdGFyKTtcbmltcG9ydCAqIGFzIG1vbmFjb19lZGl0b3JfY29yZV9zdGFyIGZyb20gXCIuLi8uLi9lZGl0b3IvZWRpdG9yLmFwaS5qc1wiO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvdHlwZXNjcmlwdC93b3JrZXJNYW5hZ2VyLnRzXG52YXIgV29ya2VyTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoX21vZGVJZCwgX2RlZmF1bHRzKSB7XG4gICAgdGhpcy5fbW9kZUlkID0gX21vZGVJZDtcbiAgICB0aGlzLl9kZWZhdWx0cyA9IF9kZWZhdWx0cztcbiAgICB0aGlzLl93b3JrZXIgPSBudWxsO1xuICAgIHRoaXMuX2NsaWVudCA9IG51bGw7XG4gICAgdGhpcy5fY29uZmlnQ2hhbmdlTGlzdGVuZXIgPSB0aGlzLl9kZWZhdWx0cy5vbkRpZENoYW5nZSgoKSA9PiB0aGlzLl9zdG9wV29ya2VyKCkpO1xuICAgIHRoaXMuX3VwZGF0ZUV4dHJhTGlic1Rva2VuID0gMDtcbiAgICB0aGlzLl9leHRyYUxpYnNDaGFuZ2VMaXN0ZW5lciA9IHRoaXMuX2RlZmF1bHRzLm9uRGlkRXh0cmFMaWJzQ2hhbmdlKFxuICAgICAgKCkgPT4gdGhpcy5fdXBkYXRlRXh0cmFMaWJzKClcbiAgICApO1xuICB9XG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5fY29uZmlnQ2hhbmdlTGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuX2V4dHJhTGlic0NoYW5nZUxpc3RlbmVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLl9zdG9wV29ya2VyKCk7XG4gIH1cbiAgX3N0b3BXb3JrZXIoKSB7XG4gICAgaWYgKHRoaXMuX3dvcmtlcikge1xuICAgICAgdGhpcy5fd29ya2VyLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX2NsaWVudCA9IG51bGw7XG4gIH1cbiAgYXN5bmMgX3VwZGF0ZUV4dHJhTGlicygpIHtcbiAgICBpZiAoIXRoaXMuX3dvcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBteVRva2VuID0gKyt0aGlzLl91cGRhdGVFeHRyYUxpYnNUb2tlbjtcbiAgICBjb25zdCBwcm94eSA9IGF3YWl0IHRoaXMuX3dvcmtlci5nZXRQcm94eSgpO1xuICAgIGlmICh0aGlzLl91cGRhdGVFeHRyYUxpYnNUb2tlbiAhPT0gbXlUb2tlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcm94eS51cGRhdGVFeHRyYUxpYnModGhpcy5fZGVmYXVsdHMuZ2V0RXh0cmFMaWJzKCkpO1xuICB9XG4gIF9nZXRDbGllbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9jbGllbnQpIHtcbiAgICAgIHRoaXMuX2NsaWVudCA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3dvcmtlciA9IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmVkaXRvci5jcmVhdGVXZWJXb3JrZXIoe1xuICAgICAgICAgIC8vIG1vZHVsZSB0aGF0IGV4cG9ydHMgdGhlIGNyZWF0ZSgpIG1ldGhvZCBhbmQgcmV0dXJucyBhIGBUeXBlU2NyaXB0V29ya2VyYCBpbnN0YW5jZVxuICAgICAgICAgIG1vZHVsZUlkOiBcInZzL2xhbmd1YWdlL3R5cGVzY3JpcHQvdHNXb3JrZXJcIixcbiAgICAgICAgICBsYWJlbDogdGhpcy5fbW9kZUlkLFxuICAgICAgICAgIGtlZXBJZGxlTW9kZWxzOiB0cnVlLFxuICAgICAgICAgIC8vIHBhc3NlZCBpbiB0byB0aGUgY3JlYXRlKCkgbWV0aG9kXG4gICAgICAgICAgY3JlYXRlRGF0YToge1xuICAgICAgICAgICAgY29tcGlsZXJPcHRpb25zOiB0aGlzLl9kZWZhdWx0cy5nZXRDb21waWxlck9wdGlvbnMoKSxcbiAgICAgICAgICAgIGV4dHJhTGliczogdGhpcy5fZGVmYXVsdHMuZ2V0RXh0cmFMaWJzKCksXG4gICAgICAgICAgICBjdXN0b21Xb3JrZXJQYXRoOiB0aGlzLl9kZWZhdWx0cy53b3JrZXJPcHRpb25zLmN1c3RvbVdvcmtlclBhdGgsXG4gICAgICAgICAgICBpbmxheUhpbnRzT3B0aW9uczogdGhpcy5fZGVmYXVsdHMuaW5sYXlIaW50c09wdGlvbnNcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fZGVmYXVsdHMuZ2V0RWFnZXJNb2RlbFN5bmMoKSkge1xuICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLl93b3JrZXIud2l0aFN5bmNlZFJlc291cmNlcyhcbiAgICAgICAgICAgIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmVkaXRvci5nZXRNb2RlbHMoKS5maWx0ZXIoKG1vZGVsKSA9PiBtb2RlbC5nZXRMYW5ndWFnZUlkKCkgPT09IHRoaXMuX21vZGVJZCkubWFwKChtb2RlbCkgPT4gbW9kZWwudXJpKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3dvcmtlci5nZXRQcm94eSgpO1xuICAgICAgfSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudDtcbiAgfVxuICBhc3luYyBnZXRMYW5ndWFnZVNlcnZpY2VXb3JrZXIoLi4ucmVzb3VyY2VzKSB7XG4gICAgY29uc3QgY2xpZW50ID0gYXdhaXQgdGhpcy5fZ2V0Q2xpZW50KCk7XG4gICAgaWYgKHRoaXMuX3dvcmtlcikge1xuICAgICAgYXdhaXQgdGhpcy5fd29ya2VyLndpdGhTeW5jZWRSZXNvdXJjZXMocmVzb3VyY2VzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaWVudDtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmd1YWdlL3R5cGVzY3JpcHQvbGFuZ3VhZ2VGZWF0dXJlcy50c1xuaW1wb3J0IHtcbiAgdHlwZXNjcmlwdERlZmF1bHRzXG59IGZyb20gXCIuL21vbmFjby5jb250cmlidXRpb24uanNcIjtcblxuLy8gc3JjL2xhbmd1YWdlL3R5cGVzY3JpcHQvbGliL2xpYi5pbmRleC50c1xudmFyIGxpYkZpbGVTZXQgPSB7fTtcbmxpYkZpbGVTZXRbXCJsaWIuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmRlY29yYXRvcnMuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmRlY29yYXRvcnMubGVnYWN5LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5kb20uYXN5bmNpdGVyYWJsZS5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZG9tLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5kb20uaXRlcmFibGUuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxNS5jb2xsZWN0aW9uLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTUuY29yZS5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDE1LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTUuZ2VuZXJhdG9yLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTUuaXRlcmFibGUuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxNS5wcm9taXNlLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTUucHJveHkuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxNS5yZWZsZWN0LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTUuc3ltYm9sLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTUuc3ltYm9sLndlbGxrbm93bi5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDE2LmFycmF5LmluY2x1ZGUuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxNi5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDE2LmZ1bGwuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxNi5pbnRsLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTcuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxNy5kYXRlLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTcuZnVsbC5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDE3LmludGwuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxNy5vYmplY3QuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxNy5zaGFyZWRtZW1vcnkuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxNy5zdHJpbmcuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxNy50eXBlZGFycmF5cy5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDE4LmFzeW5jZ2VuZXJhdG9yLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTguYXN5bmNpdGVyYWJsZS5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDE4LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTguZnVsbC5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDE4LmludGwuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxOC5wcm9taXNlLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTgucmVnZXhwLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTkuYXJyYXkuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxOS5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDE5LmZ1bGwuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAxOS5pbnRsLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTkub2JqZWN0LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTkuc3RyaW5nLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMTkuc3ltYm9sLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjAuYmlnaW50LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjAuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAyMC5kYXRlLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjAuZnVsbC5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDIwLmludGwuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAyMC5udW1iZXIuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAyMC5wcm9taXNlLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjAuc2hhcmVkbWVtb3J5LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjAuc3RyaW5nLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjAuc3ltYm9sLndlbGxrbm93bi5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDIxLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjEuZnVsbC5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDIxLmludGwuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAyMS5wcm9taXNlLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjEuc3RyaW5nLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjEud2Vha3JlZi5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDIyLmFycmF5LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjIuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAyMi5lcnJvci5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXMyMDIyLmZ1bGwuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAyMi5pbnRsLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjIub2JqZWN0LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjIucmVnZXhwLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjIuc2hhcmVkbWVtb3J5LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjIuc3RyaW5nLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjMuYXJyYXkuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAyMy5jb2xsZWN0aW9uLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczIwMjMuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzMjAyMy5mdWxsLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lczUuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzNi5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXNuZXh0LmNvbGxlY3Rpb24uZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzbmV4dC5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXNuZXh0LmRlY29yYXRvcnMuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzbmV4dC5kaXNwb3NhYmxlLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5lc25leHQuZnVsbC5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIuZXNuZXh0LmludGwuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzbmV4dC5vYmplY3QuZC50c1wiXSA9IHRydWU7XG5saWJGaWxlU2V0W1wibGliLmVzbmV4dC5wcm9taXNlLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi5zY3JpcHRob3N0LmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi53ZWJ3b3JrZXIuYXN5bmNpdGVyYWJsZS5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIud2Vid29ya2VyLmQudHNcIl0gPSB0cnVlO1xubGliRmlsZVNldFtcImxpYi53ZWJ3b3JrZXIuaW1wb3J0c2NyaXB0cy5kLnRzXCJdID0gdHJ1ZTtcbmxpYkZpbGVTZXRbXCJsaWIud2Vid29ya2VyLml0ZXJhYmxlLmQudHNcIl0gPSB0cnVlO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvdHlwZXNjcmlwdC9sYW5ndWFnZUZlYXR1cmVzLnRzXG5mdW5jdGlvbiBmbGF0dGVuRGlhZ25vc3RpY01lc3NhZ2VUZXh0KGRpYWcsIG5ld0xpbmUsIGluZGVudCA9IDApIHtcbiAgaWYgKHR5cGVvZiBkaWFnID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRpYWc7XG4gIH0gZWxzZSBpZiAoZGlhZyA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gIGlmIChpbmRlbnQpIHtcbiAgICByZXN1bHQgKz0gbmV3TGluZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGVudDsgaSsrKSB7XG4gICAgICByZXN1bHQgKz0gXCIgIFwiO1xuICAgIH1cbiAgfVxuICByZXN1bHQgKz0gZGlhZy5tZXNzYWdlVGV4dDtcbiAgaW5kZW50Kys7XG4gIGlmIChkaWFnLm5leHQpIHtcbiAgICBmb3IgKGNvbnN0IGtpZCBvZiBkaWFnLm5leHQpIHtcbiAgICAgIHJlc3VsdCArPSBmbGF0dGVuRGlhZ25vc3RpY01lc3NhZ2VUZXh0KGtpZCwgbmV3TGluZSwgaW5kZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRpc3BsYXlQYXJ0c1RvU3RyaW5nKGRpc3BsYXlQYXJ0cykge1xuICBpZiAoZGlzcGxheVBhcnRzKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlQYXJ0cy5tYXAoKGRpc3BsYXlQYXJ0KSA9PiBkaXNwbGF5UGFydC50ZXh0KS5qb2luKFwiXCIpO1xuICB9XG4gIHJldHVybiBcIlwiO1xufVxudmFyIEFkYXB0ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF93b3JrZXIpIHtcbiAgICB0aGlzLl93b3JrZXIgPSBfd29ya2VyO1xuICB9XG4gIC8vIHByb3RlY3RlZCBfcG9zaXRpb25Ub09mZnNldChtb2RlbDogZWRpdG9yLklUZXh0TW9kZWwsIHBvc2l0aW9uOiBtb25hY28uSVBvc2l0aW9uKTogbnVtYmVyIHtcbiAgLy8gXHRyZXR1cm4gbW9kZWwuZ2V0T2Zmc2V0QXQocG9zaXRpb24pO1xuICAvLyB9XG4gIC8vIHByb3RlY3RlZCBfb2Zmc2V0VG9Qb3NpdGlvbihtb2RlbDogZWRpdG9yLklUZXh0TW9kZWwsIG9mZnNldDogbnVtYmVyKTogbW9uYWNvLklQb3NpdGlvbiB7XG4gIC8vIFx0cmV0dXJuIG1vZGVsLmdldFBvc2l0aW9uQXQob2Zmc2V0KTtcbiAgLy8gfVxuICBfdGV4dFNwYW5Ub1JhbmdlKG1vZGVsLCBzcGFuKSB7XG4gICAgbGV0IHAxID0gbW9kZWwuZ2V0UG9zaXRpb25BdChzcGFuLnN0YXJ0KTtcbiAgICBsZXQgcDIgPSBtb2RlbC5nZXRQb3NpdGlvbkF0KHNwYW4uc3RhcnQgKyBzcGFuLmxlbmd0aCk7XG4gICAgbGV0IHsgbGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLCBjb2x1bW46IHN0YXJ0Q29sdW1uIH0gPSBwMTtcbiAgICBsZXQgeyBsaW5lTnVtYmVyOiBlbmRMaW5lTnVtYmVyLCBjb2x1bW46IGVuZENvbHVtbiB9ID0gcDI7XG4gICAgcmV0dXJuIHsgc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbiwgZW5kTGluZU51bWJlciwgZW5kQ29sdW1uIH07XG4gIH1cbn07XG52YXIgTGliRmlsZXMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF93b3JrZXIpIHtcbiAgICB0aGlzLl93b3JrZXIgPSBfd29ya2VyO1xuICAgIHRoaXMuX2xpYkZpbGVzID0ge307XG4gICAgdGhpcy5faGFzRmV0Y2hlZExpYkZpbGVzID0gZmFsc2U7XG4gICAgdGhpcy5fZmV0Y2hMaWJGaWxlc1Byb21pc2UgPSBudWxsO1xuICB9XG4gIGlzTGliRmlsZSh1cmkpIHtcbiAgICBpZiAoIXVyaSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodXJpLnBhdGguaW5kZXhPZihcIi9saWIuXCIpID09PSAwKSB7XG4gICAgICByZXR1cm4gISFsaWJGaWxlU2V0W3VyaS5wYXRoLnNsaWNlKDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldE9yQ3JlYXRlTW9kZWwoZmlsZU5hbWUpIHtcbiAgICBjb25zdCB1cmkgPSBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5VcmkucGFyc2UoZmlsZU5hbWUpO1xuICAgIGNvbnN0IG1vZGVsID0gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMuZWRpdG9yLmdldE1vZGVsKHVyaSk7XG4gICAgaWYgKG1vZGVsKSB7XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzTGliRmlsZSh1cmkpICYmIHRoaXMuX2hhc0ZldGNoZWRMaWJGaWxlcykge1xuICAgICAgcmV0dXJuIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmVkaXRvci5jcmVhdGVNb2RlbCh0aGlzLl9saWJGaWxlc1t1cmkucGF0aC5zbGljZSgxKV0sIFwidHlwZXNjcmlwdFwiLCB1cmkpO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVkTGliRmlsZSA9IHR5cGVzY3JpcHREZWZhdWx0cy5nZXRFeHRyYUxpYnMoKVtmaWxlTmFtZV07XG4gICAgaWYgKG1hdGNoZWRMaWJGaWxlKSB7XG4gICAgICByZXR1cm4gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMuZWRpdG9yLmNyZWF0ZU1vZGVsKG1hdGNoZWRMaWJGaWxlLmNvbnRlbnQsIFwidHlwZXNjcmlwdFwiLCB1cmkpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfY29udGFpbnNMaWJGaWxlKHVyaXMpIHtcbiAgICBmb3IgKGxldCB1cmkgb2YgdXJpcykge1xuICAgICAgaWYgKHRoaXMuaXNMaWJGaWxlKHVyaSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyBmZXRjaExpYkZpbGVzSWZOZWNlc3NhcnkodXJpcykge1xuICAgIGlmICghdGhpcy5fY29udGFpbnNMaWJGaWxlKHVyaXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuX2ZldGNoTGliRmlsZXMoKTtcbiAgfVxuICBfZmV0Y2hMaWJGaWxlcygpIHtcbiAgICBpZiAoIXRoaXMuX2ZldGNoTGliRmlsZXNQcm9taXNlKSB7XG4gICAgICB0aGlzLl9mZXRjaExpYkZpbGVzUHJvbWlzZSA9IHRoaXMuX3dvcmtlcigpLnRoZW4oKHcpID0+IHcuZ2V0TGliRmlsZXMoKSkudGhlbigobGliRmlsZXMpID0+IHtcbiAgICAgICAgdGhpcy5faGFzRmV0Y2hlZExpYkZpbGVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbGliRmlsZXMgPSBsaWJGaWxlcztcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZmV0Y2hMaWJGaWxlc1Byb21pc2U7XG4gIH1cbn07XG52YXIgRGlhZ25vc3RpY3NBZGFwdGVyID0gY2xhc3MgZXh0ZW5kcyBBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IoX2xpYkZpbGVzLCBfZGVmYXVsdHMsIF9zZWxlY3Rvciwgd29ya2VyKSB7XG4gICAgc3VwZXIod29ya2VyKTtcbiAgICB0aGlzLl9saWJGaWxlcyA9IF9saWJGaWxlcztcbiAgICB0aGlzLl9kZWZhdWx0cyA9IF9kZWZhdWx0cztcbiAgICB0aGlzLl9zZWxlY3RvciA9IF9zZWxlY3RvcjtcbiAgICB0aGlzLl9kaXNwb3NhYmxlcyA9IFtdO1xuICAgIHRoaXMuX2xpc3RlbmVyID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgY29uc3Qgb25Nb2RlbEFkZCA9IChtb2RlbCkgPT4ge1xuICAgICAgaWYgKG1vZGVsLmdldExhbmd1YWdlSWQoKSAhPT0gX3NlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heWJlVmFsaWRhdGUgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25seVZpc2libGUgfSA9IHRoaXMuX2RlZmF1bHRzLmdldERpYWdub3N0aWNzT3B0aW9ucygpO1xuICAgICAgICBpZiAob25seVZpc2libGUpIHtcbiAgICAgICAgICBpZiAobW9kZWwuaXNBdHRhY2hlZFRvRWRpdG9yKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvVmFsaWRhdGUobW9kZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9kb1ZhbGlkYXRlKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGxldCBoYW5kbGU7XG4gICAgICBjb25zdCBjaGFuZ2VTdWJzY3JpcHRpb24gPSBtb2RlbC5vbkRpZENoYW5nZUNvbnRlbnQoKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgaGFuZGxlID0gd2luZG93LnNldFRpbWVvdXQobWF5YmVWYWxpZGF0ZSwgNTAwKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgdmlzaWJsZVN1YnNjcmlwdGlvbiA9IG1vZGVsLm9uRGlkQ2hhbmdlQXR0YWNoZWQoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IG9ubHlWaXNpYmxlIH0gPSB0aGlzLl9kZWZhdWx0cy5nZXREaWFnbm9zdGljc09wdGlvbnMoKTtcbiAgICAgICAgaWYgKG9ubHlWaXNpYmxlKSB7XG4gICAgICAgICAgaWYgKG1vZGVsLmlzQXR0YWNoZWRUb0VkaXRvcigpKSB7XG4gICAgICAgICAgICBtYXliZVZhbGlkYXRlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmVkaXRvci5zZXRNb2RlbE1hcmtlcnMobW9kZWwsIHRoaXMuX3NlbGVjdG9yLCBbXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2xpc3RlbmVyW21vZGVsLnVyaS50b1N0cmluZygpXSA9IHtcbiAgICAgICAgZGlzcG9zZSgpIHtcbiAgICAgICAgICBjaGFuZ2VTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgIHZpc2libGVTdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgbWF5YmVWYWxpZGF0ZSgpO1xuICAgIH07XG4gICAgY29uc3Qgb25Nb2RlbFJlbW92ZWQgPSAobW9kZWwpID0+IHtcbiAgICAgIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmVkaXRvci5zZXRNb2RlbE1hcmtlcnMobW9kZWwsIHRoaXMuX3NlbGVjdG9yLCBbXSk7XG4gICAgICBjb25zdCBrZXkgPSBtb2RlbC51cmkudG9TdHJpbmcoKTtcbiAgICAgIGlmICh0aGlzLl9saXN0ZW5lcltrZXldKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyW2tleV0uZGlzcG9zZSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJba2V5XTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuX2Rpc3Bvc2FibGVzLnB1c2goXG4gICAgICBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5lZGl0b3Iub25EaWRDcmVhdGVNb2RlbCgobW9kZWwpID0+IG9uTW9kZWxBZGQobW9kZWwpKVxuICAgICk7XG4gICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5lZGl0b3Iub25XaWxsRGlzcG9zZU1vZGVsKG9uTW9kZWxSZW1vdmVkKSk7XG4gICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChcbiAgICAgIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmVkaXRvci5vbkRpZENoYW5nZU1vZGVsTGFuZ3VhZ2UoKGV2ZW50KSA9PiB7XG4gICAgICAgIG9uTW9kZWxSZW1vdmVkKGV2ZW50Lm1vZGVsKTtcbiAgICAgICAgb25Nb2RlbEFkZChldmVudC5tb2RlbCk7XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaCh7XG4gICAgICBkaXNwb3NlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmVkaXRvci5nZXRNb2RlbHMoKSkge1xuICAgICAgICAgIG9uTW9kZWxSZW1vdmVkKG1vZGVsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHJlY29tcHV0ZURpYWdvc3RpY3MgPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG1vZGVsIG9mIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmVkaXRvci5nZXRNb2RlbHMoKSkge1xuICAgICAgICBvbk1vZGVsUmVtb3ZlZChtb2RlbCk7XG4gICAgICAgIG9uTW9kZWxBZGQobW9kZWwpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaCh0aGlzLl9kZWZhdWx0cy5vbkRpZENoYW5nZShyZWNvbXB1dGVEaWFnb3N0aWNzKSk7XG4gICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaCh0aGlzLl9kZWZhdWx0cy5vbkRpZEV4dHJhTGlic0NoYW5nZShyZWNvbXB1dGVEaWFnb3N0aWNzKSk7XG4gICAgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMuZWRpdG9yLmdldE1vZGVscygpLmZvckVhY2goKG1vZGVsKSA9PiBvbk1vZGVsQWRkKG1vZGVsKSk7XG4gIH1cbiAgZGlzcG9zZSgpIHtcbiAgICB0aGlzLl9kaXNwb3NhYmxlcy5mb3JFYWNoKChkKSA9PiBkICYmIGQuZGlzcG9zZSgpKTtcbiAgICB0aGlzLl9kaXNwb3NhYmxlcyA9IFtdO1xuICB9XG4gIGFzeW5jIF9kb1ZhbGlkYXRlKG1vZGVsKSB7XG4gICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5fd29ya2VyKG1vZGVsLnVyaSk7XG4gICAgaWYgKG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IHsgbm9TeW50YXhWYWxpZGF0aW9uLCBub1NlbWFudGljVmFsaWRhdGlvbiwgbm9TdWdnZXN0aW9uRGlhZ25vc3RpY3MgfSA9IHRoaXMuX2RlZmF1bHRzLmdldERpYWdub3N0aWNzT3B0aW9ucygpO1xuICAgIGlmICghbm9TeW50YXhWYWxpZGF0aW9uKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKHdvcmtlci5nZXRTeW50YWN0aWNEaWFnbm9zdGljcyhtb2RlbC51cmkudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICBpZiAoIW5vU2VtYW50aWNWYWxpZGF0aW9uKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKHdvcmtlci5nZXRTZW1hbnRpY0RpYWdub3N0aWNzKG1vZGVsLnVyaS50b1N0cmluZygpKSk7XG4gICAgfVxuICAgIGlmICghbm9TdWdnZXN0aW9uRGlhZ25vc3RpY3MpIHtcbiAgICAgIHByb21pc2VzLnB1c2god29ya2VyLmdldFN1Z2dlc3Rpb25EaWFnbm9zdGljcyhtb2RlbC51cmkudG9TdHJpbmcoKSkpO1xuICAgIH1cbiAgICBjb25zdCBhbGxEaWFnbm9zdGljcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICBpZiAoIWFsbERpYWdub3N0aWNzIHx8IG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkaWFnbm9zdGljcyA9IGFsbERpYWdub3N0aWNzLnJlZHVjZSgocCwgYykgPT4gYy5jb25jYXQocCksIFtdKS5maWx0ZXIoXG4gICAgICAoZCkgPT4gKHRoaXMuX2RlZmF1bHRzLmdldERpYWdub3N0aWNzT3B0aW9ucygpLmRpYWdub3N0aWNDb2Rlc1RvSWdub3JlIHx8IFtdKS5pbmRleE9mKGQuY29kZSkgPT09IC0xXG4gICAgKTtcbiAgICBjb25zdCByZWxhdGVkVXJpcyA9IGRpYWdub3N0aWNzLm1hcCgoZCkgPT4gZC5yZWxhdGVkSW5mb3JtYXRpb24gfHwgW10pLnJlZHVjZSgocCwgYykgPT4gYy5jb25jYXQocCksIFtdKS5tYXAoXG4gICAgICAocmVsYXRlZEluZm9ybWF0aW9uKSA9PiByZWxhdGVkSW5mb3JtYXRpb24uZmlsZSA/IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLlVyaS5wYXJzZShyZWxhdGVkSW5mb3JtYXRpb24uZmlsZS5maWxlTmFtZSkgOiBudWxsXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLl9saWJGaWxlcy5mZXRjaExpYkZpbGVzSWZOZWNlc3NhcnkocmVsYXRlZFVyaXMpO1xuICAgIGlmIChtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMuZWRpdG9yLnNldE1vZGVsTWFya2VycyhcbiAgICAgIG1vZGVsLFxuICAgICAgdGhpcy5fc2VsZWN0b3IsXG4gICAgICBkaWFnbm9zdGljcy5tYXAoKGQpID0+IHRoaXMuX2NvbnZlcnREaWFnbm9zdGljcyhtb2RlbCwgZCkpXG4gICAgKTtcbiAgfVxuICBfY29udmVydERpYWdub3N0aWNzKG1vZGVsLCBkaWFnKSB7XG4gICAgY29uc3QgZGlhZ1N0YXJ0ID0gZGlhZy5zdGFydCB8fCAwO1xuICAgIGNvbnN0IGRpYWdMZW5ndGggPSBkaWFnLmxlbmd0aCB8fCAxO1xuICAgIGNvbnN0IHsgbGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLCBjb2x1bW46IHN0YXJ0Q29sdW1uIH0gPSBtb2RlbC5nZXRQb3NpdGlvbkF0KGRpYWdTdGFydCk7XG4gICAgY29uc3QgeyBsaW5lTnVtYmVyOiBlbmRMaW5lTnVtYmVyLCBjb2x1bW46IGVuZENvbHVtbiB9ID0gbW9kZWwuZ2V0UG9zaXRpb25BdChcbiAgICAgIGRpYWdTdGFydCArIGRpYWdMZW5ndGhcbiAgICApO1xuICAgIGNvbnN0IHRhZ3MgPSBbXTtcbiAgICBpZiAoZGlhZy5yZXBvcnRzVW5uZWNlc3NhcnkpIHtcbiAgICAgIHRhZ3MucHVzaChtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5NYXJrZXJUYWcuVW5uZWNlc3NhcnkpO1xuICAgIH1cbiAgICBpZiAoZGlhZy5yZXBvcnRzRGVwcmVjYXRlZCkge1xuICAgICAgdGFncy5wdXNoKG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLk1hcmtlclRhZy5EZXByZWNhdGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNldmVyaXR5OiB0aGlzLl90c0RpYWdub3N0aWNDYXRlZ29yeVRvTWFya2VyU2V2ZXJpdHkoZGlhZy5jYXRlZ29yeSksXG4gICAgICBzdGFydExpbmVOdW1iZXIsXG4gICAgICBzdGFydENvbHVtbixcbiAgICAgIGVuZExpbmVOdW1iZXIsXG4gICAgICBlbmRDb2x1bW4sXG4gICAgICBtZXNzYWdlOiBmbGF0dGVuRGlhZ25vc3RpY01lc3NhZ2VUZXh0KGRpYWcubWVzc2FnZVRleHQsIFwiXFxuXCIpLFxuICAgICAgY29kZTogZGlhZy5jb2RlLnRvU3RyaW5nKCksXG4gICAgICB0YWdzLFxuICAgICAgcmVsYXRlZEluZm9ybWF0aW9uOiB0aGlzLl9jb252ZXJ0UmVsYXRlZEluZm9ybWF0aW9uKG1vZGVsLCBkaWFnLnJlbGF0ZWRJbmZvcm1hdGlvbilcbiAgICB9O1xuICB9XG4gIF9jb252ZXJ0UmVsYXRlZEluZm9ybWF0aW9uKG1vZGVsLCByZWxhdGVkSW5mb3JtYXRpb24pIHtcbiAgICBpZiAoIXJlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICByZWxhdGVkSW5mb3JtYXRpb24uZm9yRWFjaCgoaW5mbykgPT4ge1xuICAgICAgbGV0IHJlbGF0ZWRSZXNvdXJjZSA9IG1vZGVsO1xuICAgICAgaWYgKGluZm8uZmlsZSkge1xuICAgICAgICByZWxhdGVkUmVzb3VyY2UgPSB0aGlzLl9saWJGaWxlcy5nZXRPckNyZWF0ZU1vZGVsKGluZm8uZmlsZS5maWxlTmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXJlbGF0ZWRSZXNvdXJjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpbmZvU3RhcnQgPSBpbmZvLnN0YXJ0IHx8IDA7XG4gICAgICBjb25zdCBpbmZvTGVuZ3RoID0gaW5mby5sZW5ndGggfHwgMTtcbiAgICAgIGNvbnN0IHsgbGluZU51bWJlcjogc3RhcnRMaW5lTnVtYmVyLCBjb2x1bW46IHN0YXJ0Q29sdW1uIH0gPSByZWxhdGVkUmVzb3VyY2UuZ2V0UG9zaXRpb25BdChpbmZvU3RhcnQpO1xuICAgICAgY29uc3QgeyBsaW5lTnVtYmVyOiBlbmRMaW5lTnVtYmVyLCBjb2x1bW46IGVuZENvbHVtbiB9ID0gcmVsYXRlZFJlc291cmNlLmdldFBvc2l0aW9uQXQoXG4gICAgICAgIGluZm9TdGFydCArIGluZm9MZW5ndGhcbiAgICAgICk7XG4gICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgIHJlc291cmNlOiByZWxhdGVkUmVzb3VyY2UudXJpLFxuICAgICAgICBzdGFydExpbmVOdW1iZXIsXG4gICAgICAgIHN0YXJ0Q29sdW1uLFxuICAgICAgICBlbmRMaW5lTnVtYmVyLFxuICAgICAgICBlbmRDb2x1bW4sXG4gICAgICAgIG1lc3NhZ2U6IGZsYXR0ZW5EaWFnbm9zdGljTWVzc2FnZVRleHQoaW5mby5tZXNzYWdlVGV4dCwgXCJcXG5cIilcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgX3RzRGlhZ25vc3RpY0NhdGVnb3J5VG9NYXJrZXJTZXZlcml0eShjYXRlZ29yeSkge1xuICAgIHN3aXRjaCAoY2F0ZWdvcnkpIHtcbiAgICAgIGNhc2UgMSAvKiBFcnJvciAqLzpcbiAgICAgICAgcmV0dXJuIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLk1hcmtlclNldmVyaXR5LkVycm9yO1xuICAgICAgY2FzZSAzIC8qIE1lc3NhZ2UgKi86XG4gICAgICAgIHJldHVybiBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5NYXJrZXJTZXZlcml0eS5JbmZvO1xuICAgICAgY2FzZSAwIC8qIFdhcm5pbmcgKi86XG4gICAgICAgIHJldHVybiBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5NYXJrZXJTZXZlcml0eS5XYXJuaW5nO1xuICAgICAgY2FzZSAyIC8qIFN1Z2dlc3Rpb24gKi86XG4gICAgICAgIHJldHVybiBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5NYXJrZXJTZXZlcml0eS5IaW50O1xuICAgIH1cbiAgICByZXR1cm4gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMuTWFya2VyU2V2ZXJpdHkuSW5mbztcbiAgfVxufTtcbnZhciBTdWdnZXN0QWRhcHRlciA9IGNsYXNzIF9TdWdnZXN0QWRhcHRlciBleHRlbmRzIEFkYXB0ZXIge1xuICBnZXQgdHJpZ2dlckNoYXJhY3RlcnMoKSB7XG4gICAgcmV0dXJuIFtcIi5cIl07XG4gIH1cbiAgYXN5bmMgcHJvdmlkZUNvbXBsZXRpb25JdGVtcyhtb2RlbCwgcG9zaXRpb24sIF9jb250ZXh0LCB0b2tlbikge1xuICAgIGNvbnN0IHdvcmRJbmZvID0gbW9kZWwuZ2V0V29yZFVudGlsUG9zaXRpb24ocG9zaXRpb24pO1xuICAgIGNvbnN0IHdvcmRSYW5nZSA9IG5ldyBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5SYW5nZShcbiAgICAgIHBvc2l0aW9uLmxpbmVOdW1iZXIsXG4gICAgICB3b3JkSW5mby5zdGFydENvbHVtbixcbiAgICAgIHBvc2l0aW9uLmxpbmVOdW1iZXIsXG4gICAgICB3b3JkSW5mby5lbmRDb2x1bW5cbiAgICApO1xuICAgIGNvbnN0IHJlc291cmNlID0gbW9kZWwudXJpO1xuICAgIGNvbnN0IG9mZnNldCA9IG1vZGVsLmdldE9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICBjb25zdCB3b3JrZXIgPSBhd2FpdCB0aGlzLl93b3JrZXIocmVzb3VyY2UpO1xuICAgIGlmIChtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5mbyA9IGF3YWl0IHdvcmtlci5nZXRDb21wbGV0aW9uc0F0UG9zaXRpb24ocmVzb3VyY2UudG9TdHJpbmcoKSwgb2Zmc2V0KTtcbiAgICBpZiAoIWluZm8gfHwgbW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN1Z2dlc3Rpb25zID0gaW5mby5lbnRyaWVzLm1hcCgoZW50cnkpID0+IHtcbiAgICAgIGxldCByYW5nZSA9IHdvcmRSYW5nZTtcbiAgICAgIGlmIChlbnRyeS5yZXBsYWNlbWVudFNwYW4pIHtcbiAgICAgICAgY29uc3QgcDEgPSBtb2RlbC5nZXRQb3NpdGlvbkF0KGVudHJ5LnJlcGxhY2VtZW50U3Bhbi5zdGFydCk7XG4gICAgICAgIGNvbnN0IHAyID0gbW9kZWwuZ2V0UG9zaXRpb25BdChlbnRyeS5yZXBsYWNlbWVudFNwYW4uc3RhcnQgKyBlbnRyeS5yZXBsYWNlbWVudFNwYW4ubGVuZ3RoKTtcbiAgICAgICAgcmFuZ2UgPSBuZXcgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMuUmFuZ2UocDEubGluZU51bWJlciwgcDEuY29sdW1uLCBwMi5saW5lTnVtYmVyLCBwMi5jb2x1bW4pO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFncyA9IFtdO1xuICAgICAgaWYgKGVudHJ5LmtpbmRNb2RpZmllcnMgIT09IHZvaWQgMCAmJiBlbnRyeS5raW5kTW9kaWZpZXJzLmluZGV4T2YoXCJkZXByZWNhdGVkXCIpICE9PSAtMSkge1xuICAgICAgICB0YWdzLnB1c2gobW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLkNvbXBsZXRpb25JdGVtVGFnLkRlcHJlY2F0ZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJpOiByZXNvdXJjZSxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgcmFuZ2UsXG4gICAgICAgIGxhYmVsOiBlbnRyeS5uYW1lLFxuICAgICAgICBpbnNlcnRUZXh0OiBlbnRyeS5uYW1lLFxuICAgICAgICBzb3J0VGV4dDogZW50cnkuc29ydFRleHQsXG4gICAgICAgIGtpbmQ6IF9TdWdnZXN0QWRhcHRlci5jb252ZXJ0S2luZChlbnRyeS5raW5kKSxcbiAgICAgICAgdGFnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgc3VnZ2VzdGlvbnNcbiAgICB9O1xuICB9XG4gIGFzeW5jIHJlc29sdmVDb21wbGV0aW9uSXRlbShpdGVtLCB0b2tlbikge1xuICAgIGNvbnN0IG15SXRlbSA9IGl0ZW07XG4gICAgY29uc3QgcmVzb3VyY2UgPSBteUl0ZW0udXJpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gbXlJdGVtLnBvc2l0aW9uO1xuICAgIGNvbnN0IG9mZnNldCA9IG15SXRlbS5vZmZzZXQ7XG4gICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5fd29ya2VyKHJlc291cmNlKTtcbiAgICBjb25zdCBkZXRhaWxzID0gYXdhaXQgd29ya2VyLmdldENvbXBsZXRpb25FbnRyeURldGFpbHMoXG4gICAgICByZXNvdXJjZS50b1N0cmluZygpLFxuICAgICAgb2Zmc2V0LFxuICAgICAgbXlJdGVtLmxhYmVsXG4gICAgKTtcbiAgICBpZiAoIWRldGFpbHMpIHtcbiAgICAgIHJldHVybiBteUl0ZW07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB1cmk6IHJlc291cmNlLFxuICAgICAgcG9zaXRpb24sXG4gICAgICBsYWJlbDogZGV0YWlscy5uYW1lLFxuICAgICAga2luZDogX1N1Z2dlc3RBZGFwdGVyLmNvbnZlcnRLaW5kKGRldGFpbHMua2luZCksXG4gICAgICBkZXRhaWw6IGRpc3BsYXlQYXJ0c1RvU3RyaW5nKGRldGFpbHMuZGlzcGxheVBhcnRzKSxcbiAgICAgIGRvY3VtZW50YXRpb246IHtcbiAgICAgICAgdmFsdWU6IF9TdWdnZXN0QWRhcHRlci5jcmVhdGVEb2N1bWVudGF0aW9uU3RyaW5nKGRldGFpbHMpXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgY29udmVydEtpbmQoa2luZCkge1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLaW5kLnByaW1pdGl2ZVR5cGU6XG4gICAgICBjYXNlIEtpbmQua2V5d29yZDpcbiAgICAgICAgcmV0dXJuIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbUtpbmQuS2V5d29yZDtcbiAgICAgIGNhc2UgS2luZC52YXJpYWJsZTpcbiAgICAgIGNhc2UgS2luZC5sb2NhbFZhcmlhYmxlOlxuICAgICAgICByZXR1cm4gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLkNvbXBsZXRpb25JdGVtS2luZC5WYXJpYWJsZTtcbiAgICAgIGNhc2UgS2luZC5tZW1iZXJWYXJpYWJsZTpcbiAgICAgIGNhc2UgS2luZC5tZW1iZXJHZXRBY2Nlc3NvcjpcbiAgICAgIGNhc2UgS2luZC5tZW1iZXJTZXRBY2Nlc3NvcjpcbiAgICAgICAgcmV0dXJuIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbUtpbmQuRmllbGQ7XG4gICAgICBjYXNlIEtpbmQuZnVuY3Rpb246XG4gICAgICBjYXNlIEtpbmQubWVtYmVyRnVuY3Rpb246XG4gICAgICBjYXNlIEtpbmQuY29uc3RydWN0U2lnbmF0dXJlOlxuICAgICAgY2FzZSBLaW5kLmNhbGxTaWduYXR1cmU6XG4gICAgICBjYXNlIEtpbmQuaW5kZXhTaWduYXR1cmU6XG4gICAgICAgIHJldHVybiBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uO1xuICAgICAgY2FzZSBLaW5kLmVudW06XG4gICAgICAgIHJldHVybiBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kLkVudW07XG4gICAgICBjYXNlIEtpbmQubW9kdWxlOlxuICAgICAgICByZXR1cm4gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLkNvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGU7XG4gICAgICBjYXNlIEtpbmQuY2xhc3M6XG4gICAgICAgIHJldHVybiBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kLkNsYXNzO1xuICAgICAgY2FzZSBLaW5kLmludGVyZmFjZTpcbiAgICAgICAgcmV0dXJuIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5Db21wbGV0aW9uSXRlbUtpbmQuSW50ZXJmYWNlO1xuICAgICAgY2FzZSBLaW5kLndhcm5pbmc6XG4gICAgICAgIHJldHVybiBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kLkZpbGU7XG4gICAgfVxuICAgIHJldHVybiBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5O1xuICB9XG4gIHN0YXRpYyBjcmVhdGVEb2N1bWVudGF0aW9uU3RyaW5nKGRldGFpbHMpIHtcbiAgICBsZXQgZG9jdW1lbnRhdGlvblN0cmluZyA9IGRpc3BsYXlQYXJ0c1RvU3RyaW5nKGRldGFpbHMuZG9jdW1lbnRhdGlvbik7XG4gICAgaWYgKGRldGFpbHMudGFncykge1xuICAgICAgZm9yIChjb25zdCB0YWcgb2YgZGV0YWlscy50YWdzKSB7XG4gICAgICAgIGRvY3VtZW50YXRpb25TdHJpbmcgKz0gYFxuXG4ke3RhZ1RvU3RyaW5nKHRhZyl9YDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRvY3VtZW50YXRpb25TdHJpbmc7XG4gIH1cbn07XG5mdW5jdGlvbiB0YWdUb1N0cmluZyh0YWcpIHtcbiAgbGV0IHRhZ0xhYmVsID0gYCpAJHt0YWcubmFtZX0qYDtcbiAgaWYgKHRhZy5uYW1lID09PSBcInBhcmFtXCIgJiYgdGFnLnRleHQpIHtcbiAgICBjb25zdCBbcGFyYW1OYW1lLCAuLi5yZXN0XSA9IHRhZy50ZXh0O1xuICAgIHRhZ0xhYmVsICs9IGBcXGAke3BhcmFtTmFtZS50ZXh0fVxcYGA7XG4gICAgaWYgKHJlc3QubGVuZ3RoID4gMClcbiAgICAgIHRhZ0xhYmVsICs9IGAgXFx1MjAxNCAke3Jlc3QubWFwKChyKSA9PiByLnRleHQpLmpvaW4oXCIgXCIpfWA7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0YWcudGV4dCkpIHtcbiAgICB0YWdMYWJlbCArPSBgIFxcdTIwMTQgJHt0YWcudGV4dC5tYXAoKHIpID0+IHIudGV4dCkuam9pbihcIiBcIil9YDtcbiAgfSBlbHNlIGlmICh0YWcudGV4dCkge1xuICAgIHRhZ0xhYmVsICs9IGAgXFx1MjAxNCAke3RhZy50ZXh0fWA7XG4gIH1cbiAgcmV0dXJuIHRhZ0xhYmVsO1xufVxudmFyIFNpZ25hdHVyZUhlbHBBZGFwdGVyID0gY2xhc3MgX1NpZ25hdHVyZUhlbHBBZGFwdGVyIGV4dGVuZHMgQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5zaWduYXR1cmVIZWxwVHJpZ2dlckNoYXJhY3RlcnMgPSBbXCIoXCIsIFwiLFwiXTtcbiAgfVxuICBzdGF0aWMgX3RvU2lnbmF0dXJlSGVscFRyaWdnZXJSZWFzb24oY29udGV4dCkge1xuICAgIHN3aXRjaCAoY29udGV4dC50cmlnZ2VyS2luZCkge1xuICAgICAgY2FzZSBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLlRyaWdnZXJDaGFyYWN0ZXI6XG4gICAgICAgIGlmIChjb250ZXh0LnRyaWdnZXJDaGFyYWN0ZXIpIHtcbiAgICAgICAgICBpZiAoY29udGV4dC5pc1JldHJpZ2dlcikge1xuICAgICAgICAgICAgcmV0dXJuIHsga2luZDogXCJyZXRyaWdnZXJcIiwgdHJpZ2dlckNoYXJhY3RlcjogY29udGV4dC50cmlnZ2VyQ2hhcmFjdGVyIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6IFwiY2hhcmFjdGVyVHlwZWRcIiwgdHJpZ2dlckNoYXJhY3RlcjogY29udGV4dC50cmlnZ2VyQ2hhcmFjdGVyIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7IGtpbmQ6IFwiaW52b2tlZFwiIH07XG4gICAgICAgIH1cbiAgICAgIGNhc2UgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLlNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZC5Db250ZW50Q2hhbmdlOlxuICAgICAgICByZXR1cm4gY29udGV4dC5pc1JldHJpZ2dlciA/IHsga2luZDogXCJyZXRyaWdnZXJcIiB9IDogeyBraW5kOiBcImludm9rZWRcIiB9O1xuICAgICAgY2FzZSBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kLkludm9rZTpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB7IGtpbmQ6IFwiaW52b2tlZFwiIH07XG4gICAgfVxuICB9XG4gIGFzeW5jIHByb3ZpZGVTaWduYXR1cmVIZWxwKG1vZGVsLCBwb3NpdGlvbiwgdG9rZW4sIGNvbnRleHQpIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IG1vZGVsLnVyaTtcbiAgICBjb25zdCBvZmZzZXQgPSBtb2RlbC5nZXRPZmZzZXRBdChwb3NpdGlvbik7XG4gICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5fd29ya2VyKHJlc291cmNlKTtcbiAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZm8gPSBhd2FpdCB3b3JrZXIuZ2V0U2lnbmF0dXJlSGVscEl0ZW1zKHJlc291cmNlLnRvU3RyaW5nKCksIG9mZnNldCwge1xuICAgICAgdHJpZ2dlclJlYXNvbjogX1NpZ25hdHVyZUhlbHBBZGFwdGVyLl90b1NpZ25hdHVyZUhlbHBUcmlnZ2VyUmVhc29uKGNvbnRleHQpXG4gICAgfSk7XG4gICAgaWYgKCFpbmZvIHx8IG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSB7XG4gICAgICBhY3RpdmVTaWduYXR1cmU6IGluZm8uc2VsZWN0ZWRJdGVtSW5kZXgsXG4gICAgICBhY3RpdmVQYXJhbWV0ZXI6IGluZm8uYXJndW1lbnRJbmRleCxcbiAgICAgIHNpZ25hdHVyZXM6IFtdXG4gICAgfTtcbiAgICBpbmZvLml0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHtcbiAgICAgICAgbGFiZWw6IFwiXCIsXG4gICAgICAgIHBhcmFtZXRlcnM6IFtdXG4gICAgICB9O1xuICAgICAgc2lnbmF0dXJlLmRvY3VtZW50YXRpb24gPSB7XG4gICAgICAgIHZhbHVlOiBkaXNwbGF5UGFydHNUb1N0cmluZyhpdGVtLmRvY3VtZW50YXRpb24pXG4gICAgICB9O1xuICAgICAgc2lnbmF0dXJlLmxhYmVsICs9IGRpc3BsYXlQYXJ0c1RvU3RyaW5nKGl0ZW0ucHJlZml4RGlzcGxheVBhcnRzKTtcbiAgICAgIGl0ZW0ucGFyYW1ldGVycy5mb3JFYWNoKChwLCBpLCBhKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZGlzcGxheVBhcnRzVG9TdHJpbmcocC5kaXNwbGF5UGFydHMpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXIgPSB7XG4gICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgZG9jdW1lbnRhdGlvbjoge1xuICAgICAgICAgICAgdmFsdWU6IGRpc3BsYXlQYXJ0c1RvU3RyaW5nKHAuZG9jdW1lbnRhdGlvbilcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHNpZ25hdHVyZS5sYWJlbCArPSBsYWJlbDtcbiAgICAgICAgc2lnbmF0dXJlLnBhcmFtZXRlcnMucHVzaChwYXJhbWV0ZXIpO1xuICAgICAgICBpZiAoaSA8IGEubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIHNpZ25hdHVyZS5sYWJlbCArPSBkaXNwbGF5UGFydHNUb1N0cmluZyhpdGVtLnNlcGFyYXRvckRpc3BsYXlQYXJ0cyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2lnbmF0dXJlLmxhYmVsICs9IGRpc3BsYXlQYXJ0c1RvU3RyaW5nKGl0ZW0uc3VmZml4RGlzcGxheVBhcnRzKTtcbiAgICAgIHJldC5zaWduYXR1cmVzLnB1c2goc2lnbmF0dXJlKTtcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHJldCxcbiAgICAgIGRpc3Bvc2UoKSB7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBRdWlja0luZm9BZGFwdGVyID0gY2xhc3MgZXh0ZW5kcyBBZGFwdGVyIHtcbiAgYXN5bmMgcHJvdmlkZUhvdmVyKG1vZGVsLCBwb3NpdGlvbiwgdG9rZW4pIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IG1vZGVsLnVyaTtcbiAgICBjb25zdCBvZmZzZXQgPSBtb2RlbC5nZXRPZmZzZXRBdChwb3NpdGlvbik7XG4gICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5fd29ya2VyKHJlc291cmNlKTtcbiAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGluZm8gPSBhd2FpdCB3b3JrZXIuZ2V0UXVpY2tJbmZvQXRQb3NpdGlvbihyZXNvdXJjZS50b1N0cmluZygpLCBvZmZzZXQpO1xuICAgIGlmICghaW5mbyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZG9jdW1lbnRhdGlvbiA9IGRpc3BsYXlQYXJ0c1RvU3RyaW5nKGluZm8uZG9jdW1lbnRhdGlvbik7XG4gICAgY29uc3QgdGFncyA9IGluZm8udGFncyA/IGluZm8udGFncy5tYXAoKHRhZykgPT4gdGFnVG9TdHJpbmcodGFnKSkuam9pbihcIiAgXFxuXFxuXCIpIDogXCJcIjtcbiAgICBjb25zdCBjb250ZW50cyA9IGRpc3BsYXlQYXJ0c1RvU3RyaW5nKGluZm8uZGlzcGxheVBhcnRzKTtcbiAgICByZXR1cm4ge1xuICAgICAgcmFuZ2U6IHRoaXMuX3RleHRTcGFuVG9SYW5nZShtb2RlbCwgaW5mby50ZXh0U3BhbiksXG4gICAgICBjb250ZW50czogW1xuICAgICAgICB7XG4gICAgICAgICAgdmFsdWU6IFwiYGBgdHlwZXNjcmlwdFxcblwiICsgY29udGVudHMgKyBcIlxcbmBgYFxcblwiXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB2YWx1ZTogZG9jdW1lbnRhdGlvbiArICh0YWdzID8gXCJcXG5cXG5cIiArIHRhZ3MgOiBcIlwiKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxufTtcbnZhciBEb2N1bWVudEhpZ2hsaWdodEFkYXB0ZXIgPSBjbGFzcyBleHRlbmRzIEFkYXB0ZXIge1xuICBhc3luYyBwcm92aWRlRG9jdW1lbnRIaWdobGlnaHRzKG1vZGVsLCBwb3NpdGlvbiwgdG9rZW4pIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IG1vZGVsLnVyaTtcbiAgICBjb25zdCBvZmZzZXQgPSBtb2RlbC5nZXRPZmZzZXRBdChwb3NpdGlvbik7XG4gICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5fd29ya2VyKHJlc291cmNlKTtcbiAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVudHJpZXMgPSBhd2FpdCB3b3JrZXIuZ2V0RG9jdW1lbnRIaWdobGlnaHRzKHJlc291cmNlLnRvU3RyaW5nKCksIG9mZnNldCwgW1xuICAgICAgcmVzb3VyY2UudG9TdHJpbmcoKVxuICAgIF0pO1xuICAgIGlmICghZW50cmllcyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGVudHJpZXMuZmxhdE1hcCgoZW50cnkpID0+IHtcbiAgICAgIHJldHVybiBlbnRyeS5oaWdobGlnaHRTcGFucy5tYXAoKGhpZ2hsaWdodFNwYW5zKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmFuZ2U6IHRoaXMuX3RleHRTcGFuVG9SYW5nZShtb2RlbCwgaGlnaGxpZ2h0U3BhbnMudGV4dFNwYW4pLFxuICAgICAgICAgIGtpbmQ6IGhpZ2hsaWdodFNwYW5zLmtpbmQgPT09IFwid3JpdHRlblJlZmVyZW5jZVwiID8gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLkRvY3VtZW50SGlnaGxpZ2h0S2luZC5Xcml0ZSA6IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5Eb2N1bWVudEhpZ2hsaWdodEtpbmQuVGV4dFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn07XG52YXIgRGVmaW5pdGlvbkFkYXB0ZXIgPSBjbGFzcyBleHRlbmRzIEFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcihfbGliRmlsZXMsIHdvcmtlcikge1xuICAgIHN1cGVyKHdvcmtlcik7XG4gICAgdGhpcy5fbGliRmlsZXMgPSBfbGliRmlsZXM7XG4gIH1cbiAgYXN5bmMgcHJvdmlkZURlZmluaXRpb24obW9kZWwsIHBvc2l0aW9uLCB0b2tlbikge1xuICAgIGNvbnN0IHJlc291cmNlID0gbW9kZWwudXJpO1xuICAgIGNvbnN0IG9mZnNldCA9IG1vZGVsLmdldE9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICBjb25zdCB3b3JrZXIgPSBhd2FpdCB0aGlzLl93b3JrZXIocmVzb3VyY2UpO1xuICAgIGlmIChtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZW50cmllcyA9IGF3YWl0IHdvcmtlci5nZXREZWZpbml0aW9uQXRQb3NpdGlvbihyZXNvdXJjZS50b1N0cmluZygpLCBvZmZzZXQpO1xuICAgIGlmICghZW50cmllcyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5fbGliRmlsZXMuZmV0Y2hMaWJGaWxlc0lmTmVjZXNzYXJ5KFxuICAgICAgZW50cmllcy5tYXAoKGVudHJ5KSA9PiBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5VcmkucGFyc2UoZW50cnkuZmlsZU5hbWUpKVxuICAgICk7XG4gICAgaWYgKG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICBjb25zdCByZWZNb2RlbCA9IHRoaXMuX2xpYkZpbGVzLmdldE9yQ3JlYXRlTW9kZWwoZW50cnkuZmlsZU5hbWUpO1xuICAgICAgaWYgKHJlZk1vZGVsKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICB1cmk6IHJlZk1vZGVsLnVyaSxcbiAgICAgICAgICByYW5nZTogdGhpcy5fdGV4dFNwYW5Ub1JhbmdlKHJlZk1vZGVsLCBlbnRyeS50ZXh0U3BhbilcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgUmVmZXJlbmNlQWRhcHRlciA9IGNsYXNzIGV4dGVuZHMgQWRhcHRlciB7XG4gIGNvbnN0cnVjdG9yKF9saWJGaWxlcywgd29ya2VyKSB7XG4gICAgc3VwZXIod29ya2VyKTtcbiAgICB0aGlzLl9saWJGaWxlcyA9IF9saWJGaWxlcztcbiAgfVxuICBhc3luYyBwcm92aWRlUmVmZXJlbmNlcyhtb2RlbCwgcG9zaXRpb24sIGNvbnRleHQsIHRva2VuKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBtb2RlbC51cmk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbW9kZWwuZ2V0T2Zmc2V0QXQocG9zaXRpb24pO1xuICAgIGNvbnN0IHdvcmtlciA9IGF3YWl0IHRoaXMuX3dvcmtlcihyZXNvdXJjZSk7XG4gICAgaWYgKG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgd29ya2VyLmdldFJlZmVyZW5jZXNBdFBvc2l0aW9uKHJlc291cmNlLnRvU3RyaW5nKCksIG9mZnNldCk7XG4gICAgaWYgKCFlbnRyaWVzIHx8IG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLl9saWJGaWxlcy5mZXRjaExpYkZpbGVzSWZOZWNlc3NhcnkoXG4gICAgICBlbnRyaWVzLm1hcCgoZW50cnkpID0+IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLlVyaS5wYXJzZShlbnRyeS5maWxlTmFtZSkpXG4gICAgKTtcbiAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgIGNvbnN0IHJlZk1vZGVsID0gdGhpcy5fbGliRmlsZXMuZ2V0T3JDcmVhdGVNb2RlbChlbnRyeS5maWxlTmFtZSk7XG4gICAgICBpZiAocmVmTW9kZWwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIHVyaTogcmVmTW9kZWwudXJpLFxuICAgICAgICAgIHJhbmdlOiB0aGlzLl90ZXh0U3BhblRvUmFuZ2UocmVmTW9kZWwsIGVudHJ5LnRleHRTcGFuKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciBPdXRsaW5lQWRhcHRlciA9IGNsYXNzIGV4dGVuZHMgQWRhcHRlciB7XG4gIGFzeW5jIHByb3ZpZGVEb2N1bWVudFN5bWJvbHMobW9kZWwsIHRva2VuKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBtb2RlbC51cmk7XG4gICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5fd29ya2VyKHJlc291cmNlKTtcbiAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJvb3QgPSBhd2FpdCB3b3JrZXIuZ2V0TmF2aWdhdGlvblRyZWUocmVzb3VyY2UudG9TdHJpbmcoKSk7XG4gICAgaWYgKCFyb290IHx8IG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjb252ZXJ0ID0gKGl0ZW0sIGNvbnRhaW5lckxhYmVsKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQyID0ge1xuICAgICAgICBuYW1lOiBpdGVtLnRleHQsXG4gICAgICAgIGRldGFpbDogXCJcIixcbiAgICAgICAga2luZDogb3V0bGluZVR5cGVUYWJsZVtpdGVtLmtpbmRdIHx8IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5TeW1ib2xLaW5kLlZhcmlhYmxlLFxuICAgICAgICByYW5nZTogdGhpcy5fdGV4dFNwYW5Ub1JhbmdlKG1vZGVsLCBpdGVtLnNwYW5zWzBdKSxcbiAgICAgICAgc2VsZWN0aW9uUmFuZ2U6IHRoaXMuX3RleHRTcGFuVG9SYW5nZShtb2RlbCwgaXRlbS5zcGFuc1swXSksXG4gICAgICAgIHRhZ3M6IFtdLFxuICAgICAgICBjaGlsZHJlbjogaXRlbS5jaGlsZEl0ZW1zPy5tYXAoKGNoaWxkKSA9PiBjb252ZXJ0KGNoaWxkLCBpdGVtLnRleHQpKSxcbiAgICAgICAgY29udGFpbmVyTmFtZTogY29udGFpbmVyTGFiZWxcbiAgICAgIH07XG4gICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHJvb3QuY2hpbGRJdGVtcyA/IHJvb3QuY2hpbGRJdGVtcy5tYXAoKGl0ZW0pID0+IGNvbnZlcnQoaXRlbSkpIDogW107XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbnZhciBLaW5kID0gY2xhc3Mge1xuICBzdGF0aWMge1xuICAgIHRoaXMudW5rbm93biA9IFwiXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLmtleXdvcmQgPSBcImtleXdvcmRcIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuc2NyaXB0ID0gXCJzY3JpcHRcIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMubW9kdWxlID0gXCJtb2R1bGVcIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuY2xhc3MgPSBcImNsYXNzXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLmludGVyZmFjZSA9IFwiaW50ZXJmYWNlXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnR5cGUgPSBcInR5cGVcIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuZW51bSA9IFwiZW51bVwiO1xuICB9XG4gIHN0YXRpYyB7XG4gICAgdGhpcy52YXJpYWJsZSA9IFwidmFyXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLmxvY2FsVmFyaWFibGUgPSBcImxvY2FsIHZhclwiO1xuICB9XG4gIHN0YXRpYyB7XG4gICAgdGhpcy5mdW5jdGlvbiA9IFwiZnVuY3Rpb25cIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMubG9jYWxGdW5jdGlvbiA9IFwibG9jYWwgZnVuY3Rpb25cIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMubWVtYmVyRnVuY3Rpb24gPSBcIm1ldGhvZFwiO1xuICB9XG4gIHN0YXRpYyB7XG4gICAgdGhpcy5tZW1iZXJHZXRBY2Nlc3NvciA9IFwiZ2V0dGVyXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLm1lbWJlclNldEFjY2Vzc29yID0gXCJzZXR0ZXJcIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMubWVtYmVyVmFyaWFibGUgPSBcInByb3BlcnR5XCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9ySW1wbGVtZW50YXRpb24gPSBcImNvbnN0cnVjdG9yXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLmNhbGxTaWduYXR1cmUgPSBcImNhbGxcIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuaW5kZXhTaWduYXR1cmUgPSBcImluZGV4XCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLmNvbnN0cnVjdFNpZ25hdHVyZSA9IFwiY29uc3RydWN0XCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnBhcmFtZXRlciA9IFwicGFyYW1ldGVyXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnR5cGVQYXJhbWV0ZXIgPSBcInR5cGUgcGFyYW1ldGVyXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLnByaW1pdGl2ZVR5cGUgPSBcInByaW1pdGl2ZSB0eXBlXCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLmxhYmVsID0gXCJsYWJlbFwiO1xuICB9XG4gIHN0YXRpYyB7XG4gICAgdGhpcy5hbGlhcyA9IFwiYWxpYXNcIjtcbiAgfVxuICBzdGF0aWMge1xuICAgIHRoaXMuY29uc3QgPSBcImNvbnN0XCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLmxldCA9IFwibGV0XCI7XG4gIH1cbiAgc3RhdGljIHtcbiAgICB0aGlzLndhcm5pbmcgPSBcIndhcm5pbmdcIjtcbiAgfVxufTtcbnZhciBvdXRsaW5lVHlwZVRhYmxlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQubW9kdWxlXSA9IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5TeW1ib2xLaW5kLk1vZHVsZTtcbm91dGxpbmVUeXBlVGFibGVbS2luZC5jbGFzc10gPSBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuU3ltYm9sS2luZC5DbGFzcztcbm91dGxpbmVUeXBlVGFibGVbS2luZC5lbnVtXSA9IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5TeW1ib2xLaW5kLkVudW07XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQuaW50ZXJmYWNlXSA9IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5TeW1ib2xLaW5kLkludGVyZmFjZTtcbm91dGxpbmVUeXBlVGFibGVbS2luZC5tZW1iZXJGdW5jdGlvbl0gPSBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuU3ltYm9sS2luZC5NZXRob2Q7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQubWVtYmVyVmFyaWFibGVdID0gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLlN5bWJvbEtpbmQuUHJvcGVydHk7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQubWVtYmVyR2V0QWNjZXNzb3JdID0gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLlN5bWJvbEtpbmQuUHJvcGVydHk7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQubWVtYmVyU2V0QWNjZXNzb3JdID0gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLlN5bWJvbEtpbmQuUHJvcGVydHk7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQudmFyaWFibGVdID0gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLlN5bWJvbEtpbmQuVmFyaWFibGU7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQuY29uc3RdID0gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLlN5bWJvbEtpbmQuVmFyaWFibGU7XG5vdXRsaW5lVHlwZVRhYmxlW0tpbmQubG9jYWxWYXJpYWJsZV0gPSBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuU3ltYm9sS2luZC5WYXJpYWJsZTtcbm91dGxpbmVUeXBlVGFibGVbS2luZC52YXJpYWJsZV0gPSBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuU3ltYm9sS2luZC5WYXJpYWJsZTtcbm91dGxpbmVUeXBlVGFibGVbS2luZC5mdW5jdGlvbl0gPSBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMuU3ltYm9sS2luZC5GdW5jdGlvbjtcbm91dGxpbmVUeXBlVGFibGVbS2luZC5sb2NhbEZ1bmN0aW9uXSA9IG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5TeW1ib2xLaW5kLkZ1bmN0aW9uO1xudmFyIEZvcm1hdEhlbHBlciA9IGNsYXNzIGV4dGVuZHMgQWRhcHRlciB7XG4gIHN0YXRpYyBfY29udmVydE9wdGlvbnMob3B0aW9ucykge1xuICAgIHJldHVybiB7XG4gICAgICBDb252ZXJ0VGFic1RvU3BhY2VzOiBvcHRpb25zLmluc2VydFNwYWNlcyxcbiAgICAgIFRhYlNpemU6IG9wdGlvbnMudGFiU2l6ZSxcbiAgICAgIEluZGVudFNpemU6IG9wdGlvbnMudGFiU2l6ZSxcbiAgICAgIEluZGVudFN0eWxlOiAyIC8qIFNtYXJ0ICovLFxuICAgICAgTmV3TGluZUNoYXJhY3RlcjogXCJcXG5cIixcbiAgICAgIEluc2VydFNwYWNlQWZ0ZXJDb21tYURlbGltaXRlcjogdHJ1ZSxcbiAgICAgIEluc2VydFNwYWNlQWZ0ZXJTZW1pY29sb25JbkZvclN0YXRlbWVudHM6IHRydWUsXG4gICAgICBJbnNlcnRTcGFjZUJlZm9yZUFuZEFmdGVyQmluYXJ5T3BlcmF0b3JzOiB0cnVlLFxuICAgICAgSW5zZXJ0U3BhY2VBZnRlcktleXdvcmRzSW5Db250cm9sRmxvd1N0YXRlbWVudHM6IHRydWUsXG4gICAgICBJbnNlcnRTcGFjZUFmdGVyRnVuY3Rpb25LZXl3b3JkRm9yQW5vbnltb3VzRnVuY3Rpb25zOiB0cnVlLFxuICAgICAgSW5zZXJ0U3BhY2VBZnRlck9wZW5pbmdBbmRCZWZvcmVDbG9zaW5nTm9uZW1wdHlQYXJlbnRoZXNpczogZmFsc2UsXG4gICAgICBJbnNlcnRTcGFjZUFmdGVyT3BlbmluZ0FuZEJlZm9yZUNsb3NpbmdOb25lbXB0eUJyYWNrZXRzOiBmYWxzZSxcbiAgICAgIEluc2VydFNwYWNlQWZ0ZXJPcGVuaW5nQW5kQmVmb3JlQ2xvc2luZ1RlbXBsYXRlU3RyaW5nQnJhY2VzOiBmYWxzZSxcbiAgICAgIFBsYWNlT3BlbkJyYWNlT25OZXdMaW5lRm9yQ29udHJvbEJsb2NrczogZmFsc2UsXG4gICAgICBQbGFjZU9wZW5CcmFjZU9uTmV3TGluZUZvckZ1bmN0aW9uczogZmFsc2VcbiAgICB9O1xuICB9XG4gIF9jb252ZXJ0VGV4dENoYW5nZXMobW9kZWwsIGNoYW5nZSkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBjaGFuZ2UubmV3VGV4dCxcbiAgICAgIHJhbmdlOiB0aGlzLl90ZXh0U3BhblRvUmFuZ2UobW9kZWwsIGNoYW5nZS5zcGFuKVxuICAgIH07XG4gIH1cbn07XG52YXIgRm9ybWF0QWRhcHRlciA9IGNsYXNzIGV4dGVuZHMgRm9ybWF0SGVscGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmNhbkZvcm1hdE11bHRpcGxlUmFuZ2VzID0gZmFsc2U7XG4gIH1cbiAgYXN5bmMgcHJvdmlkZURvY3VtZW50UmFuZ2VGb3JtYXR0aW5nRWRpdHMobW9kZWwsIHJhbmdlLCBvcHRpb25zLCB0b2tlbikge1xuICAgIGNvbnN0IHJlc291cmNlID0gbW9kZWwudXJpO1xuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gbW9kZWwuZ2V0T2Zmc2V0QXQoe1xuICAgICAgbGluZU51bWJlcjogcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgY29sdW1uOiByYW5nZS5zdGFydENvbHVtblxuICAgIH0pO1xuICAgIGNvbnN0IGVuZE9mZnNldCA9IG1vZGVsLmdldE9mZnNldEF0KHtcbiAgICAgIGxpbmVOdW1iZXI6IHJhbmdlLmVuZExpbmVOdW1iZXIsXG4gICAgICBjb2x1bW46IHJhbmdlLmVuZENvbHVtblxuICAgIH0pO1xuICAgIGNvbnN0IHdvcmtlciA9IGF3YWl0IHRoaXMuX3dvcmtlcihyZXNvdXJjZSk7XG4gICAgaWYgKG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlZGl0cyA9IGF3YWl0IHdvcmtlci5nZXRGb3JtYXR0aW5nRWRpdHNGb3JSYW5nZShcbiAgICAgIHJlc291cmNlLnRvU3RyaW5nKCksXG4gICAgICBzdGFydE9mZnNldCxcbiAgICAgIGVuZE9mZnNldCxcbiAgICAgIEZvcm1hdEhlbHBlci5fY29udmVydE9wdGlvbnMob3B0aW9ucylcbiAgICApO1xuICAgIGlmICghZWRpdHMgfHwgbW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBlZGl0cy5tYXAoKGVkaXQpID0+IHRoaXMuX2NvbnZlcnRUZXh0Q2hhbmdlcyhtb2RlbCwgZWRpdCkpO1xuICB9XG59O1xudmFyIEZvcm1hdE9uVHlwZUFkYXB0ZXIgPSBjbGFzcyBleHRlbmRzIEZvcm1hdEhlbHBlciB7XG4gIGdldCBhdXRvRm9ybWF0VHJpZ2dlckNoYXJhY3RlcnMoKSB7XG4gICAgcmV0dXJuIFtcIjtcIiwgXCJ9XCIsIFwiXFxuXCJdO1xuICB9XG4gIGFzeW5jIHByb3ZpZGVPblR5cGVGb3JtYXR0aW5nRWRpdHMobW9kZWwsIHBvc2l0aW9uLCBjaCwgb3B0aW9ucywgdG9rZW4pIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IG1vZGVsLnVyaTtcbiAgICBjb25zdCBvZmZzZXQgPSBtb2RlbC5nZXRPZmZzZXRBdChwb3NpdGlvbik7XG4gICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5fd29ya2VyKHJlc291cmNlKTtcbiAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRzID0gYXdhaXQgd29ya2VyLmdldEZvcm1hdHRpbmdFZGl0c0FmdGVyS2V5c3Ryb2tlKFxuICAgICAgcmVzb3VyY2UudG9TdHJpbmcoKSxcbiAgICAgIG9mZnNldCxcbiAgICAgIGNoLFxuICAgICAgRm9ybWF0SGVscGVyLl9jb252ZXJ0T3B0aW9ucyhvcHRpb25zKVxuICAgICk7XG4gICAgaWYgKCFlZGl0cyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRzLm1hcCgoZWRpdCkgPT4gdGhpcy5fY29udmVydFRleHRDaGFuZ2VzKG1vZGVsLCBlZGl0KSk7XG4gIH1cbn07XG52YXIgQ29kZUFjdGlvbkFkYXB0b3IgPSBjbGFzcyBleHRlbmRzIEZvcm1hdEhlbHBlciB7XG4gIGFzeW5jIHByb3ZpZGVDb2RlQWN0aW9ucyhtb2RlbCwgcmFuZ2UsIGNvbnRleHQsIHRva2VuKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBtb2RlbC51cmk7XG4gICAgY29uc3Qgc3RhcnQgPSBtb2RlbC5nZXRPZmZzZXRBdCh7XG4gICAgICBsaW5lTnVtYmVyOiByYW5nZS5zdGFydExpbmVOdW1iZXIsXG4gICAgICBjb2x1bW46IHJhbmdlLnN0YXJ0Q29sdW1uXG4gICAgfSk7XG4gICAgY29uc3QgZW5kID0gbW9kZWwuZ2V0T2Zmc2V0QXQoe1xuICAgICAgbGluZU51bWJlcjogcmFuZ2UuZW5kTGluZU51bWJlcixcbiAgICAgIGNvbHVtbjogcmFuZ2UuZW5kQ29sdW1uXG4gICAgfSk7XG4gICAgY29uc3QgZm9ybWF0T3B0aW9ucyA9IEZvcm1hdEhlbHBlci5fY29udmVydE9wdGlvbnMobW9kZWwuZ2V0T3B0aW9ucygpKTtcbiAgICBjb25zdCBlcnJvckNvZGVzID0gY29udGV4dC5tYXJrZXJzLmZpbHRlcigobSkgPT4gbS5jb2RlKS5tYXAoKG0pID0+IG0uY29kZSkubWFwKE51bWJlcik7XG4gICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5fd29ya2VyKHJlc291cmNlKTtcbiAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvZGVGaXhlcyA9IGF3YWl0IHdvcmtlci5nZXRDb2RlRml4ZXNBdFBvc2l0aW9uKFxuICAgICAgcmVzb3VyY2UudG9TdHJpbmcoKSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgZXJyb3JDb2RlcyxcbiAgICAgIGZvcm1hdE9wdGlvbnNcbiAgICApO1xuICAgIGlmICghY29kZUZpeGVzIHx8IG1vZGVsLmlzRGlzcG9zZWQoKSkge1xuICAgICAgcmV0dXJuIHsgYWN0aW9uczogW10sIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgIH0gfTtcbiAgICB9XG4gICAgY29uc3QgYWN0aW9ucyA9IGNvZGVGaXhlcy5maWx0ZXIoKGZpeCkgPT4ge1xuICAgICAgcmV0dXJuIGZpeC5jaGFuZ2VzLmZpbHRlcigoY2hhbmdlKSA9PiBjaGFuZ2UuaXNOZXdGaWxlKS5sZW5ndGggPT09IDA7XG4gICAgfSkubWFwKChmaXgpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl90c0NvZGVGaXhBY3Rpb25Ub01vbmFjb0NvZGVBY3Rpb24obW9kZWwsIGNvbnRleHQsIGZpeCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbnMsXG4gICAgICBkaXNwb3NlOiAoKSA9PiB7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBfdHNDb2RlRml4QWN0aW9uVG9Nb25hY29Db2RlQWN0aW9uKG1vZGVsLCBjb250ZXh0LCBjb2RlRml4KSB7XG4gICAgY29uc3QgZWRpdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjb2RlRml4LmNoYW5nZXMpIHtcbiAgICAgIGZvciAoY29uc3QgdGV4dENoYW5nZSBvZiBjaGFuZ2UudGV4dENoYW5nZXMpIHtcbiAgICAgICAgZWRpdHMucHVzaCh7XG4gICAgICAgICAgcmVzb3VyY2U6IG1vZGVsLnVyaSxcbiAgICAgICAgICB2ZXJzaW9uSWQ6IHZvaWQgMCxcbiAgICAgICAgICB0ZXh0RWRpdDoge1xuICAgICAgICAgICAgcmFuZ2U6IHRoaXMuX3RleHRTcGFuVG9SYW5nZShtb2RlbCwgdGV4dENoYW5nZS5zcGFuKSxcbiAgICAgICAgICAgIHRleHQ6IHRleHRDaGFuZ2UubmV3VGV4dFxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFjdGlvbiA9IHtcbiAgICAgIHRpdGxlOiBjb2RlRml4LmRlc2NyaXB0aW9uLFxuICAgICAgZWRpdDogeyBlZGl0cyB9LFxuICAgICAgZGlhZ25vc3RpY3M6IGNvbnRleHQubWFya2VycyxcbiAgICAgIGtpbmQ6IFwicXVpY2tmaXhcIlxuICAgIH07XG4gICAgcmV0dXJuIGFjdGlvbjtcbiAgfVxufTtcbnZhciBSZW5hbWVBZGFwdGVyID0gY2xhc3MgZXh0ZW5kcyBBZGFwdGVyIHtcbiAgY29uc3RydWN0b3IoX2xpYkZpbGVzLCB3b3JrZXIpIHtcbiAgICBzdXBlcih3b3JrZXIpO1xuICAgIHRoaXMuX2xpYkZpbGVzID0gX2xpYkZpbGVzO1xuICB9XG4gIGFzeW5jIHByb3ZpZGVSZW5hbWVFZGl0cyhtb2RlbCwgcG9zaXRpb24sIG5ld05hbWUsIHRva2VuKSB7XG4gICAgY29uc3QgcmVzb3VyY2UgPSBtb2RlbC51cmk7XG4gICAgY29uc3QgZmlsZU5hbWUgPSByZXNvdXJjZS50b1N0cmluZygpO1xuICAgIGNvbnN0IG9mZnNldCA9IG1vZGVsLmdldE9mZnNldEF0KHBvc2l0aW9uKTtcbiAgICBjb25zdCB3b3JrZXIgPSBhd2FpdCB0aGlzLl93b3JrZXIocmVzb3VyY2UpO1xuICAgIGlmIChtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmVuYW1lSW5mbyA9IGF3YWl0IHdvcmtlci5nZXRSZW5hbWVJbmZvKGZpbGVOYW1lLCBvZmZzZXQsIHtcbiAgICAgIGFsbG93UmVuYW1lT2ZJbXBvcnRQYXRoOiBmYWxzZVxuICAgIH0pO1xuICAgIGlmIChyZW5hbWVJbmZvLmNhblJlbmFtZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVkaXRzOiBbXSxcbiAgICAgICAgcmVqZWN0UmVhc29uOiByZW5hbWVJbmZvLmxvY2FsaXplZEVycm9yTWVzc2FnZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHJlbmFtZUluZm8uZmlsZVRvUmVuYW1lICE9PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlbmFtaW5nIGZpbGVzIGlzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCByZW5hbWVMb2NhdGlvbnMgPSBhd2FpdCB3b3JrZXIuZmluZFJlbmFtZUxvY2F0aW9ucyhcbiAgICAgIGZpbGVOYW1lLFxuICAgICAgb2Zmc2V0LFxuICAgICAgLypzdHJpbmdzKi9cbiAgICAgIGZhbHNlLFxuICAgICAgLypjb21tZW50cyovXG4gICAgICBmYWxzZSxcbiAgICAgIC8qcHJlZml4QW5kU3VmZml4Ki9cbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBpZiAoIXJlbmFtZUxvY2F0aW9ucyB8fCBtb2RlbC5pc0Rpc3Bvc2VkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJlbmFtZUxvY2F0aW9uIG9mIHJlbmFtZUxvY2F0aW9ucykge1xuICAgICAgY29uc3QgbW9kZWwyID0gdGhpcy5fbGliRmlsZXMuZ2V0T3JDcmVhdGVNb2RlbChyZW5hbWVMb2NhdGlvbi5maWxlTmFtZSk7XG4gICAgICBpZiAobW9kZWwyKSB7XG4gICAgICAgIGVkaXRzLnB1c2goe1xuICAgICAgICAgIHJlc291cmNlOiBtb2RlbDIudXJpLFxuICAgICAgICAgIHZlcnNpb25JZDogdm9pZCAwLFxuICAgICAgICAgIHRleHRFZGl0OiB7XG4gICAgICAgICAgICByYW5nZTogdGhpcy5fdGV4dFNwYW5Ub1JhbmdlKG1vZGVsMiwgcmVuYW1lTG9jYXRpb24udGV4dFNwYW4pLFxuICAgICAgICAgICAgdGV4dDogbmV3TmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsZSAke3JlbmFtZUxvY2F0aW9uLmZpbGVOYW1lfS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZWRpdHMgfTtcbiAgfVxufTtcbnZhciBJbmxheUhpbnRzQWRhcHRlciA9IGNsYXNzIGV4dGVuZHMgQWRhcHRlciB7XG4gIGFzeW5jIHByb3ZpZGVJbmxheUhpbnRzKG1vZGVsLCByYW5nZSwgdG9rZW4pIHtcbiAgICBjb25zdCByZXNvdXJjZSA9IG1vZGVsLnVyaTtcbiAgICBjb25zdCBmaWxlTmFtZSA9IHJlc291cmNlLnRvU3RyaW5nKCk7XG4gICAgY29uc3Qgc3RhcnQgPSBtb2RlbC5nZXRPZmZzZXRBdCh7XG4gICAgICBsaW5lTnVtYmVyOiByYW5nZS5zdGFydExpbmVOdW1iZXIsXG4gICAgICBjb2x1bW46IHJhbmdlLnN0YXJ0Q29sdW1uXG4gICAgfSk7XG4gICAgY29uc3QgZW5kID0gbW9kZWwuZ2V0T2Zmc2V0QXQoe1xuICAgICAgbGluZU51bWJlcjogcmFuZ2UuZW5kTGluZU51bWJlcixcbiAgICAgIGNvbHVtbjogcmFuZ2UuZW5kQ29sdW1uXG4gICAgfSk7XG4gICAgY29uc3Qgd29ya2VyID0gYXdhaXQgdGhpcy5fd29ya2VyKHJlc291cmNlKTtcbiAgICBpZiAobW9kZWwuaXNEaXNwb3NlZCgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdHNIaW50cyA9IGF3YWl0IHdvcmtlci5wcm92aWRlSW5sYXlIaW50cyhmaWxlTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgY29uc3QgaGludHMgPSB0c0hpbnRzLm1hcCgoaGludCkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaGludCxcbiAgICAgICAgbGFiZWw6IGhpbnQudGV4dCxcbiAgICAgICAgcG9zaXRpb246IG1vZGVsLmdldFBvc2l0aW9uQXQoaGludC5wb3NpdGlvbiksXG4gICAgICAgIGtpbmQ6IHRoaXMuX2NvbnZlcnRIaW50S2luZChoaW50LmtpbmQpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB7IGhpbnRzLCBkaXNwb3NlOiAoKSA9PiB7XG4gICAgfSB9O1xuICB9XG4gIF9jb252ZXJ0SGludEtpbmQoa2luZCkge1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBcIlBhcmFtZXRlclwiOlxuICAgICAgICByZXR1cm4gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLklubGF5SGludEtpbmQuUGFyYW1ldGVyO1xuICAgICAgY2FzZSBcIlR5cGVcIjpcbiAgICAgICAgcmV0dXJuIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5JbmxheUhpbnRLaW5kLlR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLklubGF5SGludEtpbmQuVHlwZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9sYW5ndWFnZS90eXBlc2NyaXB0L3RzTW9kZS50c1xudmFyIGphdmFTY3JpcHRXb3JrZXI7XG52YXIgdHlwZVNjcmlwdFdvcmtlcjtcbmZ1bmN0aW9uIHNldHVwVHlwZVNjcmlwdChkZWZhdWx0cykge1xuICB0eXBlU2NyaXB0V29ya2VyID0gc2V0dXBNb2RlKGRlZmF1bHRzLCBcInR5cGVzY3JpcHRcIik7XG59XG5mdW5jdGlvbiBzZXR1cEphdmFTY3JpcHQoZGVmYXVsdHMpIHtcbiAgamF2YVNjcmlwdFdvcmtlciA9IHNldHVwTW9kZShkZWZhdWx0cywgXCJqYXZhc2NyaXB0XCIpO1xufVxuZnVuY3Rpb24gZ2V0SmF2YVNjcmlwdFdvcmtlcigpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBpZiAoIWphdmFTY3JpcHRXb3JrZXIpIHtcbiAgICAgIHJldHVybiByZWplY3QoXCJKYXZhU2NyaXB0IG5vdCByZWdpc3RlcmVkIVwiKTtcbiAgICB9XG4gICAgcmVzb2x2ZShqYXZhU2NyaXB0V29ya2VyKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRUeXBlU2NyaXB0V29ya2VyKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmICghdHlwZVNjcmlwdFdvcmtlcikge1xuICAgICAgcmV0dXJuIHJlamVjdChcIlR5cGVTY3JpcHQgbm90IHJlZ2lzdGVyZWQhXCIpO1xuICAgIH1cbiAgICByZXNvbHZlKHR5cGVTY3JpcHRXb3JrZXIpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNldHVwTW9kZShkZWZhdWx0cywgbW9kZUlkKSB7XG4gIGNvbnN0IGRpc3Bvc2FibGVzID0gW107XG4gIGNvbnN0IHByb3ZpZGVycyA9IFtdO1xuICBjb25zdCBjbGllbnQgPSBuZXcgV29ya2VyTWFuYWdlcihtb2RlSWQsIGRlZmF1bHRzKTtcbiAgZGlzcG9zYWJsZXMucHVzaChjbGllbnQpO1xuICBjb25zdCB3b3JrZXIgPSAoLi4udXJpcykgPT4ge1xuICAgIHJldHVybiBjbGllbnQuZ2V0TGFuZ3VhZ2VTZXJ2aWNlV29ya2VyKC4uLnVyaXMpO1xuICB9O1xuICBjb25zdCBsaWJGaWxlcyA9IG5ldyBMaWJGaWxlcyh3b3JrZXIpO1xuICBmdW5jdGlvbiByZWdpc3RlclByb3ZpZGVycygpIHtcbiAgICBjb25zdCB7IG1vZGVDb25maWd1cmF0aW9uIH0gPSBkZWZhdWx0cztcbiAgICBkaXNwb3NlQWxsKHByb3ZpZGVycyk7XG4gICAgaWYgKG1vZGVDb25maWd1cmF0aW9uLmNvbXBsZXRpb25JdGVtcykge1xuICAgICAgcHJvdmlkZXJzLnB1c2goXG4gICAgICAgIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5yZWdpc3RlckNvbXBsZXRpb25JdGVtUHJvdmlkZXIoXG4gICAgICAgICAgbW9kZUlkLFxuICAgICAgICAgIG5ldyBTdWdnZXN0QWRhcHRlcih3b3JrZXIpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtb2RlQ29uZmlndXJhdGlvbi5zaWduYXR1cmVIZWxwKSB7XG4gICAgICBwcm92aWRlcnMucHVzaChcbiAgICAgICAgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLnJlZ2lzdGVyU2lnbmF0dXJlSGVscFByb3ZpZGVyKFxuICAgICAgICAgIG1vZGVJZCxcbiAgICAgICAgICBuZXcgU2lnbmF0dXJlSGVscEFkYXB0ZXIod29ya2VyKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobW9kZUNvbmZpZ3VyYXRpb24uaG92ZXJzKSB7XG4gICAgICBwcm92aWRlcnMucHVzaChcbiAgICAgICAgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLnJlZ2lzdGVySG92ZXJQcm92aWRlcihtb2RlSWQsIG5ldyBRdWlja0luZm9BZGFwdGVyKHdvcmtlcikpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobW9kZUNvbmZpZ3VyYXRpb24uZG9jdW1lbnRIaWdobGlnaHRzKSB7XG4gICAgICBwcm92aWRlcnMucHVzaChcbiAgICAgICAgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLnJlZ2lzdGVyRG9jdW1lbnRIaWdobGlnaHRQcm92aWRlcihcbiAgICAgICAgICBtb2RlSWQsXG4gICAgICAgICAgbmV3IERvY3VtZW50SGlnaGxpZ2h0QWRhcHRlcih3b3JrZXIpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtb2RlQ29uZmlndXJhdGlvbi5kZWZpbml0aW9ucykge1xuICAgICAgcHJvdmlkZXJzLnB1c2goXG4gICAgICAgIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5yZWdpc3RlckRlZmluaXRpb25Qcm92aWRlcihcbiAgICAgICAgICBtb2RlSWQsXG4gICAgICAgICAgbmV3IERlZmluaXRpb25BZGFwdGVyKGxpYkZpbGVzLCB3b3JrZXIpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtb2RlQ29uZmlndXJhdGlvbi5yZWZlcmVuY2VzKSB7XG4gICAgICBwcm92aWRlcnMucHVzaChcbiAgICAgICAgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLnJlZ2lzdGVyUmVmZXJlbmNlUHJvdmlkZXIoXG4gICAgICAgICAgbW9kZUlkLFxuICAgICAgICAgIG5ldyBSZWZlcmVuY2VBZGFwdGVyKGxpYkZpbGVzLCB3b3JrZXIpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtb2RlQ29uZmlndXJhdGlvbi5kb2N1bWVudFN5bWJvbHMpIHtcbiAgICAgIHByb3ZpZGVycy5wdXNoKFxuICAgICAgICBtb25hY29fZWRpdG9yX2NvcmVfZXhwb3J0cy5sYW5ndWFnZXMucmVnaXN0ZXJEb2N1bWVudFN5bWJvbFByb3ZpZGVyKFxuICAgICAgICAgIG1vZGVJZCxcbiAgICAgICAgICBuZXcgT3V0bGluZUFkYXB0ZXIod29ya2VyKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobW9kZUNvbmZpZ3VyYXRpb24ucmVuYW1lKSB7XG4gICAgICBwcm92aWRlcnMucHVzaChcbiAgICAgICAgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLnJlZ2lzdGVyUmVuYW1lUHJvdmlkZXIoXG4gICAgICAgICAgbW9kZUlkLFxuICAgICAgICAgIG5ldyBSZW5hbWVBZGFwdGVyKGxpYkZpbGVzLCB3b3JrZXIpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChtb2RlQ29uZmlndXJhdGlvbi5kb2N1bWVudFJhbmdlRm9ybWF0dGluZ0VkaXRzKSB7XG4gICAgICBwcm92aWRlcnMucHVzaChcbiAgICAgICAgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLnJlZ2lzdGVyRG9jdW1lbnRSYW5nZUZvcm1hdHRpbmdFZGl0UHJvdmlkZXIoXG4gICAgICAgICAgbW9kZUlkLFxuICAgICAgICAgIG5ldyBGb3JtYXRBZGFwdGVyKHdvcmtlcilcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1vZGVDb25maWd1cmF0aW9uLm9uVHlwZUZvcm1hdHRpbmdFZGl0cykge1xuICAgICAgcHJvdmlkZXJzLnB1c2goXG4gICAgICAgIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5yZWdpc3Rlck9uVHlwZUZvcm1hdHRpbmdFZGl0UHJvdmlkZXIoXG4gICAgICAgICAgbW9kZUlkLFxuICAgICAgICAgIG5ldyBGb3JtYXRPblR5cGVBZGFwdGVyKHdvcmtlcilcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1vZGVDb25maWd1cmF0aW9uLmNvZGVBY3Rpb25zKSB7XG4gICAgICBwcm92aWRlcnMucHVzaChcbiAgICAgICAgbW9uYWNvX2VkaXRvcl9jb3JlX2V4cG9ydHMubGFuZ3VhZ2VzLnJlZ2lzdGVyQ29kZUFjdGlvblByb3ZpZGVyKG1vZGVJZCwgbmV3IENvZGVBY3Rpb25BZGFwdG9yKHdvcmtlcikpXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAobW9kZUNvbmZpZ3VyYXRpb24uaW5sYXlIaW50cykge1xuICAgICAgcHJvdmlkZXJzLnB1c2goXG4gICAgICAgIG1vbmFjb19lZGl0b3JfY29yZV9leHBvcnRzLmxhbmd1YWdlcy5yZWdpc3RlcklubGF5SGludHNQcm92aWRlcihtb2RlSWQsIG5ldyBJbmxheUhpbnRzQWRhcHRlcih3b3JrZXIpKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1vZGVDb25maWd1cmF0aW9uLmRpYWdub3N0aWNzKSB7XG4gICAgICBwcm92aWRlcnMucHVzaChuZXcgRGlhZ25vc3RpY3NBZGFwdGVyKGxpYkZpbGVzLCBkZWZhdWx0cywgbW9kZUlkLCB3b3JrZXIpKTtcbiAgICB9XG4gIH1cbiAgcmVnaXN0ZXJQcm92aWRlcnMoKTtcbiAgZGlzcG9zYWJsZXMucHVzaChhc0Rpc3Bvc2FibGUocHJvdmlkZXJzKSk7XG4gIHJldHVybiB3b3JrZXI7XG59XG5mdW5jdGlvbiBhc0Rpc3Bvc2FibGUoZGlzcG9zYWJsZXMpIHtcbiAgcmV0dXJuIHsgZGlzcG9zZTogKCkgPT4gZGlzcG9zZUFsbChkaXNwb3NhYmxlcykgfTtcbn1cbmZ1bmN0aW9uIGRpc3Bvc2VBbGwoZGlzcG9zYWJsZXMpIHtcbiAgd2hpbGUgKGRpc3Bvc2FibGVzLmxlbmd0aCkge1xuICAgIGRpc3Bvc2FibGVzLnBvcCgpLmRpc3Bvc2UoKTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgQWRhcHRlcixcbiAgQ29kZUFjdGlvbkFkYXB0b3IsXG4gIERlZmluaXRpb25BZGFwdGVyLFxuICBEaWFnbm9zdGljc0FkYXB0ZXIsXG4gIERvY3VtZW50SGlnaGxpZ2h0QWRhcHRlcixcbiAgRm9ybWF0QWRhcHRlcixcbiAgRm9ybWF0SGVscGVyLFxuICBGb3JtYXRPblR5cGVBZGFwdGVyLFxuICBJbmxheUhpbnRzQWRhcHRlcixcbiAgS2luZCxcbiAgTGliRmlsZXMsXG4gIE91dGxpbmVBZGFwdGVyLFxuICBRdWlja0luZm9BZGFwdGVyLFxuICBSZWZlcmVuY2VBZGFwdGVyLFxuICBSZW5hbWVBZGFwdGVyLFxuICBTaWduYXR1cmVIZWxwQWRhcHRlcixcbiAgU3VnZ2VzdEFkYXB0ZXIsXG4gIFdvcmtlck1hbmFnZXIsXG4gIGZsYXR0ZW5EaWFnbm9zdGljTWVzc2FnZVRleHQsXG4gIGdldEphdmFTY3JpcHRXb3JrZXIsXG4gIGdldFR5cGVTY3JpcHRXb3JrZXIsXG4gIHNldHVwSmF2YVNjcmlwdCxcbiAgc2V0dXBUeXBlU2NyaXB0XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59355\n')}}]);