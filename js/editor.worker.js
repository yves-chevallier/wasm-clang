(()=>{var __webpack_modules__={49:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{"use strict";eval("\n// UNUSED EXPORTS: initialize\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/errors.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nclass ErrorHandler {\n    constructor() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(() => {\n                if (e.stack) {\n                    if (ErrorNoTelemetry.isErrorNoTelemetry(e)) {\n                        throw new ErrorNoTelemetry(e.message + '\\n\\n' + e.stack);\n                    }\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    emit(e) {\n        this.listeners.forEach((listener) => {\n            listener(e);\n        });\n    }\n    onUnexpectedError(e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    }\n    // For external errors, we don't want the listeners to be called\n    onUnexpectedExternalError(e) {\n        this.unexpectedErrorHandler(e);\n    }\n}\nconst errorHandler = new ErrorHandler();\nfunction errors_onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nfunction onUnexpectedExternalError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        errorHandler.onUnexpectedExternalError(e);\n    }\n    return undefined;\n}\nfunction transformErrorForSerialization(error) {\n    if (error instanceof Error) {\n        const { name, message } = error;\n        const stack = error.stacktrace || error.stack;\n        return {\n            $isError: true,\n            name,\n            message,\n            stack,\n            noTelemetry: ErrorNoTelemetry.isErrorNoTelemetry(error)\n        };\n    }\n    // return as is\n    return error;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nfunction isCancellationError(error) {\n    if (error instanceof CancellationError) {\n        return true;\n    }\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nclass CancellationError extends Error {\n    constructor() {\n        super(canceledName);\n        this.name = this.message;\n    }\n}\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nfunction canceled() {\n    const error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\nfunction illegalArgument(name) {\n    if (name) {\n        return new Error(`Illegal argument: ${name}`);\n    }\n    else {\n        return new Error('Illegal argument');\n    }\n}\nfunction illegalState(name) {\n    if (name) {\n        return new Error(`Illegal state: ${name}`);\n    }\n    else {\n        return new Error('Illegal state');\n    }\n}\nclass NotSupportedError extends Error {\n    constructor(message) {\n        super('NotSupported');\n        if (message) {\n            this.message = message;\n        }\n    }\n}\n/**\n * Error that when thrown won't be logged in telemetry as an unhandled error.\n */\nclass ErrorNoTelemetry extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = 'CodeExpectedError';\n    }\n    static fromError(err) {\n        if (err instanceof ErrorNoTelemetry) {\n            return err;\n        }\n        const result = new ErrorNoTelemetry();\n        result.message = err.message;\n        result.stack = err.stack;\n        return result;\n    }\n    static isErrorNoTelemetry(err) {\n        return err.name === 'CodeExpectedError';\n    }\n}\n/**\n * This error indicates a bug.\n * Do not throw this for invalid user input.\n * Only catch this error to recover gracefully from bugs.\n */\nclass errors_BugIndicatingError extends Error {\n    constructor(message) {\n        super(message || 'An unexpected bug occurred.');\n        Object.setPrototypeOf(this, errors_BugIndicatingError.prototype);\n        // Because we know for sure only buggy code throws this,\n        // we definitely want to break here and fix the bug.\n        // eslint-disable-next-line no-debugger\n        // debugger;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/functional.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Given a function, returns a function that is only calling that function once.\n */\nfunction functional_createSingleCallFunction(fn, fnDidRunCallback) {\n    const _this = this;\n    let didCall = false;\n    let result;\n    return function () {\n        if (didCall) {\n            return result;\n        }\n        didCall = true;\n        if (fnDidRunCallback) {\n            try {\n                result = fn.apply(_this, arguments);\n            }\n            finally {\n                fnDidRunCallback();\n            }\n        }\n        else {\n            result = fn.apply(_this, arguments);\n        }\n        return result;\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/iterator.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar Iterable;\n(function (Iterable) {\n    function is(thing) {\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n    }\n    Iterable.is = is;\n    const _empty = Object.freeze([]);\n    function empty() {\n        return _empty;\n    }\n    Iterable.empty = empty;\n    function* single(element) {\n        yield element;\n    }\n    Iterable.single = single;\n    function wrap(iterableOrElement) {\n        if (is(iterableOrElement)) {\n            return iterableOrElement;\n        }\n        else {\n            return single(iterableOrElement);\n        }\n    }\n    Iterable.wrap = wrap;\n    function from(iterable) {\n        return iterable || _empty;\n    }\n    Iterable.from = from;\n    function* reverse(array) {\n        for (let i = array.length - 1; i >= 0; i--) {\n            yield array[i];\n        }\n    }\n    Iterable.reverse = reverse;\n    function isEmpty(iterable) {\n        return !iterable || iterable[Symbol.iterator]().next().done === true;\n    }\n    Iterable.isEmpty = isEmpty;\n    function first(iterable) {\n        return iterable[Symbol.iterator]().next().value;\n    }\n    Iterable.first = first;\n    function some(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Iterable.some = some;\n    function find(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return undefined;\n    }\n    Iterable.find = find;\n    function* filter(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                yield element;\n            }\n        }\n    }\n    Iterable.filter = filter;\n    function* map(iterable, fn) {\n        let index = 0;\n        for (const element of iterable) {\n            yield fn(element, index++);\n        }\n    }\n    Iterable.map = map;\n    function* concat(...iterables) {\n        for (const iterable of iterables) {\n            yield* iterable;\n        }\n    }\n    Iterable.concat = concat;\n    function reduce(iterable, reducer, initialValue) {\n        let value = initialValue;\n        for (const element of iterable) {\n            value = reducer(value, element);\n        }\n        return value;\n    }\n    Iterable.reduce = reduce;\n    /**\n     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n     */\n    function* slice(arr, from, to = arr.length) {\n        if (from < 0) {\n            from += arr.length;\n        }\n        if (to < 0) {\n            to += arr.length;\n        }\n        else if (to > arr.length) {\n            to = arr.length;\n        }\n        for (; from < to; from++) {\n            yield arr[from];\n        }\n    }\n    Iterable.slice = slice;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n        const consumed = [];\n        if (atMost === 0) {\n            return [consumed, iterable];\n        }\n        const iterator = iterable[Symbol.iterator]();\n        for (let i = 0; i < atMost; i++) {\n            const next = iterator.next();\n            if (next.done) {\n                return [consumed, Iterable.empty()];\n            }\n            consumed.push(next.value);\n        }\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\n    }\n    Iterable.consume = consume;\n    async function asyncToArray(iterable) {\n        const result = [];\n        for await (const item of iterable) {\n            result.push(item);\n        }\n        return Promise.resolve(result);\n    }\n    Iterable.asyncToArray = asyncToArray;\n})(Iterable || (Iterable = {}));\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/lifecycle.js\n\n\n// #region Disposable Tracking\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nfunction setDisposableTracker(tracker) {\n    disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\n    setDisposableTracker(new class {\n        trackDisposable(x) {\n            const stack = new Error('Potentially leaked disposable').stack;\n            setTimeout(() => {\n                if (!x[__is_disposable_tracked__]) {\n                    console.log(stack);\n                }\n            }, 3000);\n        }\n        setParent(child, parent) {\n            if (child && child !== lifecycle_Disposable.None) {\n                try {\n                    child[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n        markAsDisposed(disposable) {\n            if (disposable && disposable !== lifecycle_Disposable.None) {\n                try {\n                    disposable[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n        markAsSingleton(disposable) { }\n    });\n}\nfunction trackDisposable(x) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\n    return x;\n}\nfunction markAsDisposed(disposable) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n    if (!disposableTracker) {\n        return;\n    }\n    for (const child of children) {\n        disposableTracker.setParent(child, parent);\n    }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nfunction markAsSingleton(singleton) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);\n    return singleton;\n}\n/**\n * Check if `thing` is {@link IDisposable disposable}.\n */\nfunction isDisposable(thing) {\n    return typeof thing === 'object' && thing !== null && typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nfunction dispose(arg) {\n    if (Iterable.is(arg)) {\n        const errors = [];\n        for (const d of arg) {\n            if (d) {\n                try {\n                    d.dispose();\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        else if (errors.length > 1) {\n            throw new AggregateError(errors, 'Encountered errors while disposing of store');\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        arg.dispose();\n        return arg;\n    }\n}\n/**\n * Combine multiple disposable values into a single {@link IDisposable}.\n */\nfunction combinedDisposable(...disposables) {\n    const parent = lifecycle_toDisposable(() => dispose(disposables));\n    setParentOfDisposables(disposables, parent);\n    return parent;\n}\n/**\n * Turn a function that implements dispose into an {@link IDisposable}.\n *\n * @param fn Clean up function, guaranteed to be called only **once**.\n */\nfunction lifecycle_toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: functional_createSingleCallFunction(() => {\n            markAsDisposed(self);\n            fn();\n        })\n    });\n    return self;\n}\n/**\n * Manages a collection of disposable values.\n *\n * This is the preferred way to manage multiple disposables. A `DisposableStore` is safer to work with than an\n * `IDisposable[]` as it considers edge cases, such as registering the same value multiple times or adding an item to a\n * store that has already been disposed of.\n */\nclass DisposableStore {\n    constructor() {\n        this._toDispose = new Set();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Dispose of all registered disposables and mark this object as disposed.\n     *\n     * Any future disposables added to this object will be disposed of on `add`.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clear();\n    }\n    /**\n     * @return `true` if this object has been disposed of.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n    clear() {\n        if (this._toDispose.size === 0) {\n            return;\n        }\n        try {\n            dispose(this._toDispose);\n        }\n        finally {\n            this._toDispose.clear();\n        }\n    }\n    /**\n     * Add a new {@link IDisposable disposable} to the collection.\n     */\n    add(o) {\n        if (!o) {\n            return o;\n        }\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        setParentOfDisposable(o, this);\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n            }\n        }\n        else {\n            this._toDispose.add(o);\n        }\n        return o;\n    }\n    /**\n     * Deletes the value from the store, but does not dispose it.\n     */\n    deleteAndLeak(o) {\n        if (!o) {\n            return;\n        }\n        if (this._toDispose.has(o)) {\n            this._toDispose.delete(o);\n            setParentOfDisposable(o, null);\n        }\n    }\n}\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\n/**\n * Abstract base class for a {@link IDisposable disposable} object.\n *\n * Subclasses can {@linkcode _register} disposables that will be automatically cleaned up when this object is disposed of.\n */\nclass lifecycle_Disposable {\n    constructor() {\n        this._store = new DisposableStore();\n        trackDisposable(this);\n        setParentOfDisposable(this._store, this);\n    }\n    dispose() {\n        markAsDisposed(this);\n        this._store.dispose();\n    }\n    /**\n     * Adds `o` to the collection of disposables managed by this object.\n     */\n    _register(o) {\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        return this._store.add(o);\n    }\n}\n/**\n * A disposable that does nothing when it is disposed of.\n *\n * TODO: This should not be a static property.\n */\nlifecycle_Disposable.None = Object.freeze({ dispose() { } });\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nclass MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        var _a;\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        if (value) {\n            setParentOfDisposable(value, this);\n        }\n        this._value = value;\n    }\n    /**\n     * Resets the stored value and disposed of the previously stored value.\n     */\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        var _a;\n        this._isDisposed = true;\n        markAsDisposed(this);\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._value = undefined;\n    }\n}\nclass RefCountedDisposable {\n    constructor(_disposable) {\n        this._disposable = _disposable;\n        this._counter = 1;\n    }\n    acquire() {\n        this._counter++;\n        return this;\n    }\n    release() {\n        if (--this._counter === 0) {\n            this._disposable.dispose();\n        }\n        return this;\n    }\n}\nclass ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\n/**\n * A map the manages the lifecycle of the values that it stores.\n */\nclass DisposableMap {\n    constructor() {\n        this._store = new Map();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Disposes of all stored values and mark this object as disposed.\n     *\n     * Trying to use this object after it has been disposed of is an error.\n     */\n    dispose() {\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clearAndDisposeAll();\n    }\n    /**\n     * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.\n     */\n    clearAndDisposeAll() {\n        if (!this._store.size) {\n            return;\n        }\n        try {\n            dispose(this._store.values());\n        }\n        finally {\n            this._store.clear();\n        }\n    }\n    get(key) {\n        return this._store.get(key);\n    }\n    set(key, value, skipDisposeOnOverwrite = false) {\n        var _a;\n        if (this._isDisposed) {\n            console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n        }\n        if (!skipDisposeOnOverwrite) {\n            (_a = this._store.get(key)) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n        this._store.set(key, value);\n    }\n    /**\n     * Delete the value stored for `key` from this map and also dispose of it.\n     */\n    deleteAndDispose(key) {\n        var _a;\n        (_a = this._store.get(key)) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._store.delete(key);\n    }\n    [Symbol.iterator]() {\n        return this._store[Symbol.iterator]();\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/linkedList.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass Node {\n    constructor(element) {\n        this.element = element;\n        this.next = Node.Undefined;\n        this.prev = Node.Undefined;\n    }\n}\nNode.Undefined = new Node(undefined);\nclass LinkedList {\n    constructor() {\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    get size() {\n        return this._size;\n    }\n    isEmpty() {\n        return this._first === Node.Undefined;\n    }\n    clear() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            const next = node.next;\n            node.prev = Node.Undefined;\n            node.next = Node.Undefined;\n            node = next;\n        }\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    unshift(element) {\n        return this._insert(element, false);\n    }\n    push(element) {\n        return this._insert(element, true);\n    }\n    _insert(element, atTheEnd) {\n        const newNode = new Node(element);\n        if (this._first === Node.Undefined) {\n            this._first = newNode;\n            this._last = newNode;\n        }\n        else if (atTheEnd) {\n            // push\n            const oldLast = this._last;\n            this._last = newNode;\n            newNode.prev = oldLast;\n            oldLast.next = newNode;\n        }\n        else {\n            // unshift\n            const oldFirst = this._first;\n            this._first = newNode;\n            newNode.next = oldFirst;\n            oldFirst.prev = newNode;\n        }\n        this._size += 1;\n        let didRemove = false;\n        return () => {\n            if (!didRemove) {\n                didRemove = true;\n                this._remove(newNode);\n            }\n        };\n    }\n    shift() {\n        if (this._first === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._first.element;\n            this._remove(this._first);\n            return res;\n        }\n    }\n    pop() {\n        if (this._last === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._last.element;\n            this._remove(this._last);\n            return res;\n        }\n    }\n    _remove(node) {\n        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n            // middle\n            const anchor = node.prev;\n            anchor.next = node.next;\n            node.next.prev = anchor;\n        }\n        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n            // only node\n            this._first = Node.Undefined;\n            this._last = Node.Undefined;\n        }\n        else if (node.next === Node.Undefined) {\n            // last\n            this._last = this._last.prev;\n            this._last.next = Node.Undefined;\n        }\n        else if (node.prev === Node.Undefined) {\n            // first\n            this._first = this._first.next;\n            this._first.prev = Node.Undefined;\n        }\n        // done\n        this._size -= 1;\n    }\n    *[Symbol.iterator]() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            yield node.element;\n            node = node.next;\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/stopwatch.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst hasPerformanceNow = (globalThis.performance && typeof globalThis.performance.now === 'function');\nclass StopWatch {\n    static create(highResolution) {\n        return new StopWatch(highResolution);\n    }\n    constructor(highResolution) {\n        this._now = hasPerformanceNow && highResolution === false ? Date.now : globalThis.performance.now.bind(globalThis.performance);\n        this._startTime = this._now();\n        this._stopTime = -1;\n    }\n    stop() {\n        this._stopTime = this._now();\n    }\n    reset() {\n        this._startTime = this._now();\n        this._stopTime = -1;\n    }\n    elapsed() {\n        if (this._stopTime !== -1) {\n            return this._stopTime - this._startTime;\n        }\n        return this._now() - this._startTime;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/event.js\n\n\n\n\n\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a listener is GC'ed without having been disposed. This is a LEAK.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableListenerGCedWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableDisposeWithListenerWarning = false;\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nconst _enableSnapshotPotentialLeakWarning = false;\nvar Event;\n(function (Event) {\n    Event.None = () => lifecycle_Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onDidAddListener: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onDidAddListener = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which debounces calls and defers the listeners to a later task via a shared\n     * `setTimeout`. The event is converted into a signal (`Event<void>`) to avoid additional object creation as a\n     * result of merging events and to try prevent race conditions that could arise when using related deferred and\n     * non-deferred events.\n     *\n     * This is useful for deferring non-critical work (eg. general UI updates) to ensure it does not block critical work\n     * (eg. latency of keypress to text rendered).\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function defer(event, disposable) {\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n    }\n    Event.defer = defer;\n    /**\n     * Given an event, returns another event which only fires once.\n     *\n     * @param event The event source for the new event.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * Maps an event of one type into an event of another type using a mapping function, similar to how\n     * `Array.prototype.map` works.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param map The mapping function.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * Wraps an event in another event that performs some function on the event object before firing.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param each The function to perform on the event object.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => {\n            const disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n            return addAndReturnDisposable(disposable, disposables);\n        };\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onWillAddFirstListener() {\n                listener = event(emitter.fire, emitter);\n            },\n            onDidRemoveLastListener() {\n                listener === null || listener === void 0 ? void 0 : listener.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    /**\n     * Adds the IDisposable to the store if it's set, and returns it. Useful to\n     * Event function implementation.\n     */\n    function addAndReturnDisposable(d, store) {\n        if (store instanceof Array) {\n            store.push(d);\n        }\n        else if (store) {\n            store.add(d);\n        }\n        return d;\n    }\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        let doFire;\n        const options = {\n            leakWarningThreshold,\n            onWillAddFirstListener() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    doFire = () => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    };\n                    if (typeof delay === 'number') {\n                        clearTimeout(handle);\n                        handle = setTimeout(doFire, delay);\n                    }\n                    else {\n                        if (handle === undefined) {\n                            handle = 0;\n                            queueMicrotask(doFire);\n                        }\n                    }\n                });\n            },\n            onWillRemoveListener() {\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\n                    doFire === null || doFire === void 0 ? void 0 : doFire();\n                }\n            },\n            onDidRemoveLastListener() {\n                doFire = undefined;\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        disposable === null || disposable === void 0 ? void 0 : disposable.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * Debounces an event, firing after some delay (default=0) with an array of all event original objects.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function accumulate(event, delay = 0, disposable) {\n        return Event.debounce(event, (last, e) => {\n            if (!last) {\n                return [e];\n            }\n            last.push(e);\n            return last;\n        }, delay, undefined, true, undefined, disposable);\n    }\n    Event.accumulate = accumulate;\n    /**\n     * Filters an event such that some condition is _not_ met more than once in a row, effectively ensuring duplicate\n     * event objects from different sources do not fire the same event object.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param equals The equality condition.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     *\n     * @example\n     * ```\n     * // Fire only one time when a single window is opened or focused\n     * Event.latch(Event.any(onDidOpenWindow, onDidFocusWindow))\n     * ```\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * Splits an event whose parameter is a union type into 2 separate events for each type in the union.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @example\n     * ```\n     * const event = new EventEmitter<number | undefined>().event;\n     * const [numberEvent, undefinedEvent] = Event.split(event, isUndefined);\n     * ```\n     *\n     * @param event The event source for the new event.\n     * @param isT A function that determines what event is of the first type.\n     * @param disposable A disposable store to add the new EventEmitter to.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * Buffers an event until it has a listener attached.\n     *\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     *\n     * @param event The event source for the new event.\n     * @param flushAfterTimeout Determines whether to flush the buffer after a timeout immediately or after a\n     * `setTimeout` when the first event listener is added.\n     * @param _buffer Internal: A source event array used for tests.\n     *\n     * @example\n     * ```\n     * // Start accumulating events, when the first listener is attached, flush\n     * // the event after a timeout such that multiple listeners attached before\n     * // the timeout would receive the event\n     * this.onInstallExtension = Event.buffer(service.onInstallExtension, true);\n     * ```\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        if (disposable) {\n            disposable.add(listener);\n        }\n        const flush = () => {\n            buffer === null || buffer === void 0 ? void 0 : buffer.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onWillAddFirstListener() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                    if (disposable) {\n                        disposable.add(listener);\n                    }\n                }\n            },\n            onDidAddFirstListener() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onDidRemoveLastListener() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        if (disposable) {\n            disposable.add(emitter);\n        }\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    /**\n     * Wraps the event in an {@link IChainableEvent}, allowing a more functional programming style.\n     *\n     * @example\n     * ```\n     * // Normal\n     * const onEnterPressNormal = Event.filter(\n     *   Event.map(onKeyPress.event, e => new StandardKeyboardEvent(e)),\n     *   e.keyCode === KeyCode.Enter\n     * ).event;\n     *\n     * // Using chain\n     * const onEnterPressChain = Event.chain(onKeyPress.event, $ => $\n     *   .map(e => new StandardKeyboardEvent(e))\n     *   .filter(e => e.keyCode === KeyCode.Enter)\n     * );\n     * ```\n     */\n    function chain(event, sythensize) {\n        const fn = (listener, thisArgs, disposables) => {\n            const cs = sythensize(new ChainableSynthesis());\n            return event(function (value) {\n                const result = cs.evaluate(value);\n                if (result !== HaltChainable) {\n                    listener.call(thisArgs, result);\n                }\n            }, undefined, disposables);\n        };\n        return fn;\n    }\n    Event.chain = chain;\n    const HaltChainable = Symbol('HaltChainable');\n    class ChainableSynthesis {\n        constructor() {\n            this.steps = [];\n        }\n        map(fn) {\n            this.steps.push(fn);\n            return this;\n        }\n        forEach(fn) {\n            this.steps.push(v => {\n                fn(v);\n                return v;\n            });\n            return this;\n        }\n        filter(fn) {\n            this.steps.push(v => fn(v) ? v : HaltChainable);\n            return this;\n        }\n        reduce(merge, initial) {\n            let last = initial;\n            this.steps.push(v => {\n                last = merge(last, v);\n                return last;\n            });\n            return this;\n        }\n        latch(equals = (a, b) => a === b) {\n            let firstCall = true;\n            let cache;\n            this.steps.push(value => {\n                const shouldEmit = firstCall || !equals(value, cache);\n                firstCall = false;\n                cache = value;\n                return shouldEmit ? value : HaltChainable;\n            });\n            return this;\n        }\n        evaluate(value) {\n            for (const step of this.steps) {\n                value = step(value);\n                if (value === HaltChainable) {\n                    break;\n                }\n            }\n            return value;\n        }\n    }\n    /**\n     * Creates an {@link Event} from a node event emitter.\n     */\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    /**\n     * Creates an {@link Event} from a DOM event emitter.\n     */\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    /**\n     * Creates a promise out of an event, using the {@link Event.once} helper.\n     */\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    /**\n     * Creates an event out of a promise that fires once when the promise is\n     * resolved with the result of the promise or `undefined`.\n     */\n    function fromPromise(promise) {\n        const result = new Emitter();\n        promise.then(res => {\n            result.fire(res);\n        }, () => {\n            result.fire(undefined);\n        }).finally(() => {\n            result.dispose();\n        });\n        return result.event;\n    }\n    Event.fromPromise = fromPromise;\n    function runAndSubscribe(event, handler, initial) {\n        handler(initial);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    class EmitterObserver {\n        constructor(_observable, store) {\n            this._observable = _observable;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onWillAddFirstListener: () => {\n                    _observable.addObserver(this);\n                },\n                onDidRemoveLastListener: () => {\n                    _observable.removeObserver(this);\n                }\n            };\n            if (!store) {\n                _addLeakageTraceLogic(options);\n            }\n            this.emitter = new Emitter(options);\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter++;\n        }\n        handlePossibleChange(_observable) {\n            // assert(_observable === this.obs);\n        }\n        handleChange(_observable, _change) {\n            // assert(_observable === this.obs);\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            // assert(_observable === this.obs);\n            this._counter--;\n            if (this._counter === 0) {\n                this._observable.reportChanges();\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this._observable.get());\n                }\n            }\n        }\n    }\n    /**\n     * Creates an event emitter that is fired when the observable changes.\n     * Each listeners subscribes to the emitter.\n     */\n    function fromObservable(obs, store) {\n        const observer = new EmitterObserver(obs, store);\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n    /**\n     * Each listener is attached to the observable directly.\n     */\n    function fromObservableLight(observable) {\n        return (listener, thisArgs, disposables) => {\n            let count = 0;\n            let didChange = false;\n            const observer = {\n                beginUpdate() {\n                    count++;\n                },\n                endUpdate() {\n                    count--;\n                    if (count === 0) {\n                        observable.reportChanges();\n                        if (didChange) {\n                            didChange = false;\n                            listener.call(thisArgs);\n                        }\n                    }\n                },\n                handlePossibleChange() {\n                    // noop\n                },\n                handleChange() {\n                    didChange = true;\n                }\n            };\n            observable.addObserver(observer);\n            observable.reportChanges();\n            const disposable = {\n                dispose() {\n                    observable.removeObserver(observer);\n                }\n            };\n            if (disposables instanceof DisposableStore) {\n                disposables.add(disposable);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(disposable);\n            }\n            return disposable;\n        };\n    }\n    Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nclass EventProfiling {\n    constructor(name) {\n        this.listenerCount = 0;\n        this.invocationCount = 0;\n        this.elapsedOverall = 0;\n        this.durations = [];\n        this.name = `${name}_${EventProfiling._idPool++}`;\n        EventProfiling.all.add(this);\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch();\n        this.listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this.durations.push(elapsed);\n            this.elapsedOverall += elapsed;\n            this.invocationCount += 1;\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling.all = new Set();\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(_errorHandler, threshold, name = Math.random().toString(18).slice(2, 5)) {\n        this._errorHandler = _errorHandler;\n        this.threshold = threshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        var _a;\n        (_a = this._stacks) === null || _a === void 0 ? void 0 : _a.clear();\n    }\n    check(stack, listenerCount) {\n        const threshold = this.threshold;\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            const [topStack, topCount] = this.getMostFrequentStack();\n            const message = `[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`;\n            console.warn(message);\n            console.warn(topStack);\n            const error = new ListenerLeakError(message, topStack);\n            this._errorHandler(error);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n    getMostFrequentStack() {\n        if (!this._stacks) {\n            return undefined;\n        }\n        let topStack;\n        let topCount = 0;\n        for (const [stack, count] of this._stacks) {\n            if (!topStack || topCount < count) {\n                topStack = [stack, count];\n                topCount = count;\n            }\n        }\n        return topStack;\n    }\n}\nclass Stacktrace {\n    static create() {\n        var _a;\n        const err = new Error();\n        return new Stacktrace((_a = err.stack) !== null && _a !== void 0 ? _a : '');\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\n// error that is logged when going over the configured listener threshold\nclass ListenerLeakError extends Error {\n    constructor(message, stack) {\n        super(message);\n        this.name = 'ListenerLeakError';\n        this.stack = stack;\n    }\n}\n// SEVERE error that is logged when having gone way over the configured listener\n// threshold so that the emitter refuses to accept more listeners\nclass ListenerRefusalError extends Error {\n    constructor(message, stack) {\n        super(message);\n        this.name = 'ListenerRefusalError';\n        this.stack = stack;\n    }\n}\nclass UniqueContainer {\n    constructor(value) {\n        this.value = value;\n    }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n    if (listeners instanceof UniqueContainer) {\n        fn(listeners);\n    }\n    else {\n        for (let i = 0; i < listeners.length; i++) {\n            const l = listeners[i];\n            if (l) {\n                fn(l);\n            }\n        }\n    }\n};\nconst _listenerFinalizers = _enableListenerGCedWarning\n    ? new FinalizationRegistry(heldValue => {\n        if (typeof heldValue === 'string') {\n            console.warn('[LEAKING LISTENER] GC\\'ed a listener that was NOT yet disposed. This is where is was created:');\n            console.warn(heldValue);\n        }\n    })\n    : undefined;\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nclass Emitter {\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f;\n        this._size = 0;\n        this._options = options;\n        this._leakageMon = (_globalLeakWarningThreshold > 0 || ((_a = this._options) === null || _a === void 0 ? void 0 : _a.leakWarningThreshold))\n            ? new LeakageMonitor((_b = options === null || options === void 0 ? void 0 : options.onListenerError) !== null && _b !== void 0 ? _b : errors_onUnexpectedError, (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.leakWarningThreshold) !== null && _d !== void 0 ? _d : _globalLeakWarningThreshold) :\n            undefined;\n        this._perfMon = ((_e = this._options) === null || _e === void 0 ? void 0 : _e._profName) ? new EventProfiling(this._options._profName) : undefined;\n        this._deliveryQueue = (_f = this._options) === null || _f === void 0 ? void 0 : _f.deliveryQueue;\n    }\n    dispose() {\n        var _a, _b, _c, _d;\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) === this) {\n                this._deliveryQueue.reset();\n            }\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = this._listeners;\n                    queueMicrotask(() => {\n                        forEachListener(listeners, l => { var _a; return (_a = l.stack) === null || _a === void 0 ? void 0 : _a.print(); });\n                    });\n                }\n                this._listeners = undefined;\n                this._size = 0;\n            }\n            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onDidRemoveLastListener) === null || _c === void 0 ? void 0 : _c.call(_b);\n            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        var _a;\n        (_a = this._event) !== null && _a !== void 0 ? _a : (this._event = (callback, thisArgs, disposables) => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {\n                const message = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;\n                console.warn(message);\n                const tuple = (_a = this._leakageMon.getMostFrequentStack()) !== null && _a !== void 0 ? _a : ['UNKNOWN stack', -1];\n                const error = new ListenerRefusalError(`${message}. HINT: Stack shows most frequent listener (${tuple[1]}-times)`, tuple[0]);\n                const errorHandler = ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onListenerError) || errors_onUnexpectedError;\n                errorHandler(error);\n                return lifecycle_Disposable.None;\n            }\n            if (this._disposed) {\n                // todo: should we warn if a listener is added to a disposed emitter? This happens often\n                return lifecycle_Disposable.None;\n            }\n            if (thisArgs) {\n                callback = callback.bind(thisArgs);\n            }\n            const contained = new UniqueContainer(callback);\n            let removeMonitor;\n            let stack;\n            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n                // check and record this emitter for potential leakage\n                contained.stack = Stacktrace.create();\n                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n            }\n            if (_enableDisposeWithListenerWarning) {\n                contained.stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n            }\n            if (!this._listeners) {\n                (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onWillAddFirstListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n                this._listeners = contained;\n                (_f = (_e = this._options) === null || _e === void 0 ? void 0 : _e.onDidAddFirstListener) === null || _f === void 0 ? void 0 : _f.call(_e, this);\n            }\n            else if (this._listeners instanceof UniqueContainer) {\n                (_g = this._deliveryQueue) !== null && _g !== void 0 ? _g : (this._deliveryQueue = new EventDeliveryQueuePrivate());\n                this._listeners = [this._listeners, contained];\n            }\n            else {\n                this._listeners.push(contained);\n            }\n            this._size++;\n            const result = lifecycle_toDisposable(() => {\n                _listenerFinalizers === null || _listenerFinalizers === void 0 ? void 0 : _listenerFinalizers.unregister(result);\n                removeMonitor === null || removeMonitor === void 0 ? void 0 : removeMonitor();\n                this._removeListener(contained);\n            });\n            if (disposables instanceof DisposableStore) {\n                disposables.add(result);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(result);\n            }\n            if (_listenerFinalizers) {\n                const stack = new Error().stack.split('\\n').slice(2).join('\\n').trim();\n                _listenerFinalizers.register(result, stack, result);\n            }\n            return result;\n        });\n        return this._event;\n    }\n    _removeListener(listener) {\n        var _a, _b, _c, _d;\n        (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.onWillRemoveListener) === null || _b === void 0 ? void 0 : _b.call(_a, this);\n        if (!this._listeners) {\n            return; // expected if a listener gets disposed\n        }\n        if (this._size === 1) {\n            this._listeners = undefined;\n            (_d = (_c = this._options) === null || _c === void 0 ? void 0 : _c.onDidRemoveLastListener) === null || _d === void 0 ? void 0 : _d.call(_c, this);\n            this._size = 0;\n            return;\n        }\n        // size > 1 which requires that listeners be a list:\n        const listeners = this._listeners;\n        const index = listeners.indexOf(listener);\n        if (index === -1) {\n            console.log('disposed?', this._disposed);\n            console.log('size?', this._size);\n            console.log('arr?', JSON.stringify(this._listeners));\n            throw new Error('Attempted to dispose unknown listener');\n        }\n        this._size--;\n        listeners[index] = undefined;\n        const adjustDeliveryQueue = this._deliveryQueue.current === this;\n        if (this._size * compactionThreshold <= listeners.length) {\n            let n = 0;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listeners[i]) {\n                    listeners[n++] = listeners[i];\n                }\n                else if (adjustDeliveryQueue) {\n                    this._deliveryQueue.end--;\n                    if (n < this._deliveryQueue.i) {\n                        this._deliveryQueue.i--;\n                    }\n                }\n            }\n            listeners.length = n;\n        }\n    }\n    _deliver(listener, value) {\n        var _a;\n        if (!listener) {\n            return;\n        }\n        const errorHandler = ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onListenerError) || errors_onUnexpectedError;\n        if (!errorHandler) {\n            listener.value(value);\n            return;\n        }\n        try {\n            listener.value(value);\n        }\n        catch (e) {\n            errorHandler(e);\n        }\n    }\n    /** Delivers items in the queue. Assumes the queue is ready to go. */\n    _deliverQueue(dq) {\n        const listeners = dq.current._listeners;\n        while (dq.i < dq.end) {\n            // important: dq.i is incremented before calling deliver() because it might reenter deliverQueue()\n            this._deliver(listeners[dq.i++], dq.value);\n        }\n        dq.reset();\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b, _c, _d;\n        if ((_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.current) {\n            this._deliverQueue(this._deliveryQueue);\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop(); // last fire() will have starting perfmon, stop it before starting the next dispatch\n        }\n        (_c = this._perfMon) === null || _c === void 0 ? void 0 : _c.start(this._size);\n        if (!this._listeners) {\n            // no-op\n        }\n        else if (this._listeners instanceof UniqueContainer) {\n            this._deliver(this._listeners, event);\n        }\n        else {\n            const dq = this._deliveryQueue;\n            dq.enqueue(this, event, this._listeners.length);\n            this._deliverQueue(dq);\n        }\n        (_d = this._perfMon) === null || _d === void 0 ? void 0 : _d.stop();\n    }\n    hasListeners() {\n        return this._size > 0;\n    }\n}\nconst createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nclass EventDeliveryQueuePrivate {\n    constructor() {\n        /**\n         * Index in current's listener list.\n         */\n        this.i = -1;\n        /**\n         * The last index in the listener's list to deliver.\n         */\n        this.end = 0;\n    }\n    enqueue(emitter, value, end) {\n        this.i = 0;\n        this.end = end;\n        this.current = emitter;\n        this.value = value;\n    }\n    reset() {\n        this.i = this.end; // force any current emission loop to stop, mainly for during dispose\n        this.current = undefined;\n        this.value = undefined;\n    }\n}\nclass PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                if (this._eventQueue.size > 0) {\n                    const events = Array.from(this._eventQueue);\n                    this._eventQueue.clear();\n                    super.fire(this._mergeFn(events));\n                }\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._size) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nclass DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * An emitter which queue all events and then process them at the\n * end of the event loop.\n */\nclass MicrotaskEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._queuedEvents = [];\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    fire(event) {\n        if (!this.hasListeners()) {\n            return;\n        }\n        this._queuedEvents.push(event);\n        if (this._queuedEvents.length === 1) {\n            queueMicrotask(() => {\n                if (this._mergeFn) {\n                    super.fire(this._mergeFn(this._queuedEvents));\n                }\n                else {\n                    this._queuedEvents.forEach(e => super.fire(e));\n                }\n                this._queuedEvents = [];\n            });\n        }\n    }\n}\n/**\n * An event emitter that multiplexes many events into a single event.\n *\n * @example Listen to the `onData` event of all `Thing`s, dynamically adding and removing `Thing`s\n * to the multiplexer as needed.\n *\n * ```typescript\n * const anythingDataMultiplexer = new EventMultiplexer<{ data: string }>();\n *\n * const thingListeners = DisposableMap<Thing, IDisposable>();\n *\n * thingService.onDidAddThing(thing => {\n *   thingListeners.set(thing, anythingDataMultiplexer.add(thing.onData);\n * });\n * thingService.onDidRemoveThing(thing => {\n *   thingListeners.deleteAndDispose(thing);\n * });\n *\n * anythingDataMultiplexer.event(e => {\n *   console.log('Something fired data ' + e.data)\n * });\n * ```\n */\nclass EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = new Emitter({\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\n        });\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return toDisposable(createSingleCallFunction(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        var _a;\n        (_a = e.listener) === null || _a === void 0 ? void 0 : _a.dispose();\n        e.listener = null;\n    }\n    dispose() {\n        var _a;\n        this.emitter.dispose();\n        for (const e of this.events) {\n            (_a = e.listener) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n        this.events = [];\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nclass EventBufferer {\n    constructor() {\n        this.data = [];\n    }\n    wrapEvent(event, reduce, initial) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                var _a;\n                const data = this.data[this.data.length - 1];\n                // Non-reduce scenario\n                if (!reduce) {\n                    // Buffering case\n                    if (data) {\n                        data.buffers.push(() => listener.call(thisArgs, i));\n                    }\n                    else {\n                        // Not buffering case\n                        listener.call(thisArgs, i);\n                    }\n                    return;\n                }\n                // Reduce scenario\n                const reduceData = data;\n                // Not buffering case\n                if (!reduceData) {\n                    // TODO: Is there a way to cache this reduce call for all listeners?\n                    listener.call(thisArgs, reduce(initial, i));\n                    return;\n                }\n                // Buffering case\n                (_a = reduceData.items) !== null && _a !== void 0 ? _a : (reduceData.items = []);\n                reduceData.items.push(i);\n                if (reduceData.buffers.length === 0) {\n                    // Include a single buffered function that will reduce all events when we're done buffering events\n                    data.buffers.push(() => {\n                        var _a;\n                        // cache the reduced result so that the value can be shared across all listeners\n                        (_a = reduceData.reducedResult) !== null && _a !== void 0 ? _a : (reduceData.reducedResult = initial\n                            ? reduceData.items.reduce(reduce, initial)\n                            : reduceData.items.reduce(reduce));\n                        listener.call(thisArgs, reduceData.reducedResult);\n                    });\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const data = { buffers: new Array() };\n        this.data.push(data);\n        const r = fn();\n        this.data.pop();\n        data.buffers.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nclass Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onDidAddFirstListener: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onDidRemoveLastListener: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/objects.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nfunction deepClone(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return obj;\n    }\n    if (obj instanceof RegExp) {\n        return obj;\n    }\n    const result = Array.isArray(obj) ? [] : {};\n    Object.entries(obj).forEach(([key, value]) => {\n        result[key] = value && typeof value === 'object' ? deepClone(value) : value;\n    });\n    return result;\n}\nfunction deepFreeze(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return obj;\n    }\n    const stack = [obj];\n    while (stack.length > 0) {\n        const obj = stack.shift();\n        Object.freeze(obj);\n        for (const key in obj) {\n            if (_hasOwnProperty.call(obj, key)) {\n                const prop = obj[key];\n                if (typeof prop === 'object' && !Object.isFrozen(prop) && !isTypedArray(prop)) {\n                    stack.push(prop);\n                }\n            }\n        }\n    }\n    return obj;\n}\nconst _hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction cloneAndChange(obj, changer) {\n    return _cloneAndChange(obj, changer, new Set());\n}\nfunction _cloneAndChange(obj, changer, seen) {\n    if (isUndefinedOrNull(obj)) {\n        return obj;\n    }\n    const changed = changer(obj);\n    if (typeof changed !== 'undefined') {\n        return changed;\n    }\n    if (Array.isArray(obj)) {\n        const r1 = [];\n        for (const e of obj) {\n            r1.push(_cloneAndChange(e, changer, seen));\n        }\n        return r1;\n    }\n    if (isObject(obj)) {\n        if (seen.has(obj)) {\n            throw new Error('Cannot clone recursive data-structure');\n        }\n        seen.add(obj);\n        const r2 = {};\n        for (const i2 in obj) {\n            if (_hasOwnProperty.call(obj, i2)) {\n                r2[i2] = _cloneAndChange(obj[i2], changer, seen);\n            }\n        }\n        seen.delete(obj);\n        return r2;\n    }\n    return obj;\n}\n/**\n * Copies all properties of source into destination. The optional parameter \"overwrite\" allows to control\n * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).\n */\nfunction mixin(destination, source, overwrite = true) {\n    if (!isObject(destination)) {\n        return source;\n    }\n    if (isObject(source)) {\n        Object.keys(source).forEach(key => {\n            if (key in destination) {\n                if (overwrite) {\n                    if (isObject(destination[key]) && isObject(source[key])) {\n                        mixin(destination[key], source[key], overwrite);\n                    }\n                    else {\n                        destination[key] = source[key];\n                    }\n                }\n            }\n            else {\n                destination[key] = source[key];\n            }\n        });\n    }\n    return destination;\n}\nfunction objects_equals(one, other) {\n    if (one === other) {\n        return true;\n    }\n    if (one === null || one === undefined || other === null || other === undefined) {\n        return false;\n    }\n    if (typeof one !== typeof other) {\n        return false;\n    }\n    if (typeof one !== 'object') {\n        return false;\n    }\n    if ((Array.isArray(one)) !== (Array.isArray(other))) {\n        return false;\n    }\n    let i;\n    let key;\n    if (Array.isArray(one)) {\n        if (one.length !== other.length) {\n            return false;\n        }\n        for (i = 0; i < one.length; i++) {\n            if (!objects_equals(one[i], other[i])) {\n                return false;\n            }\n        }\n    }\n    else {\n        const oneKeys = [];\n        for (key in one) {\n            oneKeys.push(key);\n        }\n        oneKeys.sort();\n        const otherKeys = [];\n        for (key in other) {\n            otherKeys.push(key);\n        }\n        otherKeys.sort();\n        if (!objects_equals(oneKeys, otherKeys)) {\n            return false;\n        }\n        for (i = 0; i < oneKeys.length; i++) {\n            if (!objects_equals(one[oneKeys[i]], other[oneKeys[i]])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction getAllPropertyNames(obj) {\n    let res = [];\n    while (Object.prototype !== obj) {\n        res = res.concat(Object.getOwnPropertyNames(obj));\n        obj = Object.getPrototypeOf(obj);\n    }\n    return res;\n}\nfunction getAllMethodNames(obj) {\n    const methods = [];\n    for (const prop of getAllPropertyNames(obj)) {\n        if (typeof obj[prop] === 'function') {\n            methods.push(prop);\n        }\n    }\n    return methods;\n}\nfunction createProxyObject(methodNames, invoke) {\n    const createProxyMethod = (method) => {\n        return function () {\n            const args = Array.prototype.slice.call(arguments, 0);\n            return invoke(method, args);\n        };\n    };\n    const result = {};\n    for (const methodName of methodNames) {\n        result[methodName] = createProxyMethod(methodName);\n    }\n    return result;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/nls.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nlet isPseudo = (typeof document !== 'undefined' && document.location && document.location.hash.indexOf('pseudo=true') >= 0);\nconst DEFAULT_TAG = 'i-default';\nfunction _format(message, args) {\n    let result;\n    if (args.length === 0) {\n        result = message;\n    }\n    else {\n        result = message.replace(/\\{(\\d+)\\}/g, (match, rest) => {\n            const index = rest[0];\n            const arg = args[index];\n            let result = match;\n            if (typeof arg === 'string') {\n                result = arg;\n            }\n            else if (typeof arg === 'number' || typeof arg === 'boolean' || arg === void 0 || arg === null) {\n                result = String(arg);\n            }\n            return result;\n        });\n    }\n    if (isPseudo) {\n        // FF3B and FF3D is the Unicode zenkaku representation for [ and ]\n        result = '\\uFF3B' + result.replace(/[aouei]/g, '$&$&') + '\\uFF3D';\n    }\n    return result;\n}\nfunction findLanguageForModule(config, name) {\n    let result = config[name];\n    if (result) {\n        return result;\n    }\n    result = config['*'];\n    if (result) {\n        return result;\n    }\n    return null;\n}\nfunction endWithSlash(path) {\n    if (path.charAt(path.length - 1) === '/') {\n        return path;\n    }\n    return path + '/';\n}\nasync function getMessagesFromTranslationsService(translationServiceUrl, language, name) {\n    const url = endWithSlash(translationServiceUrl) + endWithSlash(language) + 'vscode/' + endWithSlash(name);\n    const res = await fetch(url);\n    if (res.ok) {\n        const messages = await res.json();\n        return messages;\n    }\n    throw new Error(`${res.status} - ${res.statusText}`);\n}\nfunction createScopedLocalize(scope) {\n    return function (idx, defaultValue) {\n        const restArgs = Array.prototype.slice.call(arguments, 2);\n        return _format(scope[idx], restArgs);\n    };\n}\nfunction createScopedLocalize2(scope) {\n    return (idx, defaultValue, ...args) => ({\n        value: _format(scope[idx], args),\n        original: _format(defaultValue, args)\n    });\n}\n/**\n * @skipMangle\n */\nfunction nls_localize(data, message, ...args) {\n    return _format(message, args);\n}\n/**\n * @skipMangle\n */\nfunction localize2(data, message, ...args) {\n    const original = _format(message, args);\n    return {\n        value: original,\n        original\n    };\n}\n/**\n * @skipMangle\n */\nfunction getConfiguredDefaultLocale(_) {\n    // This returns undefined because this implementation isn't used and is overwritten by the loader\n    // when loaded.\n    return undefined;\n}\n/**\n * @skipMangle\n */\nfunction setPseudoTranslation(value) {\n    isPseudo = value;\n}\n/**\n * Invoked in a built product at run-time\n * @skipMangle\n */\nfunction create(key, data) {\n    var _a;\n    return {\n        localize: createScopedLocalize(data[key]),\n        localize2: createScopedLocalize2(data[key]),\n        getConfiguredDefaultLocale: (_a = data.getConfiguredDefaultLocale) !== null && _a !== void 0 ? _a : ((_) => undefined)\n    };\n}\n/**\n * Invoked by the loader at run-time\n * @skipMangle\n */\nfunction load(name, req, load, config) {\n    var _a;\n    const pluginConfig = (_a = config['vs/nls']) !== null && _a !== void 0 ? _a : {};\n    if (!name || name.length === 0) {\n        // TODO: We need to give back the mangled names here\n        return load({\n            localize: nls_localize,\n            localize2: localize2,\n            getConfiguredDefaultLocale: () => { var _a; return (_a = pluginConfig.availableLanguages) === null || _a === void 0 ? void 0 : _a['*']; }\n        });\n    }\n    const language = pluginConfig.availableLanguages ? findLanguageForModule(pluginConfig.availableLanguages, name) : null;\n    const useDefaultLanguage = language === null || language === DEFAULT_TAG;\n    let suffix = '.nls';\n    if (!useDefaultLanguage) {\n        suffix = suffix + '.' + language;\n    }\n    const messagesLoaded = (messages) => {\n        if (Array.isArray(messages)) {\n            messages.localize = createScopedLocalize(messages);\n            messages.localize2 = createScopedLocalize2(messages);\n        }\n        else {\n            messages.localize = createScopedLocalize(messages[name]);\n            messages.localize2 = createScopedLocalize2(messages[name]);\n        }\n        messages.getConfiguredDefaultLocale = () => { var _a; return (_a = pluginConfig.availableLanguages) === null || _a === void 0 ? void 0 : _a['*']; };\n        load(messages);\n    };\n    if (typeof pluginConfig.loadBundle === 'function') {\n        pluginConfig.loadBundle(name, language, (err, messages) => {\n            // We have an error. Load the English default strings to not fail\n            if (err) {\n                req([name + '.nls'], messagesLoaded);\n            }\n            else {\n                messagesLoaded(messages);\n            }\n        });\n    }\n    else if (pluginConfig.translationServiceUrl && !useDefaultLanguage) {\n        (async () => {\n            var _a;\n            try {\n                const messages = await getMessagesFromTranslationsService(pluginConfig.translationServiceUrl, language, name);\n                return messagesLoaded(messages);\n            }\n            catch (err) {\n                // Language is already as generic as it gets, so require default messages\n                if (!language.includes('-')) {\n                    console.error(err);\n                    return req([name + '.nls'], messagesLoaded);\n                }\n                try {\n                    // Since there is a dash, the language configured is a specific sub-language of the same generic language.\n                    // Since we were unable to load the specific language, try to load the generic language. Ex. we failed to find a\n                    // Swiss German (de-CH), so try to load the generic German (de) messages instead.\n                    const genericLanguage = language.split('-')[0];\n                    const messages = await getMessagesFromTranslationsService(pluginConfig.translationServiceUrl, genericLanguage, name);\n                    // We got some messages, so we configure the configuration to use the generic language for this session.\n                    (_a = pluginConfig.availableLanguages) !== null && _a !== void 0 ? _a : (pluginConfig.availableLanguages = {});\n                    pluginConfig.availableLanguages['*'] = genericLanguage;\n                    return messagesLoaded(messages);\n                }\n                catch (err) {\n                    console.error(err);\n                    return req([name + '.nls'], messagesLoaded);\n                }\n            }\n        })();\n    }\n    else {\n        req([name + suffix], messagesLoaded, (err) => {\n            if (suffix === '.nls') {\n                console.error('Failed trying to load default language strings', err);\n                return;\n            }\n            console.error(`Failed to load message bundle for language ${language}. Falling back to the default language:`, err);\n            req([name + '.nls'], messagesLoaded);\n        });\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/platform.js\n/* provided dependency */ var process = __webpack_require__(606);\nvar _a, _b;\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst LANGUAGE_DEFAULT = 'en';\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isLinuxSnap = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isElectron = false;\nlet _isIOS = false;\nlet _isCI = false;\nlet _isMobile = false;\nlet _locale = undefined;\nlet _language = (/* unused pure expression or super */ null && (LANGUAGE_DEFAULT));\nlet _platformLocale = (/* unused pure expression or super */ null && (LANGUAGE_DEFAULT));\nlet _translationsConfigFile = (/* unused pure expression or super */ null && (undefined));\nlet _userAgent = undefined;\nconst $globalThis = globalThis;\nlet nodeProcess = undefined;\nif (typeof $globalThis.vscode !== 'undefined' && typeof $globalThis.vscode.process !== 'undefined') {\n    // Native environment (sandboxed)\n    nodeProcess = $globalThis.vscode.process;\n}\nelse if (typeof process !== 'undefined' && typeof ((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) === 'string') {\n    // Native environment (non-sandboxed)\n    nodeProcess = process;\n}\nconst isElectronProcess = typeof ((_b = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _b === void 0 ? void 0 : _b.electron) === 'string';\nconst isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === 'renderer';\n// Native environment\nif (typeof nodeProcess === 'object') {\n    _isWindows = (nodeProcess.platform === 'win32');\n    _isMacintosh = (nodeProcess.platform === 'darwin');\n    _isLinux = (nodeProcess.platform === 'linux');\n    _isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\n    _isElectron = isElectronProcess;\n    _isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'];\n    _locale = LANGUAGE_DEFAULT;\n    _language = LANGUAGE_DEFAULT;\n    const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n    if (rawNlsConfig) {\n        try {\n            const nlsConfig = JSON.parse(rawNlsConfig);\n            const resolved = nlsConfig.availableLanguages['*'];\n            _locale = nlsConfig.locale;\n            _platformLocale = nlsConfig.osLocale;\n            // VSCode's default language is 'en'\n            _language = resolved ? resolved : LANGUAGE_DEFAULT;\n            _translationsConfigFile = nlsConfig._translationsConfigFile;\n        }\n        catch (e) {\n        }\n    }\n    _isNative = true;\n}\n// Web environment\nelse if (typeof navigator === 'object' && !isElectronRenderer) {\n    _userAgent = navigator.userAgent;\n    _isWindows = _userAgent.indexOf('Windows') >= 0;\n    _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n    _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n    _isLinux = _userAgent.indexOf('Linux') >= 0;\n    _isMobile = (_userAgent === null || _userAgent === void 0 ? void 0 : _userAgent.indexOf('Mobi')) >= 0;\n    _isWeb = true;\n    const configuredLocale = getConfiguredDefaultLocale(\n    // This call _must_ be done in the file that calls `nls.getConfiguredDefaultLocale`\n    // to ensure that the NLS AMD Loader plugin has been loaded and configured.\n    // This is because the loader plugin decides what the default locale is based on\n    // how it's able to resolve the strings.\n    nls_localize({ key: 'ensureLoaderPluginIsLoaded', comment: ['{Locked}'] }, '_'));\n    _locale = configuredLocale || LANGUAGE_DEFAULT;\n    _language = _locale;\n    _platformLocale = navigator.language;\n}\n// Unknown environment\nelse {\n    console.error('Unable to resolve platform.');\n}\nlet _platform = 0 /* Platform.Web */;\nif (_isMacintosh) {\n    _platform = 1 /* Platform.Mac */;\n}\nelse if (_isWindows) {\n    _platform = 3 /* Platform.Windows */;\n}\nelse if (_isLinux) {\n    _platform = 2 /* Platform.Linux */;\n}\nconst isWindows = _isWindows;\nconst isMacintosh = _isMacintosh;\nconst isLinux = (/* unused pure expression or super */ null && (_isLinux));\nconst isNative = (/* unused pure expression or super */ null && (_isNative));\nconst platform_isWeb = (/* unused pure expression or super */ null && (_isWeb));\nconst isWebWorker = (_isWeb && typeof $globalThis.importScripts === 'function');\nconst webWorkerOrigin = isWebWorker ? $globalThis.origin : undefined;\nconst isIOS = (/* unused pure expression or super */ null && (_isIOS));\nconst isMobile = (/* unused pure expression or super */ null && (_isMobile));\nconst userAgent = _userAgent;\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese)\n */\nconst language = (/* unused pure expression or super */ null && (_language));\nconst setTimeout0IsFaster = (typeof $globalThis.postMessage === 'function' && !$globalThis.importScripts);\n/**\n * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.\n *\n * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay\n * that browsers set when the nesting level is > 5.\n */\nconst setTimeout0 = (() => {\n    if (setTimeout0IsFaster) {\n        const pending = [];\n        $globalThis.addEventListener('message', (e) => {\n            if (e.data && e.data.vscodeScheduleAsyncWork) {\n                for (let i = 0, len = pending.length; i < len; i++) {\n                    const candidate = pending[i];\n                    if (candidate.id === e.data.vscodeScheduleAsyncWork) {\n                        pending.splice(i, 1);\n                        candidate.callback();\n                        return;\n                    }\n                }\n            }\n        });\n        let lastId = 0;\n        return (callback) => {\n            const myId = ++lastId;\n            pending.push({\n                id: myId,\n                callback: callback\n            });\n            $globalThis.postMessage({ vscodeScheduleAsyncWork: myId }, '*');\n        };\n    }\n    return (callback) => setTimeout(callback);\n})();\nconst OS = ((/* unused pure expression or super */ null && (_isMacintosh || _isIOS ? 2 /* OperatingSystem.Macintosh */ : (_isWindows ? 1 /* OperatingSystem.Windows */ : 3 /* OperatingSystem.Linux */))));\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nfunction isLittleEndian() {\n    if (!_isLittleEndianComputed) {\n        _isLittleEndianComputed = true;\n        const test = new Uint8Array(2);\n        test[0] = 1;\n        test[1] = 2;\n        const view = new Uint16Array(test.buffer);\n        _isLittleEndian = (view[0] === (2 << 8) + 1);\n    }\n    return _isLittleEndian;\n}\nconst isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);\nconst isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);\nconst isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));\nconst isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);\nconst isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/cache.js\nfunction identity(t) {\n    return t;\n}\n/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last key/value.\n*/\nclass LRUCachedFunction {\n    constructor(arg1, arg2) {\n        this.lastCache = undefined;\n        this.lastArgKey = undefined;\n        if (typeof arg1 === 'function') {\n            this._fn = arg1;\n            this._computeKey = identity;\n        }\n        else {\n            this._fn = arg2;\n            this._computeKey = arg1.getCacheKey;\n        }\n    }\n    get(arg) {\n        const key = this._computeKey(arg);\n        if (this.lastArgKey !== key) {\n            this.lastArgKey = key;\n            this.lastCache = this._fn(arg);\n        }\n        return this.lastCache;\n    }\n}\n/**\n * Uses an unbounded cache to memoize the results of the given function.\n*/\nclass CachedFunction {\n    get cachedValues() {\n        return this._map;\n    }\n    constructor(arg1, arg2) {\n        this._map = new Map();\n        this._map2 = new Map();\n        if (typeof arg1 === 'function') {\n            this._fn = arg1;\n            this._computeKey = identity;\n        }\n        else {\n            this._fn = arg2;\n            this._computeKey = arg1.getCacheKey;\n        }\n    }\n    get(arg) {\n        const key = this._computeKey(arg);\n        if (this._map2.has(key)) {\n            return this._map2.get(key);\n        }\n        const value = this._fn(arg);\n        this._map.set(arg, value);\n        this._map2.set(key, value);\n        return value;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/lazy.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass Lazy {\n    constructor(executor) {\n        this.executor = executor;\n        this._didRun = false;\n    }\n    /**\n     * Get the wrapped value.\n     *\n     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n     */\n    get value() {\n        if (!this._didRun) {\n            try {\n                this._value = this.executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    /**\n     * Get the wrapped value without forcing evaluation.\n     */\n    get rawValue() { return this._value; }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/strings.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar strings_a;\n\n\nfunction isFalsyOrWhitespace(str) {\n    if (!str || typeof str !== 'string') {\n        return true;\n    }\n    return str.trim().length === 0;\n}\nconst _formatRegexp = /{(\\d+)}/g;\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nfunction format(value, ...args) {\n    if (args.length === 0) {\n        return value;\n    }\n    return value.replace(_formatRegexp, function (match, group) {\n        const idx = parseInt(group, 10);\n        return isNaN(idx) || idx < 0 || idx >= args.length ?\n            match :\n            args[idx];\n    });\n}\n/**\n * Encodes the given value so that it can be used as literal value in html attributes.\n *\n * In other words, computes `$val`, such that `attr` in `<div attr=\"$val\" />` has the runtime value `value`.\n * This prevents XSS injection.\n */\nfunction htmlAttributeEncodeValue(value) {\n    return value.replace(/[<>\"'&]/g, ch => {\n        switch (ch) {\n            case '<': return '&lt;';\n            case '>': return '&gt;';\n            case '\"': return '&quot;';\n            case '\\'': return '&apos;';\n            case '&': return '&amp;';\n        }\n        return ch;\n    });\n}\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nfunction strings_escape(html) {\n    return html.replace(/[<>&]/g, function (match) {\n        switch (match) {\n            case '<': return '&lt;';\n            case '>': return '&gt;';\n            case '&': return '&amp;';\n            default: return match;\n        }\n    });\n}\n/**\n * Escapes regular expression characters in a given string\n */\nfunction escapeRegExpCharacters(value) {\n    return value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\n}\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nfunction trim(haystack, needle = ' ') {\n    const trimmed = ltrim(haystack, needle);\n    return rtrim(trimmed, needle);\n}\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nfunction ltrim(haystack, needle) {\n    if (!haystack || !needle) {\n        return haystack;\n    }\n    const needleLen = needle.length;\n    if (needleLen === 0 || haystack.length === 0) {\n        return haystack;\n    }\n    let offset = 0;\n    while (haystack.indexOf(needle, offset) === offset) {\n        offset = offset + needleLen;\n    }\n    return haystack.substring(offset);\n}\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nfunction rtrim(haystack, needle) {\n    if (!haystack || !needle) {\n        return haystack;\n    }\n    const needleLen = needle.length, haystackLen = haystack.length;\n    if (needleLen === 0 || haystackLen === 0) {\n        return haystack;\n    }\n    let offset = haystackLen, idx = -1;\n    while (true) {\n        idx = haystack.lastIndexOf(needle, offset - 1);\n        if (idx === -1 || idx + needleLen !== offset) {\n            break;\n        }\n        if (idx === 0) {\n            return '';\n        }\n        offset = idx;\n    }\n    return haystack.substring(0, offset);\n}\nfunction convertSimple2RegExpPattern(pattern) {\n    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\nfunction stripWildcards(pattern) {\n    return pattern.replace(/\\*/g, '');\n}\nfunction createRegExp(searchString, isRegex, options = {}) {\n    if (!searchString) {\n        throw new Error('Cannot create regex from empty string');\n    }\n    if (!isRegex) {\n        searchString = escapeRegExpCharacters(searchString);\n    }\n    if (options.wholeWord) {\n        if (!/\\B/.test(searchString.charAt(0))) {\n            searchString = '\\\\b' + searchString;\n        }\n        if (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n            searchString = searchString + '\\\\b';\n        }\n    }\n    let modifiers = '';\n    if (options.global) {\n        modifiers += 'g';\n    }\n    if (!options.matchCase) {\n        modifiers += 'i';\n    }\n    if (options.multiline) {\n        modifiers += 'm';\n    }\n    if (options.unicode) {\n        modifiers += 'u';\n    }\n    return new RegExp(searchString, modifiers);\n}\nfunction regExpLeadsToEndlessLoop(regexp) {\n    // Exit early if it's one of these special cases which are meant to match\n    // against an empty string\n    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n        return false;\n    }\n    // We check against an empty string. If the regular expression doesn't advance\n    // (e.g. ends in an endless loop) it will match an empty string.\n    const match = regexp.exec('');\n    return !!(match && regexp.lastIndex === 0);\n}\nfunction splitLines(str) {\n    return str.split(/\\r\\n|\\r|\\n/);\n}\nfunction splitLinesIncludeSeparators(str) {\n    var _b;\n    const linesWithSeparators = [];\n    const splitLinesAndSeparators = str.split(/(\\r\\n|\\r|\\n)/);\n    for (let i = 0; i < Math.ceil(splitLinesAndSeparators.length / 2); i++) {\n        linesWithSeparators.push(splitLinesAndSeparators[2 * i] + ((_b = splitLinesAndSeparators[2 * i + 1]) !== null && _b !== void 0 ? _b : ''));\n    }\n    return linesWithSeparators;\n}\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nfunction firstNonWhitespaceIndex(str) {\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nfunction getLeadingWhitespace(str, start = 0, end = str.length) {\n    for (let i = start; i < end; i++) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {\n            return str.substring(start, i);\n        }\n    }\n    return str.substring(start, end);\n}\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nfunction lastNonWhitespaceIndex(str, startIndex = str.length - 1) {\n    for (let i = startIndex; i >= 0; i--) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* CharCode.Space */ && chCode !== 9 /* CharCode.Tab */) {\n            return i;\n        }\n    }\n    return -1;\n}\nfunction compare(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    else if (a > b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nfunction compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {\n    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n        const codeA = a.charCodeAt(aStart);\n        const codeB = b.charCodeAt(bStart);\n        if (codeA < codeB) {\n            return -1;\n        }\n        else if (codeA > codeB) {\n            return 1;\n        }\n    }\n    const aLen = aEnd - aStart;\n    const bLen = bEnd - bStart;\n    if (aLen < bLen) {\n        return -1;\n    }\n    else if (aLen > bLen) {\n        return 1;\n    }\n    return 0;\n}\nfunction compareIgnoreCase(a, b) {\n    return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\nfunction compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {\n    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n        let codeA = a.charCodeAt(aStart);\n        let codeB = b.charCodeAt(bStart);\n        if (codeA === codeB) {\n            // equal\n            continue;\n        }\n        if (codeA >= 128 || codeB >= 128) {\n            // not ASCII letters -> fallback to lower-casing strings\n            return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n        }\n        // mapper lower-case ascii letter onto upper-case varinats\n        // [97-122] (lower ascii) --\x3e [65-90] (upper ascii)\n        if (isLowerAsciiLetter(codeA)) {\n            codeA -= 32;\n        }\n        if (isLowerAsciiLetter(codeB)) {\n            codeB -= 32;\n        }\n        // compare both code points\n        const diff = codeA - codeB;\n        if (diff === 0) {\n            continue;\n        }\n        return diff;\n    }\n    const aLen = aEnd - aStart;\n    const bLen = bEnd - bStart;\n    if (aLen < bLen) {\n        return -1;\n    }\n    else if (aLen > bLen) {\n        return 1;\n    }\n    return 0;\n}\nfunction isAsciiDigit(code) {\n    return code >= 48 /* CharCode.Digit0 */ && code <= 57 /* CharCode.Digit9 */;\n}\nfunction isLowerAsciiLetter(code) {\n    return code >= 97 /* CharCode.a */ && code <= 122 /* CharCode.z */;\n}\nfunction isUpperAsciiLetter(code) {\n    return code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */;\n}\nfunction equalsIgnoreCase(a, b) {\n    return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;\n}\nfunction startsWithIgnoreCase(str, candidate) {\n    const candidateLength = candidate.length;\n    if (candidate.length > str.length) {\n        return false;\n    }\n    return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;\n}\n/**\n * @returns the length of the common prefix of the two strings.\n */\nfunction commonPrefixLength(a, b) {\n    const len = Math.min(a.length, b.length);\n    let i;\n    for (i = 0; i < len; i++) {\n        if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n            return i;\n        }\n    }\n    return len;\n}\n/**\n * @returns the length of the common suffix of the two strings.\n */\nfunction commonSuffixLength(a, b) {\n    const len = Math.min(a.length, b.length);\n    let i;\n    const aLastIndex = a.length - 1;\n    const bLastIndex = b.length - 1;\n    for (i = 0; i < len; i++) {\n        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n            return i;\n        }\n    }\n    return len;\n}\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nfunction isHighSurrogate(charCode) {\n    return (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nfunction isLowSurrogate(charCode) {\n    return (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nfunction computeCodePoint(highSurrogate, lowSurrogate) {\n    return ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\n}\n/**\n * get the code point that begins at offset `offset`\n */\nfunction getNextCodePoint(str, len, offset) {\n    const charCode = str.charCodeAt(offset);\n    if (isHighSurrogate(charCode) && offset + 1 < len) {\n        const nextCharCode = str.charCodeAt(offset + 1);\n        if (isLowSurrogate(nextCharCode)) {\n            return computeCodePoint(charCode, nextCharCode);\n        }\n    }\n    return charCode;\n}\n/**\n * get the code point that ends right before offset `offset`\n */\nfunction getPrevCodePoint(str, offset) {\n    const charCode = str.charCodeAt(offset - 1);\n    if (isLowSurrogate(charCode) && offset > 1) {\n        const prevCharCode = str.charCodeAt(offset - 2);\n        if (isHighSurrogate(prevCharCode)) {\n            return computeCodePoint(prevCharCode, charCode);\n        }\n    }\n    return charCode;\n}\nclass CodePointIterator {\n    get offset() {\n        return this._offset;\n    }\n    constructor(str, offset = 0) {\n        this._str = str;\n        this._len = str.length;\n        this._offset = offset;\n    }\n    setOffset(offset) {\n        this._offset = offset;\n    }\n    prevCodePoint() {\n        const codePoint = getPrevCodePoint(this._str, this._offset);\n        this._offset -= (codePoint >= 65536 /* Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n        return codePoint;\n    }\n    nextCodePoint() {\n        const codePoint = getNextCodePoint(this._str, this._len, this._offset);\n        this._offset += (codePoint >= 65536 /* Constants.UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n        return codePoint;\n    }\n    eol() {\n        return (this._offset >= this._len);\n    }\n}\nclass GraphemeIterator {\n    get offset() {\n        return this._iterator.offset;\n    }\n    constructor(str, offset = 0) {\n        this._iterator = new CodePointIterator(str, offset);\n    }\n    nextGraphemeLength() {\n        const graphemeBreakTree = GraphemeBreakTree.getInstance();\n        const iterator = this._iterator;\n        const initialOffset = iterator.offset;\n        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n        while (!iterator.eol()) {\n            const offset = iterator.offset;\n            const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n            if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n                // move iterator back\n                iterator.setOffset(offset);\n                break;\n            }\n            graphemeBreakType = nextGraphemeBreakType;\n        }\n        return (iterator.offset - initialOffset);\n    }\n    prevGraphemeLength() {\n        const graphemeBreakTree = GraphemeBreakTree.getInstance();\n        const iterator = this._iterator;\n        const initialOffset = iterator.offset;\n        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n        while (iterator.offset > 0) {\n            const offset = iterator.offset;\n            const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n            if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\n                // move iterator back\n                iterator.setOffset(offset);\n                break;\n            }\n            graphemeBreakType = prevGraphemeBreakType;\n        }\n        return (initialOffset - iterator.offset);\n    }\n    eol() {\n        return this._iterator.eol();\n    }\n}\nfunction nextCharLength(str, initialOffset) {\n    const iterator = new GraphemeIterator(str, initialOffset);\n    return iterator.nextGraphemeLength();\n}\nfunction prevCharLength(str, initialOffset) {\n    const iterator = new GraphemeIterator(str, initialOffset);\n    return iterator.prevGraphemeLength();\n}\nfunction getCharContainingOffset(str, offset) {\n    if (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {\n        offset--;\n    }\n    const endOffset = offset + nextCharLength(str, offset);\n    const startOffset = endOffset - prevCharLength(str, endOffset);\n    return [startOffset, endOffset];\n}\nlet CONTAINS_RTL = (/* unused pure expression or super */ null && (undefined));\nfunction makeContainsRtl() {\n    // Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js\n    return /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA\\u07FE-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u088E\\u08A0-\\u08C9\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDC7\\uFDF0-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE35\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDD23\\uDE80-\\uDEA9\\uDEAD-\\uDF45\\uDF51-\\uDF81\\uDF86-\\uDFF6]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD4B-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n}\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nfunction containsRTL(str) {\n    if (!CONTAINS_RTL) {\n        CONTAINS_RTL = makeContainsRtl();\n    }\n    return CONTAINS_RTL.test(str);\n}\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nfunction strings_isBasicASCII(str) {\n    return IS_BASIC_ASCII.test(str);\n}\nconst UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\n/**\n * Returns true if `str` contains unusual line terminators, like LS or PS\n */\nfunction containsUnusualLineTerminators(str) {\n    return UNUSUAL_LINE_TERMINATORS.test(str);\n}\nfunction isFullWidthCharacter(charCode) {\n    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n    // http://jrgraphix.net/research/unicode_blocks.php\n    //          2E80 - 2EFF   CJK Radicals Supplement\n    //          2F00 - 2FDF   Kangxi Radicals\n    //          2FF0 - 2FFF   Ideographic Description Characters\n    //          3000 - 303F   CJK Symbols and Punctuation\n    //          3040 - 309F   Hiragana\n    //          30A0 - 30FF   Katakana\n    //          3100 - 312F   Bopomofo\n    //          3130 - 318F   Hangul Compatibility Jamo\n    //          3190 - 319F   Kanbun\n    //          31A0 - 31BF   Bopomofo Extended\n    //          31F0 - 31FF   Katakana Phonetic Extensions\n    //          3200 - 32FF   Enclosed CJK Letters and Months\n    //          3300 - 33FF   CJK Compatibility\n    //          3400 - 4DBF   CJK Unified Ideographs Extension A\n    //          4DC0 - 4DFF   Yijing Hexagram Symbols\n    //          4E00 - 9FFF   CJK Unified Ideographs\n    //          A000 - A48F   Yi Syllables\n    //          A490 - A4CF   Yi Radicals\n    //          AC00 - D7AF   Hangul Syllables\n    // [IGNORE] D800 - DB7F   High Surrogates\n    // [IGNORE] DB80 - DBFF   High Private Use Surrogates\n    // [IGNORE] DC00 - DFFF   Low Surrogates\n    // [IGNORE] E000 - F8FF   Private Use Area\n    //          F900 - FAFF   CJK Compatibility Ideographs\n    // [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms\n    // [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A\n    // [IGNORE] FE00 - FE0F   Variation Selectors\n    // [IGNORE] FE20 - FE2F   Combining Half Marks\n    // [IGNORE] FE30 - FE4F   CJK Compatibility Forms\n    // [IGNORE] FE50 - FE6F   Small Form Variants\n    // [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B\n    //          FF00 - FFEF   Halfwidth and Fullwidth Forms\n    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n    // [IGNORE] FFF0 - FFFF   Specials\n    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)\n        || (charCode >= 0xF900 && charCode <= 0xFAFF)\n        || (charCode >= 0xFF01 && charCode <= 0xFF5E));\n}\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js\n */\nfunction isEmojiImprecise(x) {\n    return ((x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)\n        || (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)\n        || (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)\n        || (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)\n        || (x >= 129648 && x <= 129782));\n}\n// -- UTF-8 BOM\nconst UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* CharCode.UTF8_BOM */);\nfunction startsWithUTF8BOM(str) {\n    return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* CharCode.UTF8_BOM */);\n}\nfunction containsUppercaseCharacter(target, ignoreEscapedChars = false) {\n    if (!target) {\n        return false;\n    }\n    if (ignoreEscapedChars) {\n        target = target.replace(/\\\\./g, '');\n    }\n    return target.toLowerCase() !== target;\n}\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nfunction singleLetterHash(n) {\n    const LETTERS_CNT = (90 /* CharCode.Z */ - 65 /* CharCode.A */ + 1);\n    n = n % (2 * LETTERS_CNT);\n    if (n < LETTERS_CNT) {\n        return String.fromCharCode(97 /* CharCode.a */ + n);\n    }\n    return String.fromCharCode(65 /* CharCode.A */ + n - LETTERS_CNT);\n}\nfunction breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {\n    // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\n    // !!! Let's make the common case a bit faster\n    if (breakTypeA === 0 /* GraphemeBreakType.Other */) {\n        // see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\n        return (breakTypeB !== 5 /* GraphemeBreakType.Extend */ && breakTypeB !== 7 /* GraphemeBreakType.SpacingMark */);\n    }\n    // Do not break between a CR and LF. Otherwise, break before and after controls.\n    // GB3                                        CR  LF\n    // GB4                       (Control | CR | LF) \n    // GB5                                            (Control | CR | LF)\n    if (breakTypeA === 2 /* GraphemeBreakType.CR */) {\n        if (breakTypeB === 3 /* GraphemeBreakType.LF */) {\n            return false; // GB3\n        }\n    }\n    if (breakTypeA === 4 /* GraphemeBreakType.Control */ || breakTypeA === 2 /* GraphemeBreakType.CR */ || breakTypeA === 3 /* GraphemeBreakType.LF */) {\n        return true; // GB4\n    }\n    if (breakTypeB === 4 /* GraphemeBreakType.Control */ || breakTypeB === 2 /* GraphemeBreakType.CR */ || breakTypeB === 3 /* GraphemeBreakType.LF */) {\n        return true; // GB5\n    }\n    // Do not break Hangul syllable sequences.\n    // GB6                                         L  (L | V | LV | LVT)\n    // GB7                                  (LV | V)  (V | T)\n    // GB8                                 (LVT | T)  T\n    if (breakTypeA === 8 /* GraphemeBreakType.L */) {\n        if (breakTypeB === 8 /* GraphemeBreakType.L */ || breakTypeB === 9 /* GraphemeBreakType.V */ || breakTypeB === 11 /* GraphemeBreakType.LV */ || breakTypeB === 12 /* GraphemeBreakType.LVT */) {\n            return false; // GB6\n        }\n    }\n    if (breakTypeA === 11 /* GraphemeBreakType.LV */ || breakTypeA === 9 /* GraphemeBreakType.V */) {\n        if (breakTypeB === 9 /* GraphemeBreakType.V */ || breakTypeB === 10 /* GraphemeBreakType.T */) {\n            return false; // GB7\n        }\n    }\n    if (breakTypeA === 12 /* GraphemeBreakType.LVT */ || breakTypeA === 10 /* GraphemeBreakType.T */) {\n        if (breakTypeB === 10 /* GraphemeBreakType.T */) {\n            return false; // GB8\n        }\n    }\n    // Do not break before extending characters or ZWJ.\n    // GB9                                            (Extend | ZWJ)\n    if (breakTypeB === 5 /* GraphemeBreakType.Extend */ || breakTypeB === 13 /* GraphemeBreakType.ZWJ */) {\n        return false; // GB9\n    }\n    // The GB9a and GB9b rules only apply to extended grapheme clusters:\n    // Do not break before SpacingMarks, or after Prepend characters.\n    // GB9a                                           SpacingMark\n    // GB9b                                  Prepend \n    if (breakTypeB === 7 /* GraphemeBreakType.SpacingMark */) {\n        return false; // GB9a\n    }\n    if (breakTypeA === 1 /* GraphemeBreakType.Prepend */) {\n        return false; // GB9b\n    }\n    // Do not break within emoji modifier sequences or emoji zwj sequences.\n    // GB11    \\p{Extended_Pictographic} Extend* ZWJ  \\p{Extended_Pictographic}\n    if (breakTypeA === 13 /* GraphemeBreakType.ZWJ */ && breakTypeB === 14 /* GraphemeBreakType.Extended_Pictographic */) {\n        // Note: we are not implementing the rule entirely here to avoid introducing states\n        return false; // GB11\n    }\n    // GB12                          sot (RI RI)* RI  RI\n    // GB13                        [^RI] (RI RI)* RI  RI\n    if (breakTypeA === 6 /* GraphemeBreakType.Regional_Indicator */ && breakTypeB === 6 /* GraphemeBreakType.Regional_Indicator */) {\n        // Note: we are not implementing the rule entirely here to avoid introducing states\n        return false; // GB12 & GB13\n    }\n    // GB999                                     Any  Any\n    return true;\n}\nclass GraphemeBreakTree {\n    static getInstance() {\n        if (!GraphemeBreakTree._INSTANCE) {\n            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\n        }\n        return GraphemeBreakTree._INSTANCE;\n    }\n    constructor() {\n        this._data = getGraphemeBreakRawData();\n    }\n    getGraphemeBreakType(codePoint) {\n        // !!! Let's make 7bit ASCII a bit faster: 0..31\n        if (codePoint < 32) {\n            if (codePoint === 10 /* CharCode.LineFeed */) {\n                return 3 /* GraphemeBreakType.LF */;\n            }\n            if (codePoint === 13 /* CharCode.CarriageReturn */) {\n                return 2 /* GraphemeBreakType.CR */;\n            }\n            return 4 /* GraphemeBreakType.Control */;\n        }\n        // !!! Let's make 7bit ASCII a bit faster: 32..126\n        if (codePoint < 127) {\n            return 0 /* GraphemeBreakType.Other */;\n        }\n        const data = this._data;\n        const nodeCount = data.length / 3;\n        let nodeIndex = 1;\n        while (nodeIndex <= nodeCount) {\n            if (codePoint < data[3 * nodeIndex]) {\n                // go left\n                nodeIndex = 2 * nodeIndex;\n            }\n            else if (codePoint > data[3 * nodeIndex + 1]) {\n                // go right\n                nodeIndex = 2 * nodeIndex + 1;\n            }\n            else {\n                // hit\n                return data[3 * nodeIndex + 2];\n            }\n        }\n        return 0 /* GraphemeBreakType.Other */;\n    }\n}\nGraphemeBreakTree._INSTANCE = null;\nfunction getGraphemeBreakRawData() {\n    // generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js\n    return JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');\n}\n//#endregion\n/**\n * Computes the offset after performing a left delete on the given string,\n * while considering unicode grapheme/emoji rules.\n*/\nfunction getLeftDeleteOffset(offset, str) {\n    if (offset === 0) {\n        return 0;\n    }\n    // Try to delete emoji part.\n    const emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);\n    if (emojiOffset !== undefined) {\n        return emojiOffset;\n    }\n    // Otherwise, just skip a single code point.\n    const iterator = new CodePointIterator(str, offset);\n    iterator.prevCodePoint();\n    return iterator.offset;\n}\nfunction getOffsetBeforeLastEmojiComponent(initialOffset, str) {\n    // See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the\n    // structure of emojis.\n    const iterator = new CodePointIterator(str, initialOffset);\n    let codePoint = iterator.prevCodePoint();\n    // Skip modifiers\n    while ((isEmojiModifier(codePoint) || codePoint === 65039 /* CodePoint.emojiVariantSelector */ || codePoint === 8419 /* CodePoint.enclosingKeyCap */)) {\n        if (iterator.offset === 0) {\n            // Cannot skip modifier, no preceding emoji base.\n            return undefined;\n        }\n        codePoint = iterator.prevCodePoint();\n    }\n    // Expect base emoji\n    if (!isEmojiImprecise(codePoint)) {\n        // Unexpected code point, not a valid emoji.\n        return undefined;\n    }\n    let resultOffset = iterator.offset;\n    if (resultOffset > 0) {\n        // Skip optional ZWJ code points that combine multiple emojis.\n        // In theory, we should check if that ZWJ actually combines multiple emojis\n        // to prevent deleting ZWJs in situations we didn't account for.\n        const optionalZwjCodePoint = iterator.prevCodePoint();\n        if (optionalZwjCodePoint === 8205 /* CodePoint.zwj */) {\n            resultOffset = iterator.offset;\n        }\n    }\n    return resultOffset;\n}\nfunction isEmojiModifier(codePoint) {\n    return 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;\n}\nconst noBreakWhitespace = '\\xa0';\nclass AmbiguousCharacters {\n    static getInstance(locales) {\n        return strings_a.cache.get(Array.from(locales));\n    }\n    static getLocales() {\n        return strings_a._locales.value;\n    }\n    constructor(confusableDictionary) {\n        this.confusableDictionary = confusableDictionary;\n    }\n    isAmbiguous(codePoint) {\n        return this.confusableDictionary.has(codePoint);\n    }\n    /**\n     * Returns the non basic ASCII code point that the given code point can be confused,\n     * or undefined if such code point does note exist.\n     */\n    getPrimaryConfusable(codePoint) {\n        return this.confusableDictionary.get(codePoint);\n    }\n    getConfusableCodePoints() {\n        return new Set(this.confusableDictionary.keys());\n    }\n}\nstrings_a = AmbiguousCharacters;\nAmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {\n    // Generated using https://github.com/hediet/vscode-unicode-data\n    // Stored as key1, value1, key2, value2, ...\n    return JSON.parse('{\\\"_common\\\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],\\\"_default\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"cs\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"de\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"es\\\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"fr\\\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"it\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"ja\\\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\\\"ko\\\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"pl\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"pt-BR\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"qps-ploc\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"ru\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"tr\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"zh-hans\\\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\\\"zh-hant\\\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');\n});\nAmbiguousCharacters.cache = new LRUCachedFunction({ getCacheKey: JSON.stringify }, (locales) => {\n    function arrayToMap(arr) {\n        const result = new Map();\n        for (let i = 0; i < arr.length; i += 2) {\n            result.set(arr[i], arr[i + 1]);\n        }\n        return result;\n    }\n    function mergeMaps(map1, map2) {\n        const result = new Map(map1);\n        for (const [key, value] of map2) {\n            result.set(key, value);\n        }\n        return result;\n    }\n    function intersectMaps(map1, map2) {\n        if (!map1) {\n            return map2;\n        }\n        const result = new Map();\n        for (const [key, value] of map1) {\n            if (map2.has(key)) {\n                result.set(key, value);\n            }\n        }\n        return result;\n    }\n    const data = strings_a.ambiguousCharacterData.value;\n    let filteredLocales = locales.filter((l) => !l.startsWith('_') && l in data);\n    if (filteredLocales.length === 0) {\n        filteredLocales = ['_default'];\n    }\n    let languageSpecificMap = undefined;\n    for (const locale of filteredLocales) {\n        const map = arrayToMap(data[locale]);\n        languageSpecificMap = intersectMaps(languageSpecificMap, map);\n    }\n    const commonMap = arrayToMap(data['_common']);\n    const map = mergeMaps(commonMap, languageSpecificMap);\n    return new strings_a(map);\n});\nAmbiguousCharacters._locales = new Lazy(() => Object.keys(strings_a.ambiguousCharacterData.value).filter((k) => !k.startsWith('_')));\nclass InvisibleCharacters {\n    static getRawData() {\n        // Generated using https://github.com/hediet/vscode-unicode-data\n        return JSON.parse('[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]');\n    }\n    static getData() {\n        if (!this._data) {\n            this._data = new Set(InvisibleCharacters.getRawData());\n        }\n        return this._data;\n    }\n    static isInvisibleCharacter(codePoint) {\n        return InvisibleCharacters.getData().has(codePoint);\n    }\n    static get codePoints() {\n        return InvisibleCharacters.getData();\n    }\n}\nInvisibleCharacters._data = undefined;\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nconst INITIALIZE = '$initialize';\nlet webWorkerWarningLogged = false;\nfunction logOnceWebWorkerWarning(err) {\n    if (!isWeb) {\n        // running tests\n        return;\n    }\n    if (!webWorkerWarningLogged) {\n        webWorkerWarningLogged = true;\n        console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq');\n    }\n    console.warn(err.message);\n}\nclass RequestMessage {\n    constructor(vsWorker, req, method, args) {\n        this.vsWorker = vsWorker;\n        this.req = req;\n        this.method = method;\n        this.args = args;\n        this.type = 0 /* MessageType.Request */;\n    }\n}\nclass ReplyMessage {\n    constructor(vsWorker, seq, res, err) {\n        this.vsWorker = vsWorker;\n        this.seq = seq;\n        this.res = res;\n        this.err = err;\n        this.type = 1 /* MessageType.Reply */;\n    }\n}\nclass SubscribeEventMessage {\n    constructor(vsWorker, req, eventName, arg) {\n        this.vsWorker = vsWorker;\n        this.req = req;\n        this.eventName = eventName;\n        this.arg = arg;\n        this.type = 2 /* MessageType.SubscribeEvent */;\n    }\n}\nclass EventMessage {\n    constructor(vsWorker, req, event) {\n        this.vsWorker = vsWorker;\n        this.req = req;\n        this.event = event;\n        this.type = 3 /* MessageType.Event */;\n    }\n}\nclass UnsubscribeEventMessage {\n    constructor(vsWorker, req) {\n        this.vsWorker = vsWorker;\n        this.req = req;\n        this.type = 4 /* MessageType.UnsubscribeEvent */;\n    }\n}\nclass SimpleWorkerProtocol {\n    constructor(handler) {\n        this._workerId = -1;\n        this._handler = handler;\n        this._lastSentReq = 0;\n        this._pendingReplies = Object.create(null);\n        this._pendingEmitters = new Map();\n        this._pendingEvents = new Map();\n    }\n    setWorkerId(workerId) {\n        this._workerId = workerId;\n    }\n    sendMessage(method, args) {\n        const req = String(++this._lastSentReq);\n        return new Promise((resolve, reject) => {\n            this._pendingReplies[req] = {\n                resolve: resolve,\n                reject: reject\n            };\n            this._send(new RequestMessage(this._workerId, req, method, args));\n        });\n    }\n    listen(eventName, arg) {\n        let req = null;\n        const emitter = new Emitter({\n            onWillAddFirstListener: () => {\n                req = String(++this._lastSentReq);\n                this._pendingEmitters.set(req, emitter);\n                this._send(new SubscribeEventMessage(this._workerId, req, eventName, arg));\n            },\n            onDidRemoveLastListener: () => {\n                this._pendingEmitters.delete(req);\n                this._send(new UnsubscribeEventMessage(this._workerId, req));\n                req = null;\n            }\n        });\n        return emitter.event;\n    }\n    handleMessage(message) {\n        if (!message || !message.vsWorker) {\n            return;\n        }\n        if (this._workerId !== -1 && message.vsWorker !== this._workerId) {\n            return;\n        }\n        this._handleMessage(message);\n    }\n    _handleMessage(msg) {\n        switch (msg.type) {\n            case 1 /* MessageType.Reply */:\n                return this._handleReplyMessage(msg);\n            case 0 /* MessageType.Request */:\n                return this._handleRequestMessage(msg);\n            case 2 /* MessageType.SubscribeEvent */:\n                return this._handleSubscribeEventMessage(msg);\n            case 3 /* MessageType.Event */:\n                return this._handleEventMessage(msg);\n            case 4 /* MessageType.UnsubscribeEvent */:\n                return this._handleUnsubscribeEventMessage(msg);\n        }\n    }\n    _handleReplyMessage(replyMessage) {\n        if (!this._pendingReplies[replyMessage.seq]) {\n            console.warn('Got reply to unknown seq');\n            return;\n        }\n        const reply = this._pendingReplies[replyMessage.seq];\n        delete this._pendingReplies[replyMessage.seq];\n        if (replyMessage.err) {\n            let err = replyMessage.err;\n            if (replyMessage.err.$isError) {\n                err = new Error();\n                err.name = replyMessage.err.name;\n                err.message = replyMessage.err.message;\n                err.stack = replyMessage.err.stack;\n            }\n            reply.reject(err);\n            return;\n        }\n        reply.resolve(replyMessage.res);\n    }\n    _handleRequestMessage(requestMessage) {\n        const req = requestMessage.req;\n        const result = this._handler.handleMessage(requestMessage.method, requestMessage.args);\n        result.then((r) => {\n            this._send(new ReplyMessage(this._workerId, req, r, undefined));\n        }, (e) => {\n            if (e.detail instanceof Error) {\n                // Loading errors have a detail property that points to the actual error\n                e.detail = transformErrorForSerialization(e.detail);\n            }\n            this._send(new ReplyMessage(this._workerId, req, undefined, transformErrorForSerialization(e)));\n        });\n    }\n    _handleSubscribeEventMessage(msg) {\n        const req = msg.req;\n        const disposable = this._handler.handleEvent(msg.eventName, msg.arg)((event) => {\n            this._send(new EventMessage(this._workerId, req, event));\n        });\n        this._pendingEvents.set(req, disposable);\n    }\n    _handleEventMessage(msg) {\n        if (!this._pendingEmitters.has(msg.req)) {\n            console.warn('Got event for unknown req');\n            return;\n        }\n        this._pendingEmitters.get(msg.req).fire(msg.event);\n    }\n    _handleUnsubscribeEventMessage(msg) {\n        if (!this._pendingEvents.has(msg.req)) {\n            console.warn('Got unsubscribe for unknown req');\n            return;\n        }\n        this._pendingEvents.get(msg.req).dispose();\n        this._pendingEvents.delete(msg.req);\n    }\n    _send(msg) {\n        const transfer = [];\n        if (msg.type === 0 /* MessageType.Request */) {\n            for (let i = 0; i < msg.args.length; i++) {\n                if (msg.args[i] instanceof ArrayBuffer) {\n                    transfer.push(msg.args[i]);\n                }\n            }\n        }\n        else if (msg.type === 1 /* MessageType.Reply */) {\n            if (msg.res instanceof ArrayBuffer) {\n                transfer.push(msg.res);\n            }\n        }\n        this._handler.sendMessage(msg, transfer);\n    }\n}\n/**\n * Main thread side\n */\nclass SimpleWorkerClient extends lifecycle_Disposable {\n    constructor(workerFactory, moduleId, host) {\n        super();\n        let lazyProxyReject = null;\n        this._worker = this._register(workerFactory.create('vs/base/common/worker/simpleWorker', (msg) => {\n            this._protocol.handleMessage(msg);\n        }, (err) => {\n            // in Firefox, web workers fail lazily :(\n            // we will reject the proxy\n            lazyProxyReject === null || lazyProxyReject === void 0 ? void 0 : lazyProxyReject(err);\n        }));\n        this._protocol = new SimpleWorkerProtocol({\n            sendMessage: (msg, transfer) => {\n                this._worker.postMessage(msg, transfer);\n            },\n            handleMessage: (method, args) => {\n                if (typeof host[method] !== 'function') {\n                    return Promise.reject(new Error('Missing method ' + method + ' on main thread host.'));\n                }\n                try {\n                    return Promise.resolve(host[method].apply(host, args));\n                }\n                catch (e) {\n                    return Promise.reject(e);\n                }\n            },\n            handleEvent: (eventName, arg) => {\n                if (propertyIsDynamicEvent(eventName)) {\n                    const event = host[eventName].call(host, arg);\n                    if (typeof event !== 'function') {\n                        throw new Error(`Missing dynamic event ${eventName} on main thread host.`);\n                    }\n                    return event;\n                }\n                if (propertyIsEvent(eventName)) {\n                    const event = host[eventName];\n                    if (typeof event !== 'function') {\n                        throw new Error(`Missing event ${eventName} on main thread host.`);\n                    }\n                    return event;\n                }\n                throw new Error(`Malformed event name ${eventName}`);\n            }\n        });\n        this._protocol.setWorkerId(this._worker.getId());\n        // Gather loader configuration\n        let loaderConfiguration = null;\n        const globalRequire = globalThis.require;\n        if (typeof globalRequire !== 'undefined' && typeof globalRequire.getConfig === 'function') {\n            // Get the configuration from the Monaco AMD Loader\n            loaderConfiguration = globalRequire.getConfig();\n        }\n        else if (typeof globalThis.requirejs !== 'undefined') {\n            // Get the configuration from requirejs\n            loaderConfiguration = globalThis.requirejs.s.contexts._.config;\n        }\n        const hostMethods = getAllMethodNames(host);\n        // Send initialize message\n        this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [\n            this._worker.getId(),\n            JSON.parse(JSON.stringify(loaderConfiguration)),\n            moduleId,\n            hostMethods,\n        ]);\n        // Create proxy to loaded code\n        const proxyMethodRequest = (method, args) => {\n            return this._request(method, args);\n        };\n        const proxyListen = (eventName, arg) => {\n            return this._protocol.listen(eventName, arg);\n        };\n        this._lazyProxy = new Promise((resolve, reject) => {\n            lazyProxyReject = reject;\n            this._onModuleLoaded.then((availableMethods) => {\n                resolve(simpleWorker_createProxyObject(availableMethods, proxyMethodRequest, proxyListen));\n            }, (e) => {\n                reject(e);\n                this._onError('Worker failed to load ' + moduleId, e);\n            });\n        });\n    }\n    getProxyObject() {\n        return this._lazyProxy;\n    }\n    _request(method, args) {\n        return new Promise((resolve, reject) => {\n            this._onModuleLoaded.then(() => {\n                this._protocol.sendMessage(method, args).then(resolve, reject);\n            }, reject);\n        });\n    }\n    _onError(message, error) {\n        console.error(message);\n        console.info(error);\n    }\n}\nfunction propertyIsEvent(name) {\n    // Assume a property is an event if it has a form of \"onSomething\"\n    return name[0] === 'o' && name[1] === 'n' && isUpperAsciiLetter(name.charCodeAt(2));\n}\nfunction propertyIsDynamicEvent(name) {\n    // Assume a property is a dynamic event (a method that returns an event) if it has a form of \"onDynamicSomething\"\n    return /^onDynamic/.test(name) && isUpperAsciiLetter(name.charCodeAt(9));\n}\nfunction simpleWorker_createProxyObject(methodNames, invoke, proxyListen) {\n    const createProxyMethod = (method) => {\n        return function () {\n            const args = Array.prototype.slice.call(arguments, 0);\n            return invoke(method, args);\n        };\n    };\n    const createProxyDynamicEvent = (eventName) => {\n        return function (arg) {\n            return proxyListen(eventName, arg);\n        };\n    };\n    const result = {};\n    for (const methodName of methodNames) {\n        if (propertyIsDynamicEvent(methodName)) {\n            result[methodName] = createProxyDynamicEvent(methodName);\n            continue;\n        }\n        if (propertyIsEvent(methodName)) {\n            result[methodName] = proxyListen(methodName, undefined);\n            continue;\n        }\n        result[methodName] = createProxyMethod(methodName);\n    }\n    return result;\n}\n/**\n * Worker side\n */\nclass SimpleWorkerServer {\n    constructor(postMessage, requestHandlerFactory) {\n        this._requestHandlerFactory = requestHandlerFactory;\n        this._requestHandler = null;\n        this._protocol = new SimpleWorkerProtocol({\n            sendMessage: (msg, transfer) => {\n                postMessage(msg, transfer);\n            },\n            handleMessage: (method, args) => this._handleMessage(method, args),\n            handleEvent: (eventName, arg) => this._handleEvent(eventName, arg)\n        });\n    }\n    onmessage(msg) {\n        this._protocol.handleMessage(msg);\n    }\n    _handleMessage(method, args) {\n        if (method === INITIALIZE) {\n            return this.initialize(args[0], args[1], args[2], args[3]);\n        }\n        if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n    _handleEvent(eventName, arg) {\n        if (!this._requestHandler) {\n            throw new Error(`Missing requestHandler`);\n        }\n        if (propertyIsDynamicEvent(eventName)) {\n            const event = this._requestHandler[eventName].call(this._requestHandler, arg);\n            if (typeof event !== 'function') {\n                throw new Error(`Missing dynamic event ${eventName} on request handler.`);\n            }\n            return event;\n        }\n        if (propertyIsEvent(eventName)) {\n            const event = this._requestHandler[eventName];\n            if (typeof event !== 'function') {\n                throw new Error(`Missing event ${eventName} on request handler.`);\n            }\n            return event;\n        }\n        throw new Error(`Malformed event name ${eventName}`);\n    }\n    initialize(workerId, loaderConfig, moduleId, hostMethods) {\n        this._protocol.setWorkerId(workerId);\n        const proxyMethodRequest = (method, args) => {\n            return this._protocol.sendMessage(method, args);\n        };\n        const proxyListen = (eventName, arg) => {\n            return this._protocol.listen(eventName, arg);\n        };\n        const hostProxy = simpleWorker_createProxyObject(hostMethods, proxyMethodRequest, proxyListen);\n        if (this._requestHandlerFactory) {\n            // static request handler\n            this._requestHandler = this._requestHandlerFactory(hostProxy);\n            return Promise.resolve(getAllMethodNames(this._requestHandler));\n        }\n        if (loaderConfig) {\n            // Remove 'baseUrl', handling it is beyond scope for now\n            if (typeof loaderConfig.baseUrl !== 'undefined') {\n                delete loaderConfig['baseUrl'];\n            }\n            if (typeof loaderConfig.paths !== 'undefined') {\n                if (typeof loaderConfig.paths.vs !== 'undefined') {\n                    delete loaderConfig.paths['vs'];\n                }\n            }\n            if (typeof loaderConfig.trustedTypesPolicy !== 'undefined') {\n                // don't use, it has been destroyed during serialize\n                delete loaderConfig['trustedTypesPolicy'];\n            }\n            // Since this is in a web worker, enable catching errors\n            loaderConfig.catchError = true;\n            globalThis.require.config(loaderConfig);\n        }\n        return new Promise((resolve, reject) => {\n            // Use the global require to be sure to get the global config\n            // ESM-comment-begin\n            // \t\t\tconst req = (globalThis.require || require);\n            // ESM-comment-end\n            // ESM-uncomment-begin\n            const req = globalThis.require;\n            // ESM-uncomment-end\n            req([moduleId], (module) => {\n                this._requestHandler = module.create(hostProxy);\n                if (!this._requestHandler) {\n                    reject(new Error(`No RequestHandler!`));\n                    return;\n                }\n                resolve(getAllMethodNames(this._requestHandler));\n            }, reject);\n        });\n    }\n}\n/**\n * Called on the worker side\n * @skipMangle\n */\nfunction simpleWorker_create(postMessage) {\n    return new SimpleWorkerServer(postMessage, null);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Represents information about a specific difference between two sequences.\n */\nclass DiffChange {\n    /**\n     * Constructs a new DiffChange with the given sequence information\n     * and content.\n     */\n    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {\n        //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n        this.originalStart = originalStart;\n        this.originalLength = originalLength;\n        this.modifiedStart = modifiedStart;\n        this.modifiedLength = modifiedLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the original sequence.\n     */\n    getOriginalEnd() {\n        return this.originalStart + this.originalLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the modified sequence.\n     */\n    getModifiedEnd() {\n        return this.modifiedStart + this.modifiedLength;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/hash.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Return a hash value for an object.\n */\nfunction hash(obj) {\n    return doHash(obj, 0);\n}\nfunction doHash(obj, hashVal) {\n    switch (typeof obj) {\n        case 'object':\n            if (obj === null) {\n                return numberHash(349, hashVal);\n            }\n            else if (Array.isArray(obj)) {\n                return arrayHash(obj, hashVal);\n            }\n            return objectHash(obj, hashVal);\n        case 'string':\n            return stringHash(obj, hashVal);\n        case 'boolean':\n            return booleanHash(obj, hashVal);\n        case 'number':\n            return numberHash(obj, hashVal);\n        case 'undefined':\n            return numberHash(937, hashVal);\n        default:\n            return numberHash(617, hashVal);\n    }\n}\nfunction numberHash(val, initialHashVal) {\n    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32\n}\nfunction booleanHash(b, initialHashVal) {\n    return numberHash(b ? 433 : 863, initialHashVal);\n}\nfunction stringHash(s, hashVal) {\n    hashVal = numberHash(149417, hashVal);\n    for (let i = 0, length = s.length; i < length; i++) {\n        hashVal = numberHash(s.charCodeAt(i), hashVal);\n    }\n    return hashVal;\n}\nfunction arrayHash(arr, initialHashVal) {\n    initialHashVal = numberHash(104579, initialHashVal);\n    return arr.reduce((hashVal, item) => doHash(item, hashVal), initialHashVal);\n}\nfunction objectHash(obj, initialHashVal) {\n    initialHashVal = numberHash(181387, initialHashVal);\n    return Object.keys(obj).sort().reduce((hashVal, key) => {\n        hashVal = stringHash(key, hashVal);\n        return doHash(obj[key], hashVal);\n    }, initialHashVal);\n}\nfunction leftRotate(value, bits, totalBits = 32) {\n    // delta + bits = totalBits\n    const delta = totalBits - bits;\n    // All ones, expect `delta` zeros aligned to the right\n    const mask = ~((1 << delta) - 1);\n    // Join (value left-shifted `bits` bits) with (masked value right-shifted `delta` bits)\n    return ((value << bits) | ((mask & value) >>> delta)) >>> 0;\n}\nfunction fill(dest, index = 0, count = dest.byteLength, value = 0) {\n    for (let i = 0; i < count; i++) {\n        dest[index + i] = value;\n    }\n}\nfunction leftPad(value, length, char = '0') {\n    while (value.length < length) {\n        value = char + value;\n    }\n    return value;\n}\nfunction toHexString(bufferOrValue, bitsize = 32) {\n    if (bufferOrValue instanceof ArrayBuffer) {\n        return Array.from(new Uint8Array(bufferOrValue)).map(b => b.toString(16).padStart(2, '0')).join('');\n    }\n    return leftPad((bufferOrValue >>> 0).toString(16), bitsize / 4);\n}\n/**\n * A SHA1 implementation that works with strings and does not allocate.\n */\nclass StringSHA1 {\n    constructor() {\n        this._h0 = 0x67452301;\n        this._h1 = 0xEFCDAB89;\n        this._h2 = 0x98BADCFE;\n        this._h3 = 0x10325476;\n        this._h4 = 0xC3D2E1F0;\n        this._buff = new Uint8Array(64 /* SHA1Constant.BLOCK_SIZE */ + 3 /* to fit any utf-8 */);\n        this._buffDV = new DataView(this._buff.buffer);\n        this._buffLen = 0;\n        this._totalLen = 0;\n        this._leftoverHighSurrogate = 0;\n        this._finished = false;\n    }\n    update(str) {\n        const strLen = str.length;\n        if (strLen === 0) {\n            return;\n        }\n        const buff = this._buff;\n        let buffLen = this._buffLen;\n        let leftoverHighSurrogate = this._leftoverHighSurrogate;\n        let charCode;\n        let offset;\n        if (leftoverHighSurrogate !== 0) {\n            charCode = leftoverHighSurrogate;\n            offset = -1;\n            leftoverHighSurrogate = 0;\n        }\n        else {\n            charCode = str.charCodeAt(0);\n            offset = 0;\n        }\n        while (true) {\n            let codePoint = charCode;\n            if (isHighSurrogate(charCode)) {\n                if (offset + 1 < strLen) {\n                    const nextCharCode = str.charCodeAt(offset + 1);\n                    if (isLowSurrogate(nextCharCode)) {\n                        offset++;\n                        codePoint = computeCodePoint(charCode, nextCharCode);\n                    }\n                    else {\n                        // illegal => unicode replacement character\n                        codePoint = 65533 /* SHA1Constant.UNICODE_REPLACEMENT */;\n                    }\n                }\n                else {\n                    // last character is a surrogate pair\n                    leftoverHighSurrogate = charCode;\n                    break;\n                }\n            }\n            else if (isLowSurrogate(charCode)) {\n                // illegal => unicode replacement character\n                codePoint = 65533 /* SHA1Constant.UNICODE_REPLACEMENT */;\n            }\n            buffLen = this._push(buff, buffLen, codePoint);\n            offset++;\n            if (offset < strLen) {\n                charCode = str.charCodeAt(offset);\n            }\n            else {\n                break;\n            }\n        }\n        this._buffLen = buffLen;\n        this._leftoverHighSurrogate = leftoverHighSurrogate;\n    }\n    _push(buff, buffLen, codePoint) {\n        if (codePoint < 0x0080) {\n            buff[buffLen++] = codePoint;\n        }\n        else if (codePoint < 0x0800) {\n            buff[buffLen++] = 0b11000000 | ((codePoint & 0b00000000000000000000011111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        else if (codePoint < 0x10000) {\n            buff[buffLen++] = 0b11100000 | ((codePoint & 0b00000000000000001111000000000000) >>> 12);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        else {\n            buff[buffLen++] = 0b11110000 | ((codePoint & 0b00000000000111000000000000000000) >>> 18);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000111111000000000000) >>> 12);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000111111000000) >>> 6);\n            buff[buffLen++] = 0b10000000 | ((codePoint & 0b00000000000000000000000000111111) >>> 0);\n        }\n        if (buffLen >= 64 /* SHA1Constant.BLOCK_SIZE */) {\n            this._step();\n            buffLen -= 64 /* SHA1Constant.BLOCK_SIZE */;\n            this._totalLen += 64 /* SHA1Constant.BLOCK_SIZE */;\n            // take last 3 in case of UTF8 overflow\n            buff[0] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 0];\n            buff[1] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 1];\n            buff[2] = buff[64 /* SHA1Constant.BLOCK_SIZE */ + 2];\n        }\n        return buffLen;\n    }\n    digest() {\n        if (!this._finished) {\n            this._finished = true;\n            if (this._leftoverHighSurrogate) {\n                // illegal => unicode replacement character\n                this._leftoverHighSurrogate = 0;\n                this._buffLen = this._push(this._buff, this._buffLen, 65533 /* SHA1Constant.UNICODE_REPLACEMENT */);\n            }\n            this._totalLen += this._buffLen;\n            this._wrapUp();\n        }\n        return toHexString(this._h0) + toHexString(this._h1) + toHexString(this._h2) + toHexString(this._h3) + toHexString(this._h4);\n    }\n    _wrapUp() {\n        this._buff[this._buffLen++] = 0x80;\n        fill(this._buff, this._buffLen);\n        if (this._buffLen > 56) {\n            this._step();\n            fill(this._buff);\n        }\n        // this will fit because the mantissa can cover up to 52 bits\n        const ml = 8 * this._totalLen;\n        this._buffDV.setUint32(56, Math.floor(ml / 4294967296), false);\n        this._buffDV.setUint32(60, ml % 4294967296, false);\n        this._step();\n    }\n    _step() {\n        const bigBlock32 = StringSHA1._bigBlock32;\n        const data = this._buffDV;\n        for (let j = 0; j < 64 /* 16*4 */; j += 4) {\n            bigBlock32.setUint32(j, data.getUint32(j, false), false);\n        }\n        for (let j = 64; j < 320 /* 80*4 */; j += 4) {\n            bigBlock32.setUint32(j, leftRotate((bigBlock32.getUint32(j - 12, false) ^ bigBlock32.getUint32(j - 32, false) ^ bigBlock32.getUint32(j - 56, false) ^ bigBlock32.getUint32(j - 64, false)), 1), false);\n        }\n        let a = this._h0;\n        let b = this._h1;\n        let c = this._h2;\n        let d = this._h3;\n        let e = this._h4;\n        let f, k;\n        let temp;\n        for (let j = 0; j < 80; j++) {\n            if (j < 20) {\n                f = (b & c) | ((~b) & d);\n                k = 0x5A827999;\n            }\n            else if (j < 40) {\n                f = b ^ c ^ d;\n                k = 0x6ED9EBA1;\n            }\n            else if (j < 60) {\n                f = (b & c) | (b & d) | (c & d);\n                k = 0x8F1BBCDC;\n            }\n            else {\n                f = b ^ c ^ d;\n                k = 0xCA62C1D6;\n            }\n            temp = (leftRotate(a, 5) + f + e + k + bigBlock32.getUint32(j * 4, false)) & 0xffffffff;\n            e = d;\n            d = c;\n            c = leftRotate(b, 30);\n            b = a;\n            a = temp;\n        }\n        this._h0 = (this._h0 + a) & 0xffffffff;\n        this._h1 = (this._h1 + b) & 0xffffffff;\n        this._h2 = (this._h2 + c) & 0xffffffff;\n        this._h3 = (this._h3 + d) & 0xffffffff;\n        this._h4 = (this._h4 + e) & 0xffffffff;\n    }\n}\nStringSHA1._bigBlock32 = new DataView(new ArrayBuffer(320)); // 80 * 4 = 320\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/diff/diff.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nclass StringDiffSequence {\n    constructor(source) {\n        this.source = source;\n    }\n    getElements() {\n        const source = this.source;\n        const characters = new Int32Array(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            characters[i] = source.charCodeAt(i);\n        }\n        return characters;\n    }\n}\nfunction stringDiff(original, modified, pretty) {\n    return new LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;\n}\n//\n// The code below has been ported from a C# implementation in VS\n//\nclass Debug {\n    static Assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nclass MyArray {\n    /**\n     * Copies a range of elements from an Array starting at the specified source index and pastes\n     * them to another Array starting at the specified destination index. The length and the indexes\n     * are specified as 64-bit integers.\n     * sourceArray:\n     *\t\tThe Array that contains the data to copy.\n     * sourceIndex:\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n     * destinationArray:\n     *\t\tThe Array that receives the data.\n     * destinationIndex:\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n     * length:\n     *\t\tA 64-bit integer that represents the number of elements to copy.\n     */\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n}\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarkNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n    /**\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\n     */\n    constructor() {\n        this.m_changes = [];\n        this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n    }\n    /**\n     * Marks the beginning of the next change in the set of differences.\n     */\n    MarkNextChange() {\n        // Only add to the list if there is something to add\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Add the new change to our list\n            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n        }\n        // Reset for the next change\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n        this.m_originalStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n    }\n    /**\n     * Adds the original element at the given position to the elements\n     * affected by the current change. The modified index gives context\n     * to the change position with respect to the original sequence.\n     * @param originalIndex The index of the original element to add.\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n     */\n    AddOriginalElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_originalCount++;\n    }\n    /**\n     * Adds the modified element at the given position to the elements\n     * affected by the current change. The original index gives context\n     * to the change position with respect to the modified sequence.\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n     * @param modifiedIndex The index of the modified element to add.\n     */\n    AddModifiedElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_modifiedCount++;\n    }\n    /**\n     * Retrieves all of the changes marked by the class.\n     */\n    getChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        return this.m_changes;\n    }\n    /**\n     * Retrieves all of the changes marked by the class in the reverse order\n     */\n    getReverseChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        this.m_changes.reverse();\n        return this.m_changes;\n    }\n}\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nclass LcsDiff {\n    /**\n     * Constructs the DiffFinder\n     */\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\n        this._originalSequence = originalSequence;\n        this._modifiedSequence = modifiedSequence;\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\n        this._originalStringElements = originalStringElements;\n        this._originalElementsOrHash = originalElementsOrHash;\n        this._modifiedStringElements = modifiedStringElements;\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n    }\n    static _isStringArray(arr) {\n        return (arr.length > 0 && typeof arr[0] === 'string');\n    }\n    static _getElements(sequence) {\n        const elements = sequence.getElements();\n        if (LcsDiff._isStringArray(elements)) {\n            const hashes = new Int32Array(elements.length);\n            for (let i = 0, len = elements.length; i < len; i++) {\n                hashes[i] = stringHash(elements[i], 0);\n            }\n            return [elements, hashes, true];\n        }\n        if (elements instanceof Int32Array) {\n            return [[], elements, false];\n        }\n        return [[], new Int32Array(elements), false];\n    }\n    ElementsAreEqual(originalIndex, newIndex) {\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n    }\n    ElementsAreStrictEqual(originalIndex, newIndex) {\n        if (!this.ElementsAreEqual(originalIndex, newIndex)) {\n            return false;\n        }\n        const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n        const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n        return (originalElement === modifiedElement);\n    }\n    static _getStrictElement(sequence, index) {\n        if (typeof sequence.getStrictElement === 'function') {\n            return sequence.getStrictElement(index);\n        }\n        return null;\n    }\n    OriginalElementsAreEqual(index1, index2) {\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n    }\n    ModifiedElementsAreEqual(index1, index2) {\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n    }\n    ComputeDiff(pretty) {\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n    }\n    /**\n     * Computes the differences between the original and modified input\n     * sequences on the bounded range.\n     * @returns An array of the differences between the two input sequences.\n     */\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n        const quitEarlyArr = [false];\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n        if (pretty) {\n            // We have to clean up the computed diff to be more intuitive\n            // but it turns out this cannot be done correctly until the entire set\n            // of diffs have been computed\n            changes = this.PrettifyChanges(changes);\n        }\n        return {\n            quitEarly: quitEarlyArr[0],\n            changes: changes\n        };\n    }\n    /**\n     * Private helper method which computes the differences on the bounded range\n     * recursively.\n     * @returns An array of the differences between the two input sequences.\n     */\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n        quitEarlyArr[0] = false;\n        // Find the start of the differences\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n            originalStart++;\n            modifiedStart++;\n        }\n        // Find the end of the differences\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n            originalEnd--;\n            modifiedEnd--;\n        }\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n            let changes;\n            if (modifiedStart <= modifiedEnd) {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                // All insertions\n                changes = [\n                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n                ];\n            }\n            else if (originalStart <= originalEnd) {\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // All deletions\n                changes = [\n                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n                ];\n            }\n            else {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // Identical sequences - No differences\n                changes = [];\n            }\n            return changes;\n        }\n        // This problem can be solved using the Divide-And-Conquer technique.\n        const midOriginalArr = [0];\n        const midModifiedArr = [0];\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n        const midOriginal = midOriginalArr[0];\n        const midModified = midModifiedArr[0];\n        if (result !== null) {\n            // Result is not-null when there was enough memory to compute the changes while\n            // searching for the recursion point\n            return result;\n        }\n        else if (!quitEarlyArr[0]) {\n            // We can break the problem down recursively by finding the changes in the\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n            let rightChanges = [];\n            if (!quitEarlyArr[0]) {\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n            }\n            else {\n                // We didn't have time to finish the first half, so we don't have time to compute this half.\n                // Consider the entire rest of the sequence different.\n                rightChanges = [\n                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n                ];\n            }\n            return this.ConcatenateChanges(leftChanges, rightChanges);\n        }\n        // If we hit here, we quit early, and so can't return anything meaningful\n        return [\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n    }\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n        let forwardChanges = null;\n        let reverseChanges = null;\n        // First, walk backward through the forward diagonals history\n        let changeHelper = new DiffChangeHelper();\n        let diagonalMin = diagonalForwardStart;\n        let diagonalMax = diagonalForwardEnd;\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n        let lastOriginalIndex = -1073741824 /* Constants.MIN_SAFE_SMALL_INTEGER */;\n        let historyIndex = this.m_forwardHistory.length - 1;\n        do {\n            // Get the diagonal index from the relative diagonal number\n            const diagonal = diagonalRelative + diagonalForwardBase;\n            // Figure out where we came from\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                // Vertical line (the element is an insert)\n                originalIndex = forwardPoints[diagonal + 1];\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex;\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            else {\n                // Horizontal line (the element is a deletion)\n                originalIndex = forwardPoints[diagonal - 1] + 1;\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex - 1;\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            if (historyIndex >= 0) {\n                forwardPoints = this.m_forwardHistory[historyIndex];\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n                diagonalMin = 1;\n                diagonalMax = forwardPoints.length - 1;\n            }\n        } while (--historyIndex >= -1);\n        // Ironically, we get the forward changes as the reverse of the\n        // order we added them since we technically added them backwards\n        forwardChanges = changeHelper.getReverseChanges();\n        if (quitEarlyArr[0]) {\n            // TODO: Calculate a partial from the reverse diagonals.\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\n            let originalStartPoint = midOriginalArr[0] + 1;\n            let modifiedStartPoint = midModifiedArr[0] + 1;\n            if (forwardChanges !== null && forwardChanges.length > 0) {\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n            }\n            reverseChanges = [\n                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n            ];\n        }\n        else {\n            // Now walk backward through the reverse diagonals history\n            changeHelper = new DiffChangeHelper();\n            diagonalMin = diagonalReverseStart;\n            diagonalMax = diagonalReverseEnd;\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n            lastOriginalIndex = 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */;\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n            do {\n                // Get the diagonal index from the relative diagonal number\n                const diagonal = diagonalRelative + diagonalReverseBase;\n                // Figure out where we came from\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    // Horizontal line (the element is a deletion))\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex + 1;\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                else {\n                    // Vertical line (the element is an insertion)\n                    originalIndex = reversePoints[diagonal - 1];\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex;\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                if (historyIndex >= 0) {\n                    reversePoints = this.m_reverseHistory[historyIndex];\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n                    diagonalMin = 1;\n                    diagonalMax = reversePoints.length - 1;\n                }\n            } while (--historyIndex >= -1);\n            // There are cases where the reverse history will find diffs that\n            // are correct, but not intuitive, so we need shift them.\n            reverseChanges = changeHelper.getChanges();\n        }\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    }\n    /**\n     * Given the range to compute the diff on, this method finds the point:\n     * (midOriginal, midModified)\n     * that exists in the middle of the LCS of the two sequences and\n     * is the point at which the LCS problem may be broken down recursively.\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\n     * point is calculated and the full trace is available in memory, then this method\n     * will return the change list.\n     * @param originalStart The start bound of the original sequence range\n     * @param originalEnd The end bound of the original sequence range\n     * @param modifiedStart The start bound of the modified sequence range\n     * @param modifiedEnd The end bound of the modified sequence range\n     * @param midOriginal The middle point of the original sequence range\n     * @param midModified The middle point of the modified sequence range\n     * @returns The diff changes, if available, otherwise null\n     */\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n        let originalIndex = 0, modifiedIndex = 0;\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\n        // To traverse the edit graph and produce the proper LCS, our actual\n        // start position is just outside the given boundary\n        originalStart--;\n        modifiedStart--;\n        // We set these up to make the compiler happy, but they will\n        // be replaced before we return with the actual recursion point\n        midOriginalArr[0] = 0;\n        midModifiedArr[0] = 0;\n        // Clear out the history\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n        // The integer value in the cell represents the originalIndex of the furthest\n        // reaching point found so far that ends in that diagonal.\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n        const numDiagonals = maxDifferences + 1;\n        const forwardPoints = new Int32Array(numDiagonals);\n        const reversePoints = new Int32Array(numDiagonals);\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\n        const diagonalReverseBase = (originalEnd - originalStart);\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalForwardBase)\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalReverseBase)\n        const diagonalForwardOffset = (originalStart - modifiedStart);\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n        const delta = diagonalReverseBase - diagonalForwardBase;\n        const deltaIsEven = (delta % 2 === 0);\n        // Here we set up the start and end points as the furthest points found so far\n        // in both the forward and reverse directions, respectively\n        forwardPoints[diagonalForwardBase] = originalStart;\n        reversePoints[diagonalReverseBase] = originalEnd;\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n        quitEarlyArr[0] = false;\n        // A couple of points:\n        // --With this method, we iterate on the number of differences between the two sequences.\n        //   The more differences there actually are, the longer this will take.\n        // --Also, as the number of differences increases, we have to search on diagonals further\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n        //   is even and odd diagonals only when numDifferences is odd.\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n            let furthestOriginalIndex = 0;\n            let furthestModifiedIndex = 0;\n            // Run the algorithm in the forward direction\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalStart, modifiedStart)\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                    originalIndex = forwardPoints[diagonal + 1];\n                }\n                else {\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n                // Save the current originalIndex so we can test for false overlap in step 3\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // so long as the elements are equal.\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n                    originalIndex++;\n                    modifiedIndex++;\n                }\n                forwardPoints[diagonal] = originalIndex;\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n                    furthestOriginalIndex = originalIndex;\n                    furthestModifiedIndex = modifiedIndex;\n                }\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n                // then check for overlap.\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n                    if (originalIndex >= reversePoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Check to see if we should be quitting early, before moving on to the next iteration.\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n                // We can't finish, so skip ahead to generating a result from what we have.\n                quitEarlyArr[0] = true;\n                // Use the furthest distance we got in the forward direction.\n                midOriginalArr[0] = furthestOriginalIndex;\n                midModifiedArr[0] = furthestModifiedIndex;\n                if (matchLengthOfLongest > 0 && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\n                    // Enough of the history is in memory to walk it backwards\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                }\n                else {\n                    // We didn't actually remember enough of the history.\n                    //Since we are quitting the diff early, we need to shift back the originalStart and modified start\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\n                    originalStart++;\n                    modifiedStart++;\n                    return [\n                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n                    ];\n                }\n            }\n            // Run the algorithm in the reverse direction\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalEnd, modifiedEnd)\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n                // Save the current originalIndex so we can test for false overlap\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // as long as the elements are equal.\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n                    originalIndex--;\n                    modifiedIndex--;\n                }\n                reversePoints[diagonal] = originalIndex;\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n                // and diagonal is in the range of forward diagonals computed for numDifferences\n                // then check for overlap.\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n                    if (originalIndex <= forwardPoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* LocalConstants.MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* LocalConstants.MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Save current vectors to history before the next iteration\n            if (numDifferences <= 1447 /* LocalConstants.MaxDifferencesHistory */) {\n                // We are allocating space for one extra int, which we fill with\n                // the index of the diagonal base index\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n                this.m_forwardHistory.push(temp);\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n                this.m_reverseHistory.push(temp);\n            }\n        }\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\n        // NOTE: This part is a bit messy\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    }\n    /**\n     * Shifts the given changes to provide a more intuitive diff.\n     * While the first element in a diff matches the first element after the diff,\n     * we shift the diff down.\n     *\n     * @param changes The list of changes to shift\n     * @returns The shifted changes\n     */\n    PrettifyChanges(changes) {\n        // Shift all the changes down first\n        for (let i = 0; i < changes.length; i++) {\n            const change = changes[i];\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            while (change.originalStart + change.originalLength < originalStop\n                && change.modifiedStart + change.modifiedLength < modifiedStop\n                && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\n                && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n                const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n                const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n                if (endStrictEqual && !startStrictEqual) {\n                    // moving the change down would create an equal change, but the elements are not strict equal\n                    break;\n                }\n                change.originalStart++;\n                change.modifiedStart++;\n            }\n            const mergedChangeArr = [null];\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n                changes[i] = mergedChangeArr[0];\n                changes.splice(i + 1, 1);\n                i--;\n                continue;\n            }\n        }\n        // Shift changes back up until we hit empty or whitespace-only lines\n        for (let i = changes.length - 1; i >= 0; i--) {\n            const change = changes[i];\n            let originalStop = 0;\n            let modifiedStop = 0;\n            if (i > 0) {\n                const prevChange = changes[i - 1];\n                originalStop = prevChange.originalStart + prevChange.originalLength;\n                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n            }\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            let bestDelta = 0;\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n            for (let delta = 1;; delta++) {\n                const originalStart = change.originalStart - delta;\n                const modifiedStart = change.modifiedStart - delta;\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\n                    break;\n                }\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n                    break;\n                }\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n                    break;\n                }\n                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\n                const score = ((touchingPreviousChange ? 5 : 0)\n                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestDelta = delta;\n                }\n            }\n            change.originalStart -= bestDelta;\n            change.modifiedStart -= bestDelta;\n            const mergedChangeArr = [null];\n            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n                changes[i - 1] = mergedChangeArr[0];\n                changes.splice(i, 1);\n                i++;\n                continue;\n            }\n        }\n        // There could be multiple longest common substrings.\n        // Give preference to the ones containing longer lines\n        if (this._hasStrings) {\n            for (let i = 1, len = changes.length; i < len; i++) {\n                const aChange = changes[i - 1];\n                const bChange = changes[i];\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n                const aOriginalStart = aChange.originalStart;\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\n                const aModifiedStart = aChange.modifiedStart;\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\n                // Avoid wasting a lot of time with these searches\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n                    if (t) {\n                        const [originalMatchStart, modifiedMatchStart] = t;\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n                            // switch to another sequence that has a better score\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n                            bChange.originalStart = originalMatchStart + matchedLength;\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n                        }\n                    }\n                }\n            }\n        }\n        return changes;\n    }\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\n            return null;\n        }\n        const originalMax = originalStart + originalLength - desiredLength + 1;\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n        let bestScore = 0;\n        let bestOriginalStart = 0;\n        let bestModifiedStart = 0;\n        for (let i = originalStart; i < originalMax; i++) {\n            for (let j = modifiedStart; j < modifiedMax; j++) {\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\n                if (score > 0 && score > bestScore) {\n                    bestScore = score;\n                    bestOriginalStart = i;\n                    bestModifiedStart = j;\n                }\n            }\n        }\n        if (bestScore > 0) {\n            return [bestOriginalStart, bestModifiedStart];\n        }\n        return null;\n    }\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\n        let score = 0;\n        for (let l = 0; l < length; l++) {\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n                return 0;\n            }\n            score += this._originalStringElements[originalStart + l].length;\n        }\n        return score;\n    }\n    _OriginalIsBoundary(index) {\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n    }\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n            return true;\n        }\n        if (originalLength > 0) {\n            const originalEnd = originalStart + originalLength;\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _ModifiedIsBoundary(index) {\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n    }\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n            return true;\n        }\n        if (modifiedLength > 0) {\n            const modifiedEnd = modifiedStart + modifiedLength;\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n        return (originalScore + modifiedScore);\n    }\n    /**\n     * Concatenates the two input DiffChange lists and returns the resulting\n     * list.\n     * @param The left changes\n     * @param The right changes\n     * @returns The concatenated list\n     */\n    ConcatenateChanges(left, right) {\n        const mergedChangeArr = [];\n        if (left.length === 0 || right.length === 0) {\n            return (right.length > 0) ? right : left;\n        }\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n            // Since we break the problem down recursively, it is possible that we\n            // might recurse in the middle of a change thereby splitting it into\n            // two changes. Here in the combining stage, we detect and fuse those\n            // changes back together\n            const result = new Array(left.length + right.length - 1);\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\n            result[left.length - 1] = mergedChangeArr[0];\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\n            return result;\n        }\n        else {\n            const result = new Array(left.length + right.length);\n            MyArray.Copy(left, 0, result, 0, left.length);\n            MyArray.Copy(right, 0, result, left.length, right.length);\n            return result;\n        }\n    }\n    /**\n     * Returns true if the two changes overlap and can be merged into a single\n     * change\n     * @param left The left change\n     * @param right The right change\n     * @param mergedChange The merged change if the two overlap, null otherwise\n     * @returns True if the two changes overlap\n     */\n    ChangesOverlap(left, right, mergedChangeArr) {\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n            const originalStart = left.originalStart;\n            let originalLength = left.originalLength;\n            const modifiedStart = left.modifiedStart;\n            let modifiedLength = left.modifiedLength;\n            if (left.originalStart + left.originalLength >= right.originalStart) {\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\n            }\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n            }\n            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n            return true;\n        }\n        else {\n            mergedChangeArr[0] = null;\n            return false;\n        }\n    }\n    /**\n     * Helper method used to clip a diagonal index to the range of valid\n     * diagonals. This also decides whether or not the diagonal index,\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\n     * one inside the boundary depending on the Even/Odd status of the boundary\n     * and numDifferences.\n     * @param diagonal The index of the diagonal to clip.\n     * @param numDifferences The current number of differences being iterated upon.\n     * @param diagonalBaseIndex The base reference diagonal.\n     * @param numDiagonals The total number of diagonals.\n     * @returns The clipped diagonal index.\n     */\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n        if (diagonal >= 0 && diagonal < numDiagonals) {\n            // Nothing to clip, its in range\n            return diagonal;\n        }\n        // diagonalsBelow: The number of diagonals below the reference diagonal\n        // diagonalsAbove: The number of diagonals above the reference diagonal\n        const diagonalsBelow = diagonalBaseIndex;\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n        const diffEven = (numDifferences % 2 === 0);\n        if (diagonal < 0) {\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\n            return (diffEven === lowerBoundEven) ? 0 : 1;\n        }\n        else {\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/process.js\n/* provided dependency */ var process_process = __webpack_require__(606);\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nlet safeProcess;\n// Native sandbox environment\nconst vscodeGlobal = globalThis.vscode;\nif (typeof vscodeGlobal !== 'undefined' && typeof vscodeGlobal.process !== 'undefined') {\n    const sandboxProcess = vscodeGlobal.process;\n    safeProcess = {\n        get platform() { return sandboxProcess.platform; },\n        get arch() { return sandboxProcess.arch; },\n        get env() { return sandboxProcess.env; },\n        cwd() { return sandboxProcess.cwd(); }\n    };\n}\n// Native node.js environment\nelse if (typeof process_process !== 'undefined') {\n    safeProcess = {\n        get platform() { return process_process.platform; },\n        get arch() { return process_process.arch; },\n        get env() { return process_process.env; },\n        cwd() { return process_process.env['VSCODE_CWD'] || process_process.cwd(); }\n    };\n}\n// Web environment\nelse {\n    safeProcess = {\n        // Supported\n        get platform() { return isWindows ? 'win32' : isMacintosh ? 'darwin' : 'linux'; },\n        get arch() { return undefined; /* arch is undefined in web */ },\n        // Unsupported\n        get env() { return {}; },\n        cwd() { return '/'; }\n    };\n}\n/**\n * Provides safe access to the `cwd` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `/`.\n *\n * @skipMangle\n */\nconst process_cwd = safeProcess.cwd;\n/**\n * Provides safe access to the `env` property in node.js, sandboxed or web\n * environments.\n *\n * Note: in web, this property is hardcoded to be `{}`.\n */\nconst env = safeProcess.env;\n/**\n * Provides safe access to the `platform` property in node.js, sandboxed or web\n * environments.\n */\nconst platform = safeProcess.platform;\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/path.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// NOTE: VSCode's copy of nodejs path library to be usable in common (non-node) namespace\n// Copied from: https://github.com/nodejs/node/blob/v16.14.2/lib/path.js\n/**\n * Copyright Joyent, Inc. and other Node contributors.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to permit\n * persons to whom the Software is furnished to do so, subject to the\n * following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n * USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\nconst CHAR_UPPERCASE_A = 65; /* A */\nconst CHAR_LOWERCASE_A = 97; /* a */\nconst CHAR_UPPERCASE_Z = 90; /* Z */\nconst CHAR_LOWERCASE_Z = 122; /* z */\nconst CHAR_DOT = 46; /* . */\nconst CHAR_FORWARD_SLASH = 47; /* / */\nconst CHAR_BACKWARD_SLASH = 92; /* \\ */\nconst CHAR_COLON = 58; /* : */\nconst CHAR_QUESTION_MARK = 63; /* ? */\nclass ErrorInvalidArgType extends Error {\n    constructor(name, expected, actual) {\n        // determiner: 'must be' or 'must not be'\n        let determiner;\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n            determiner = 'must not be';\n            expected = expected.replace(/^not /, '');\n        }\n        else {\n            determiner = 'must be';\n        }\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n        msg += `. Received type ${typeof actual}`;\n        super(msg);\n        this.code = 'ERR_INVALID_ARG_TYPE';\n    }\n}\nfunction validateObject(pathObject, name) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n        throw new ErrorInvalidArgType(name, 'Object', pathObject);\n    }\n}\nfunction validateString(value, name) {\n    if (typeof value !== 'string') {\n        throw new ErrorInvalidArgType(name, 'string', value);\n    }\n}\nconst platformIsWin32 = (platform === 'win32');\nfunction isPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n    return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n        (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\n// Resolves . and .. elements in a path with directory names\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = 0;\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) {\n            code = path.charCodeAt(i);\n        }\n        else if (isPathSeparator(code)) {\n            break;\n        }\n        else {\n            code = CHAR_FORWARD_SLASH;\n        }\n        if (isPathSeparator(code)) {\n            if (lastSlash === i - 1 || dots === 1) {\n                // NOOP\n            }\n            else if (dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 ||\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(separator);\n                        if (lastSlashIndex === -1) {\n                            res = '';\n                            lastSegmentLength = 0;\n                        }\n                        else {\n                            res = res.slice(0, lastSlashIndex);\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n                        }\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                    else if (res.length !== 0) {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    res += res.length > 0 ? `${separator}..` : '..';\n                    lastSegmentLength = 2;\n                }\n            }\n            else {\n                if (res.length > 0) {\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\n                }\n                else {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === CHAR_DOT && dots !== -1) {\n            ++dots;\n        }\n        else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction path_format(sep, pathObject) {\n    validateObject(pathObject, 'pathObject');\n    const dir = pathObject.dir || pathObject.root;\n    const base = pathObject.base ||\n        `${pathObject.name || ''}${pathObject.ext || ''}`;\n    if (!dir) {\n        return base;\n    }\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\nconst win32 = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedDevice = '';\n        let resolvedTail = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1; i--) {\n            let path;\n            if (i >= 0) {\n                path = pathSegments[i];\n                validateString(path, 'path');\n                // Skip empty entries\n                if (path.length === 0) {\n                    continue;\n                }\n            }\n            else if (resolvedDevice.length === 0) {\n                path = process_cwd();\n            }\n            else {\n                // Windows has the concept of drive-specific current working\n                // directories. If we've resolved a drive letter but not yet an\n                // absolute path, get cwd for that drive, or the process cwd if\n                // the drive cwd is not available. We're sure the device is not\n                // a UNC path at this points, because UNC paths are always absolute.\n                path = env[`=${resolvedDevice}`] || process_cwd();\n                // Verify that a cwd was found and that it actually points\n                // to our drive. If not, default to the drive's root.\n                if (path === undefined ||\n                    (path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n                    path = `${resolvedDevice}\\\\`;\n                }\n            }\n            const len = path.length;\n            let rootEnd = 0;\n            let device = '';\n            let isAbsolute = false;\n            const code = path.charCodeAt(0);\n            // Try to match a root\n            if (len === 1) {\n                if (isPathSeparator(code)) {\n                    // `path` contains just a path separator\n                    rootEnd = 1;\n                    isAbsolute = true;\n                }\n            }\n            else if (isPathSeparator(code)) {\n                // Possible UNC root\n                // If we started with a separator, we know we at least have an\n                // absolute path of some kind (UNC or otherwise)\n                isAbsolute = true;\n                if (isPathSeparator(path.charCodeAt(1))) {\n                    // Matched double path separator at beginning\n                    let j = 2;\n                    let last = j;\n                    // Match 1 or more non-path separators\n                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        const firstPart = path.slice(last, j);\n                        // Matched!\n                        last = j;\n                        // Match 1 or more path separators\n                        while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j < len && j !== last) {\n                            // Matched!\n                            last = j;\n                            // Match 1 or more non-path separators\n                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                                j++;\n                            }\n                            if (j === len || j !== last) {\n                                // We matched a UNC root\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                                rootEnd = j;\n                            }\n                        }\n                    }\n                }\n                else {\n                    rootEnd = 1;\n                }\n            }\n            else if (isWindowsDeviceRoot(code) &&\n                path.charCodeAt(1) === CHAR_COLON) {\n                // Possible device root\n                device = path.slice(0, 2);\n                rootEnd = 2;\n                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n                    // Treat separator following drive name as an absolute path\n                    // indicator\n                    isAbsolute = true;\n                    rootEnd = 3;\n                }\n            }\n            if (device.length > 0) {\n                if (resolvedDevice.length > 0) {\n                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n                        // This path points to another device so it is not applicable\n                        continue;\n                    }\n                }\n                else {\n                    resolvedDevice = device;\n                }\n            }\n            if (resolvedAbsolute) {\n                if (resolvedDevice.length > 0) {\n                    break;\n                }\n            }\n            else {\n                resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n                resolvedAbsolute = isAbsolute;\n                if (isAbsolute && resolvedDevice.length > 0) {\n                    break;\n                }\n            }\n        }\n        // At this point the path should be resolved to a full absolute path,\n        // but handle relative paths to be safe (might happen when process.cwd()\n        // fails)\n        // Normalize the tail path\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n        return resolvedAbsolute ?\n            `${resolvedDevice}\\\\${resolvedTail}` :\n            `${resolvedDevice}${resolvedTail}` || '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return '.';\n        }\n        let rootEnd = 0;\n        let device;\n        let isAbsolute = false;\n        const code = path.charCodeAt(0);\n        // Try to match a root\n        if (len === 1) {\n            // `path` contains just a single char, exit early to avoid\n            // unnecessary work\n            return isPosixPathSeparator(code) ? '\\\\' : path;\n        }\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            // If we started with a separator, we know we at least have an absolute\n            // path of some kind (UNC or otherwise)\n            isAbsolute = true;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    const firstPart = path.slice(last, j);\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            // Return the normalized version of the UNC root since there\n                            // is nothing left to process\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n                        }\n                        if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                            rootEnd = j;\n                        }\n                    }\n                }\n            }\n            else {\n                rootEnd = 1;\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            // Possible device root\n            device = path.slice(0, 2);\n            rootEnd = 2;\n            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n                // Treat separator following drive name as an absolute path\n                // indicator\n                isAbsolute = true;\n                rootEnd = 3;\n            }\n        }\n        let tail = rootEnd < len ?\n            normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n            '';\n        if (tail.length === 0 && !isAbsolute) {\n            tail = '.';\n        }\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n            tail += '\\\\';\n        }\n        if (device === undefined) {\n            return isAbsolute ? `\\\\${tail}` : tail;\n        }\n        return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return false;\n        }\n        const code = path.charCodeAt(0);\n        return isPathSeparator(code) ||\n            // Possible device root\n            (len > 2 &&\n                isWindowsDeviceRoot(code) &&\n                path.charCodeAt(1) === CHAR_COLON &&\n                isPathSeparator(path.charCodeAt(2)));\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        let firstPart;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = firstPart = arg;\n                }\n                else {\n                    joined += `\\\\${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        // Make sure that the joined path doesn't start with two slashes, because\n        // normalize() will mistake it for a UNC path then.\n        //\n        // This step is skipped when it is very clear that the user actually\n        // intended to point at a UNC path. This is assumed when the first\n        // non-empty string arguments starts with exactly two slashes followed by\n        // at least one more non-slash character.\n        //\n        // Note that for normalize() to treat a path as a UNC path it needs to\n        // have at least 2 components, so we don't filter for that here.\n        // This means that the user can use join to construct UNC paths from\n        // a server name and a share name; for example:\n        //   path.join('//server', 'share') -> '\\\\\\\\server\\\\share\\\\')\n        let needsReplace = true;\n        let slashCount = 0;\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n            ++slashCount;\n            const firstLen = firstPart.length;\n            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n                ++slashCount;\n                if (firstLen > 2) {\n                    if (isPathSeparator(firstPart.charCodeAt(2))) {\n                        ++slashCount;\n                    }\n                    else {\n                        // We matched a UNC path in the first part\n                        needsReplace = false;\n                    }\n                }\n            }\n        }\n        if (needsReplace) {\n            // Find any more consecutive slashes we need to replace\n            while (slashCount < joined.length &&\n                isPathSeparator(joined.charCodeAt(slashCount))) {\n                slashCount++;\n            }\n            // Replace the slashes if needed\n            if (slashCount >= 2) {\n                joined = `\\\\${joined.slice(slashCount)}`;\n            }\n        }\n        return win32.normalize(joined);\n    },\n    // It will solve the relative path from `from` to `to`, for instance:\n    //  from = 'C:\\\\orandea\\\\test\\\\aaa'\n    //  to = 'C:\\\\orandea\\\\impl\\\\bbb'\n    // The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        const fromOrig = win32.resolve(from);\n        const toOrig = win32.resolve(to);\n        if (fromOrig === toOrig) {\n            return '';\n        }\n        from = fromOrig.toLowerCase();\n        to = toOrig.toLowerCase();\n        if (from === to) {\n            return '';\n        }\n        // Trim any leading backslashes\n        let fromStart = 0;\n        while (fromStart < from.length &&\n            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n            fromStart++;\n        }\n        // Trim trailing backslashes (applicable to UNC paths only)\n        let fromEnd = from.length;\n        while (fromEnd - 1 > fromStart &&\n            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n            fromEnd--;\n        }\n        const fromLen = fromEnd - fromStart;\n        // Trim any leading backslashes\n        let toStart = 0;\n        while (toStart < to.length &&\n            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n            toStart++;\n        }\n        // Trim trailing backslashes (applicable to UNC paths only)\n        let toEnd = to.length;\n        while (toEnd - 1 > toStart &&\n            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n            toEnd--;\n        }\n        const toLen = toEnd - toStart;\n        // Compare paths to find the longest common path from root\n        const length = fromLen < toLen ? fromLen : toLen;\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        // We found a mismatch before the first common path separator was seen, so\n        // return the original `to`.\n        if (i !== length) {\n            if (lastCommonSep === -1) {\n                return toOrig;\n            }\n        }\n        else {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\n                    return toOrig.slice(toStart + i + 1);\n                }\n                if (i === 2) {\n                    // We get here if `from` is the device root.\n                    // For example: from='C:\\\\'; to='C:\\\\foo'\n                    return toOrig.slice(toStart + i);\n                }\n            }\n            if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\n                    lastCommonSep = i;\n                }\n                else if (i === 2) {\n                    // We get here if `to` is the device root.\n                    // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\n                    lastCommonSep = 3;\n                }\n            }\n            if (lastCommonSep === -1) {\n                lastCommonSep = 0;\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to` and\n        // `from`\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n                out += out.length === 0 ? '..' : '\\\\..';\n            }\n        }\n        toStart += lastCommonSep;\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts\n        if (out.length > 0) {\n            return `${out}${toOrig.slice(toStart, toEnd)}`;\n        }\n        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n            ++toStart;\n        }\n        return toOrig.slice(toStart, toEnd);\n    },\n    toNamespacedPath(path) {\n        // Note: this will *probably* throw somewhere.\n        if (typeof path !== 'string' || path.length === 0) {\n            return path;\n        }\n        const resolvedPath = win32.resolve(path);\n        if (resolvedPath.length <= 2) {\n            return path;\n        }\n        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n            // Possible UNC root\n            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n                const code = resolvedPath.charCodeAt(2);\n                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n                    // Matched non-long UNC root, convert the path to a long UNC path\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n            resolvedPath.charCodeAt(1) === CHAR_COLON &&\n            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n            // Matched device root, convert the path to a long UNC path\n            return `\\\\\\\\?\\\\${resolvedPath}`;\n        }\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return '.';\n        }\n        let rootEnd = -1;\n        let offset = 0;\n        const code = path.charCodeAt(0);\n        if (len === 1) {\n            // `path` contains just a path separator, exit early to avoid\n            // unnecessary work or a dot.\n            return isPathSeparator(code) ? path : '.';\n        }\n        // Try to match a root\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            rootEnd = offset = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            return path;\n                        }\n                        if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            // Offset by 1 to include the separator after the UNC root to\n                            // treat it as a \"normal root\" on top of a (UNC) root\n                            rootEnd = offset = j + 1;\n                        }\n                    }\n                }\n            }\n            // Possible device root\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n            offset = rootEnd;\n        }\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = len - 1; i >= offset; --i) {\n            if (isPathSeparator(path.charCodeAt(i))) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            if (rootEnd === -1) {\n                return '.';\n            }\n            end = rootEnd;\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        // Check for a drive letter prefix so as not to mistake the following\n        // path separator as an extra separator at the end of the path that can be\n        // disregarded\n        if (path.length >= 2 &&\n            isWindowsDeviceRoot(path.charCodeAt(0)) &&\n            path.charCodeAt(1) === CHAR_COLON) {\n            start = 2;\n        }\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= start; --i) {\n                const code = path.charCodeAt(i);\n                if (isPathSeparator(code)) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= start; --i) {\n            if (isPathSeparator(path.charCodeAt(i))) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let start = 0;\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Check for a drive letter prefix so as not to mistake the following\n        // path separator as an extra separator at the end of the path that can be\n        // disregarded\n        if (path.length >= 2 &&\n            path.charCodeAt(1) === CHAR_COLON &&\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\n            start = startPart = 2;\n        }\n        for (let i = path.length - 1; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (isPathSeparator(code)) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: path_format.bind(null, '\\\\'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const len = path.length;\n        let rootEnd = 0;\n        let code = path.charCodeAt(0);\n        if (len === 1) {\n            if (isPathSeparator(code)) {\n                // `path` contains just a path separator, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n            }\n            ret.base = ret.name = path;\n            return ret;\n        }\n        // Try to match a root\n        if (isPathSeparator(code)) {\n            // Possible UNC root\n            rootEnd = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                // Matched double path separator at beginning\n                let j = 2;\n                let last = j;\n                // Match 1 or more non-path separators\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    // Matched!\n                    last = j;\n                    // Match 1 or more path separators\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        // Matched!\n                        last = j;\n                        // Match 1 or more non-path separators\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            // We matched a UNC root only\n                            rootEnd = j;\n                        }\n                        else if (j !== last) {\n                            // We matched a UNC root with leftovers\n                            rootEnd = j + 1;\n                        }\n                    }\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            // Possible device root\n            if (len <= 2) {\n                // `path` contains just a drive root, exit early to avoid\n                // unnecessary work\n                ret.root = ret.dir = path;\n                return ret;\n            }\n            rootEnd = 2;\n            if (isPathSeparator(path.charCodeAt(2))) {\n                if (len === 3) {\n                    // `path` contains just a drive root, exit early to avoid\n                    // unnecessary work\n                    ret.root = ret.dir = path;\n                    return ret;\n                }\n                rootEnd = 3;\n            }\n        }\n        if (rootEnd > 0) {\n            ret.root = path.slice(0, rootEnd);\n        }\n        let startDot = -1;\n        let startPart = rootEnd;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= rootEnd; --i) {\n            code = path.charCodeAt(i);\n            if (isPathSeparator(code)) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 &&\n                    startDot === end - 1 &&\n                    startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(startPart, end);\n            }\n            else {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        // If the directory is the root, use the entire root as the `dir` including\n        // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise, strip out the\n        // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\n        if (startPart > 0 && startPart !== rootEnd) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else {\n            ret.dir = ret.root;\n        }\n        return ret;\n    },\n    sep: '\\\\',\n    delimiter: ';',\n    win32: null,\n    posix: null\n};\nconst posixCwd = (() => {\n    if (platformIsWin32) {\n        // Converts Windows' backslash path separators to POSIX forward slashes\n        // and truncates any drive indicator\n        const regexp = /\\\\/g;\n        return () => {\n            const cwd = process_cwd().replace(regexp, '/');\n            return cwd.slice(cwd.indexOf('/'));\n        };\n    }\n    // We're already on POSIX, no need for any transformations\n    return () => process_cwd();\n})();\nconst posix = {\n    // path.resolve([from ...], to)\n    resolve(...pathSegments) {\n        let resolvedPath = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            const path = i >= 0 ? pathSegments[i] : posixCwd();\n            validateString(path, 'path');\n            // Skip empty entries\n            if (path.length === 0) {\n                continue;\n            }\n            resolvedPath = `${path}/${resolvedPath}`;\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        // Normalize the path\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n        if (resolvedAbsolute) {\n            return `/${resolvedPath}`;\n        }\n        return resolvedPath.length > 0 ? resolvedPath : '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n        // Normalize the path\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n        if (path.length === 0) {\n            if (isAbsolute) {\n                return '/';\n            }\n            return trailingSeparator ? './' : '.';\n        }\n        if (trailingSeparator) {\n            path += '/';\n        }\n        return isAbsolute ? `/${path}` : path;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = arg;\n                }\n                else {\n                    joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        return posix.normalize(joined);\n    },\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        // Trim leading forward slashes.\n        from = posix.resolve(from);\n        to = posix.resolve(to);\n        if (from === to) {\n            return '';\n        }\n        const fromStart = 1;\n        const fromEnd = from.length;\n        const fromLen = fromEnd - fromStart;\n        const toStart = 1;\n        const toLen = to.length - toStart;\n        // Compare paths to find the longest common path from root\n        const length = (fromLen < toLen ? fromLen : toLen);\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_FORWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        if (i === length) {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `from` is the exact base path for `to`.\n                    // For example: from='/foo/bar'; to='/foo/bar/baz'\n                    return to.slice(toStart + i + 1);\n                }\n                if (i === 0) {\n                    // We get here if `from` is the root\n                    // For example: from='/'; to='/foo'\n                    return to.slice(toStart + i);\n                }\n            }\n            else if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n                    // We get here if `to` is the exact base path for `from`.\n                    // For example: from='/foo/bar/baz'; to='/foo/bar'\n                    lastCommonSep = i;\n                }\n                else if (i === 0) {\n                    // We get here if `to` is the root.\n                    // For example: from='/foo/bar'; to='/'\n                    lastCommonSep = 0;\n                }\n            }\n        }\n        let out = '';\n        // Generate the relative path based on the path difference between `to`\n        // and `from`.\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                out += out.length === 0 ? '..' : '/..';\n            }\n        }\n        // Lastly, append the rest of the destination (`to`) path that comes after\n        // the common path parts.\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\n    },\n    toNamespacedPath(path) {\n        // Non-op on posix systems\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = path.length - 1; i >= 1; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                // We saw the first non-path separator\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            return hasRoot ? '/' : '.';\n        }\n        if (hasRoot && end === 1) {\n            return '//';\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= 0; --i) {\n                const code = path.charCodeAt(i);\n                if (code === CHAR_FORWARD_SLASH) {\n                    // If we reached a path separator that was not part of a set of path\n                    // separators at the end of the string, stop now\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        // We saw the first non-path separator, remember this index in case\n                        // we need it if the extension ends up not matching\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        // Try to match the explicit extension\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                // We matched the extension, so mark this as the end of our path\n                                // component\n                                end = i;\n                            }\n                        }\n                        else {\n                            // Extension does not match, so our result is the entire path\n                            // component\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // path component\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        for (let i = path.length - 1; i >= 0; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            // We saw a non-dot character immediately before the dot\n            preDotState === 0 ||\n            // The (right-most) trimmed path component is exactly '..'\n            (preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: path_format.bind(null, '/'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let start;\n        if (isAbsolute) {\n            ret.root = '/';\n            start = 1;\n        }\n        else {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        // Track the state of characters (if any) we see before our first dot and\n        // after any path separator we find\n        let preDotState = 0;\n        // Get non-dir info\n        for (; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                // If we reached a path separator that was not part of a set of path\n                // separators at the end of the string, stop now\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                // We saw the first non-path separator, mark this as the end of our\n                // extension\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                // If this is our first dot, mark it as the start of our extension\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                // We saw a non-dot and non-path separator before our dot, so we should\n                // have a good chance at having a non-empty extension\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\n            if (startDot === -1 ||\n                // We saw a non-dot character immediately before the dot\n                preDotState === 0 ||\n                // The (right-most) trimmed path component is exactly '..'\n                (preDotState === 1 &&\n                    startDot === end - 1 &&\n                    startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(start, end);\n            }\n            else {\n                ret.name = path.slice(start, startDot);\n                ret.base = path.slice(start, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        if (startPart > 0) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else if (isAbsolute) {\n            ret.dir = '/';\n        }\n        return ret;\n    },\n    sep: '/',\n    delimiter: ':',\n    win32: null,\n    posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nconst normalize = (platformIsWin32 ? win32.normalize : posix.normalize);\nconst resolve = (platformIsWin32 ? win32.resolve : posix.resolve);\nconst relative = (platformIsWin32 ? win32.relative : posix.relative);\nconst dirname = (platformIsWin32 ? win32.dirname : posix.dirname);\nconst basename = (platformIsWin32 ? win32.basename : posix.basename);\nconst extname = (platformIsWin32 ? win32.extname : posix.extname);\nconst sep = (platformIsWin32 ? win32.sep : posix.sep);\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/uri.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\nfunction _validateUri(ret, _strict) {\n    // scheme, must be set\n    if (!ret.scheme && _strict) {\n        throw new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n    }\n    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n    // ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    if (ret.scheme && !_schemePattern.test(ret.scheme)) {\n        throw new Error('[UriError]: Scheme contains illegal characters.');\n    }\n    // path, http://tools.ietf.org/html/rfc3986#section-3.3\n    // If a URI contains an authority component, then the path component\n    // must either be empty or begin with a slash (\"/\") character.  If a URI\n    // does not contain an authority component, then the path cannot begin\n    // with two slash characters (\"//\").\n    if (ret.path) {\n        if (ret.authority) {\n            if (!_singleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n            }\n        }\n        else {\n            if (_doubleSlashStart.test(ret.path)) {\n                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n            }\n        }\n    }\n}\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme, _strict) {\n    if (!scheme && !_strict) {\n        return 'file';\n    }\n    return scheme;\n}\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme, path) {\n    // the slash-character is our 'default base' as we don't\n    // support constructing URIs relative to other URIs. This\n    // also means that we alter and potentially break paths.\n    // see https://tools.ietf.org/html/rfc3986#section-5.1.4\n    switch (scheme) {\n        case 'https':\n        case 'http':\n        case 'file':\n            if (!path) {\n                path = _slash;\n            }\n            else if (path[0] !== _slash) {\n                path = _slash + path;\n            }\n            break;\n    }\n    return path;\n}\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nclass uri_URI {\n    static isUri(thing) {\n        if (thing instanceof uri_URI) {\n            return true;\n        }\n        if (!thing) {\n            return false;\n        }\n        return typeof thing.authority === 'string'\n            && typeof thing.fragment === 'string'\n            && typeof thing.path === 'string'\n            && typeof thing.query === 'string'\n            && typeof thing.scheme === 'string'\n            && typeof thing.fsPath === 'string'\n            && typeof thing.with === 'function'\n            && typeof thing.toString === 'function';\n    }\n    /**\n     * @internal\n     */\n    constructor(schemeOrData, authority, path, query, fragment, _strict = false) {\n        if (typeof schemeOrData === 'object') {\n            this.scheme = schemeOrData.scheme || _empty;\n            this.authority = schemeOrData.authority || _empty;\n            this.path = schemeOrData.path || _empty;\n            this.query = schemeOrData.query || _empty;\n            this.fragment = schemeOrData.fragment || _empty;\n            // no validation because it's this URI\n            // that creates uri components.\n            // _validateUri(this);\n        }\n        else {\n            this.scheme = _schemeFix(schemeOrData, _strict);\n            this.authority = authority || _empty;\n            this.path = _referenceResolution(this.scheme, path || _empty);\n            this.query = query || _empty;\n            this.fragment = fragment || _empty;\n            _validateUri(this, _strict);\n        }\n    }\n    // ---- filesystem path -----------------------\n    /**\n     * Returns a string representing the corresponding file system path of this URI.\n     * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n     * platform specific path separator.\n     *\n     * * Will *not* validate the path for invalid characters and semantics.\n     * * Will *not* look at the scheme of this URI.\n     * * The result shall *not* be used for display purposes but for accessing a file on disk.\n     *\n     *\n     * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n     * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n     *\n     * ```ts\n        const u = URI.parse('file://server/c$/folder/file.txt')\n        u.authority === 'server'\n        u.path === '/shares/c$/file.txt'\n        u.fsPath === '\\\\server\\c$\\folder\\file.txt'\n    ```\n     *\n     * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n     * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n     * with URIs that represent files on disk (`file` scheme).\n     */\n    get fsPath() {\n        // if (this.scheme !== 'file') {\n        // \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n        // }\n        return uriToFsPath(this, false);\n    }\n    // ---- modify to new -------------------------\n    with(change) {\n        if (!change) {\n            return this;\n        }\n        let { scheme, authority, path, query, fragment } = change;\n        if (scheme === undefined) {\n            scheme = this.scheme;\n        }\n        else if (scheme === null) {\n            scheme = _empty;\n        }\n        if (authority === undefined) {\n            authority = this.authority;\n        }\n        else if (authority === null) {\n            authority = _empty;\n        }\n        if (path === undefined) {\n            path = this.path;\n        }\n        else if (path === null) {\n            path = _empty;\n        }\n        if (query === undefined) {\n            query = this.query;\n        }\n        else if (query === null) {\n            query = _empty;\n        }\n        if (fragment === undefined) {\n            fragment = this.fragment;\n        }\n        else if (fragment === null) {\n            fragment = _empty;\n        }\n        if (scheme === this.scheme\n            && authority === this.authority\n            && path === this.path\n            && query === this.query\n            && fragment === this.fragment) {\n            return this;\n        }\n        return new Uri(scheme, authority, path, query, fragment);\n    }\n    // ---- parse & validate ------------------------\n    /**\n     * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n     * `file:///usr/home`, or `scheme:with/path`.\n     *\n     * @param value A string which represents an URI (see `URI#toString`).\n     */\n    static parse(value, _strict = false) {\n        const match = _regexp.exec(value);\n        if (!match) {\n            return new Uri(_empty, _empty, _empty, _empty, _empty);\n        }\n        return new Uri(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);\n    }\n    /**\n     * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n     * `/usr/home`, or `\\\\server\\share\\some\\path`.\n     *\n     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n     * `URI.parse('file://' + path)` because the path might contain characters that are\n     * interpreted (# and ?). See the following sample:\n     * ```ts\n    const good = URI.file('/coding/c#/project1');\n    good.scheme === 'file';\n    good.path === '/coding/c#/project1';\n    good.fragment === '';\n    const bad = URI.parse('file://' + '/coding/c#/project1');\n    bad.scheme === 'file';\n    bad.path === '/coding/c'; // path is now broken\n    bad.fragment === '/project1';\n    ```\n     *\n     * @param path A file system path (see `URI#fsPath`)\n     */\n    static file(path) {\n        let authority = _empty;\n        // normalize to fwd-slashes on windows,\n        // on other systems bwd-slashes are valid\n        // filename character, eg /f\\oo/ba\\r.txt\n        if (isWindows) {\n            path = path.replace(/\\\\/g, _slash);\n        }\n        // check for authority as used in UNC shares\n        // or use the path as given\n        if (path[0] === _slash && path[1] === _slash) {\n            const idx = path.indexOf(_slash, 2);\n            if (idx === -1) {\n                authority = path.substring(2);\n                path = _slash;\n            }\n            else {\n                authority = path.substring(2, idx);\n                path = path.substring(idx) || _slash;\n            }\n        }\n        return new Uri('file', authority, path, _empty, _empty);\n    }\n    /**\n     * Creates new URI from uri components.\n     *\n     * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs\n     * validation and should be used for untrusted uri components retrieved from storage,\n     * user input, command arguments etc\n     */\n    static from(components, strict) {\n        const result = new Uri(components.scheme, components.authority, components.path, components.query, components.fragment, strict);\n        return result;\n    }\n    /**\n     * Join a URI path with path fragments and normalizes the resulting path.\n     *\n     * @param uri The input URI.\n     * @param pathFragment The path fragment to add to the URI path.\n     * @returns The resulting URI.\n     */\n    static joinPath(uri, ...pathFragment) {\n        if (!uri.path) {\n            throw new Error(`[UriError]: cannot call joinPath on URI without path`);\n        }\n        let newPath;\n        if (isWindows && uri.scheme === 'file') {\n            newPath = uri_URI.file(win32.join(uriToFsPath(uri, true), ...pathFragment)).path;\n        }\n        else {\n            newPath = posix.join(uri.path, ...pathFragment);\n        }\n        return uri.with({ path: newPath });\n    }\n    // ---- printing/externalize ---------------------------\n    /**\n     * Creates a string representation for this URI. It's guaranteed that calling\n     * `URI.parse` with the result of this function creates an URI which is equal\n     * to this URI.\n     *\n     * * The result shall *not* be used for display purposes but for externalization or transport.\n     * * The result will be encoded using the percentage encoding and encoding happens mostly\n     * ignore the scheme-specific encoding rules.\n     *\n     * @param skipEncoding Do not encode the result, default is `false`\n     */\n    toString(skipEncoding = false) {\n        return _asFormatted(this, skipEncoding);\n    }\n    toJSON() {\n        return this;\n    }\n    static revive(data) {\n        var _a, _b;\n        if (!data) {\n            return data;\n        }\n        else if (data instanceof uri_URI) {\n            return data;\n        }\n        else {\n            const result = new Uri(data);\n            result._formatted = (_a = data.external) !== null && _a !== void 0 ? _a : null;\n            result._fsPath = data._sep === _pathSepMarker ? (_b = data.fsPath) !== null && _b !== void 0 ? _b : null : null;\n            return result;\n        }\n    }\n}\nconst _pathSepMarker = isWindows ? 1 : undefined;\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends uri_URI {\n    constructor() {\n        super(...arguments);\n        this._formatted = null;\n        this._fsPath = null;\n    }\n    get fsPath() {\n        if (!this._fsPath) {\n            this._fsPath = uriToFsPath(this, false);\n        }\n        return this._fsPath;\n    }\n    toString(skipEncoding = false) {\n        if (!skipEncoding) {\n            if (!this._formatted) {\n                this._formatted = _asFormatted(this, false);\n            }\n            return this._formatted;\n        }\n        else {\n            // we don't cache that\n            return _asFormatted(this, true);\n        }\n    }\n    toJSON() {\n        const res = {\n            $mid: 1 /* MarshalledId.Uri */\n        };\n        // cached state\n        if (this._fsPath) {\n            res.fsPath = this._fsPath;\n            res._sep = _pathSepMarker;\n        }\n        if (this._formatted) {\n            res.external = this._formatted;\n        }\n        //--- uri components\n        if (this.path) {\n            res.path = this.path;\n        }\n        // TODO\n        // this isn't correct and can violate the UriComponents contract but\n        // this is part of the vscode.Uri API and we shouldn't change how that\n        // works anymore\n        if (this.scheme) {\n            res.scheme = this.scheme;\n        }\n        if (this.authority) {\n            res.authority = this.authority;\n        }\n        if (this.query) {\n            res.query = this.query;\n        }\n        if (this.fragment) {\n            res.fragment = this.fragment;\n        }\n        return res;\n    }\n}\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable = {\n    [58 /* CharCode.Colon */]: '%3A', // gen-delims\n    [47 /* CharCode.Slash */]: '%2F',\n    [63 /* CharCode.QuestionMark */]: '%3F',\n    [35 /* CharCode.Hash */]: '%23',\n    [91 /* CharCode.OpenSquareBracket */]: '%5B',\n    [93 /* CharCode.CloseSquareBracket */]: '%5D',\n    [64 /* CharCode.AtSign */]: '%40',\n    [33 /* CharCode.ExclamationMark */]: '%21', // sub-delims\n    [36 /* CharCode.DollarSign */]: '%24',\n    [38 /* CharCode.Ampersand */]: '%26',\n    [39 /* CharCode.SingleQuote */]: '%27',\n    [40 /* CharCode.OpenParen */]: '%28',\n    [41 /* CharCode.CloseParen */]: '%29',\n    [42 /* CharCode.Asterisk */]: '%2A',\n    [43 /* CharCode.Plus */]: '%2B',\n    [44 /* CharCode.Comma */]: '%2C',\n    [59 /* CharCode.Semicolon */]: '%3B',\n    [61 /* CharCode.Equals */]: '%3D',\n    [32 /* CharCode.Space */]: '%20',\n};\nfunction encodeURIComponentFast(uriComponent, isPath, isAuthority) {\n    let res = undefined;\n    let nativeEncodePos = -1;\n    for (let pos = 0; pos < uriComponent.length; pos++) {\n        const code = uriComponent.charCodeAt(pos);\n        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n        if ((code >= 97 /* CharCode.a */ && code <= 122 /* CharCode.z */)\n            || (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */)\n            || (code >= 48 /* CharCode.Digit0 */ && code <= 57 /* CharCode.Digit9 */)\n            || code === 45 /* CharCode.Dash */\n            || code === 46 /* CharCode.Period */\n            || code === 95 /* CharCode.Underline */\n            || code === 126 /* CharCode.Tilde */\n            || (isPath && code === 47 /* CharCode.Slash */)\n            || (isAuthority && code === 91 /* CharCode.OpenSquareBracket */)\n            || (isAuthority && code === 93 /* CharCode.CloseSquareBracket */)\n            || (isAuthority && code === 58 /* CharCode.Colon */)) {\n            // check if we are delaying native encode\n            if (nativeEncodePos !== -1) {\n                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                nativeEncodePos = -1;\n            }\n            // check if we write into a new string (by default we try to return the param)\n            if (res !== undefined) {\n                res += uriComponent.charAt(pos);\n            }\n        }\n        else {\n            // encoding needed, we need to allocate a new string\n            if (res === undefined) {\n                res = uriComponent.substr(0, pos);\n            }\n            // check with default table first\n            const escaped = encodeTable[code];\n            if (escaped !== undefined) {\n                // check if we are delaying native encode\n                if (nativeEncodePos !== -1) {\n                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n                    nativeEncodePos = -1;\n                }\n                // append escaped variant to result\n                res += escaped;\n            }\n            else if (nativeEncodePos === -1) {\n                // use native encode only when needed\n                nativeEncodePos = pos;\n            }\n        }\n    }\n    if (nativeEncodePos !== -1) {\n        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n    }\n    return res !== undefined ? res : uriComponent;\n}\nfunction encodeURIComponentMinimal(path) {\n    let res = undefined;\n    for (let pos = 0; pos < path.length; pos++) {\n        const code = path.charCodeAt(pos);\n        if (code === 35 /* CharCode.Hash */ || code === 63 /* CharCode.QuestionMark */) {\n            if (res === undefined) {\n                res = path.substr(0, pos);\n            }\n            res += encodeTable[code];\n        }\n        else {\n            if (res !== undefined) {\n                res += path[pos];\n            }\n        }\n    }\n    return res !== undefined ? res : path;\n}\n/**\n * Compute `fsPath` for the given uri\n */\nfunction uriToFsPath(uri, keepDriveLetterCasing) {\n    let value;\n    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n        // unc path: file://shares/c$/far/boo\n        value = `//${uri.authority}${uri.path}`;\n    }\n    else if (uri.path.charCodeAt(0) === 47 /* CharCode.Slash */\n        && (uri.path.charCodeAt(1) >= 65 /* CharCode.A */ && uri.path.charCodeAt(1) <= 90 /* CharCode.Z */ || uri.path.charCodeAt(1) >= 97 /* CharCode.a */ && uri.path.charCodeAt(1) <= 122 /* CharCode.z */)\n        && uri.path.charCodeAt(2) === 58 /* CharCode.Colon */) {\n        if (!keepDriveLetterCasing) {\n            // windows drive letter: file:///c:/far/boo\n            value = uri.path[1].toLowerCase() + uri.path.substr(2);\n        }\n        else {\n            value = uri.path.substr(1);\n        }\n    }\n    else {\n        // other path\n        value = uri.path;\n    }\n    if (isWindows) {\n        value = value.replace(/\\//g, '\\\\');\n    }\n    return value;\n}\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri, skipEncoding) {\n    const encoder = !skipEncoding\n        ? encodeURIComponentFast\n        : encodeURIComponentMinimal;\n    let res = '';\n    let { scheme, authority, path, query, fragment } = uri;\n    if (scheme) {\n        res += scheme;\n        res += ':';\n    }\n    if (authority || scheme === 'file') {\n        res += _slash;\n        res += _slash;\n    }\n    if (authority) {\n        let idx = authority.indexOf('@');\n        if (idx !== -1) {\n            // <user>@<auth>\n            const userinfo = authority.substr(0, idx);\n            authority = authority.substr(idx + 1);\n            idx = userinfo.lastIndexOf(':');\n            if (idx === -1) {\n                res += encoder(userinfo, false, false);\n            }\n            else {\n                // <user>:<pass>@<auth>\n                res += encoder(userinfo.substr(0, idx), false, false);\n                res += ':';\n                res += encoder(userinfo.substr(idx + 1), false, true);\n            }\n            res += '@';\n        }\n        authority = authority.toLowerCase();\n        idx = authority.lastIndexOf(':');\n        if (idx === -1) {\n            res += encoder(authority, false, true);\n        }\n        else {\n            // <auth>:<port>\n            res += encoder(authority.substr(0, idx), false, true);\n            res += authority.substr(idx);\n        }\n    }\n    if (path) {\n        // lower-case windows drive letters in /C:/fff or C:/fff\n        if (path.length >= 3 && path.charCodeAt(0) === 47 /* CharCode.Slash */ && path.charCodeAt(2) === 58 /* CharCode.Colon */) {\n            const code = path.charCodeAt(1);\n            if (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */) {\n                path = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n            }\n        }\n        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* CharCode.Colon */) {\n            const code = path.charCodeAt(0);\n            if (code >= 65 /* CharCode.A */ && code <= 90 /* CharCode.Z */) {\n                path = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n            }\n        }\n        // encode the rest of the path\n        res += encoder(path, true, false);\n    }\n    if (query) {\n        res += '?';\n        res += encoder(query, false, false);\n    }\n    if (fragment) {\n        res += '#';\n        res += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n    }\n    return res;\n}\n// --- decode\nfunction decodeURIComponentGraceful(str) {\n    try {\n        return decodeURIComponent(str);\n    }\n    catch (_a) {\n        if (str.length > 3) {\n            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n        }\n        else {\n            return str;\n        }\n    }\n}\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\nfunction percentDecode(str) {\n    if (!str.match(_rEncodedAsHex)) {\n        return str;\n    }\n    return str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/position.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nclass position_Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new position_Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return position_Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return position_Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return position_Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new position_Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new position_Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n    toJSON() {\n        return {\n            lineNumber: this.lineNumber,\n            column: this.column\n        };\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/range.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nclass range_Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return range_Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return range_Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return range_Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return range_Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return range_Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new range_Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return range_Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        const otherStartLineNumber = b.startLineNumber;\n        const otherStartColumn = b.startColumn;\n        const otherEndLineNumber = b.endLineNumber;\n        const otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new range_Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return range_Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return range_Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new position_Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return range_Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new position_Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new range_Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new range_Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return range_Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new range_Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    collapseToEnd() {\n        return range_Range.collapseToEnd(this);\n    }\n    /**\n     * Create a new empty range using this range's end position.\n     */\n    static collapseToEnd(range) {\n        return new range_Range(range.endLineNumber, range.endColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Moves the range by the given amount of lines.\n     */\n    delta(lineCount) {\n        return new range_Range(this.startLineNumber + lineCount, this.startColumn, this.endLineNumber + lineCount, this.endColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new range_Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new range_Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/arrays.js\n/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nfunction tail(array, n = 0) {\n    return array[array.length - (1 + n)];\n}\nfunction tail2(arr) {\n    if (arr.length === 0) {\n        throw new Error('Invalid tail call');\n    }\n    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\nfunction arrays_equals(one, other, itemEquals = (a, b) => a === b) {\n    if (one === other) {\n        return true;\n    }\n    if (!one || !other) {\n        return false;\n    }\n    if (one.length !== other.length) {\n        return false;\n    }\n    for (let i = 0, len = one.length; i < len; i++) {\n        if (!itemEquals(one[i], other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Remove the element at `index` by replacing it with the last element. This is faster than `splice`\n * but changes the order of the array\n */\nfunction removeFastWithoutKeepingOrder(array, index) {\n    const last = array.length - 1;\n    if (index < last) {\n        array[index] = array[last];\n    }\n    array.pop();\n}\n/**\n * Performs a binary search algorithm over a sorted array.\n *\n * @param array The array being searched.\n * @param key The value we search for.\n * @param comparator A function that takes two array elements and returns zero\n *   if they are equal, a negative number if the first element precedes the\n *   second one in the sorting order, or a positive number if the second element\n *   precedes the first one.\n * @return See {@link binarySearch2}\n */\nfunction binarySearch(array, key, comparator) {\n    return binarySearch2(array.length, i => comparator(array[i], key));\n}\n/**\n * Performs a binary search algorithm over a sorted collection. Useful for cases\n * when we need to perform a binary search over something that isn't actually an\n * array, and converting data to an array would defeat the use of binary search\n * in the first place.\n *\n * @param length The collection length.\n * @param compareToKey A function that takes an index of an element in the\n *   collection and returns zero if the value at this index is equal to the\n *   search key, a negative number if the value precedes the search key in the\n *   sorting order, or a positive number if the search key precedes the value.\n * @return A non-negative index of an element, if found. If not found, the\n *   result is -(n+1) (or ~n, using bitwise notation), where n is the index\n *   where the key should be inserted to maintain the sorting order.\n */\nfunction binarySearch2(length, compareToKey) {\n    let low = 0, high = length - 1;\n    while (low <= high) {\n        const mid = ((low + high) / 2) | 0;\n        const comp = compareToKey(mid);\n        if (comp < 0) {\n            low = mid + 1;\n        }\n        else if (comp > 0) {\n            high = mid - 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -(low + 1);\n}\nfunction quickSelect(nth, data, compare) {\n    nth = nth | 0;\n    if (nth >= data.length) {\n        throw new TypeError('invalid index');\n    }\n    const pivotValue = data[Math.floor(data.length * Math.random())];\n    const lower = [];\n    const higher = [];\n    const pivots = [];\n    for (const value of data) {\n        const val = compare(value, pivotValue);\n        if (val < 0) {\n            lower.push(value);\n        }\n        else if (val > 0) {\n            higher.push(value);\n        }\n        else {\n            pivots.push(value);\n        }\n    }\n    if (nth < lower.length) {\n        return quickSelect(nth, lower, compare);\n    }\n    else if (nth < lower.length + pivots.length) {\n        return pivots[0];\n    }\n    else {\n        return quickSelect(nth - (lower.length + pivots.length), higher, compare);\n    }\n}\nfunction groupBy(data, compare) {\n    const result = [];\n    let currentGroup = undefined;\n    for (const element of data.slice(0).sort(compare)) {\n        if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n            currentGroup = [element];\n            result.push(currentGroup);\n        }\n        else {\n            currentGroup.push(element);\n        }\n    }\n    return result;\n}\n/**\n * Splits the given items into a list of (non-empty) groups.\n * `shouldBeGrouped` is used to decide if two consecutive items should be in the same group.\n * The order of the items is preserved.\n */\nfunction* groupAdjacentBy(items, shouldBeGrouped) {\n    let currentGroup;\n    let last;\n    for (const item of items) {\n        if (last !== undefined && shouldBeGrouped(last, item)) {\n            currentGroup.push(item);\n        }\n        else {\n            if (currentGroup) {\n                yield currentGroup;\n            }\n            currentGroup = [item];\n        }\n        last = item;\n    }\n    if (currentGroup) {\n        yield currentGroup;\n    }\n}\nfunction forEachAdjacent(arr, f) {\n    for (let i = 0; i <= arr.length; i++) {\n        f(i === 0 ? undefined : arr[i - 1], i === arr.length ? undefined : arr[i]);\n    }\n}\nfunction forEachWithNeighbors(arr, f) {\n    for (let i = 0; i < arr.length; i++) {\n        f(i === 0 ? undefined : arr[i - 1], arr[i], i + 1 === arr.length ? undefined : arr[i + 1]);\n    }\n}\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nfunction coalesce(array) {\n    return array.filter((e) => !!e);\n}\n/**\n * Remove all falsy values from `array`. The original array IS modified.\n */\nfunction coalesceInPlace(array) {\n    let to = 0;\n    for (let i = 0; i < array.length; i++) {\n        if (!!array[i]) {\n            array[to] = array[i];\n            to += 1;\n        }\n    }\n    array.length = to;\n}\n/**\n * @returns false if the provided object is an array and not empty.\n */\nfunction isFalsyOrEmpty(obj) {\n    return !Array.isArray(obj) || obj.length === 0;\n}\nfunction isNonEmptyArray(obj) {\n    return Array.isArray(obj) && obj.length > 0;\n}\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nfunction distinct(array, keyFn = value => value) {\n    const seen = new Set();\n    return array.filter(element => {\n        const key = keyFn(element);\n        if (seen.has(key)) {\n            return false;\n        }\n        seen.add(key);\n        return true;\n    });\n}\nfunction firstOrDefault(array, notFoundValue) {\n    return array.length > 0 ? array[0] : notFoundValue;\n}\nfunction range(arg, to) {\n    let from = typeof to === 'number' ? arg : 0;\n    if (typeof to === 'number') {\n        from = arg;\n    }\n    else {\n        from = 0;\n        to = arg;\n    }\n    const result = [];\n    if (from <= to) {\n        for (let i = from; i < to; i++) {\n            result.push(i);\n        }\n    }\n    else {\n        for (let i = from; i > to; i--) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nfunction arrays_arrayInsert(target, insertIndex, insertArr) {\n    const before = target.slice(0, insertIndex);\n    const after = target.slice(insertIndex);\n    return before.concat(insertArr, after);\n}\n/**\n * Pushes an element to the start of the array, if found.\n */\nfunction pushToStart(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.unshift(value);\n    }\n}\n/**\n * Pushes an element to the end of the array, if found.\n */\nfunction pushToEnd(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.push(value);\n    }\n}\nfunction pushMany(arr, items) {\n    for (const item of items) {\n        arr.push(item);\n    }\n}\nfunction asArray(x) {\n    return Array.isArray(x) ? x : [x];\n}\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nfunction insertInto(array, start, newItems) {\n    const startIdx = getActualStartIndex(array, start);\n    const originalLength = array.length;\n    const newItemsLength = newItems.length;\n    array.length = originalLength + newItemsLength;\n    // Move the items after the start index, start from the end so that we don't overwrite any value.\n    for (let i = originalLength - 1; i >= startIdx; i--) {\n        array[i + newItemsLength] = array[i];\n    }\n    for (let i = 0; i < newItemsLength; i++) {\n        array[i + startIdx] = newItems[i];\n    }\n}\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nfunction splice(array, start, deleteCount, newItems) {\n    const index = getActualStartIndex(array, start);\n    let result = array.splice(index, deleteCount);\n    if (result === undefined) {\n        // see https://bugs.webkit.org/show_bug.cgi?id=261140\n        result = [];\n    }\n    insertInto(array, index, newItems);\n    return result;\n}\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex(array, start) {\n    return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\nvar CompareResult;\n(function (CompareResult) {\n    function isLessThan(result) {\n        return result < 0;\n    }\n    CompareResult.isLessThan = isLessThan;\n    function isLessThanOrEqual(result) {\n        return result <= 0;\n    }\n    CompareResult.isLessThanOrEqual = isLessThanOrEqual;\n    function isGreaterThan(result) {\n        return result > 0;\n    }\n    CompareResult.isGreaterThan = isGreaterThan;\n    function isNeitherLessOrGreaterThan(result) {\n        return result === 0;\n    }\n    CompareResult.isNeitherLessOrGreaterThan = isNeitherLessOrGreaterThan;\n    CompareResult.greaterThan = 1;\n    CompareResult.lessThan = -1;\n    CompareResult.neitherLessOrGreaterThan = 0;\n})(CompareResult || (CompareResult = {}));\nfunction compareBy(selector, comparator) {\n    return (a, b) => comparator(selector(a), selector(b));\n}\nfunction tieBreakComparators(...comparators) {\n    return (item1, item2) => {\n        for (const comparator of comparators) {\n            const result = comparator(item1, item2);\n            if (!CompareResult.isNeitherLessOrGreaterThan(result)) {\n                return result;\n            }\n        }\n        return CompareResult.neitherLessOrGreaterThan;\n    };\n}\n/**\n * The natural order on numbers.\n*/\nconst numberComparator = (a, b) => a - b;\nconst booleanComparator = (a, b) => numberComparator(a ? 1 : 0, b ? 1 : 0);\nfunction reverseOrder(comparator) {\n    return (a, b) => -comparator(a, b);\n}\nclass ArrayQueue {\n    /**\n     * Constructs a queue that is backed by the given array. Runtime is O(1).\n    */\n    constructor(items) {\n        this.items = items;\n        this.firstIdx = 0;\n        this.lastIdx = this.items.length - 1;\n    }\n    get length() {\n        return this.lastIdx - this.firstIdx + 1;\n    }\n    /**\n     * Consumes elements from the beginning of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n    */\n    takeWhile(predicate) {\n        // P(k) := k <= this.lastIdx && predicate(this.items[k])\n        // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n        let startIdx = this.firstIdx;\n        while (startIdx < this.items.length && predicate(this.items[startIdx])) {\n            startIdx++;\n        }\n        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n        this.firstIdx = startIdx;\n        return result;\n    }\n    /**\n     * Consumes elements from the end of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned.\n     * The result has the same order as the underlying array!\n    */\n    takeFromEndWhile(predicate) {\n        // P(k) := this.firstIdx >= k && predicate(this.items[k])\n        // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n        let endIdx = this.lastIdx;\n        while (endIdx >= 0 && predicate(this.items[endIdx])) {\n            endIdx--;\n        }\n        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n        this.lastIdx = endIdx;\n        return result;\n    }\n    peek() {\n        if (this.length === 0) {\n            return undefined;\n        }\n        return this.items[this.firstIdx];\n    }\n    dequeue() {\n        const result = this.items[this.firstIdx];\n        this.firstIdx++;\n        return result;\n    }\n    takeCount(count) {\n        const result = this.items.slice(this.firstIdx, this.firstIdx + count);\n        this.firstIdx += count;\n        return result;\n    }\n}\n/**\n * This class is faster than an iterator and array for lazy computed data.\n*/\nclass CallbackIterable {\n    constructor(\n    /**\n     * Calls the callback for every item.\n     * Stops when the callback returns false.\n    */\n    iterate) {\n        this.iterate = iterate;\n    }\n    toArray() {\n        const result = [];\n        this.iterate(item => { result.push(item); return true; });\n        return result;\n    }\n    filter(predicate) {\n        return new CallbackIterable(cb => this.iterate(item => predicate(item) ? cb(item) : true));\n    }\n    map(mapFn) {\n        return new CallbackIterable(cb => this.iterate(item => cb(mapFn(item))));\n    }\n    findLast(predicate) {\n        let result;\n        this.iterate(item => {\n            if (predicate(item)) {\n                result = item;\n            }\n            return true;\n        });\n        return result;\n    }\n    findLastMaxBy(comparator) {\n        let result;\n        let first = true;\n        this.iterate(item => {\n            if (first || CompareResult.isGreaterThan(comparator(item, result))) {\n                first = false;\n                result = item;\n            }\n            return true;\n        });\n        return result;\n    }\n}\nCallbackIterable.empty = new CallbackIterable(_callback => { });\n/**\n * Represents a re-arrangement of items in an array.\n */\nclass Permutation {\n    constructor(_indexMap) {\n        this._indexMap = _indexMap;\n    }\n    /**\n     * Returns a permutation that sorts the given array according to the given compare function.\n     */\n    static createSortPermutation(arr, compareFn) {\n        const sortIndices = Array.from(arr.keys()).sort((index1, index2) => compareFn(arr[index1], arr[index2]));\n        return new Permutation(sortIndices);\n    }\n    /**\n     * Returns a new array with the elements of the given array re-arranged according to this permutation.\n     */\n    apply(arr) {\n        return arr.map((_, index) => arr[this._indexMap[index]]);\n    }\n    /**\n     * Returns a new permutation that undoes the re-arrangement of this permutation.\n    */\n    inverse() {\n        const inverseIndexMap = this._indexMap.slice();\n        for (let i = 0; i < this._indexMap.length; i++) {\n            inverseIndexMap[this._indexMap[i]] = i;\n        }\n        return new Permutation(inverseIndexMap);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/uint.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction toUint8(v) {\n    if (v < 0) {\n        return 0;\n    }\n    if (v > 255 /* Constants.MAX_UINT_8 */) {\n        return 255 /* Constants.MAX_UINT_8 */;\n    }\n    return v | 0;\n}\nfunction toUint32(v) {\n    if (v < 0) {\n        return 0;\n    }\n    if (v > 4294967295 /* Constants.MAX_UINT_32 */) {\n        return 4294967295 /* Constants.MAX_UINT_32 */;\n    }\n    return v | 0;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/model/prefixSumComputer.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nclass PrefixSumComputer {\n    constructor(values) {\n        this.values = values;\n        this.prefixSum = new Uint32Array(values.length);\n        this.prefixSumValidIndex = new Int32Array(1);\n        this.prefixSumValidIndex[0] = -1;\n    }\n    insertValues(insertIndex, insertValues) {\n        insertIndex = toUint32(insertIndex);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        const insertValuesLen = insertValues.length;\n        if (insertValuesLen === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length + insertValuesLen);\n        this.values.set(oldValues.subarray(0, insertIndex), 0);\n        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);\n        this.values.set(insertValues, insertIndex);\n        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = insertIndex - 1;\n        }\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    setValue(index, value) {\n        index = toUint32(index);\n        value = toUint32(value);\n        if (this.values[index] === value) {\n            return false;\n        }\n        this.values[index] = value;\n        if (index - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = index - 1;\n        }\n        return true;\n    }\n    removeValues(startIndex, count) {\n        startIndex = toUint32(startIndex);\n        count = toUint32(count);\n        const oldValues = this.values;\n        const oldPrefixSum = this.prefixSum;\n        if (startIndex >= oldValues.length) {\n            return false;\n        }\n        const maxCount = oldValues.length - startIndex;\n        if (count >= maxCount) {\n            count = maxCount;\n        }\n        if (count === 0) {\n            return false;\n        }\n        this.values = new Uint32Array(oldValues.length - count);\n        this.values.set(oldValues.subarray(0, startIndex), 0);\n        this.values.set(oldValues.subarray(startIndex + count), startIndex);\n        this.prefixSum = new Uint32Array(this.values.length);\n        if (startIndex - 1 < this.prefixSumValidIndex[0]) {\n            this.prefixSumValidIndex[0] = startIndex - 1;\n        }\n        if (this.prefixSumValidIndex[0] >= 0) {\n            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));\n        }\n        return true;\n    }\n    getTotalSum() {\n        if (this.values.length === 0) {\n            return 0;\n        }\n        return this._getPrefixSum(this.values.length - 1);\n    }\n    /**\n     * Returns the sum of the first `index + 1` many items.\n     * @returns `SUM(0 <= j <= index, values[j])`.\n     */\n    getPrefixSum(index) {\n        if (index < 0) {\n            return 0;\n        }\n        index = toUint32(index);\n        return this._getPrefixSum(index);\n    }\n    _getPrefixSum(index) {\n        if (index <= this.prefixSumValidIndex[0]) {\n            return this.prefixSum[index];\n        }\n        let startIndex = this.prefixSumValidIndex[0] + 1;\n        if (startIndex === 0) {\n            this.prefixSum[0] = this.values[0];\n            startIndex++;\n        }\n        if (index >= this.values.length) {\n            index = this.values.length - 1;\n        }\n        for (let i = startIndex; i <= index; i++) {\n            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];\n        }\n        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);\n        return this.prefixSum[index];\n    }\n    getIndexOf(sum) {\n        sum = Math.floor(sum);\n        // Compute all sums (to get a fully valid prefixSum)\n        this.getTotalSum();\n        let low = 0;\n        let high = this.values.length - 1;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStop = this.prefixSum[mid];\n            midStart = midStop - this.values[mid];\n            if (sum < midStart) {\n                high = mid - 1;\n            }\n            else if (sum >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        return new PrefixSumIndexOfResult(mid, sum - midStart);\n    }\n}\n/**\n * {@link getIndexOf} has an amortized runtime complexity of O(1).\n *\n * ({@link PrefixSumComputer.getIndexOf} is just  O(log n))\n*/\nclass ConstantTimePrefixSumComputer {\n    constructor(values) {\n        this._values = values;\n        this._isValid = false;\n        this._validEndIndex = -1;\n        this._prefixSum = [];\n        this._indexBySum = [];\n    }\n    /**\n     * @returns SUM(0 <= j < values.length, values[j])\n     */\n    getTotalSum() {\n        this._ensureValid();\n        return this._indexBySum.length;\n    }\n    /**\n     * Returns the sum of the first `count` many items.\n     * @returns `SUM(0 <= j < count, values[j])`.\n     */\n    getPrefixSum(count) {\n        this._ensureValid();\n        if (count === 0) {\n            return 0;\n        }\n        return this._prefixSum[count - 1];\n    }\n    /**\n     * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`\n     */\n    getIndexOf(sum) {\n        this._ensureValid();\n        const idx = this._indexBySum[sum];\n        const viewLinesAbove = idx > 0 ? this._prefixSum[idx - 1] : 0;\n        return new PrefixSumIndexOfResult(idx, sum - viewLinesAbove);\n    }\n    removeValues(start, deleteCount) {\n        this._values.splice(start, deleteCount);\n        this._invalidate(start);\n    }\n    insertValues(insertIndex, insertArr) {\n        this._values = arrayInsert(this._values, insertIndex, insertArr);\n        this._invalidate(insertIndex);\n    }\n    _invalidate(index) {\n        this._isValid = false;\n        this._validEndIndex = Math.min(this._validEndIndex, index - 1);\n    }\n    _ensureValid() {\n        if (this._isValid) {\n            return;\n        }\n        for (let i = this._validEndIndex + 1, len = this._values.length; i < len; i++) {\n            const value = this._values[i];\n            const sumAbove = i > 0 ? this._prefixSum[i - 1] : 0;\n            this._prefixSum[i] = sumAbove + value;\n            for (let j = 0; j < value; j++) {\n                this._indexBySum[sumAbove + j] = i;\n            }\n        }\n        // trim things\n        this._prefixSum.length = this._values.length;\n        this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1];\n        // mark as valid\n        this._isValid = true;\n        this._validEndIndex = this._values.length - 1;\n    }\n    setValue(index, value) {\n        if (this._values[index] === value) {\n            // no change\n            return;\n        }\n        this._values[index] = value;\n        this._invalidate(index);\n    }\n}\nclass PrefixSumIndexOfResult {\n    constructor(index, remainder) {\n        this.index = index;\n        this.remainder = remainder;\n        this._prefixSumIndexOfResultBrand = undefined;\n        this.index = index;\n        this.remainder = remainder;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nclass MirrorTextModel {\n    constructor(uri, lines, eol, versionId) {\n        this._uri = uri;\n        this._lines = lines;\n        this._eol = eol;\n        this._versionId = versionId;\n        this._lineStarts = null;\n        this._cachedTextValue = null;\n    }\n    dispose() {\n        this._lines.length = 0;\n    }\n    get version() {\n        return this._versionId;\n    }\n    getText() {\n        if (this._cachedTextValue === null) {\n            this._cachedTextValue = this._lines.join(this._eol);\n        }\n        return this._cachedTextValue;\n    }\n    onEvents(e) {\n        if (e.eol && e.eol !== this._eol) {\n            this._eol = e.eol;\n            this._lineStarts = null;\n        }\n        // Update my lines\n        const changes = e.changes;\n        for (const change of changes) {\n            this._acceptDeleteRange(change.range);\n            this._acceptInsertText(new position_Position(change.range.startLineNumber, change.range.startColumn), change.text);\n        }\n        this._versionId = e.versionId;\n        this._cachedTextValue = null;\n    }\n    _ensureLineStarts() {\n        if (!this._lineStarts) {\n            const eolLength = this._eol.length;\n            const linesLength = this._lines.length;\n            const lineStartValues = new Uint32Array(linesLength);\n            for (let i = 0; i < linesLength; i++) {\n                lineStartValues[i] = this._lines[i].length + eolLength;\n            }\n            this._lineStarts = new PrefixSumComputer(lineStartValues);\n        }\n    }\n    /**\n     * All changes to a line's text go through this method\n     */\n    _setLineText(lineIndex, newValue) {\n        this._lines[lineIndex] = newValue;\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.setValue(lineIndex, this._lines[lineIndex].length + this._eol.length);\n        }\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            // Delete text on the affected line\n            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));\n            return;\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)\n            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));\n        // Delete middle lines\n        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n        }\n    }\n    _acceptInsertText(position, insertText) {\n        if (insertText.length === 0) {\n            // Nothing to insert\n            return;\n        }\n        const insertLines = splitLines(insertText);\n        if (insertLines.length === 1) {\n            // Inserting text on one line\n            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n                + insertLines[0]\n                + this._lines[position.lineNumber - 1].substring(position.column - 1));\n            return;\n        }\n        // Append overflowing text from first line to the end of text to insert\n        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);\n        // Delete overflowing text from first line and insert text on first line\n        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)\n            + insertLines[0]);\n        // Insert new lines & store lengths\n        const newLengths = new Uint32Array(insertLines.length - 1);\n        for (let i = 1; i < insertLines.length; i++) {\n            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);\n            newLengths[i - 1] = insertLines[i].length + this._eol.length;\n        }\n        if (this._lineStarts) {\n            // update prefix sum\n            this._lineStarts.insertValues(position.lineNumber, newLengths);\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nconst USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nconst DEFAULT_WORD_REGEXP = createWordRegExp();\nfunction ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = new LinkedList();\n_defaultConfig.unshift({\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n});\nfunction getWordAtText(column, wordDefinition, text, textOffset, config) {\n    // Ensure the regex has the 'g' flag, otherwise this will loop forever\n    wordDefinition = ensureValidWordDefinition(wordDefinition);\n    if (!config) {\n        config = Iterable.first(_defaultConfig);\n    }\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A fast character classifier that uses a compact array for ASCII values.\n */\nclass CharacterClassifier {\n    constructor(_defaultValue) {\n        const defaultValue = toUint8(_defaultValue);\n        this._defaultValue = defaultValue;\n        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);\n        this._map = new Map();\n    }\n    static _createAsciiMap(defaultValue) {\n        const asciiMap = new Uint8Array(256);\n        asciiMap.fill(defaultValue);\n        return asciiMap;\n    }\n    set(charCode, _value) {\n        const value = toUint8(_value);\n        if (charCode >= 0 && charCode < 256) {\n            this._asciiMap[charCode] = value;\n        }\n        else {\n            this._map.set(charCode, value);\n        }\n    }\n    get(charCode) {\n        if (charCode >= 0 && charCode < 256) {\n            return this._asciiMap[charCode];\n        }\n        else {\n            return (this._map.get(charCode) || this._defaultValue);\n        }\n    }\n    clear() {\n        this._asciiMap.fill(this._defaultValue);\n        this._map.clear();\n    }\n}\nclass CharacterSet {\n    constructor() {\n        this._actual = new CharacterClassifier(0 /* Boolean.False */);\n    }\n    add(charCode) {\n        this._actual.set(charCode, 1 /* Boolean.True */);\n    }\n    has(charCode) {\n        return (this._actual.get(charCode) === 1 /* Boolean.True */);\n    }\n    clear() {\n        return this._actual.clear();\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/languages/linkComputer.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nclass Uint8Matrix {\n    constructor(rows, cols, defaultValue) {\n        const data = new Uint8Array(rows * cols);\n        for (let i = 0, len = rows * cols; i < len; i++) {\n            data[i] = defaultValue;\n        }\n        this._data = data;\n        this.rows = rows;\n        this.cols = cols;\n    }\n    get(row, col) {\n        return this._data[row * this.cols + col];\n    }\n    set(row, col, value) {\n        this._data[row * this.cols + col] = value;\n    }\n}\nclass StateMachine {\n    constructor(edges) {\n        let maxCharCode = 0;\n        let maxState = 0 /* State.Invalid */;\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            if (chCode > maxCharCode) {\n                maxCharCode = chCode;\n            }\n            if (from > maxState) {\n                maxState = from;\n            }\n            if (to > maxState) {\n                maxState = to;\n            }\n        }\n        maxCharCode++;\n        maxState++;\n        const states = new Uint8Matrix(maxState, maxCharCode, 0 /* State.Invalid */);\n        for (let i = 0, len = edges.length; i < len; i++) {\n            const [from, chCode, to] = edges[i];\n            states.set(from, chCode, to);\n        }\n        this._states = states;\n        this._maxCharCode = maxCharCode;\n    }\n    nextState(currentState, chCode) {\n        if (chCode < 0 || chCode >= this._maxCharCode) {\n            return 0 /* State.Invalid */;\n        }\n        return this._states.get(currentState, chCode);\n    }\n}\n// State machine for http:// or https:// or file://\nlet _stateMachine = null;\nfunction getStateMachine() {\n    if (_stateMachine === null) {\n        _stateMachine = new StateMachine([\n            [1 /* State.Start */, 104 /* CharCode.h */, 2 /* State.H */],\n            [1 /* State.Start */, 72 /* CharCode.H */, 2 /* State.H */],\n            [1 /* State.Start */, 102 /* CharCode.f */, 6 /* State.F */],\n            [1 /* State.Start */, 70 /* CharCode.F */, 6 /* State.F */],\n            [2 /* State.H */, 116 /* CharCode.t */, 3 /* State.HT */],\n            [2 /* State.H */, 84 /* CharCode.T */, 3 /* State.HT */],\n            [3 /* State.HT */, 116 /* CharCode.t */, 4 /* State.HTT */],\n            [3 /* State.HT */, 84 /* CharCode.T */, 4 /* State.HTT */],\n            [4 /* State.HTT */, 112 /* CharCode.p */, 5 /* State.HTTP */],\n            [4 /* State.HTT */, 80 /* CharCode.P */, 5 /* State.HTTP */],\n            [5 /* State.HTTP */, 115 /* CharCode.s */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 83 /* CharCode.S */, 9 /* State.BeforeColon */],\n            [5 /* State.HTTP */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [6 /* State.F */, 105 /* CharCode.i */, 7 /* State.FI */],\n            [6 /* State.F */, 73 /* CharCode.I */, 7 /* State.FI */],\n            [7 /* State.FI */, 108 /* CharCode.l */, 8 /* State.FIL */],\n            [7 /* State.FI */, 76 /* CharCode.L */, 8 /* State.FIL */],\n            [8 /* State.FIL */, 101 /* CharCode.e */, 9 /* State.BeforeColon */],\n            [8 /* State.FIL */, 69 /* CharCode.E */, 9 /* State.BeforeColon */],\n            [9 /* State.BeforeColon */, 58 /* CharCode.Colon */, 10 /* State.AfterColon */],\n            [10 /* State.AfterColon */, 47 /* CharCode.Slash */, 11 /* State.AlmostThere */],\n            [11 /* State.AlmostThere */, 47 /* CharCode.Slash */, 12 /* State.End */],\n        ]);\n    }\n    return _stateMachine;\n}\nlet _classifier = null;\nfunction getClassifier() {\n    if (_classifier === null) {\n        _classifier = new CharacterClassifier(0 /* CharacterClass.None */);\n        // allow-any-unicode-next-line\n        const FORCE_TERMINATION_CHARACTERS = ' \\t<>\\'\\\"';\n        for (let i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {\n            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* CharacterClass.ForceTermination */);\n        }\n        const CANNOT_END_WITH_CHARACTERS = '.,;:';\n        for (let i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {\n            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CharacterClass.CannotEndIn */);\n        }\n    }\n    return _classifier;\n}\nclass LinkComputer {\n    static _createLink(classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {\n        // Do not allow to end link in certain characters...\n        let lastIncludedCharIndex = linkEndIndex - 1;\n        do {\n            const chCode = line.charCodeAt(lastIncludedCharIndex);\n            const chClass = classifier.get(chCode);\n            if (chClass !== 2 /* CharacterClass.CannotEndIn */) {\n                break;\n            }\n            lastIncludedCharIndex--;\n        } while (lastIncludedCharIndex > linkBeginIndex);\n        // Handle links enclosed in parens, square brackets and curlys.\n        if (linkBeginIndex > 0) {\n            const charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);\n            const lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);\n            if ((charCodeBeforeLink === 40 /* CharCode.OpenParen */ && lastCharCodeInLink === 41 /* CharCode.CloseParen */)\n                || (charCodeBeforeLink === 91 /* CharCode.OpenSquareBracket */ && lastCharCodeInLink === 93 /* CharCode.CloseSquareBracket */)\n                || (charCodeBeforeLink === 123 /* CharCode.OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CharCode.CloseCurlyBrace */)) {\n                // Do not end in ) if ( is before the link start\n                // Do not end in ] if [ is before the link start\n                // Do not end in } if { is before the link start\n                lastIncludedCharIndex--;\n            }\n        }\n        return {\n            range: {\n                startLineNumber: lineNumber,\n                startColumn: linkBeginIndex + 1,\n                endLineNumber: lineNumber,\n                endColumn: lastIncludedCharIndex + 2\n            },\n            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)\n        };\n    }\n    static computeLinks(model, stateMachine = getStateMachine()) {\n        const classifier = getClassifier();\n        const result = [];\n        for (let i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {\n            const line = model.getLineContent(i);\n            const len = line.length;\n            let j = 0;\n            let linkBeginIndex = 0;\n            let linkBeginChCode = 0;\n            let state = 1 /* State.Start */;\n            let hasOpenParens = false;\n            let hasOpenSquareBracket = false;\n            let inSquareBrackets = false;\n            let hasOpenCurlyBracket = false;\n            while (j < len) {\n                let resetStateMachine = false;\n                const chCode = line.charCodeAt(j);\n                if (state === 13 /* State.Accept */) {\n                    let chClass;\n                    switch (chCode) {\n                        case 40 /* CharCode.OpenParen */:\n                            hasOpenParens = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 41 /* CharCode.CloseParen */:\n                            chClass = (hasOpenParens ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 91 /* CharCode.OpenSquareBracket */:\n                            inSquareBrackets = true;\n                            hasOpenSquareBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 93 /* CharCode.CloseSquareBracket */:\n                            inSquareBrackets = false;\n                            chClass = (hasOpenSquareBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        case 123 /* CharCode.OpenCurlyBrace */:\n                            hasOpenCurlyBracket = true;\n                            chClass = 0 /* CharacterClass.None */;\n                            break;\n                        case 125 /* CharCode.CloseCurlyBrace */:\n                            chClass = (hasOpenCurlyBracket ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        // The following three rules make it that ' or \" or ` are allowed inside links\n                        // only if the link is wrapped by some other quote character\n                        case 39 /* CharCode.SingleQuote */:\n                        case 34 /* CharCode.DoubleQuote */:\n                        case 96 /* CharCode.BackTick */:\n                            if (linkBeginChCode === chCode) {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            else if (linkBeginChCode === 39 /* CharCode.SingleQuote */ || linkBeginChCode === 34 /* CharCode.DoubleQuote */ || linkBeginChCode === 96 /* CharCode.BackTick */) {\n                                chClass = 0 /* CharacterClass.None */;\n                            }\n                            else {\n                                chClass = 1 /* CharacterClass.ForceTermination */;\n                            }\n                            break;\n                        case 42 /* CharCode.Asterisk */:\n                            // `*` terminates a link if the link began with `*`\n                            chClass = (linkBeginChCode === 42 /* CharCode.Asterisk */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 124 /* CharCode.Pipe */:\n                            // `|` terminates a link if the link began with `|`\n                            chClass = (linkBeginChCode === 124 /* CharCode.Pipe */) ? 1 /* CharacterClass.ForceTermination */ : 0 /* CharacterClass.None */;\n                            break;\n                        case 32 /* CharCode.Space */:\n                            // ` ` allow space in between [ and ]\n                            chClass = (inSquareBrackets ? 0 /* CharacterClass.None */ : 1 /* CharacterClass.ForceTermination */);\n                            break;\n                        default:\n                            chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));\n                        resetStateMachine = true;\n                    }\n                }\n                else if (state === 12 /* State.End */) {\n                    let chClass;\n                    if (chCode === 91 /* CharCode.OpenSquareBracket */) {\n                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]\n                        hasOpenSquareBracket = true;\n                        chClass = 0 /* CharacterClass.None */;\n                    }\n                    else {\n                        chClass = classifier.get(chCode);\n                    }\n                    // Check if character terminates link\n                    if (chClass === 1 /* CharacterClass.ForceTermination */) {\n                        resetStateMachine = true;\n                    }\n                    else {\n                        state = 13 /* State.Accept */;\n                    }\n                }\n                else {\n                    state = stateMachine.nextState(state, chCode);\n                    if (state === 0 /* State.Invalid */) {\n                        resetStateMachine = true;\n                    }\n                }\n                if (resetStateMachine) {\n                    state = 1 /* State.Start */;\n                    hasOpenParens = false;\n                    hasOpenSquareBracket = false;\n                    hasOpenCurlyBracket = false;\n                    // Record where the link started\n                    linkBeginIndex = j + 1;\n                    linkBeginChCode = chCode;\n                }\n                j++;\n            }\n            if (state === 13 /* State.Accept */) {\n                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));\n            }\n        }\n        return result;\n    }\n}\n/**\n * Returns an array of all links contains in the provided\n * document. *Note* that this operation is computational\n * expensive and should not run in the UI thread.\n */\nfunction computeLinks(model) {\n    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return LinkComputer.computeLinks(model);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/languages/supports/inplaceReplaceSupport.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass BasicInplaceReplace {\n    constructor() {\n        this._defaultValueSet = [\n            ['true', 'false'],\n            ['True', 'False'],\n            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],\n            ['public', 'protected', 'private'],\n        ];\n    }\n    navigateValueSet(range1, text1, range2, text2, up) {\n        if (range1 && text1) {\n            const result = this.doNavigateValueSet(text1, up);\n            if (result) {\n                return {\n                    range: range1,\n                    value: result\n                };\n            }\n        }\n        if (range2 && text2) {\n            const result = this.doNavigateValueSet(text2, up);\n            if (result) {\n                return {\n                    range: range2,\n                    value: result\n                };\n            }\n        }\n        return null;\n    }\n    doNavigateValueSet(text, up) {\n        const numberResult = this.numberReplace(text, up);\n        if (numberResult !== null) {\n            return numberResult;\n        }\n        return this.textReplace(text, up);\n    }\n    numberReplace(value, up) {\n        const precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));\n        let n1 = Number(value);\n        const n2 = parseFloat(value);\n        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {\n            if (n1 === 0 && !up) {\n                return null; // don't do negative\n                //\t\t\t} else if(n1 === 9 && up) {\n                //\t\t\t\treturn null; // don't insert 10 into a number\n            }\n            else {\n                n1 = Math.floor(n1 * precision);\n                n1 += up ? precision : -precision;\n                return String(n1 / precision);\n            }\n        }\n        return null;\n    }\n    textReplace(value, up) {\n        return this.valueSetsReplace(this._defaultValueSet, value, up);\n    }\n    valueSetsReplace(valueSets, value, up) {\n        let result = null;\n        for (let i = 0, len = valueSets.length; result === null && i < len; i++) {\n            result = this.valueSetReplace(valueSets[i], value, up);\n        }\n        return result;\n    }\n    valueSetReplace(valueSet, value, up) {\n        let idx = valueSet.indexOf(value);\n        if (idx >= 0) {\n            idx += up ? +1 : -1;\n            if (idx < 0) {\n                idx = valueSet.length - 1;\n            }\n            else {\n                idx %= valueSet.length;\n            }\n            return valueSet[idx];\n        }\n        return null;\n    }\n}\nBasicInplaceReplace.INSTANCE = new BasicInplaceReplace();\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/cancellation.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nconst shortcutEvent = Object.freeze(function (callback, context) {\n    const handle = setTimeout(callback.bind(context), 0);\n    return { dispose() { clearTimeout(handle); } };\n});\nvar CancellationToken;\n(function (CancellationToken) {\n    function isCancellationToken(thing) {\n        if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {\n            return true;\n        }\n        if (thing instanceof MutableToken) {\n            return true;\n        }\n        if (!thing || typeof thing !== 'object') {\n            return false;\n        }\n        return typeof thing.isCancellationRequested === 'boolean'\n            && typeof thing.onCancellationRequested === 'function';\n    }\n    CancellationToken.isCancellationToken = isCancellationToken;\n    CancellationToken.None = Object.freeze({\n        isCancellationRequested: false,\n        onCancellationRequested: Event.None\n    });\n    CancellationToken.Cancelled = Object.freeze({\n        isCancellationRequested: true,\n        onCancellationRequested: shortcutEvent\n    });\n})(CancellationToken || (CancellationToken = {}));\nclass MutableToken {\n    constructor() {\n        this._isCancelled = false;\n        this._emitter = null;\n    }\n    cancel() {\n        if (!this._isCancelled) {\n            this._isCancelled = true;\n            if (this._emitter) {\n                this._emitter.fire(undefined);\n                this.dispose();\n            }\n        }\n    }\n    get isCancellationRequested() {\n        return this._isCancelled;\n    }\n    get onCancellationRequested() {\n        if (this._isCancelled) {\n            return shortcutEvent;\n        }\n        if (!this._emitter) {\n            this._emitter = new Emitter();\n        }\n        return this._emitter.event;\n    }\n    dispose() {\n        if (this._emitter) {\n            this._emitter.dispose();\n            this._emitter = null;\n        }\n    }\n}\nclass CancellationTokenSource {\n    constructor(parent) {\n        this._token = undefined;\n        this._parentListener = undefined;\n        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);\n    }\n    get token() {\n        if (!this._token) {\n            // be lazy and create the token only when\n            // actually needed\n            this._token = new MutableToken();\n        }\n        return this._token;\n    }\n    cancel() {\n        if (!this._token) {\n            // save an object by returning the default\n            // cancelled token when cancellation happens\n            // before someone asks for the token\n            this._token = CancellationToken.Cancelled;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually cancel\n            this._token.cancel();\n        }\n    }\n    dispose(cancel = false) {\n        var _a;\n        if (cancel) {\n            this.cancel();\n        }\n        (_a = this._parentListener) === null || _a === void 0 ? void 0 : _a.dispose();\n        if (!this._token) {\n            // ensure to initialize with an empty token if we had none\n            this._token = CancellationToken.None;\n        }\n        else if (this._token instanceof MutableToken) {\n            // actually dispose\n            this._token.dispose();\n        }\n    }\n}\nfunction cancelOnDispose(store) {\n    const source = new CancellationTokenSource();\n    store.add({ dispose() { source.cancel(); } });\n    return source.token;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/keyCodes.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass KeyCodeStrMap {\n    constructor() {\n        this._keyCodeToStr = [];\n        this._strToKeyCode = Object.create(null);\n    }\n    define(keyCode, str) {\n        this._keyCodeToStr[keyCode] = str;\n        this._strToKeyCode[str.toLowerCase()] = keyCode;\n    }\n    keyCodeToStr(keyCode) {\n        return this._keyCodeToStr[keyCode];\n    }\n    strToKeyCode(str) {\n        return this._strToKeyCode[str.toLowerCase()] || 0 /* KeyCode.Unknown */;\n    }\n}\nconst uiMap = new KeyCodeStrMap();\nconst userSettingsUSMap = new KeyCodeStrMap();\nconst userSettingsGeneralMap = new KeyCodeStrMap();\nconst EVENT_KEY_CODE_MAP = new Array(230);\nconst NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE = {};\nconst scanCodeIntToStr = [];\nconst scanCodeStrToInt = Object.create(null);\nconst scanCodeLowerCaseStrToInt = Object.create(null);\n/**\n * -1 if a ScanCode => KeyCode mapping depends on kb layout.\n */\nconst IMMUTABLE_CODE_TO_KEY_CODE = [];\n/**\n * -1 if a KeyCode => ScanCode mapping depends on kb layout.\n */\nconst IMMUTABLE_KEY_CODE_TO_CODE = [];\nfor (let i = 0; i <= 193 /* ScanCode.MAX_VALUE */; i++) {\n    IMMUTABLE_CODE_TO_KEY_CODE[i] = -1 /* KeyCode.DependsOnKbLayout */;\n}\nfor (let i = 0; i <= 132 /* KeyCode.MAX_VALUE */; i++) {\n    IMMUTABLE_KEY_CODE_TO_CODE[i] = -1 /* ScanCode.DependsOnKbLayout */;\n}\n(function () {\n    // See https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n    // See https://github.com/microsoft/node-native-keymap/blob/88c0b0e5/deps/chromium/keyboard_codes_win.h\n    const empty = '';\n    const mappings = [\n        // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel\n        [1, 0 /* ScanCode.None */, 'None', 0 /* KeyCode.Unknown */, 'unknown', 0, 'VK_UNKNOWN', empty, empty],\n        [1, 1 /* ScanCode.Hyper */, 'Hyper', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 2 /* ScanCode.Super */, 'Super', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 3 /* ScanCode.Fn */, 'Fn', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 4 /* ScanCode.FnLock */, 'FnLock', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 5 /* ScanCode.Suspend */, 'Suspend', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 6 /* ScanCode.Resume */, 'Resume', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 7 /* ScanCode.Turbo */, 'Turbo', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 8 /* ScanCode.Sleep */, 'Sleep', 0 /* KeyCode.Unknown */, empty, 0, 'VK_SLEEP', empty, empty],\n        [1, 9 /* ScanCode.WakeUp */, 'WakeUp', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [0, 10 /* ScanCode.KeyA */, 'KeyA', 31 /* KeyCode.KeyA */, 'A', 65, 'VK_A', empty, empty],\n        [0, 11 /* ScanCode.KeyB */, 'KeyB', 32 /* KeyCode.KeyB */, 'B', 66, 'VK_B', empty, empty],\n        [0, 12 /* ScanCode.KeyC */, 'KeyC', 33 /* KeyCode.KeyC */, 'C', 67, 'VK_C', empty, empty],\n        [0, 13 /* ScanCode.KeyD */, 'KeyD', 34 /* KeyCode.KeyD */, 'D', 68, 'VK_D', empty, empty],\n        [0, 14 /* ScanCode.KeyE */, 'KeyE', 35 /* KeyCode.KeyE */, 'E', 69, 'VK_E', empty, empty],\n        [0, 15 /* ScanCode.KeyF */, 'KeyF', 36 /* KeyCode.KeyF */, 'F', 70, 'VK_F', empty, empty],\n        [0, 16 /* ScanCode.KeyG */, 'KeyG', 37 /* KeyCode.KeyG */, 'G', 71, 'VK_G', empty, empty],\n        [0, 17 /* ScanCode.KeyH */, 'KeyH', 38 /* KeyCode.KeyH */, 'H', 72, 'VK_H', empty, empty],\n        [0, 18 /* ScanCode.KeyI */, 'KeyI', 39 /* KeyCode.KeyI */, 'I', 73, 'VK_I', empty, empty],\n        [0, 19 /* ScanCode.KeyJ */, 'KeyJ', 40 /* KeyCode.KeyJ */, 'J', 74, 'VK_J', empty, empty],\n        [0, 20 /* ScanCode.KeyK */, 'KeyK', 41 /* KeyCode.KeyK */, 'K', 75, 'VK_K', empty, empty],\n        [0, 21 /* ScanCode.KeyL */, 'KeyL', 42 /* KeyCode.KeyL */, 'L', 76, 'VK_L', empty, empty],\n        [0, 22 /* ScanCode.KeyM */, 'KeyM', 43 /* KeyCode.KeyM */, 'M', 77, 'VK_M', empty, empty],\n        [0, 23 /* ScanCode.KeyN */, 'KeyN', 44 /* KeyCode.KeyN */, 'N', 78, 'VK_N', empty, empty],\n        [0, 24 /* ScanCode.KeyO */, 'KeyO', 45 /* KeyCode.KeyO */, 'O', 79, 'VK_O', empty, empty],\n        [0, 25 /* ScanCode.KeyP */, 'KeyP', 46 /* KeyCode.KeyP */, 'P', 80, 'VK_P', empty, empty],\n        [0, 26 /* ScanCode.KeyQ */, 'KeyQ', 47 /* KeyCode.KeyQ */, 'Q', 81, 'VK_Q', empty, empty],\n        [0, 27 /* ScanCode.KeyR */, 'KeyR', 48 /* KeyCode.KeyR */, 'R', 82, 'VK_R', empty, empty],\n        [0, 28 /* ScanCode.KeyS */, 'KeyS', 49 /* KeyCode.KeyS */, 'S', 83, 'VK_S', empty, empty],\n        [0, 29 /* ScanCode.KeyT */, 'KeyT', 50 /* KeyCode.KeyT */, 'T', 84, 'VK_T', empty, empty],\n        [0, 30 /* ScanCode.KeyU */, 'KeyU', 51 /* KeyCode.KeyU */, 'U', 85, 'VK_U', empty, empty],\n        [0, 31 /* ScanCode.KeyV */, 'KeyV', 52 /* KeyCode.KeyV */, 'V', 86, 'VK_V', empty, empty],\n        [0, 32 /* ScanCode.KeyW */, 'KeyW', 53 /* KeyCode.KeyW */, 'W', 87, 'VK_W', empty, empty],\n        [0, 33 /* ScanCode.KeyX */, 'KeyX', 54 /* KeyCode.KeyX */, 'X', 88, 'VK_X', empty, empty],\n        [0, 34 /* ScanCode.KeyY */, 'KeyY', 55 /* KeyCode.KeyY */, 'Y', 89, 'VK_Y', empty, empty],\n        [0, 35 /* ScanCode.KeyZ */, 'KeyZ', 56 /* KeyCode.KeyZ */, 'Z', 90, 'VK_Z', empty, empty],\n        [0, 36 /* ScanCode.Digit1 */, 'Digit1', 22 /* KeyCode.Digit1 */, '1', 49, 'VK_1', empty, empty],\n        [0, 37 /* ScanCode.Digit2 */, 'Digit2', 23 /* KeyCode.Digit2 */, '2', 50, 'VK_2', empty, empty],\n        [0, 38 /* ScanCode.Digit3 */, 'Digit3', 24 /* KeyCode.Digit3 */, '3', 51, 'VK_3', empty, empty],\n        [0, 39 /* ScanCode.Digit4 */, 'Digit4', 25 /* KeyCode.Digit4 */, '4', 52, 'VK_4', empty, empty],\n        [0, 40 /* ScanCode.Digit5 */, 'Digit5', 26 /* KeyCode.Digit5 */, '5', 53, 'VK_5', empty, empty],\n        [0, 41 /* ScanCode.Digit6 */, 'Digit6', 27 /* KeyCode.Digit6 */, '6', 54, 'VK_6', empty, empty],\n        [0, 42 /* ScanCode.Digit7 */, 'Digit7', 28 /* KeyCode.Digit7 */, '7', 55, 'VK_7', empty, empty],\n        [0, 43 /* ScanCode.Digit8 */, 'Digit8', 29 /* KeyCode.Digit8 */, '8', 56, 'VK_8', empty, empty],\n        [0, 44 /* ScanCode.Digit9 */, 'Digit9', 30 /* KeyCode.Digit9 */, '9', 57, 'VK_9', empty, empty],\n        [0, 45 /* ScanCode.Digit0 */, 'Digit0', 21 /* KeyCode.Digit0 */, '0', 48, 'VK_0', empty, empty],\n        [1, 46 /* ScanCode.Enter */, 'Enter', 3 /* KeyCode.Enter */, 'Enter', 13, 'VK_RETURN', empty, empty],\n        [1, 47 /* ScanCode.Escape */, 'Escape', 9 /* KeyCode.Escape */, 'Escape', 27, 'VK_ESCAPE', empty, empty],\n        [1, 48 /* ScanCode.Backspace */, 'Backspace', 1 /* KeyCode.Backspace */, 'Backspace', 8, 'VK_BACK', empty, empty],\n        [1, 49 /* ScanCode.Tab */, 'Tab', 2 /* KeyCode.Tab */, 'Tab', 9, 'VK_TAB', empty, empty],\n        [1, 50 /* ScanCode.Space */, 'Space', 10 /* KeyCode.Space */, 'Space', 32, 'VK_SPACE', empty, empty],\n        [0, 51 /* ScanCode.Minus */, 'Minus', 88 /* KeyCode.Minus */, '-', 189, 'VK_OEM_MINUS', '-', 'OEM_MINUS'],\n        [0, 52 /* ScanCode.Equal */, 'Equal', 86 /* KeyCode.Equal */, '=', 187, 'VK_OEM_PLUS', '=', 'OEM_PLUS'],\n        [0, 53 /* ScanCode.BracketLeft */, 'BracketLeft', 92 /* KeyCode.BracketLeft */, '[', 219, 'VK_OEM_4', '[', 'OEM_4'],\n        [0, 54 /* ScanCode.BracketRight */, 'BracketRight', 94 /* KeyCode.BracketRight */, ']', 221, 'VK_OEM_6', ']', 'OEM_6'],\n        [0, 55 /* ScanCode.Backslash */, 'Backslash', 93 /* KeyCode.Backslash */, '\\\\', 220, 'VK_OEM_5', '\\\\', 'OEM_5'],\n        [0, 56 /* ScanCode.IntlHash */, 'IntlHash', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty], // has been dropped from the w3c spec\n        [0, 57 /* ScanCode.Semicolon */, 'Semicolon', 85 /* KeyCode.Semicolon */, ';', 186, 'VK_OEM_1', ';', 'OEM_1'],\n        [0, 58 /* ScanCode.Quote */, 'Quote', 95 /* KeyCode.Quote */, '\\'', 222, 'VK_OEM_7', '\\'', 'OEM_7'],\n        [0, 59 /* ScanCode.Backquote */, 'Backquote', 91 /* KeyCode.Backquote */, '`', 192, 'VK_OEM_3', '`', 'OEM_3'],\n        [0, 60 /* ScanCode.Comma */, 'Comma', 87 /* KeyCode.Comma */, ',', 188, 'VK_OEM_COMMA', ',', 'OEM_COMMA'],\n        [0, 61 /* ScanCode.Period */, 'Period', 89 /* KeyCode.Period */, '.', 190, 'VK_OEM_PERIOD', '.', 'OEM_PERIOD'],\n        [0, 62 /* ScanCode.Slash */, 'Slash', 90 /* KeyCode.Slash */, '/', 191, 'VK_OEM_2', '/', 'OEM_2'],\n        [1, 63 /* ScanCode.CapsLock */, 'CapsLock', 8 /* KeyCode.CapsLock */, 'CapsLock', 20, 'VK_CAPITAL', empty, empty],\n        [1, 64 /* ScanCode.F1 */, 'F1', 59 /* KeyCode.F1 */, 'F1', 112, 'VK_F1', empty, empty],\n        [1, 65 /* ScanCode.F2 */, 'F2', 60 /* KeyCode.F2 */, 'F2', 113, 'VK_F2', empty, empty],\n        [1, 66 /* ScanCode.F3 */, 'F3', 61 /* KeyCode.F3 */, 'F3', 114, 'VK_F3', empty, empty],\n        [1, 67 /* ScanCode.F4 */, 'F4', 62 /* KeyCode.F4 */, 'F4', 115, 'VK_F4', empty, empty],\n        [1, 68 /* ScanCode.F5 */, 'F5', 63 /* KeyCode.F5 */, 'F5', 116, 'VK_F5', empty, empty],\n        [1, 69 /* ScanCode.F6 */, 'F6', 64 /* KeyCode.F6 */, 'F6', 117, 'VK_F6', empty, empty],\n        [1, 70 /* ScanCode.F7 */, 'F7', 65 /* KeyCode.F7 */, 'F7', 118, 'VK_F7', empty, empty],\n        [1, 71 /* ScanCode.F8 */, 'F8', 66 /* KeyCode.F8 */, 'F8', 119, 'VK_F8', empty, empty],\n        [1, 72 /* ScanCode.F9 */, 'F9', 67 /* KeyCode.F9 */, 'F9', 120, 'VK_F9', empty, empty],\n        [1, 73 /* ScanCode.F10 */, 'F10', 68 /* KeyCode.F10 */, 'F10', 121, 'VK_F10', empty, empty],\n        [1, 74 /* ScanCode.F11 */, 'F11', 69 /* KeyCode.F11 */, 'F11', 122, 'VK_F11', empty, empty],\n        [1, 75 /* ScanCode.F12 */, 'F12', 70 /* KeyCode.F12 */, 'F12', 123, 'VK_F12', empty, empty],\n        [1, 76 /* ScanCode.PrintScreen */, 'PrintScreen', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 77 /* ScanCode.ScrollLock */, 'ScrollLock', 84 /* KeyCode.ScrollLock */, 'ScrollLock', 145, 'VK_SCROLL', empty, empty],\n        [1, 78 /* ScanCode.Pause */, 'Pause', 7 /* KeyCode.PauseBreak */, 'PauseBreak', 19, 'VK_PAUSE', empty, empty],\n        [1, 79 /* ScanCode.Insert */, 'Insert', 19 /* KeyCode.Insert */, 'Insert', 45, 'VK_INSERT', empty, empty],\n        [1, 80 /* ScanCode.Home */, 'Home', 14 /* KeyCode.Home */, 'Home', 36, 'VK_HOME', empty, empty],\n        [1, 81 /* ScanCode.PageUp */, 'PageUp', 11 /* KeyCode.PageUp */, 'PageUp', 33, 'VK_PRIOR', empty, empty],\n        [1, 82 /* ScanCode.Delete */, 'Delete', 20 /* KeyCode.Delete */, 'Delete', 46, 'VK_DELETE', empty, empty],\n        [1, 83 /* ScanCode.End */, 'End', 13 /* KeyCode.End */, 'End', 35, 'VK_END', empty, empty],\n        [1, 84 /* ScanCode.PageDown */, 'PageDown', 12 /* KeyCode.PageDown */, 'PageDown', 34, 'VK_NEXT', empty, empty],\n        [1, 85 /* ScanCode.ArrowRight */, 'ArrowRight', 17 /* KeyCode.RightArrow */, 'RightArrow', 39, 'VK_RIGHT', 'Right', empty],\n        [1, 86 /* ScanCode.ArrowLeft */, 'ArrowLeft', 15 /* KeyCode.LeftArrow */, 'LeftArrow', 37, 'VK_LEFT', 'Left', empty],\n        [1, 87 /* ScanCode.ArrowDown */, 'ArrowDown', 18 /* KeyCode.DownArrow */, 'DownArrow', 40, 'VK_DOWN', 'Down', empty],\n        [1, 88 /* ScanCode.ArrowUp */, 'ArrowUp', 16 /* KeyCode.UpArrow */, 'UpArrow', 38, 'VK_UP', 'Up', empty],\n        [1, 89 /* ScanCode.NumLock */, 'NumLock', 83 /* KeyCode.NumLock */, 'NumLock', 144, 'VK_NUMLOCK', empty, empty],\n        [1, 90 /* ScanCode.NumpadDivide */, 'NumpadDivide', 113 /* KeyCode.NumpadDivide */, 'NumPad_Divide', 111, 'VK_DIVIDE', empty, empty],\n        [1, 91 /* ScanCode.NumpadMultiply */, 'NumpadMultiply', 108 /* KeyCode.NumpadMultiply */, 'NumPad_Multiply', 106, 'VK_MULTIPLY', empty, empty],\n        [1, 92 /* ScanCode.NumpadSubtract */, 'NumpadSubtract', 111 /* KeyCode.NumpadSubtract */, 'NumPad_Subtract', 109, 'VK_SUBTRACT', empty, empty],\n        [1, 93 /* ScanCode.NumpadAdd */, 'NumpadAdd', 109 /* KeyCode.NumpadAdd */, 'NumPad_Add', 107, 'VK_ADD', empty, empty],\n        [1, 94 /* ScanCode.NumpadEnter */, 'NumpadEnter', 3 /* KeyCode.Enter */, empty, 0, empty, empty, empty],\n        [1, 95 /* ScanCode.Numpad1 */, 'Numpad1', 99 /* KeyCode.Numpad1 */, 'NumPad1', 97, 'VK_NUMPAD1', empty, empty],\n        [1, 96 /* ScanCode.Numpad2 */, 'Numpad2', 100 /* KeyCode.Numpad2 */, 'NumPad2', 98, 'VK_NUMPAD2', empty, empty],\n        [1, 97 /* ScanCode.Numpad3 */, 'Numpad3', 101 /* KeyCode.Numpad3 */, 'NumPad3', 99, 'VK_NUMPAD3', empty, empty],\n        [1, 98 /* ScanCode.Numpad4 */, 'Numpad4', 102 /* KeyCode.Numpad4 */, 'NumPad4', 100, 'VK_NUMPAD4', empty, empty],\n        [1, 99 /* ScanCode.Numpad5 */, 'Numpad5', 103 /* KeyCode.Numpad5 */, 'NumPad5', 101, 'VK_NUMPAD5', empty, empty],\n        [1, 100 /* ScanCode.Numpad6 */, 'Numpad6', 104 /* KeyCode.Numpad6 */, 'NumPad6', 102, 'VK_NUMPAD6', empty, empty],\n        [1, 101 /* ScanCode.Numpad7 */, 'Numpad7', 105 /* KeyCode.Numpad7 */, 'NumPad7', 103, 'VK_NUMPAD7', empty, empty],\n        [1, 102 /* ScanCode.Numpad8 */, 'Numpad8', 106 /* KeyCode.Numpad8 */, 'NumPad8', 104, 'VK_NUMPAD8', empty, empty],\n        [1, 103 /* ScanCode.Numpad9 */, 'Numpad9', 107 /* KeyCode.Numpad9 */, 'NumPad9', 105, 'VK_NUMPAD9', empty, empty],\n        [1, 104 /* ScanCode.Numpad0 */, 'Numpad0', 98 /* KeyCode.Numpad0 */, 'NumPad0', 96, 'VK_NUMPAD0', empty, empty],\n        [1, 105 /* ScanCode.NumpadDecimal */, 'NumpadDecimal', 112 /* KeyCode.NumpadDecimal */, 'NumPad_Decimal', 110, 'VK_DECIMAL', empty, empty],\n        [0, 106 /* ScanCode.IntlBackslash */, 'IntlBackslash', 97 /* KeyCode.IntlBackslash */, 'OEM_102', 226, 'VK_OEM_102', empty, empty],\n        [1, 107 /* ScanCode.ContextMenu */, 'ContextMenu', 58 /* KeyCode.ContextMenu */, 'ContextMenu', 93, empty, empty, empty],\n        [1, 108 /* ScanCode.Power */, 'Power', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 109 /* ScanCode.NumpadEqual */, 'NumpadEqual', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 110 /* ScanCode.F13 */, 'F13', 71 /* KeyCode.F13 */, 'F13', 124, 'VK_F13', empty, empty],\n        [1, 111 /* ScanCode.F14 */, 'F14', 72 /* KeyCode.F14 */, 'F14', 125, 'VK_F14', empty, empty],\n        [1, 112 /* ScanCode.F15 */, 'F15', 73 /* KeyCode.F15 */, 'F15', 126, 'VK_F15', empty, empty],\n        [1, 113 /* ScanCode.F16 */, 'F16', 74 /* KeyCode.F16 */, 'F16', 127, 'VK_F16', empty, empty],\n        [1, 114 /* ScanCode.F17 */, 'F17', 75 /* KeyCode.F17 */, 'F17', 128, 'VK_F17', empty, empty],\n        [1, 115 /* ScanCode.F18 */, 'F18', 76 /* KeyCode.F18 */, 'F18', 129, 'VK_F18', empty, empty],\n        [1, 116 /* ScanCode.F19 */, 'F19', 77 /* KeyCode.F19 */, 'F19', 130, 'VK_F19', empty, empty],\n        [1, 117 /* ScanCode.F20 */, 'F20', 78 /* KeyCode.F20 */, 'F20', 131, 'VK_F20', empty, empty],\n        [1, 118 /* ScanCode.F21 */, 'F21', 79 /* KeyCode.F21 */, 'F21', 132, 'VK_F21', empty, empty],\n        [1, 119 /* ScanCode.F22 */, 'F22', 80 /* KeyCode.F22 */, 'F22', 133, 'VK_F22', empty, empty],\n        [1, 120 /* ScanCode.F23 */, 'F23', 81 /* KeyCode.F23 */, 'F23', 134, 'VK_F23', empty, empty],\n        [1, 121 /* ScanCode.F24 */, 'F24', 82 /* KeyCode.F24 */, 'F24', 135, 'VK_F24', empty, empty],\n        [1, 122 /* ScanCode.Open */, 'Open', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 123 /* ScanCode.Help */, 'Help', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 124 /* ScanCode.Select */, 'Select', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 125 /* ScanCode.Again */, 'Again', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 126 /* ScanCode.Undo */, 'Undo', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 127 /* ScanCode.Cut */, 'Cut', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 128 /* ScanCode.Copy */, 'Copy', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 129 /* ScanCode.Paste */, 'Paste', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 130 /* ScanCode.Find */, 'Find', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 131 /* ScanCode.AudioVolumeMute */, 'AudioVolumeMute', 117 /* KeyCode.AudioVolumeMute */, 'AudioVolumeMute', 173, 'VK_VOLUME_MUTE', empty, empty],\n        [1, 132 /* ScanCode.AudioVolumeUp */, 'AudioVolumeUp', 118 /* KeyCode.AudioVolumeUp */, 'AudioVolumeUp', 175, 'VK_VOLUME_UP', empty, empty],\n        [1, 133 /* ScanCode.AudioVolumeDown */, 'AudioVolumeDown', 119 /* KeyCode.AudioVolumeDown */, 'AudioVolumeDown', 174, 'VK_VOLUME_DOWN', empty, empty],\n        [1, 134 /* ScanCode.NumpadComma */, 'NumpadComma', 110 /* KeyCode.NUMPAD_SEPARATOR */, 'NumPad_Separator', 108, 'VK_SEPARATOR', empty, empty],\n        [0, 135 /* ScanCode.IntlRo */, 'IntlRo', 115 /* KeyCode.ABNT_C1 */, 'ABNT_C1', 193, 'VK_ABNT_C1', empty, empty],\n        [1, 136 /* ScanCode.KanaMode */, 'KanaMode', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [0, 137 /* ScanCode.IntlYen */, 'IntlYen', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 138 /* ScanCode.Convert */, 'Convert', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 139 /* ScanCode.NonConvert */, 'NonConvert', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 140 /* ScanCode.Lang1 */, 'Lang1', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 141 /* ScanCode.Lang2 */, 'Lang2', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 142 /* ScanCode.Lang3 */, 'Lang3', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 143 /* ScanCode.Lang4 */, 'Lang4', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 144 /* ScanCode.Lang5 */, 'Lang5', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 145 /* ScanCode.Abort */, 'Abort', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 146 /* ScanCode.Props */, 'Props', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 147 /* ScanCode.NumpadParenLeft */, 'NumpadParenLeft', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 148 /* ScanCode.NumpadParenRight */, 'NumpadParenRight', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 149 /* ScanCode.NumpadBackspace */, 'NumpadBackspace', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 150 /* ScanCode.NumpadMemoryStore */, 'NumpadMemoryStore', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 151 /* ScanCode.NumpadMemoryRecall */, 'NumpadMemoryRecall', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 152 /* ScanCode.NumpadMemoryClear */, 'NumpadMemoryClear', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 153 /* ScanCode.NumpadMemoryAdd */, 'NumpadMemoryAdd', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 154 /* ScanCode.NumpadMemorySubtract */, 'NumpadMemorySubtract', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 155 /* ScanCode.NumpadClear */, 'NumpadClear', 131 /* KeyCode.Clear */, 'Clear', 12, 'VK_CLEAR', empty, empty],\n        [1, 156 /* ScanCode.NumpadClearEntry */, 'NumpadClearEntry', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 5 /* KeyCode.Ctrl */, 'Ctrl', 17, 'VK_CONTROL', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 4 /* KeyCode.Shift */, 'Shift', 16, 'VK_SHIFT', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 6 /* KeyCode.Alt */, 'Alt', 18, 'VK_MENU', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 57 /* KeyCode.Meta */, 'Meta', 91, 'VK_COMMAND', empty, empty],\n        [1, 157 /* ScanCode.ControlLeft */, 'ControlLeft', 5 /* KeyCode.Ctrl */, empty, 0, 'VK_LCONTROL', empty, empty],\n        [1, 158 /* ScanCode.ShiftLeft */, 'ShiftLeft', 4 /* KeyCode.Shift */, empty, 0, 'VK_LSHIFT', empty, empty],\n        [1, 159 /* ScanCode.AltLeft */, 'AltLeft', 6 /* KeyCode.Alt */, empty, 0, 'VK_LMENU', empty, empty],\n        [1, 160 /* ScanCode.MetaLeft */, 'MetaLeft', 57 /* KeyCode.Meta */, empty, 0, 'VK_LWIN', empty, empty],\n        [1, 161 /* ScanCode.ControlRight */, 'ControlRight', 5 /* KeyCode.Ctrl */, empty, 0, 'VK_RCONTROL', empty, empty],\n        [1, 162 /* ScanCode.ShiftRight */, 'ShiftRight', 4 /* KeyCode.Shift */, empty, 0, 'VK_RSHIFT', empty, empty],\n        [1, 163 /* ScanCode.AltRight */, 'AltRight', 6 /* KeyCode.Alt */, empty, 0, 'VK_RMENU', empty, empty],\n        [1, 164 /* ScanCode.MetaRight */, 'MetaRight', 57 /* KeyCode.Meta */, empty, 0, 'VK_RWIN', empty, empty],\n        [1, 165 /* ScanCode.BrightnessUp */, 'BrightnessUp', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 166 /* ScanCode.BrightnessDown */, 'BrightnessDown', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 167 /* ScanCode.MediaPlay */, 'MediaPlay', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 168 /* ScanCode.MediaRecord */, 'MediaRecord', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 169 /* ScanCode.MediaFastForward */, 'MediaFastForward', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 170 /* ScanCode.MediaRewind */, 'MediaRewind', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 171 /* ScanCode.MediaTrackNext */, 'MediaTrackNext', 124 /* KeyCode.MediaTrackNext */, 'MediaTrackNext', 176, 'VK_MEDIA_NEXT_TRACK', empty, empty],\n        [1, 172 /* ScanCode.MediaTrackPrevious */, 'MediaTrackPrevious', 125 /* KeyCode.MediaTrackPrevious */, 'MediaTrackPrevious', 177, 'VK_MEDIA_PREV_TRACK', empty, empty],\n        [1, 173 /* ScanCode.MediaStop */, 'MediaStop', 126 /* KeyCode.MediaStop */, 'MediaStop', 178, 'VK_MEDIA_STOP', empty, empty],\n        [1, 174 /* ScanCode.Eject */, 'Eject', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 175 /* ScanCode.MediaPlayPause */, 'MediaPlayPause', 127 /* KeyCode.MediaPlayPause */, 'MediaPlayPause', 179, 'VK_MEDIA_PLAY_PAUSE', empty, empty],\n        [1, 176 /* ScanCode.MediaSelect */, 'MediaSelect', 128 /* KeyCode.LaunchMediaPlayer */, 'LaunchMediaPlayer', 181, 'VK_MEDIA_LAUNCH_MEDIA_SELECT', empty, empty],\n        [1, 177 /* ScanCode.LaunchMail */, 'LaunchMail', 129 /* KeyCode.LaunchMail */, 'LaunchMail', 180, 'VK_MEDIA_LAUNCH_MAIL', empty, empty],\n        [1, 178 /* ScanCode.LaunchApp2 */, 'LaunchApp2', 130 /* KeyCode.LaunchApp2 */, 'LaunchApp2', 183, 'VK_MEDIA_LAUNCH_APP2', empty, empty],\n        [1, 179 /* ScanCode.LaunchApp1 */, 'LaunchApp1', 0 /* KeyCode.Unknown */, empty, 0, 'VK_MEDIA_LAUNCH_APP1', empty, empty],\n        [1, 180 /* ScanCode.SelectTask */, 'SelectTask', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 181 /* ScanCode.LaunchScreenSaver */, 'LaunchScreenSaver', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 182 /* ScanCode.BrowserSearch */, 'BrowserSearch', 120 /* KeyCode.BrowserSearch */, 'BrowserSearch', 170, 'VK_BROWSER_SEARCH', empty, empty],\n        [1, 183 /* ScanCode.BrowserHome */, 'BrowserHome', 121 /* KeyCode.BrowserHome */, 'BrowserHome', 172, 'VK_BROWSER_HOME', empty, empty],\n        [1, 184 /* ScanCode.BrowserBack */, 'BrowserBack', 122 /* KeyCode.BrowserBack */, 'BrowserBack', 166, 'VK_BROWSER_BACK', empty, empty],\n        [1, 185 /* ScanCode.BrowserForward */, 'BrowserForward', 123 /* KeyCode.BrowserForward */, 'BrowserForward', 167, 'VK_BROWSER_FORWARD', empty, empty],\n        [1, 186 /* ScanCode.BrowserStop */, 'BrowserStop', 0 /* KeyCode.Unknown */, empty, 0, 'VK_BROWSER_STOP', empty, empty],\n        [1, 187 /* ScanCode.BrowserRefresh */, 'BrowserRefresh', 0 /* KeyCode.Unknown */, empty, 0, 'VK_BROWSER_REFRESH', empty, empty],\n        [1, 188 /* ScanCode.BrowserFavorites */, 'BrowserFavorites', 0 /* KeyCode.Unknown */, empty, 0, 'VK_BROWSER_FAVORITES', empty, empty],\n        [1, 189 /* ScanCode.ZoomToggle */, 'ZoomToggle', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 190 /* ScanCode.MailReply */, 'MailReply', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 191 /* ScanCode.MailForward */, 'MailForward', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        [1, 192 /* ScanCode.MailSend */, 'MailSend', 0 /* KeyCode.Unknown */, empty, 0, empty, empty, empty],\n        // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n        // If an Input Method Editor is processing key input and the event is keydown, return 229.\n        [1, 0 /* ScanCode.None */, empty, 114 /* KeyCode.KEY_IN_COMPOSITION */, 'KeyInComposition', 229, empty, empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 116 /* KeyCode.ABNT_C2 */, 'ABNT_C2', 194, 'VK_ABNT_C2', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 96 /* KeyCode.OEM_8 */, 'OEM_8', 223, 'VK_OEM_8', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_KANA', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_HANGUL', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_JUNJA', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_FINAL', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_HANJA', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_KANJI', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_CONVERT', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_NONCONVERT', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_ACCEPT', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_MODECHANGE', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_SELECT', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PRINT', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_EXECUTE', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_SNAPSHOT', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_HELP', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_APPS', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PROCESSKEY', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PACKET', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_DBE_SBCSCHAR', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_DBE_DBCSCHAR', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_ATTN', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_CRSEL', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_EXSEL', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_EREOF', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PLAY', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_ZOOM', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_NONAME', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_PA1', empty, empty],\n        [1, 0 /* ScanCode.None */, empty, 0 /* KeyCode.Unknown */, empty, 0, 'VK_OEM_CLEAR', empty, empty],\n    ];\n    const seenKeyCode = [];\n    const seenScanCode = [];\n    for (const mapping of mappings) {\n        const [immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel] = mapping;\n        if (!seenScanCode[scanCode]) {\n            seenScanCode[scanCode] = true;\n            scanCodeIntToStr[scanCode] = scanCodeStr;\n            scanCodeStrToInt[scanCodeStr] = scanCode;\n            scanCodeLowerCaseStrToInt[scanCodeStr.toLowerCase()] = scanCode;\n            if (immutable) {\n                IMMUTABLE_CODE_TO_KEY_CODE[scanCode] = keyCode;\n                if ((keyCode !== 0 /* KeyCode.Unknown */)\n                    && (keyCode !== 3 /* KeyCode.Enter */)\n                    && (keyCode !== 5 /* KeyCode.Ctrl */)\n                    && (keyCode !== 4 /* KeyCode.Shift */)\n                    && (keyCode !== 6 /* KeyCode.Alt */)\n                    && (keyCode !== 57 /* KeyCode.Meta */)) {\n                    IMMUTABLE_KEY_CODE_TO_CODE[keyCode] = scanCode;\n                }\n            }\n        }\n        if (!seenKeyCode[keyCode]) {\n            seenKeyCode[keyCode] = true;\n            if (!keyCodeStr) {\n                throw new Error(`String representation missing for key code ${keyCode} around scan code ${scanCodeStr}`);\n            }\n            uiMap.define(keyCode, keyCodeStr);\n            userSettingsUSMap.define(keyCode, usUserSettingsLabel || keyCodeStr);\n            userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel || usUserSettingsLabel || keyCodeStr);\n        }\n        if (eventKeyCode) {\n            EVENT_KEY_CODE_MAP[eventKeyCode] = keyCode;\n        }\n        if (vkey) {\n            NATIVE_WINDOWS_KEY_CODE_TO_KEY_CODE[vkey] = keyCode;\n        }\n    }\n    // Manually added due to the exclusion above (due to duplication with NumpadEnter)\n    IMMUTABLE_KEY_CODE_TO_CODE[3 /* KeyCode.Enter */] = 46 /* ScanCode.Enter */;\n})();\nvar KeyCodeUtils;\n(function (KeyCodeUtils) {\n    function toString(keyCode) {\n        return uiMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toString = toString;\n    function fromString(key) {\n        return uiMap.strToKeyCode(key);\n    }\n    KeyCodeUtils.fromString = fromString;\n    function toUserSettingsUS(keyCode) {\n        return userSettingsUSMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;\n    function toUserSettingsGeneral(keyCode) {\n        return userSettingsGeneralMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;\n    function fromUserSettings(key) {\n        return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);\n    }\n    KeyCodeUtils.fromUserSettings = fromUserSettings;\n    function toElectronAccelerator(keyCode) {\n        if (keyCode >= 98 /* KeyCode.Numpad0 */ && keyCode <= 113 /* KeyCode.NumpadDivide */) {\n            // [Electron Accelerators] Electron is able to parse numpad keys, but unfortunately it\n            // renders them just as regular keys in menus. For example, num0 is rendered as \"0\",\n            // numdiv is rendered as \"/\", numsub is rendered as \"-\".\n            //\n            // This can lead to incredible confusion, as it makes numpad based keybindings indistinguishable\n            // from keybindings based on regular keys.\n            //\n            // We therefore need to fall back to custom rendering for numpad keys.\n            return null;\n        }\n        switch (keyCode) {\n            case 16 /* KeyCode.UpArrow */:\n                return 'Up';\n            case 18 /* KeyCode.DownArrow */:\n                return 'Down';\n            case 15 /* KeyCode.LeftArrow */:\n                return 'Left';\n            case 17 /* KeyCode.RightArrow */:\n                return 'Right';\n        }\n        return uiMap.keyCodeToStr(keyCode);\n    }\n    KeyCodeUtils.toElectronAccelerator = toElectronAccelerator;\n})(KeyCodeUtils || (KeyCodeUtils = {}));\nfunction KeyChord(firstPart, secondPart) {\n    const chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;\n    return (firstPart | chordPart) >>> 0;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/selection.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nclass Selection extends range_Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* SelectionDirection.LTR */;\n        }\n        return 1 /* SelectionDirection.RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new position_Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new position_Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* SelectionDirection.LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/types.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * @returns whether the provided parameter is a JavaScript String or not.\n */\nfunction isString(str) {\n    return (typeof str === 'string');\n}\n/**\n * @returns whether the provided parameter is of type `object` but **not**\n *\t`null`, an `array`, a `regexp`, nor a `date`.\n */\nfunction types_isObject(obj) {\n    // The method can't do a type cast since there are type (like strings) which\n    // are subclasses of any put not positvely matched by the function. Hence type\n    // narrowing results in wrong results.\n    return typeof obj === 'object'\n        && obj !== null\n        && !Array.isArray(obj)\n        && !(obj instanceof RegExp)\n        && !(obj instanceof Date);\n}\n/**\n * @returns whether the provided parameter is of type `Buffer` or Uint8Array dervived type\n */\nfunction types_isTypedArray(obj) {\n    const TypedArray = Object.getPrototypeOf(Uint8Array);\n    return typeof obj === 'object'\n        && obj instanceof TypedArray;\n}\n/**\n * In **contrast** to just checking `typeof` this will return `false` for `NaN`.\n * @returns whether the provided parameter is a JavaScript Number or not.\n */\nfunction isNumber(obj) {\n    return (typeof obj === 'number' && !isNaN(obj));\n}\n/**\n * @returns whether the provided parameter is an Iterable, casting to the given generic\n */\nfunction isIterable(obj) {\n    return !!obj && typeof obj[Symbol.iterator] === 'function';\n}\n/**\n * @returns whether the provided parameter is a JavaScript Boolean or not.\n */\nfunction isBoolean(obj) {\n    return (obj === true || obj === false);\n}\n/**\n * @returns whether the provided parameter is undefined.\n */\nfunction isUndefined(obj) {\n    return (typeof obj === 'undefined');\n}\n/**\n * @returns whether the provided parameter is defined.\n */\nfunction isDefined(arg) {\n    return !types_isUndefinedOrNull(arg);\n}\n/**\n * @returns whether the provided parameter is undefined or null.\n */\nfunction types_isUndefinedOrNull(obj) {\n    return (isUndefined(obj) || obj === null);\n}\nfunction assertType(condition, type) {\n    if (!condition) {\n        throw new Error(type ? `Unexpected type, expected '${type}'` : 'Unexpected type');\n    }\n}\n/**\n * Asserts that the argument passed in is neither undefined nor null.\n */\nfunction assertIsDefined(arg) {\n    if (types_isUndefinedOrNull(arg)) {\n        throw new Error('Assertion Failed: argument is undefined or null');\n    }\n    return arg;\n}\n/**\n * @returns whether the provided parameter is a JavaScript Function or not.\n */\nfunction isFunction(obj) {\n    return (typeof obj === 'function');\n}\nfunction validateConstraints(args, constraints) {\n    const len = Math.min(args.length, constraints.length);\n    for (let i = 0; i < len; i++) {\n        validateConstraint(args[i], constraints[i]);\n    }\n}\nfunction validateConstraint(arg, constraint) {\n    if (isString(constraint)) {\n        if (typeof arg !== constraint) {\n            throw new Error(`argument does not match constraint: typeof ${constraint}`);\n        }\n    }\n    else if (isFunction(constraint)) {\n        try {\n            if (arg instanceof constraint) {\n                return;\n            }\n        }\n        catch (_a) {\n            // ignore\n        }\n        if (!types_isUndefinedOrNull(arg) && arg.constructor === constraint) {\n            return;\n        }\n        if (constraint.length === 1 && constraint.call(undefined, arg) === true) {\n            return;\n        }\n        throw new Error(`argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true`);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/codiconsUtil.js\n\nconst _codiconFontCharacters = Object.create(null);\nfunction register(id, fontCharacter) {\n    if (isString(fontCharacter)) {\n        const val = _codiconFontCharacters[fontCharacter];\n        if (val === undefined) {\n            throw new Error(`${id} references an unknown codicon: ${fontCharacter}`);\n        }\n        fontCharacter = val;\n    }\n    _codiconFontCharacters[id] = fontCharacter;\n    return { id };\n}\n/**\n * Only to be used by the iconRegistry.\n */\nfunction getCodiconFontCharacters() {\n    return _codiconFontCharacters;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/codiconsLibrary.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// This file is automatically generated by (microsoft/vscode-codicons)/scripts/export-to-ts.js\n// Please don't edit it, as your changes will be overwritten.\n// Instead, add mappings to codiconsDerived in codicons.ts.\nconst codiconsLibrary = {\n    add: register('add', 0xea60),\n    plus: register('plus', 0xea60),\n    gistNew: register('gist-new', 0xea60),\n    repoCreate: register('repo-create', 0xea60),\n    lightbulb: register('lightbulb', 0xea61),\n    lightBulb: register('light-bulb', 0xea61),\n    repo: register('repo', 0xea62),\n    repoDelete: register('repo-delete', 0xea62),\n    gistFork: register('gist-fork', 0xea63),\n    repoForked: register('repo-forked', 0xea63),\n    gitPullRequest: register('git-pull-request', 0xea64),\n    gitPullRequestAbandoned: register('git-pull-request-abandoned', 0xea64),\n    recordKeys: register('record-keys', 0xea65),\n    keyboard: register('keyboard', 0xea65),\n    tag: register('tag', 0xea66),\n    gitPullRequestLabel: register('git-pull-request-label', 0xea66),\n    tagAdd: register('tag-add', 0xea66),\n    tagRemove: register('tag-remove', 0xea66),\n    person: register('person', 0xea67),\n    personFollow: register('person-follow', 0xea67),\n    personOutline: register('person-outline', 0xea67),\n    personFilled: register('person-filled', 0xea67),\n    gitBranch: register('git-branch', 0xea68),\n    gitBranchCreate: register('git-branch-create', 0xea68),\n    gitBranchDelete: register('git-branch-delete', 0xea68),\n    sourceControl: register('source-control', 0xea68),\n    mirror: register('mirror', 0xea69),\n    mirrorPublic: register('mirror-public', 0xea69),\n    star: register('star', 0xea6a),\n    starAdd: register('star-add', 0xea6a),\n    starDelete: register('star-delete', 0xea6a),\n    starEmpty: register('star-empty', 0xea6a),\n    comment: register('comment', 0xea6b),\n    commentAdd: register('comment-add', 0xea6b),\n    alert: register('alert', 0xea6c),\n    warning: register('warning', 0xea6c),\n    search: register('search', 0xea6d),\n    searchSave: register('search-save', 0xea6d),\n    logOut: register('log-out', 0xea6e),\n    signOut: register('sign-out', 0xea6e),\n    logIn: register('log-in', 0xea6f),\n    signIn: register('sign-in', 0xea6f),\n    eye: register('eye', 0xea70),\n    eyeUnwatch: register('eye-unwatch', 0xea70),\n    eyeWatch: register('eye-watch', 0xea70),\n    circleFilled: register('circle-filled', 0xea71),\n    primitiveDot: register('primitive-dot', 0xea71),\n    closeDirty: register('close-dirty', 0xea71),\n    debugBreakpoint: register('debug-breakpoint', 0xea71),\n    debugBreakpointDisabled: register('debug-breakpoint-disabled', 0xea71),\n    debugHint: register('debug-hint', 0xea71),\n    terminalDecorationSuccess: register('terminal-decoration-success', 0xea71),\n    primitiveSquare: register('primitive-square', 0xea72),\n    edit: register('edit', 0xea73),\n    pencil: register('pencil', 0xea73),\n    info: register('info', 0xea74),\n    issueOpened: register('issue-opened', 0xea74),\n    gistPrivate: register('gist-private', 0xea75),\n    gitForkPrivate: register('git-fork-private', 0xea75),\n    lock: register('lock', 0xea75),\n    mirrorPrivate: register('mirror-private', 0xea75),\n    close: register('close', 0xea76),\n    removeClose: register('remove-close', 0xea76),\n    x: register('x', 0xea76),\n    repoSync: register('repo-sync', 0xea77),\n    sync: register('sync', 0xea77),\n    clone: register('clone', 0xea78),\n    desktopDownload: register('desktop-download', 0xea78),\n    beaker: register('beaker', 0xea79),\n    microscope: register('microscope', 0xea79),\n    vm: register('vm', 0xea7a),\n    deviceDesktop: register('device-desktop', 0xea7a),\n    file: register('file', 0xea7b),\n    fileText: register('file-text', 0xea7b),\n    more: register('more', 0xea7c),\n    ellipsis: register('ellipsis', 0xea7c),\n    kebabHorizontal: register('kebab-horizontal', 0xea7c),\n    mailReply: register('mail-reply', 0xea7d),\n    reply: register('reply', 0xea7d),\n    organization: register('organization', 0xea7e),\n    organizationFilled: register('organization-filled', 0xea7e),\n    organizationOutline: register('organization-outline', 0xea7e),\n    newFile: register('new-file', 0xea7f),\n    fileAdd: register('file-add', 0xea7f),\n    newFolder: register('new-folder', 0xea80),\n    fileDirectoryCreate: register('file-directory-create', 0xea80),\n    trash: register('trash', 0xea81),\n    trashcan: register('trashcan', 0xea81),\n    history: register('history', 0xea82),\n    clock: register('clock', 0xea82),\n    folder: register('folder', 0xea83),\n    fileDirectory: register('file-directory', 0xea83),\n    symbolFolder: register('symbol-folder', 0xea83),\n    logoGithub: register('logo-github', 0xea84),\n    markGithub: register('mark-github', 0xea84),\n    github: register('github', 0xea84),\n    terminal: register('terminal', 0xea85),\n    console: register('console', 0xea85),\n    repl: register('repl', 0xea85),\n    zap: register('zap', 0xea86),\n    symbolEvent: register('symbol-event', 0xea86),\n    error: register('error', 0xea87),\n    stop: register('stop', 0xea87),\n    variable: register('variable', 0xea88),\n    symbolVariable: register('symbol-variable', 0xea88),\n    array: register('array', 0xea8a),\n    symbolArray: register('symbol-array', 0xea8a),\n    symbolModule: register('symbol-module', 0xea8b),\n    symbolPackage: register('symbol-package', 0xea8b),\n    symbolNamespace: register('symbol-namespace', 0xea8b),\n    symbolObject: register('symbol-object', 0xea8b),\n    symbolMethod: register('symbol-method', 0xea8c),\n    symbolFunction: register('symbol-function', 0xea8c),\n    symbolConstructor: register('symbol-constructor', 0xea8c),\n    symbolBoolean: register('symbol-boolean', 0xea8f),\n    symbolNull: register('symbol-null', 0xea8f),\n    symbolNumeric: register('symbol-numeric', 0xea90),\n    symbolNumber: register('symbol-number', 0xea90),\n    symbolStructure: register('symbol-structure', 0xea91),\n    symbolStruct: register('symbol-struct', 0xea91),\n    symbolParameter: register('symbol-parameter', 0xea92),\n    symbolTypeParameter: register('symbol-type-parameter', 0xea92),\n    symbolKey: register('symbol-key', 0xea93),\n    symbolText: register('symbol-text', 0xea93),\n    symbolReference: register('symbol-reference', 0xea94),\n    goToFile: register('go-to-file', 0xea94),\n    symbolEnum: register('symbol-enum', 0xea95),\n    symbolValue: register('symbol-value', 0xea95),\n    symbolRuler: register('symbol-ruler', 0xea96),\n    symbolUnit: register('symbol-unit', 0xea96),\n    activateBreakpoints: register('activate-breakpoints', 0xea97),\n    archive: register('archive', 0xea98),\n    arrowBoth: register('arrow-both', 0xea99),\n    arrowDown: register('arrow-down', 0xea9a),\n    arrowLeft: register('arrow-left', 0xea9b),\n    arrowRight: register('arrow-right', 0xea9c),\n    arrowSmallDown: register('arrow-small-down', 0xea9d),\n    arrowSmallLeft: register('arrow-small-left', 0xea9e),\n    arrowSmallRight: register('arrow-small-right', 0xea9f),\n    arrowSmallUp: register('arrow-small-up', 0xeaa0),\n    arrowUp: register('arrow-up', 0xeaa1),\n    bell: register('bell', 0xeaa2),\n    bold: register('bold', 0xeaa3),\n    book: register('book', 0xeaa4),\n    bookmark: register('bookmark', 0xeaa5),\n    debugBreakpointConditionalUnverified: register('debug-breakpoint-conditional-unverified', 0xeaa6),\n    debugBreakpointConditional: register('debug-breakpoint-conditional', 0xeaa7),\n    debugBreakpointConditionalDisabled: register('debug-breakpoint-conditional-disabled', 0xeaa7),\n    debugBreakpointDataUnverified: register('debug-breakpoint-data-unverified', 0xeaa8),\n    debugBreakpointData: register('debug-breakpoint-data', 0xeaa9),\n    debugBreakpointDataDisabled: register('debug-breakpoint-data-disabled', 0xeaa9),\n    debugBreakpointLogUnverified: register('debug-breakpoint-log-unverified', 0xeaaa),\n    debugBreakpointLog: register('debug-breakpoint-log', 0xeaab),\n    debugBreakpointLogDisabled: register('debug-breakpoint-log-disabled', 0xeaab),\n    briefcase: register('briefcase', 0xeaac),\n    broadcast: register('broadcast', 0xeaad),\n    browser: register('browser', 0xeaae),\n    bug: register('bug', 0xeaaf),\n    calendar: register('calendar', 0xeab0),\n    caseSensitive: register('case-sensitive', 0xeab1),\n    check: register('check', 0xeab2),\n    checklist: register('checklist', 0xeab3),\n    chevronDown: register('chevron-down', 0xeab4),\n    chevronLeft: register('chevron-left', 0xeab5),\n    chevronRight: register('chevron-right', 0xeab6),\n    chevronUp: register('chevron-up', 0xeab7),\n    chromeClose: register('chrome-close', 0xeab8),\n    chromeMaximize: register('chrome-maximize', 0xeab9),\n    chromeMinimize: register('chrome-minimize', 0xeaba),\n    chromeRestore: register('chrome-restore', 0xeabb),\n    circleOutline: register('circle-outline', 0xeabc),\n    circle: register('circle', 0xeabc),\n    debugBreakpointUnverified: register('debug-breakpoint-unverified', 0xeabc),\n    terminalDecorationIncomplete: register('terminal-decoration-incomplete', 0xeabc),\n    circleSlash: register('circle-slash', 0xeabd),\n    circuitBoard: register('circuit-board', 0xeabe),\n    clearAll: register('clear-all', 0xeabf),\n    clippy: register('clippy', 0xeac0),\n    closeAll: register('close-all', 0xeac1),\n    cloudDownload: register('cloud-download', 0xeac2),\n    cloudUpload: register('cloud-upload', 0xeac3),\n    code: register('code', 0xeac4),\n    collapseAll: register('collapse-all', 0xeac5),\n    colorMode: register('color-mode', 0xeac6),\n    commentDiscussion: register('comment-discussion', 0xeac7),\n    creditCard: register('credit-card', 0xeac9),\n    dash: register('dash', 0xeacc),\n    dashboard: register('dashboard', 0xeacd),\n    database: register('database', 0xeace),\n    debugContinue: register('debug-continue', 0xeacf),\n    debugDisconnect: register('debug-disconnect', 0xead0),\n    debugPause: register('debug-pause', 0xead1),\n    debugRestart: register('debug-restart', 0xead2),\n    debugStart: register('debug-start', 0xead3),\n    debugStepInto: register('debug-step-into', 0xead4),\n    debugStepOut: register('debug-step-out', 0xead5),\n    debugStepOver: register('debug-step-over', 0xead6),\n    debugStop: register('debug-stop', 0xead7),\n    debug: register('debug', 0xead8),\n    deviceCameraVideo: register('device-camera-video', 0xead9),\n    deviceCamera: register('device-camera', 0xeada),\n    deviceMobile: register('device-mobile', 0xeadb),\n    diffAdded: register('diff-added', 0xeadc),\n    diffIgnored: register('diff-ignored', 0xeadd),\n    diffModified: register('diff-modified', 0xeade),\n    diffRemoved: register('diff-removed', 0xeadf),\n    diffRenamed: register('diff-renamed', 0xeae0),\n    diff: register('diff', 0xeae1),\n    diffSidebyside: register('diff-sidebyside', 0xeae1),\n    discard: register('discard', 0xeae2),\n    editorLayout: register('editor-layout', 0xeae3),\n    emptyWindow: register('empty-window', 0xeae4),\n    exclude: register('exclude', 0xeae5),\n    extensions: register('extensions', 0xeae6),\n    eyeClosed: register('eye-closed', 0xeae7),\n    fileBinary: register('file-binary', 0xeae8),\n    fileCode: register('file-code', 0xeae9),\n    fileMedia: register('file-media', 0xeaea),\n    filePdf: register('file-pdf', 0xeaeb),\n    fileSubmodule: register('file-submodule', 0xeaec),\n    fileSymlinkDirectory: register('file-symlink-directory', 0xeaed),\n    fileSymlinkFile: register('file-symlink-file', 0xeaee),\n    fileZip: register('file-zip', 0xeaef),\n    files: register('files', 0xeaf0),\n    filter: register('filter', 0xeaf1),\n    flame: register('flame', 0xeaf2),\n    foldDown: register('fold-down', 0xeaf3),\n    foldUp: register('fold-up', 0xeaf4),\n    fold: register('fold', 0xeaf5),\n    folderActive: register('folder-active', 0xeaf6),\n    folderOpened: register('folder-opened', 0xeaf7),\n    gear: register('gear', 0xeaf8),\n    gift: register('gift', 0xeaf9),\n    gistSecret: register('gist-secret', 0xeafa),\n    gist: register('gist', 0xeafb),\n    gitCommit: register('git-commit', 0xeafc),\n    gitCompare: register('git-compare', 0xeafd),\n    compareChanges: register('compare-changes', 0xeafd),\n    gitMerge: register('git-merge', 0xeafe),\n    githubAction: register('github-action', 0xeaff),\n    githubAlt: register('github-alt', 0xeb00),\n    globe: register('globe', 0xeb01),\n    grabber: register('grabber', 0xeb02),\n    graph: register('graph', 0xeb03),\n    gripper: register('gripper', 0xeb04),\n    heart: register('heart', 0xeb05),\n    home: register('home', 0xeb06),\n    horizontalRule: register('horizontal-rule', 0xeb07),\n    hubot: register('hubot', 0xeb08),\n    inbox: register('inbox', 0xeb09),\n    issueReopened: register('issue-reopened', 0xeb0b),\n    issues: register('issues', 0xeb0c),\n    italic: register('italic', 0xeb0d),\n    jersey: register('jersey', 0xeb0e),\n    json: register('json', 0xeb0f),\n    kebabVertical: register('kebab-vertical', 0xeb10),\n    key: register('key', 0xeb11),\n    law: register('law', 0xeb12),\n    lightbulbAutofix: register('lightbulb-autofix', 0xeb13),\n    linkExternal: register('link-external', 0xeb14),\n    link: register('link', 0xeb15),\n    listOrdered: register('list-ordered', 0xeb16),\n    listUnordered: register('list-unordered', 0xeb17),\n    liveShare: register('live-share', 0xeb18),\n    loading: register('loading', 0xeb19),\n    location: register('location', 0xeb1a),\n    mailRead: register('mail-read', 0xeb1b),\n    mail: register('mail', 0xeb1c),\n    markdown: register('markdown', 0xeb1d),\n    megaphone: register('megaphone', 0xeb1e),\n    mention: register('mention', 0xeb1f),\n    milestone: register('milestone', 0xeb20),\n    gitPullRequestMilestone: register('git-pull-request-milestone', 0xeb20),\n    mortarBoard: register('mortar-board', 0xeb21),\n    move: register('move', 0xeb22),\n    multipleWindows: register('multiple-windows', 0xeb23),\n    mute: register('mute', 0xeb24),\n    noNewline: register('no-newline', 0xeb25),\n    note: register('note', 0xeb26),\n    octoface: register('octoface', 0xeb27),\n    openPreview: register('open-preview', 0xeb28),\n    package: register('package', 0xeb29),\n    paintcan: register('paintcan', 0xeb2a),\n    pin: register('pin', 0xeb2b),\n    play: register('play', 0xeb2c),\n    run: register('run', 0xeb2c),\n    plug: register('plug', 0xeb2d),\n    preserveCase: register('preserve-case', 0xeb2e),\n    preview: register('preview', 0xeb2f),\n    project: register('project', 0xeb30),\n    pulse: register('pulse', 0xeb31),\n    question: register('question', 0xeb32),\n    quote: register('quote', 0xeb33),\n    radioTower: register('radio-tower', 0xeb34),\n    reactions: register('reactions', 0xeb35),\n    references: register('references', 0xeb36),\n    refresh: register('refresh', 0xeb37),\n    regex: register('regex', 0xeb38),\n    remoteExplorer: register('remote-explorer', 0xeb39),\n    remote: register('remote', 0xeb3a),\n    remove: register('remove', 0xeb3b),\n    replaceAll: register('replace-all', 0xeb3c),\n    replace: register('replace', 0xeb3d),\n    repoClone: register('repo-clone', 0xeb3e),\n    repoForcePush: register('repo-force-push', 0xeb3f),\n    repoPull: register('repo-pull', 0xeb40),\n    repoPush: register('repo-push', 0xeb41),\n    report: register('report', 0xeb42),\n    requestChanges: register('request-changes', 0xeb43),\n    rocket: register('rocket', 0xeb44),\n    rootFolderOpened: register('root-folder-opened', 0xeb45),\n    rootFolder: register('root-folder', 0xeb46),\n    rss: register('rss', 0xeb47),\n    ruby: register('ruby', 0xeb48),\n    saveAll: register('save-all', 0xeb49),\n    saveAs: register('save-as', 0xeb4a),\n    save: register('save', 0xeb4b),\n    screenFull: register('screen-full', 0xeb4c),\n    screenNormal: register('screen-normal', 0xeb4d),\n    searchStop: register('search-stop', 0xeb4e),\n    server: register('server', 0xeb50),\n    settingsGear: register('settings-gear', 0xeb51),\n    settings: register('settings', 0xeb52),\n    shield: register('shield', 0xeb53),\n    smiley: register('smiley', 0xeb54),\n    sortPrecedence: register('sort-precedence', 0xeb55),\n    splitHorizontal: register('split-horizontal', 0xeb56),\n    splitVertical: register('split-vertical', 0xeb57),\n    squirrel: register('squirrel', 0xeb58),\n    starFull: register('star-full', 0xeb59),\n    starHalf: register('star-half', 0xeb5a),\n    symbolClass: register('symbol-class', 0xeb5b),\n    symbolColor: register('symbol-color', 0xeb5c),\n    symbolConstant: register('symbol-constant', 0xeb5d),\n    symbolEnumMember: register('symbol-enum-member', 0xeb5e),\n    symbolField: register('symbol-field', 0xeb5f),\n    symbolFile: register('symbol-file', 0xeb60),\n    symbolInterface: register('symbol-interface', 0xeb61),\n    symbolKeyword: register('symbol-keyword', 0xeb62),\n    symbolMisc: register('symbol-misc', 0xeb63),\n    symbolOperator: register('symbol-operator', 0xeb64),\n    symbolProperty: register('symbol-property', 0xeb65),\n    wrench: register('wrench', 0xeb65),\n    wrenchSubaction: register('wrench-subaction', 0xeb65),\n    symbolSnippet: register('symbol-snippet', 0xeb66),\n    tasklist: register('tasklist', 0xeb67),\n    telescope: register('telescope', 0xeb68),\n    textSize: register('text-size', 0xeb69),\n    threeBars: register('three-bars', 0xeb6a),\n    thumbsdown: register('thumbsdown', 0xeb6b),\n    thumbsup: register('thumbsup', 0xeb6c),\n    tools: register('tools', 0xeb6d),\n    triangleDown: register('triangle-down', 0xeb6e),\n    triangleLeft: register('triangle-left', 0xeb6f),\n    triangleRight: register('triangle-right', 0xeb70),\n    triangleUp: register('triangle-up', 0xeb71),\n    twitter: register('twitter', 0xeb72),\n    unfold: register('unfold', 0xeb73),\n    unlock: register('unlock', 0xeb74),\n    unmute: register('unmute', 0xeb75),\n    unverified: register('unverified', 0xeb76),\n    verified: register('verified', 0xeb77),\n    versions: register('versions', 0xeb78),\n    vmActive: register('vm-active', 0xeb79),\n    vmOutline: register('vm-outline', 0xeb7a),\n    vmRunning: register('vm-running', 0xeb7b),\n    watch: register('watch', 0xeb7c),\n    whitespace: register('whitespace', 0xeb7d),\n    wholeWord: register('whole-word', 0xeb7e),\n    window: register('window', 0xeb7f),\n    wordWrap: register('word-wrap', 0xeb80),\n    zoomIn: register('zoom-in', 0xeb81),\n    zoomOut: register('zoom-out', 0xeb82),\n    listFilter: register('list-filter', 0xeb83),\n    listFlat: register('list-flat', 0xeb84),\n    listSelection: register('list-selection', 0xeb85),\n    selection: register('selection', 0xeb85),\n    listTree: register('list-tree', 0xeb86),\n    debugBreakpointFunctionUnverified: register('debug-breakpoint-function-unverified', 0xeb87),\n    debugBreakpointFunction: register('debug-breakpoint-function', 0xeb88),\n    debugBreakpointFunctionDisabled: register('debug-breakpoint-function-disabled', 0xeb88),\n    debugStackframeActive: register('debug-stackframe-active', 0xeb89),\n    circleSmallFilled: register('circle-small-filled', 0xeb8a),\n    debugStackframeDot: register('debug-stackframe-dot', 0xeb8a),\n    terminalDecorationMark: register('terminal-decoration-mark', 0xeb8a),\n    debugStackframe: register('debug-stackframe', 0xeb8b),\n    debugStackframeFocused: register('debug-stackframe-focused', 0xeb8b),\n    debugBreakpointUnsupported: register('debug-breakpoint-unsupported', 0xeb8c),\n    symbolString: register('symbol-string', 0xeb8d),\n    debugReverseContinue: register('debug-reverse-continue', 0xeb8e),\n    debugStepBack: register('debug-step-back', 0xeb8f),\n    debugRestartFrame: register('debug-restart-frame', 0xeb90),\n    debugAlt: register('debug-alt', 0xeb91),\n    callIncoming: register('call-incoming', 0xeb92),\n    callOutgoing: register('call-outgoing', 0xeb93),\n    menu: register('menu', 0xeb94),\n    expandAll: register('expand-all', 0xeb95),\n    feedback: register('feedback', 0xeb96),\n    gitPullRequestReviewer: register('git-pull-request-reviewer', 0xeb96),\n    groupByRefType: register('group-by-ref-type', 0xeb97),\n    ungroupByRefType: register('ungroup-by-ref-type', 0xeb98),\n    account: register('account', 0xeb99),\n    gitPullRequestAssignee: register('git-pull-request-assignee', 0xeb99),\n    bellDot: register('bell-dot', 0xeb9a),\n    debugConsole: register('debug-console', 0xeb9b),\n    library: register('library', 0xeb9c),\n    output: register('output', 0xeb9d),\n    runAll: register('run-all', 0xeb9e),\n    syncIgnored: register('sync-ignored', 0xeb9f),\n    pinned: register('pinned', 0xeba0),\n    githubInverted: register('github-inverted', 0xeba1),\n    serverProcess: register('server-process', 0xeba2),\n    serverEnvironment: register('server-environment', 0xeba3),\n    pass: register('pass', 0xeba4),\n    issueClosed: register('issue-closed', 0xeba4),\n    stopCircle: register('stop-circle', 0xeba5),\n    playCircle: register('play-circle', 0xeba6),\n    record: register('record', 0xeba7),\n    debugAltSmall: register('debug-alt-small', 0xeba8),\n    vmConnect: register('vm-connect', 0xeba9),\n    cloud: register('cloud', 0xebaa),\n    merge: register('merge', 0xebab),\n    export: register('export', 0xebac),\n    graphLeft: register('graph-left', 0xebad),\n    magnet: register('magnet', 0xebae),\n    notebook: register('notebook', 0xebaf),\n    redo: register('redo', 0xebb0),\n    checkAll: register('check-all', 0xebb1),\n    pinnedDirty: register('pinned-dirty', 0xebb2),\n    passFilled: register('pass-filled', 0xebb3),\n    circleLargeFilled: register('circle-large-filled', 0xebb4),\n    circleLarge: register('circle-large', 0xebb5),\n    circleLargeOutline: register('circle-large-outline', 0xebb5),\n    combine: register('combine', 0xebb6),\n    gather: register('gather', 0xebb6),\n    table: register('table', 0xebb7),\n    variableGroup: register('variable-group', 0xebb8),\n    typeHierarchy: register('type-hierarchy', 0xebb9),\n    typeHierarchySub: register('type-hierarchy-sub', 0xebba),\n    typeHierarchySuper: register('type-hierarchy-super', 0xebbb),\n    gitPullRequestCreate: register('git-pull-request-create', 0xebbc),\n    runAbove: register('run-above', 0xebbd),\n    runBelow: register('run-below', 0xebbe),\n    notebookTemplate: register('notebook-template', 0xebbf),\n    debugRerun: register('debug-rerun', 0xebc0),\n    workspaceTrusted: register('workspace-trusted', 0xebc1),\n    workspaceUntrusted: register('workspace-untrusted', 0xebc2),\n    workspaceUnknown: register('workspace-unknown', 0xebc3),\n    terminalCmd: register('terminal-cmd', 0xebc4),\n    terminalDebian: register('terminal-debian', 0xebc5),\n    terminalLinux: register('terminal-linux', 0xebc6),\n    terminalPowershell: register('terminal-powershell', 0xebc7),\n    terminalTmux: register('terminal-tmux', 0xebc8),\n    terminalUbuntu: register('terminal-ubuntu', 0xebc9),\n    terminalBash: register('terminal-bash', 0xebca),\n    arrowSwap: register('arrow-swap', 0xebcb),\n    copy: register('copy', 0xebcc),\n    personAdd: register('person-add', 0xebcd),\n    filterFilled: register('filter-filled', 0xebce),\n    wand: register('wand', 0xebcf),\n    debugLineByLine: register('debug-line-by-line', 0xebd0),\n    inspect: register('inspect', 0xebd1),\n    layers: register('layers', 0xebd2),\n    layersDot: register('layers-dot', 0xebd3),\n    layersActive: register('layers-active', 0xebd4),\n    compass: register('compass', 0xebd5),\n    compassDot: register('compass-dot', 0xebd6),\n    compassActive: register('compass-active', 0xebd7),\n    azure: register('azure', 0xebd8),\n    issueDraft: register('issue-draft', 0xebd9),\n    gitPullRequestClosed: register('git-pull-request-closed', 0xebda),\n    gitPullRequestDraft: register('git-pull-request-draft', 0xebdb),\n    debugAll: register('debug-all', 0xebdc),\n    debugCoverage: register('debug-coverage', 0xebdd),\n    runErrors: register('run-errors', 0xebde),\n    folderLibrary: register('folder-library', 0xebdf),\n    debugContinueSmall: register('debug-continue-small', 0xebe0),\n    beakerStop: register('beaker-stop', 0xebe1),\n    graphLine: register('graph-line', 0xebe2),\n    graphScatter: register('graph-scatter', 0xebe3),\n    pieChart: register('pie-chart', 0xebe4),\n    bracket: register('bracket', 0xeb0f),\n    bracketDot: register('bracket-dot', 0xebe5),\n    bracketError: register('bracket-error', 0xebe6),\n    lockSmall: register('lock-small', 0xebe7),\n    azureDevops: register('azure-devops', 0xebe8),\n    verifiedFilled: register('verified-filled', 0xebe9),\n    newline: register('newline', 0xebea),\n    layout: register('layout', 0xebeb),\n    layoutActivitybarLeft: register('layout-activitybar-left', 0xebec),\n    layoutActivitybarRight: register('layout-activitybar-right', 0xebed),\n    layoutPanelLeft: register('layout-panel-left', 0xebee),\n    layoutPanelCenter: register('layout-panel-center', 0xebef),\n    layoutPanelJustify: register('layout-panel-justify', 0xebf0),\n    layoutPanelRight: register('layout-panel-right', 0xebf1),\n    layoutPanel: register('layout-panel', 0xebf2),\n    layoutSidebarLeft: register('layout-sidebar-left', 0xebf3),\n    layoutSidebarRight: register('layout-sidebar-right', 0xebf4),\n    layoutStatusbar: register('layout-statusbar', 0xebf5),\n    layoutMenubar: register('layout-menubar', 0xebf6),\n    layoutCentered: register('layout-centered', 0xebf7),\n    target: register('target', 0xebf8),\n    indent: register('indent', 0xebf9),\n    recordSmall: register('record-small', 0xebfa),\n    errorSmall: register('error-small', 0xebfb),\n    terminalDecorationError: register('terminal-decoration-error', 0xebfb),\n    arrowCircleDown: register('arrow-circle-down', 0xebfc),\n    arrowCircleLeft: register('arrow-circle-left', 0xebfd),\n    arrowCircleRight: register('arrow-circle-right', 0xebfe),\n    arrowCircleUp: register('arrow-circle-up', 0xebff),\n    layoutSidebarRightOff: register('layout-sidebar-right-off', 0xec00),\n    layoutPanelOff: register('layout-panel-off', 0xec01),\n    layoutSidebarLeftOff: register('layout-sidebar-left-off', 0xec02),\n    blank: register('blank', 0xec03),\n    heartFilled: register('heart-filled', 0xec04),\n    map: register('map', 0xec05),\n    mapHorizontal: register('map-horizontal', 0xec05),\n    foldHorizontal: register('fold-horizontal', 0xec05),\n    mapFilled: register('map-filled', 0xec06),\n    mapHorizontalFilled: register('map-horizontal-filled', 0xec06),\n    foldHorizontalFilled: register('fold-horizontal-filled', 0xec06),\n    circleSmall: register('circle-small', 0xec07),\n    bellSlash: register('bell-slash', 0xec08),\n    bellSlashDot: register('bell-slash-dot', 0xec09),\n    commentUnresolved: register('comment-unresolved', 0xec0a),\n    gitPullRequestGoToChanges: register('git-pull-request-go-to-changes', 0xec0b),\n    gitPullRequestNewChanges: register('git-pull-request-new-changes', 0xec0c),\n    searchFuzzy: register('search-fuzzy', 0xec0d),\n    commentDraft: register('comment-draft', 0xec0e),\n    send: register('send', 0xec0f),\n    sparkle: register('sparkle', 0xec10),\n    insert: register('insert', 0xec11),\n    mic: register('mic', 0xec12),\n    thumbsdownFilled: register('thumbsdown-filled', 0xec13),\n    thumbsupFilled: register('thumbsup-filled', 0xec14),\n    coffee: register('coffee', 0xec15),\n    snake: register('snake', 0xec16),\n    game: register('game', 0xec17),\n    vr: register('vr', 0xec18),\n    chip: register('chip', 0xec19),\n    piano: register('piano', 0xec1a),\n    music: register('music', 0xec1b),\n    micFilled: register('mic-filled', 0xec1c),\n    repoFetch: register('repo-fetch', 0xec1d),\n    copilot: register('copilot', 0xec1e),\n    lightbulbSparkle: register('lightbulb-sparkle', 0xec1f),\n    robot: register('robot', 0xec20),\n    sparkleFilled: register('sparkle-filled', 0xec21),\n    diffSingle: register('diff-single', 0xec22),\n    diffMultiple: register('diff-multiple', 0xec23),\n    surroundWith: register('surround-with', 0xec24),\n    share: register('share', 0xec25),\n    gitStash: register('git-stash', 0xec26),\n    gitStashApply: register('git-stash-apply', 0xec27),\n    gitStashPop: register('git-stash-pop', 0xec28),\n    vscode: register('vscode', 0xec29),\n    vscodeInsiders: register('vscode-insiders', 0xec2a),\n    codeOss: register('code-oss', 0xec2b),\n    runCoverage: register('run-coverage', 0xec2c),\n    runAllCoverage: register('run-all-coverage', 0xec2d),\n    coverage: register('coverage', 0xec2e),\n    githubProject: register('github-project', 0xec2f),\n    mapVertical: register('map-vertical', 0xec30),\n    foldVertical: register('fold-vertical', 0xec30),\n    mapVerticalFilled: register('map-vertical-filled', 0xec31),\n    foldVerticalFilled: register('fold-vertical-filled', 0xec31),\n    goToSearch: register('go-to-search', 0xec32),\n    percentage: register('percentage', 0xec33),\n    sortPercentage: register('sort-percentage', 0xec33),\n    attach: register('attach', 0xec34),\n};\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/codicons.js\n\n\n/**\n * Derived icons, that could become separate icons.\n * These mappings should be moved into the mapping file in the vscode-codicons repo at some point.\n */\nconst codiconsDerived = {\n    dialogError: register('dialog-error', 'error'),\n    dialogWarning: register('dialog-warning', 'warning'),\n    dialogInfo: register('dialog-info', 'info'),\n    dialogClose: register('dialog-close', 'close'),\n    treeItemExpanded: register('tree-item-expanded', 'chevron-down'), // collapsed is done with rotation\n    treeFilterOnTypeOn: register('tree-filter-on-type-on', 'list-filter'),\n    treeFilterOnTypeOff: register('tree-filter-on-type-off', 'list-selection'),\n    treeFilterClear: register('tree-filter-clear', 'close'),\n    treeItemLoading: register('tree-item-loading', 'loading'),\n    menuSelection: register('menu-selection', 'check'),\n    menuSubmenu: register('menu-submenu', 'chevron-right'),\n    menuBarMore: register('menubar-more', 'more'),\n    scrollbarButtonLeft: register('scrollbar-button-left', 'triangle-left'),\n    scrollbarButtonRight: register('scrollbar-button-right', 'triangle-right'),\n    scrollbarButtonUp: register('scrollbar-button-up', 'triangle-up'),\n    scrollbarButtonDown: register('scrollbar-button-down', 'triangle-down'),\n    toolBarMore: register('toolbar-more', 'more'),\n    quickInputBack: register('quick-input-back', 'arrow-left'),\n    dropDownButton: register('drop-down-button', 0xeab4),\n    symbolCustomColor: register('symbol-customcolor', 0xeb5c),\n    exportIcon: register('export', 0xebac),\n    workspaceUnspecified: register('workspace-unspecified', 0xebc3),\n    newLine: register('newline', 0xebea),\n    thumbsDownFilled: register('thumbsdown-filled', 0xec13),\n    thumbsUpFilled: register('thumbsup-filled', 0xec14),\n    gitFetch: register('git-fetch', 0xec1d),\n    lightbulbSparkleAutofix: register('lightbulb-sparkle-autofix', 0xec1f),\n    debugBreakpointPending: register('debug-breakpoint-pending', 0xebd9),\n};\n/**\n * The Codicon library is a set of default icons that are built-in in VS Code.\n *\n * In the product (outside of base) Codicons should only be used as defaults. In order to have all icons in VS Code\n * themeable, component should define new, UI component specific icons using `iconRegistry.registerIcon`.\n * In that call a Codicon can be named as default.\n */\nconst Codicon = {\n    ...codiconsLibrary,\n    ...codiconsDerived\n};\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/tokenizationRegistry.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nclass TokenizationRegistry {\n    constructor() {\n        this._tokenizationSupports = new Map();\n        this._factories = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n        this._colorMap = null;\n    }\n    handleChange(languageIds) {\n        this._onDidChange.fire({\n            changedLanguages: languageIds,\n            changedColorMap: false\n        });\n    }\n    register(languageId, support) {\n        this._tokenizationSupports.set(languageId, support);\n        this.handleChange([languageId]);\n        return lifecycle_toDisposable(() => {\n            if (this._tokenizationSupports.get(languageId) !== support) {\n                return;\n            }\n            this._tokenizationSupports.delete(languageId);\n            this.handleChange([languageId]);\n        });\n    }\n    get(languageId) {\n        return this._tokenizationSupports.get(languageId) || null;\n    }\n    registerFactory(languageId, factory) {\n        var _a;\n        (_a = this._factories.get(languageId)) === null || _a === void 0 ? void 0 : _a.dispose();\n        const myData = new TokenizationSupportFactoryData(this, languageId, factory);\n        this._factories.set(languageId, myData);\n        return lifecycle_toDisposable(() => {\n            const v = this._factories.get(languageId);\n            if (!v || v !== myData) {\n                return;\n            }\n            this._factories.delete(languageId);\n            v.dispose();\n        });\n    }\n    async getOrCreate(languageId) {\n        // check first if the support is already set\n        const tokenizationSupport = this.get(languageId);\n        if (tokenizationSupport) {\n            return tokenizationSupport;\n        }\n        const factory = this._factories.get(languageId);\n        if (!factory || factory.isResolved) {\n            // no factory or factory.resolve already finished\n            return null;\n        }\n        await factory.resolve();\n        return this.get(languageId);\n    }\n    isResolved(languageId) {\n        const tokenizationSupport = this.get(languageId);\n        if (tokenizationSupport) {\n            return true;\n        }\n        const factory = this._factories.get(languageId);\n        if (!factory || factory.isResolved) {\n            return true;\n        }\n        return false;\n    }\n    setColorMap(colorMap) {\n        this._colorMap = colorMap;\n        this._onDidChange.fire({\n            changedLanguages: Array.from(this._tokenizationSupports.keys()),\n            changedColorMap: true\n        });\n    }\n    getColorMap() {\n        return this._colorMap;\n    }\n    getDefaultBackground() {\n        if (this._colorMap && this._colorMap.length > 2 /* ColorId.DefaultBackground */) {\n            return this._colorMap[2 /* ColorId.DefaultBackground */];\n        }\n        return null;\n    }\n}\nclass TokenizationSupportFactoryData extends lifecycle_Disposable {\n    get isResolved() {\n        return this._isResolved;\n    }\n    constructor(_registry, _languageId, _factory) {\n        super();\n        this._registry = _registry;\n        this._languageId = _languageId;\n        this._factory = _factory;\n        this._isDisposed = false;\n        this._resolvePromise = null;\n        this._isResolved = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n        super.dispose();\n    }\n    async resolve() {\n        if (!this._resolvePromise) {\n            this._resolvePromise = this._create();\n        }\n        return this._resolvePromise;\n    }\n    async _create() {\n        const value = await this._factory.tokenizationSupport;\n        this._isResolved = true;\n        if (value && !this._isDisposed) {\n            this._register(this._registry.register(this._languageId, value));\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/languages.js\n\n\n\n\n\nclass Token {\n    constructor(offset, type, language) {\n        this.offset = offset;\n        this.type = type;\n        this.language = language;\n        this._tokenBrand = undefined;\n    }\n    toString() {\n        return '(' + this.offset + ', ' + this.type + ')';\n    }\n}\n/**\n * @internal\n */\nclass TokenizationResult {\n    constructor(tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._tokenizationResultBrand = undefined;\n    }\n}\n/**\n * @internal\n */\nclass EncodedTokenizationResult {\n    constructor(\n    /**\n     * The tokens in binary format. Each token occupies two array indices. For token i:\n     *  - at offset 2*i => startIndex\n     *  - at offset 2*i + 1 => metadata\n     *\n     */\n    tokens, endState) {\n        this.tokens = tokens;\n        this.endState = endState;\n        this._encodedTokenizationResultBrand = undefined;\n    }\n}\nvar HoverVerbosityAction;\n(function (HoverVerbosityAction) {\n    /**\n     * Increase the verbosity of the hover\n     */\n    HoverVerbosityAction[HoverVerbosityAction[\"Increase\"] = 0] = \"Increase\";\n    /**\n     * Decrease the verbosity of the hover\n     */\n    HoverVerbosityAction[HoverVerbosityAction[\"Decrease\"] = 1] = \"Decrease\";\n})(HoverVerbosityAction || (HoverVerbosityAction = {}));\n/**\n * @internal\n */\nvar CompletionItemKinds;\n(function (CompletionItemKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* CompletionItemKind.Method */, Codicon.symbolMethod);\n    byKind.set(1 /* CompletionItemKind.Function */, Codicon.symbolFunction);\n    byKind.set(2 /* CompletionItemKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(3 /* CompletionItemKind.Field */, Codicon.symbolField);\n    byKind.set(4 /* CompletionItemKind.Variable */, Codicon.symbolVariable);\n    byKind.set(5 /* CompletionItemKind.Class */, Codicon.symbolClass);\n    byKind.set(6 /* CompletionItemKind.Struct */, Codicon.symbolStruct);\n    byKind.set(7 /* CompletionItemKind.Interface */, Codicon.symbolInterface);\n    byKind.set(8 /* CompletionItemKind.Module */, Codicon.symbolModule);\n    byKind.set(9 /* CompletionItemKind.Property */, Codicon.symbolProperty);\n    byKind.set(10 /* CompletionItemKind.Event */, Codicon.symbolEvent);\n    byKind.set(11 /* CompletionItemKind.Operator */, Codicon.symbolOperator);\n    byKind.set(12 /* CompletionItemKind.Unit */, Codicon.symbolUnit);\n    byKind.set(13 /* CompletionItemKind.Value */, Codicon.symbolValue);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(14 /* CompletionItemKind.Constant */, Codicon.symbolConstant);\n    byKind.set(15 /* CompletionItemKind.Enum */, Codicon.symbolEnum);\n    byKind.set(16 /* CompletionItemKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(17 /* CompletionItemKind.Keyword */, Codicon.symbolKeyword);\n    byKind.set(27 /* CompletionItemKind.Snippet */, Codicon.symbolSnippet);\n    byKind.set(18 /* CompletionItemKind.Text */, Codicon.symbolText);\n    byKind.set(19 /* CompletionItemKind.Color */, Codicon.symbolColor);\n    byKind.set(20 /* CompletionItemKind.File */, Codicon.symbolFile);\n    byKind.set(21 /* CompletionItemKind.Reference */, Codicon.symbolReference);\n    byKind.set(22 /* CompletionItemKind.Customcolor */, Codicon.symbolCustomColor);\n    byKind.set(23 /* CompletionItemKind.Folder */, Codicon.symbolFolder);\n    byKind.set(24 /* CompletionItemKind.TypeParameter */, Codicon.symbolTypeParameter);\n    byKind.set(25 /* CompletionItemKind.User */, Codicon.account);\n    byKind.set(26 /* CompletionItemKind.Issue */, Codicon.issues);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let codicon = byKind.get(kind);\n        if (!codicon) {\n            console.info('No codicon found for CompletionItemKind ' + kind);\n            codicon = Codicon.symbolProperty;\n        }\n        return codicon;\n    }\n    CompletionItemKinds.toIcon = toIcon;\n    const data = new Map();\n    data.set('method', 0 /* CompletionItemKind.Method */);\n    data.set('function', 1 /* CompletionItemKind.Function */);\n    data.set('constructor', 2 /* CompletionItemKind.Constructor */);\n    data.set('field', 3 /* CompletionItemKind.Field */);\n    data.set('variable', 4 /* CompletionItemKind.Variable */);\n    data.set('class', 5 /* CompletionItemKind.Class */);\n    data.set('struct', 6 /* CompletionItemKind.Struct */);\n    data.set('interface', 7 /* CompletionItemKind.Interface */);\n    data.set('module', 8 /* CompletionItemKind.Module */);\n    data.set('property', 9 /* CompletionItemKind.Property */);\n    data.set('event', 10 /* CompletionItemKind.Event */);\n    data.set('operator', 11 /* CompletionItemKind.Operator */);\n    data.set('unit', 12 /* CompletionItemKind.Unit */);\n    data.set('value', 13 /* CompletionItemKind.Value */);\n    data.set('constant', 14 /* CompletionItemKind.Constant */);\n    data.set('enum', 15 /* CompletionItemKind.Enum */);\n    data.set('enum-member', 16 /* CompletionItemKind.EnumMember */);\n    data.set('enumMember', 16 /* CompletionItemKind.EnumMember */);\n    data.set('keyword', 17 /* CompletionItemKind.Keyword */);\n    data.set('snippet', 27 /* CompletionItemKind.Snippet */);\n    data.set('text', 18 /* CompletionItemKind.Text */);\n    data.set('color', 19 /* CompletionItemKind.Color */);\n    data.set('file', 20 /* CompletionItemKind.File */);\n    data.set('reference', 21 /* CompletionItemKind.Reference */);\n    data.set('customcolor', 22 /* CompletionItemKind.Customcolor */);\n    data.set('folder', 23 /* CompletionItemKind.Folder */);\n    data.set('type-parameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('typeParameter', 24 /* CompletionItemKind.TypeParameter */);\n    data.set('account', 25 /* CompletionItemKind.User */);\n    data.set('issue', 26 /* CompletionItemKind.Issue */);\n    /**\n     * @internal\n     */\n    function fromString(value, strict) {\n        let res = data.get(value);\n        if (typeof res === 'undefined' && !strict) {\n            res = 9 /* CompletionItemKind.Property */;\n        }\n        return res;\n    }\n    CompletionItemKinds.fromString = fromString;\n})(CompletionItemKinds || (CompletionItemKinds = {}));\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nvar InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\nclass SelectedSuggestionInfo {\n    constructor(range, text, completionKind, isSnippetText) {\n        this.range = range;\n        this.text = text;\n        this.completionKind = completionKind;\n        this.isSnippetText = isSnippetText;\n    }\n    equals(other) {\n        return Range.lift(this.range).equalsRange(other.range)\n            && this.text === other.text\n            && this.completionKind === other.completionKind\n            && this.isSnippetText === other.isSnippetText;\n    }\n}\n/**\n * @internal\n */\nvar DocumentPasteTriggerKind;\n(function (DocumentPasteTriggerKind) {\n    DocumentPasteTriggerKind[DocumentPasteTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    DocumentPasteTriggerKind[DocumentPasteTriggerKind[\"PasteAs\"] = 1] = \"PasteAs\";\n})(DocumentPasteTriggerKind || (DocumentPasteTriggerKind = {}));\nvar SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));\n/**\n * A document highlight kind.\n */\nvar DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\n/**\n * @internal\n */\nfunction isLocationLink(thing) {\n    return thing\n        && URI.isUri(thing.uri)\n        && Range.isIRange(thing.range)\n        && (Range.isIRange(thing.originSelectionRange) || Range.isIRange(thing.targetSelectionRange));\n}\n/**\n * @internal\n */\nconst symbolKindNames = {\n    [17 /* SymbolKind.Array */]: nls_localize('Array', \"array\"),\n    [16 /* SymbolKind.Boolean */]: nls_localize('Boolean', \"boolean\"),\n    [4 /* SymbolKind.Class */]: nls_localize('Class', \"class\"),\n    [13 /* SymbolKind.Constant */]: nls_localize('Constant', \"constant\"),\n    [8 /* SymbolKind.Constructor */]: nls_localize('Constructor', \"constructor\"),\n    [9 /* SymbolKind.Enum */]: nls_localize('Enum', \"enumeration\"),\n    [21 /* SymbolKind.EnumMember */]: nls_localize('EnumMember', \"enumeration member\"),\n    [23 /* SymbolKind.Event */]: nls_localize('Event', \"event\"),\n    [7 /* SymbolKind.Field */]: nls_localize('Field', \"field\"),\n    [0 /* SymbolKind.File */]: nls_localize('File', \"file\"),\n    [11 /* SymbolKind.Function */]: nls_localize('Function', \"function\"),\n    [10 /* SymbolKind.Interface */]: nls_localize('Interface', \"interface\"),\n    [19 /* SymbolKind.Key */]: nls_localize('Key', \"key\"),\n    [5 /* SymbolKind.Method */]: nls_localize('Method', \"method\"),\n    [1 /* SymbolKind.Module */]: nls_localize('Module', \"module\"),\n    [2 /* SymbolKind.Namespace */]: nls_localize('Namespace', \"namespace\"),\n    [20 /* SymbolKind.Null */]: nls_localize('Null', \"null\"),\n    [15 /* SymbolKind.Number */]: nls_localize('Number', \"number\"),\n    [18 /* SymbolKind.Object */]: nls_localize('Object', \"object\"),\n    [24 /* SymbolKind.Operator */]: nls_localize('Operator', \"operator\"),\n    [3 /* SymbolKind.Package */]: nls_localize('Package', \"package\"),\n    [6 /* SymbolKind.Property */]: nls_localize('Property', \"property\"),\n    [14 /* SymbolKind.String */]: nls_localize('String', \"string\"),\n    [22 /* SymbolKind.Struct */]: nls_localize('Struct', \"struct\"),\n    [25 /* SymbolKind.TypeParameter */]: nls_localize('TypeParameter', \"type parameter\"),\n    [12 /* SymbolKind.Variable */]: nls_localize('Variable', \"variable\"),\n};\n/**\n * @internal\n */\nfunction getAriaLabelForSymbol(symbolName, kind) {\n    return localize('symbolAriaLabel', '{0} ({1})', symbolName, symbolKindNames[kind]);\n}\n/**\n * @internal\n */\nvar SymbolKinds;\n(function (SymbolKinds) {\n    const byKind = new Map();\n    byKind.set(0 /* SymbolKind.File */, Codicon.symbolFile);\n    byKind.set(1 /* SymbolKind.Module */, Codicon.symbolModule);\n    byKind.set(2 /* SymbolKind.Namespace */, Codicon.symbolNamespace);\n    byKind.set(3 /* SymbolKind.Package */, Codicon.symbolPackage);\n    byKind.set(4 /* SymbolKind.Class */, Codicon.symbolClass);\n    byKind.set(5 /* SymbolKind.Method */, Codicon.symbolMethod);\n    byKind.set(6 /* SymbolKind.Property */, Codicon.symbolProperty);\n    byKind.set(7 /* SymbolKind.Field */, Codicon.symbolField);\n    byKind.set(8 /* SymbolKind.Constructor */, Codicon.symbolConstructor);\n    byKind.set(9 /* SymbolKind.Enum */, Codicon.symbolEnum);\n    byKind.set(10 /* SymbolKind.Interface */, Codicon.symbolInterface);\n    byKind.set(11 /* SymbolKind.Function */, Codicon.symbolFunction);\n    byKind.set(12 /* SymbolKind.Variable */, Codicon.symbolVariable);\n    byKind.set(13 /* SymbolKind.Constant */, Codicon.symbolConstant);\n    byKind.set(14 /* SymbolKind.String */, Codicon.symbolString);\n    byKind.set(15 /* SymbolKind.Number */, Codicon.symbolNumber);\n    byKind.set(16 /* SymbolKind.Boolean */, Codicon.symbolBoolean);\n    byKind.set(17 /* SymbolKind.Array */, Codicon.symbolArray);\n    byKind.set(18 /* SymbolKind.Object */, Codicon.symbolObject);\n    byKind.set(19 /* SymbolKind.Key */, Codicon.symbolKey);\n    byKind.set(20 /* SymbolKind.Null */, Codicon.symbolNull);\n    byKind.set(21 /* SymbolKind.EnumMember */, Codicon.symbolEnumMember);\n    byKind.set(22 /* SymbolKind.Struct */, Codicon.symbolStruct);\n    byKind.set(23 /* SymbolKind.Event */, Codicon.symbolEvent);\n    byKind.set(24 /* SymbolKind.Operator */, Codicon.symbolOperator);\n    byKind.set(25 /* SymbolKind.TypeParameter */, Codicon.symbolTypeParameter);\n    /**\n     * @internal\n     */\n    function toIcon(kind) {\n        let icon = byKind.get(kind);\n        if (!icon) {\n            console.info('No codicon found for SymbolKind ' + kind);\n            icon = Codicon.symbolProperty;\n        }\n        return icon;\n    }\n    SymbolKinds.toIcon = toIcon;\n})(SymbolKinds || (SymbolKinds = {}));\n/** @internal */\nclass TextEdit {\n}\nclass FoldingRangeKind {\n    /**\n     * Returns a {@link FoldingRangeKind} for the given value.\n     *\n     * @param value of the kind.\n     */\n    static fromValue(value) {\n        switch (value) {\n            case 'comment': return FoldingRangeKind.Comment;\n            case 'imports': return FoldingRangeKind.Imports;\n            case 'region': return FoldingRangeKind.Region;\n        }\n        return new FoldingRangeKind(value);\n    }\n    /**\n     * Creates a new {@link FoldingRangeKind}.\n     *\n     * @param value of the kind.\n     */\n    constructor(value) {\n        this.value = value;\n    }\n}\n/**\n * Kind for folding range representing a comment. The value of the kind is 'comment'.\n */\nFoldingRangeKind.Comment = new FoldingRangeKind('comment');\n/**\n * Kind for folding range representing a import. The value of the kind is 'imports'.\n */\nFoldingRangeKind.Imports = new FoldingRangeKind('imports');\n/**\n * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).\n * The value of the kind is 'region'.\n */\nFoldingRangeKind.Region = new FoldingRangeKind('region');\nvar NewSymbolNameTag;\n(function (NewSymbolNameTag) {\n    NewSymbolNameTag[NewSymbolNameTag[\"AIGenerated\"] = 1] = \"AIGenerated\";\n})(NewSymbolNameTag || (NewSymbolNameTag = {}));\nvar NewSymbolNameTriggerKind;\n(function (NewSymbolNameTriggerKind) {\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(NewSymbolNameTriggerKind || (NewSymbolNameTriggerKind = {}));\n/**\n * @internal\n */\nvar Command;\n(function (Command) {\n    /**\n     * @internal\n     */\n    function is(obj) {\n        if (!obj || typeof obj !== 'object') {\n            return false;\n        }\n        return typeof obj.id === 'string' &&\n            typeof obj.title === 'string';\n    }\n    Command.is = is;\n})(Command || (Command = {}));\nvar InlayHintKind;\n(function (InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(InlayHintKind || (InlayHintKind = {}));\n/**\n * @internal\n */\nclass LazyTokenizationSupport {\n    constructor(createSupport) {\n        this.createSupport = createSupport;\n        this._tokenizationSupport = null;\n    }\n    dispose() {\n        if (this._tokenizationSupport) {\n            this._tokenizationSupport.then((support) => {\n                if (support) {\n                    support.dispose();\n                }\n            });\n        }\n    }\n    get tokenizationSupport() {\n        if (!this._tokenizationSupport) {\n            this._tokenizationSupport = this.createSupport();\n        }\n        return this._tokenizationSupport;\n    }\n}\n/**\n * @internal\n */\nconst languages_TokenizationRegistry = new TokenizationRegistry();\nvar InlineEditTriggerKind;\n(function (InlineEditTriggerKind) {\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(InlineEditTriggerKind || (InlineEditTriggerKind = {}));\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.\nvar AccessibilitySupport;\n(function (AccessibilitySupport) {\n    /**\n     * This should be the browser case where it is not known if a screen reader is attached or no.\n     */\n    AccessibilitySupport[AccessibilitySupport[\"Unknown\"] = 0] = \"Unknown\";\n    AccessibilitySupport[AccessibilitySupport[\"Disabled\"] = 1] = \"Disabled\";\n    AccessibilitySupport[AccessibilitySupport[\"Enabled\"] = 2] = \"Enabled\";\n})(AccessibilitySupport || (AccessibilitySupport = {}));\nvar CodeActionTriggerType;\n(function (CodeActionTriggerType) {\n    CodeActionTriggerType[CodeActionTriggerType[\"Invoke\"] = 1] = \"Invoke\";\n    CodeActionTriggerType[CodeActionTriggerType[\"Auto\"] = 2] = \"Auto\";\n})(CodeActionTriggerType || (CodeActionTriggerType = {}));\nvar CompletionItemInsertTextRule;\n(function (CompletionItemInsertTextRule) {\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"None\"] = 0] = \"None\";\n    /**\n     * Adjust whitespace/indentation of multiline insert texts to\n     * match the current line indentation.\n     */\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"KeepWhitespace\"] = 1] = \"KeepWhitespace\";\n    /**\n     * `insertText` is a snippet.\n     */\n    CompletionItemInsertTextRule[CompletionItemInsertTextRule[\"InsertAsSnippet\"] = 4] = \"InsertAsSnippet\";\n})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));\nvar CompletionItemKind;\n(function (CompletionItemKind) {\n    CompletionItemKind[CompletionItemKind[\"Method\"] = 0] = \"Method\";\n    CompletionItemKind[CompletionItemKind[\"Function\"] = 1] = \"Function\";\n    CompletionItemKind[CompletionItemKind[\"Constructor\"] = 2] = \"Constructor\";\n    CompletionItemKind[CompletionItemKind[\"Field\"] = 3] = \"Field\";\n    CompletionItemKind[CompletionItemKind[\"Variable\"] = 4] = \"Variable\";\n    CompletionItemKind[CompletionItemKind[\"Class\"] = 5] = \"Class\";\n    CompletionItemKind[CompletionItemKind[\"Struct\"] = 6] = \"Struct\";\n    CompletionItemKind[CompletionItemKind[\"Interface\"] = 7] = \"Interface\";\n    CompletionItemKind[CompletionItemKind[\"Module\"] = 8] = \"Module\";\n    CompletionItemKind[CompletionItemKind[\"Property\"] = 9] = \"Property\";\n    CompletionItemKind[CompletionItemKind[\"Event\"] = 10] = \"Event\";\n    CompletionItemKind[CompletionItemKind[\"Operator\"] = 11] = \"Operator\";\n    CompletionItemKind[CompletionItemKind[\"Unit\"] = 12] = \"Unit\";\n    CompletionItemKind[CompletionItemKind[\"Value\"] = 13] = \"Value\";\n    CompletionItemKind[CompletionItemKind[\"Constant\"] = 14] = \"Constant\";\n    CompletionItemKind[CompletionItemKind[\"Enum\"] = 15] = \"Enum\";\n    CompletionItemKind[CompletionItemKind[\"EnumMember\"] = 16] = \"EnumMember\";\n    CompletionItemKind[CompletionItemKind[\"Keyword\"] = 17] = \"Keyword\";\n    CompletionItemKind[CompletionItemKind[\"Text\"] = 18] = \"Text\";\n    CompletionItemKind[CompletionItemKind[\"Color\"] = 19] = \"Color\";\n    CompletionItemKind[CompletionItemKind[\"File\"] = 20] = \"File\";\n    CompletionItemKind[CompletionItemKind[\"Reference\"] = 21] = \"Reference\";\n    CompletionItemKind[CompletionItemKind[\"Customcolor\"] = 22] = \"Customcolor\";\n    CompletionItemKind[CompletionItemKind[\"Folder\"] = 23] = \"Folder\";\n    CompletionItemKind[CompletionItemKind[\"TypeParameter\"] = 24] = \"TypeParameter\";\n    CompletionItemKind[CompletionItemKind[\"User\"] = 25] = \"User\";\n    CompletionItemKind[CompletionItemKind[\"Issue\"] = 26] = \"Issue\";\n    CompletionItemKind[CompletionItemKind[\"Snippet\"] = 27] = \"Snippet\";\n})(CompletionItemKind || (CompletionItemKind = {}));\nvar CompletionItemTag;\n(function (CompletionItemTag) {\n    CompletionItemTag[CompletionItemTag[\"Deprecated\"] = 1] = \"Deprecated\";\n})(CompletionItemTag || (CompletionItemTag = {}));\n/**\n * How a suggest provider was triggered.\n */\nvar CompletionTriggerKind;\n(function (CompletionTriggerKind) {\n    CompletionTriggerKind[CompletionTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerCharacter\"] = 1] = \"TriggerCharacter\";\n    CompletionTriggerKind[CompletionTriggerKind[\"TriggerForIncompleteCompletions\"] = 2] = \"TriggerForIncompleteCompletions\";\n})(CompletionTriggerKind || (CompletionTriggerKind = {}));\n/**\n * A positioning preference for rendering content widgets.\n */\nvar ContentWidgetPositionPreference;\n(function (ContentWidgetPositionPreference) {\n    /**\n     * Place the content widget exactly at a position\n     */\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"EXACT\"] = 0] = \"EXACT\";\n    /**\n     * Place the content widget above a position\n     */\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"ABOVE\"] = 1] = \"ABOVE\";\n    /**\n     * Place the content widget below a position\n     */\n    ContentWidgetPositionPreference[ContentWidgetPositionPreference[\"BELOW\"] = 2] = \"BELOW\";\n})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));\n/**\n * Describes the reason the cursor has changed its position.\n */\nvar CursorChangeReason;\n(function (CursorChangeReason) {\n    /**\n     * Unknown or not set.\n     */\n    CursorChangeReason[CursorChangeReason[\"NotSet\"] = 0] = \"NotSet\";\n    /**\n     * A `model.setValue()` was called.\n     */\n    CursorChangeReason[CursorChangeReason[\"ContentFlush\"] = 1] = \"ContentFlush\";\n    /**\n     * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.\n     */\n    CursorChangeReason[CursorChangeReason[\"RecoverFromMarkers\"] = 2] = \"RecoverFromMarkers\";\n    /**\n     * There was an explicit user gesture.\n     */\n    CursorChangeReason[CursorChangeReason[\"Explicit\"] = 3] = \"Explicit\";\n    /**\n     * There was a Paste.\n     */\n    CursorChangeReason[CursorChangeReason[\"Paste\"] = 4] = \"Paste\";\n    /**\n     * There was an Undo.\n     */\n    CursorChangeReason[CursorChangeReason[\"Undo\"] = 5] = \"Undo\";\n    /**\n     * There was a Redo.\n     */\n    CursorChangeReason[CursorChangeReason[\"Redo\"] = 6] = \"Redo\";\n})(CursorChangeReason || (CursorChangeReason = {}));\n/**\n * The default end of line to use when instantiating models.\n */\nvar DefaultEndOfLine;\n(function (DefaultEndOfLine) {\n    /**\n     * Use line feed (\\n) as the end of line character.\n     */\n    DefaultEndOfLine[DefaultEndOfLine[\"LF\"] = 1] = \"LF\";\n    /**\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\n     */\n    DefaultEndOfLine[DefaultEndOfLine[\"CRLF\"] = 2] = \"CRLF\";\n})(DefaultEndOfLine || (DefaultEndOfLine = {}));\n/**\n * A document highlight kind.\n */\nvar standaloneEnums_DocumentHighlightKind;\n(function (DocumentHighlightKind) {\n    /**\n     * A textual occurrence.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Text\"] = 0] = \"Text\";\n    /**\n     * Read-access of a symbol, like reading a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Read\"] = 1] = \"Read\";\n    /**\n     * Write-access of a symbol, like writing to a variable.\n     */\n    DocumentHighlightKind[DocumentHighlightKind[\"Write\"] = 2] = \"Write\";\n})(standaloneEnums_DocumentHighlightKind || (standaloneEnums_DocumentHighlightKind = {}));\n/**\n * Configuration options for auto indentation in the editor\n */\nvar EditorAutoIndentStrategy;\n(function (EditorAutoIndentStrategy) {\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"None\"] = 0] = \"None\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Keep\"] = 1] = \"Keep\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Brackets\"] = 2] = \"Brackets\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Advanced\"] = 3] = \"Advanced\";\n    EditorAutoIndentStrategy[EditorAutoIndentStrategy[\"Full\"] = 4] = \"Full\";\n})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));\nvar EditorOption;\n(function (EditorOption) {\n    EditorOption[EditorOption[\"acceptSuggestionOnCommitCharacter\"] = 0] = \"acceptSuggestionOnCommitCharacter\";\n    EditorOption[EditorOption[\"acceptSuggestionOnEnter\"] = 1] = \"acceptSuggestionOnEnter\";\n    EditorOption[EditorOption[\"accessibilitySupport\"] = 2] = \"accessibilitySupport\";\n    EditorOption[EditorOption[\"accessibilityPageSize\"] = 3] = \"accessibilityPageSize\";\n    EditorOption[EditorOption[\"ariaLabel\"] = 4] = \"ariaLabel\";\n    EditorOption[EditorOption[\"ariaRequired\"] = 5] = \"ariaRequired\";\n    EditorOption[EditorOption[\"autoClosingBrackets\"] = 6] = \"autoClosingBrackets\";\n    EditorOption[EditorOption[\"autoClosingComments\"] = 7] = \"autoClosingComments\";\n    EditorOption[EditorOption[\"screenReaderAnnounceInlineSuggestion\"] = 8] = \"screenReaderAnnounceInlineSuggestion\";\n    EditorOption[EditorOption[\"autoClosingDelete\"] = 9] = \"autoClosingDelete\";\n    EditorOption[EditorOption[\"autoClosingOvertype\"] = 10] = \"autoClosingOvertype\";\n    EditorOption[EditorOption[\"autoClosingQuotes\"] = 11] = \"autoClosingQuotes\";\n    EditorOption[EditorOption[\"autoIndent\"] = 12] = \"autoIndent\";\n    EditorOption[EditorOption[\"automaticLayout\"] = 13] = \"automaticLayout\";\n    EditorOption[EditorOption[\"autoSurround\"] = 14] = \"autoSurround\";\n    EditorOption[EditorOption[\"bracketPairColorization\"] = 15] = \"bracketPairColorization\";\n    EditorOption[EditorOption[\"guides\"] = 16] = \"guides\";\n    EditorOption[EditorOption[\"codeLens\"] = 17] = \"codeLens\";\n    EditorOption[EditorOption[\"codeLensFontFamily\"] = 18] = \"codeLensFontFamily\";\n    EditorOption[EditorOption[\"codeLensFontSize\"] = 19] = \"codeLensFontSize\";\n    EditorOption[EditorOption[\"colorDecorators\"] = 20] = \"colorDecorators\";\n    EditorOption[EditorOption[\"colorDecoratorsLimit\"] = 21] = \"colorDecoratorsLimit\";\n    EditorOption[EditorOption[\"columnSelection\"] = 22] = \"columnSelection\";\n    EditorOption[EditorOption[\"comments\"] = 23] = \"comments\";\n    EditorOption[EditorOption[\"contextmenu\"] = 24] = \"contextmenu\";\n    EditorOption[EditorOption[\"copyWithSyntaxHighlighting\"] = 25] = \"copyWithSyntaxHighlighting\";\n    EditorOption[EditorOption[\"cursorBlinking\"] = 26] = \"cursorBlinking\";\n    EditorOption[EditorOption[\"cursorSmoothCaretAnimation\"] = 27] = \"cursorSmoothCaretAnimation\";\n    EditorOption[EditorOption[\"cursorStyle\"] = 28] = \"cursorStyle\";\n    EditorOption[EditorOption[\"cursorSurroundingLines\"] = 29] = \"cursorSurroundingLines\";\n    EditorOption[EditorOption[\"cursorSurroundingLinesStyle\"] = 30] = \"cursorSurroundingLinesStyle\";\n    EditorOption[EditorOption[\"cursorWidth\"] = 31] = \"cursorWidth\";\n    EditorOption[EditorOption[\"disableLayerHinting\"] = 32] = \"disableLayerHinting\";\n    EditorOption[EditorOption[\"disableMonospaceOptimizations\"] = 33] = \"disableMonospaceOptimizations\";\n    EditorOption[EditorOption[\"domReadOnly\"] = 34] = \"domReadOnly\";\n    EditorOption[EditorOption[\"dragAndDrop\"] = 35] = \"dragAndDrop\";\n    EditorOption[EditorOption[\"dropIntoEditor\"] = 36] = \"dropIntoEditor\";\n    EditorOption[EditorOption[\"emptySelectionClipboard\"] = 37] = \"emptySelectionClipboard\";\n    EditorOption[EditorOption[\"experimentalWhitespaceRendering\"] = 38] = \"experimentalWhitespaceRendering\";\n    EditorOption[EditorOption[\"extraEditorClassName\"] = 39] = \"extraEditorClassName\";\n    EditorOption[EditorOption[\"fastScrollSensitivity\"] = 40] = \"fastScrollSensitivity\";\n    EditorOption[EditorOption[\"find\"] = 41] = \"find\";\n    EditorOption[EditorOption[\"fixedOverflowWidgets\"] = 42] = \"fixedOverflowWidgets\";\n    EditorOption[EditorOption[\"folding\"] = 43] = \"folding\";\n    EditorOption[EditorOption[\"foldingStrategy\"] = 44] = \"foldingStrategy\";\n    EditorOption[EditorOption[\"foldingHighlight\"] = 45] = \"foldingHighlight\";\n    EditorOption[EditorOption[\"foldingImportsByDefault\"] = 46] = \"foldingImportsByDefault\";\n    EditorOption[EditorOption[\"foldingMaximumRegions\"] = 47] = \"foldingMaximumRegions\";\n    EditorOption[EditorOption[\"unfoldOnClickAfterEndOfLine\"] = 48] = \"unfoldOnClickAfterEndOfLine\";\n    EditorOption[EditorOption[\"fontFamily\"] = 49] = \"fontFamily\";\n    EditorOption[EditorOption[\"fontInfo\"] = 50] = \"fontInfo\";\n    EditorOption[EditorOption[\"fontLigatures\"] = 51] = \"fontLigatures\";\n    EditorOption[EditorOption[\"fontSize\"] = 52] = \"fontSize\";\n    EditorOption[EditorOption[\"fontWeight\"] = 53] = \"fontWeight\";\n    EditorOption[EditorOption[\"fontVariations\"] = 54] = \"fontVariations\";\n    EditorOption[EditorOption[\"formatOnPaste\"] = 55] = \"formatOnPaste\";\n    EditorOption[EditorOption[\"formatOnType\"] = 56] = \"formatOnType\";\n    EditorOption[EditorOption[\"glyphMargin\"] = 57] = \"glyphMargin\";\n    EditorOption[EditorOption[\"gotoLocation\"] = 58] = \"gotoLocation\";\n    EditorOption[EditorOption[\"hideCursorInOverviewRuler\"] = 59] = \"hideCursorInOverviewRuler\";\n    EditorOption[EditorOption[\"hover\"] = 60] = \"hover\";\n    EditorOption[EditorOption[\"inDiffEditor\"] = 61] = \"inDiffEditor\";\n    EditorOption[EditorOption[\"inlineSuggest\"] = 62] = \"inlineSuggest\";\n    EditorOption[EditorOption[\"inlineEdit\"] = 63] = \"inlineEdit\";\n    EditorOption[EditorOption[\"letterSpacing\"] = 64] = \"letterSpacing\";\n    EditorOption[EditorOption[\"lightbulb\"] = 65] = \"lightbulb\";\n    EditorOption[EditorOption[\"lineDecorationsWidth\"] = 66] = \"lineDecorationsWidth\";\n    EditorOption[EditorOption[\"lineHeight\"] = 67] = \"lineHeight\";\n    EditorOption[EditorOption[\"lineNumbers\"] = 68] = \"lineNumbers\";\n    EditorOption[EditorOption[\"lineNumbersMinChars\"] = 69] = \"lineNumbersMinChars\";\n    EditorOption[EditorOption[\"linkedEditing\"] = 70] = \"linkedEditing\";\n    EditorOption[EditorOption[\"links\"] = 71] = \"links\";\n    EditorOption[EditorOption[\"matchBrackets\"] = 72] = \"matchBrackets\";\n    EditorOption[EditorOption[\"minimap\"] = 73] = \"minimap\";\n    EditorOption[EditorOption[\"mouseStyle\"] = 74] = \"mouseStyle\";\n    EditorOption[EditorOption[\"mouseWheelScrollSensitivity\"] = 75] = \"mouseWheelScrollSensitivity\";\n    EditorOption[EditorOption[\"mouseWheelZoom\"] = 76] = \"mouseWheelZoom\";\n    EditorOption[EditorOption[\"multiCursorMergeOverlapping\"] = 77] = \"multiCursorMergeOverlapping\";\n    EditorOption[EditorOption[\"multiCursorModifier\"] = 78] = \"multiCursorModifier\";\n    EditorOption[EditorOption[\"multiCursorPaste\"] = 79] = \"multiCursorPaste\";\n    EditorOption[EditorOption[\"multiCursorLimit\"] = 80] = \"multiCursorLimit\";\n    EditorOption[EditorOption[\"occurrencesHighlight\"] = 81] = \"occurrencesHighlight\";\n    EditorOption[EditorOption[\"overviewRulerBorder\"] = 82] = \"overviewRulerBorder\";\n    EditorOption[EditorOption[\"overviewRulerLanes\"] = 83] = \"overviewRulerLanes\";\n    EditorOption[EditorOption[\"padding\"] = 84] = \"padding\";\n    EditorOption[EditorOption[\"pasteAs\"] = 85] = \"pasteAs\";\n    EditorOption[EditorOption[\"parameterHints\"] = 86] = \"parameterHints\";\n    EditorOption[EditorOption[\"peekWidgetDefaultFocus\"] = 87] = \"peekWidgetDefaultFocus\";\n    EditorOption[EditorOption[\"definitionLinkOpensInPeek\"] = 88] = \"definitionLinkOpensInPeek\";\n    EditorOption[EditorOption[\"quickSuggestions\"] = 89] = \"quickSuggestions\";\n    EditorOption[EditorOption[\"quickSuggestionsDelay\"] = 90] = \"quickSuggestionsDelay\";\n    EditorOption[EditorOption[\"readOnly\"] = 91] = \"readOnly\";\n    EditorOption[EditorOption[\"readOnlyMessage\"] = 92] = \"readOnlyMessage\";\n    EditorOption[EditorOption[\"renameOnType\"] = 93] = \"renameOnType\";\n    EditorOption[EditorOption[\"renderControlCharacters\"] = 94] = \"renderControlCharacters\";\n    EditorOption[EditorOption[\"renderFinalNewline\"] = 95] = \"renderFinalNewline\";\n    EditorOption[EditorOption[\"renderLineHighlight\"] = 96] = \"renderLineHighlight\";\n    EditorOption[EditorOption[\"renderLineHighlightOnlyWhenFocus\"] = 97] = \"renderLineHighlightOnlyWhenFocus\";\n    EditorOption[EditorOption[\"renderValidationDecorations\"] = 98] = \"renderValidationDecorations\";\n    EditorOption[EditorOption[\"renderWhitespace\"] = 99] = \"renderWhitespace\";\n    EditorOption[EditorOption[\"revealHorizontalRightPadding\"] = 100] = \"revealHorizontalRightPadding\";\n    EditorOption[EditorOption[\"roundedSelection\"] = 101] = \"roundedSelection\";\n    EditorOption[EditorOption[\"rulers\"] = 102] = \"rulers\";\n    EditorOption[EditorOption[\"scrollbar\"] = 103] = \"scrollbar\";\n    EditorOption[EditorOption[\"scrollBeyondLastColumn\"] = 104] = \"scrollBeyondLastColumn\";\n    EditorOption[EditorOption[\"scrollBeyondLastLine\"] = 105] = \"scrollBeyondLastLine\";\n    EditorOption[EditorOption[\"scrollPredominantAxis\"] = 106] = \"scrollPredominantAxis\";\n    EditorOption[EditorOption[\"selectionClipboard\"] = 107] = \"selectionClipboard\";\n    EditorOption[EditorOption[\"selectionHighlight\"] = 108] = \"selectionHighlight\";\n    EditorOption[EditorOption[\"selectOnLineNumbers\"] = 109] = \"selectOnLineNumbers\";\n    EditorOption[EditorOption[\"showFoldingControls\"] = 110] = \"showFoldingControls\";\n    EditorOption[EditorOption[\"showUnused\"] = 111] = \"showUnused\";\n    EditorOption[EditorOption[\"snippetSuggestions\"] = 112] = \"snippetSuggestions\";\n    EditorOption[EditorOption[\"smartSelect\"] = 113] = \"smartSelect\";\n    EditorOption[EditorOption[\"smoothScrolling\"] = 114] = \"smoothScrolling\";\n    EditorOption[EditorOption[\"stickyScroll\"] = 115] = \"stickyScroll\";\n    EditorOption[EditorOption[\"stickyTabStops\"] = 116] = \"stickyTabStops\";\n    EditorOption[EditorOption[\"stopRenderingLineAfter\"] = 117] = \"stopRenderingLineAfter\";\n    EditorOption[EditorOption[\"suggest\"] = 118] = \"suggest\";\n    EditorOption[EditorOption[\"suggestFontSize\"] = 119] = \"suggestFontSize\";\n    EditorOption[EditorOption[\"suggestLineHeight\"] = 120] = \"suggestLineHeight\";\n    EditorOption[EditorOption[\"suggestOnTriggerCharacters\"] = 121] = \"suggestOnTriggerCharacters\";\n    EditorOption[EditorOption[\"suggestSelection\"] = 122] = \"suggestSelection\";\n    EditorOption[EditorOption[\"tabCompletion\"] = 123] = \"tabCompletion\";\n    EditorOption[EditorOption[\"tabIndex\"] = 124] = \"tabIndex\";\n    EditorOption[EditorOption[\"unicodeHighlighting\"] = 125] = \"unicodeHighlighting\";\n    EditorOption[EditorOption[\"unusualLineTerminators\"] = 126] = \"unusualLineTerminators\";\n    EditorOption[EditorOption[\"useShadowDOM\"] = 127] = \"useShadowDOM\";\n    EditorOption[EditorOption[\"useTabStops\"] = 128] = \"useTabStops\";\n    EditorOption[EditorOption[\"wordBreak\"] = 129] = \"wordBreak\";\n    EditorOption[EditorOption[\"wordSegmenterLocales\"] = 130] = \"wordSegmenterLocales\";\n    EditorOption[EditorOption[\"wordSeparators\"] = 131] = \"wordSeparators\";\n    EditorOption[EditorOption[\"wordWrap\"] = 132] = \"wordWrap\";\n    EditorOption[EditorOption[\"wordWrapBreakAfterCharacters\"] = 133] = \"wordWrapBreakAfterCharacters\";\n    EditorOption[EditorOption[\"wordWrapBreakBeforeCharacters\"] = 134] = \"wordWrapBreakBeforeCharacters\";\n    EditorOption[EditorOption[\"wordWrapColumn\"] = 135] = \"wordWrapColumn\";\n    EditorOption[EditorOption[\"wordWrapOverride1\"] = 136] = \"wordWrapOverride1\";\n    EditorOption[EditorOption[\"wordWrapOverride2\"] = 137] = \"wordWrapOverride2\";\n    EditorOption[EditorOption[\"wrappingIndent\"] = 138] = \"wrappingIndent\";\n    EditorOption[EditorOption[\"wrappingStrategy\"] = 139] = \"wrappingStrategy\";\n    EditorOption[EditorOption[\"showDeprecated\"] = 140] = \"showDeprecated\";\n    EditorOption[EditorOption[\"inlayHints\"] = 141] = \"inlayHints\";\n    EditorOption[EditorOption[\"editorClassName\"] = 142] = \"editorClassName\";\n    EditorOption[EditorOption[\"pixelRatio\"] = 143] = \"pixelRatio\";\n    EditorOption[EditorOption[\"tabFocusMode\"] = 144] = \"tabFocusMode\";\n    EditorOption[EditorOption[\"layoutInfo\"] = 145] = \"layoutInfo\";\n    EditorOption[EditorOption[\"wrappingInfo\"] = 146] = \"wrappingInfo\";\n    EditorOption[EditorOption[\"defaultColorDecorators\"] = 147] = \"defaultColorDecorators\";\n    EditorOption[EditorOption[\"colorDecoratorsActivatedOn\"] = 148] = \"colorDecoratorsActivatedOn\";\n    EditorOption[EditorOption[\"inlineCompletionsAccessibilityVerbose\"] = 149] = \"inlineCompletionsAccessibilityVerbose\";\n})(EditorOption || (EditorOption = {}));\n/**\n * End of line character preference.\n */\nvar EndOfLinePreference;\n(function (EndOfLinePreference) {\n    /**\n     * Use the end of line character identified in the text buffer.\n     */\n    EndOfLinePreference[EndOfLinePreference[\"TextDefined\"] = 0] = \"TextDefined\";\n    /**\n     * Use line feed (\\n) as the end of line character.\n     */\n    EndOfLinePreference[EndOfLinePreference[\"LF\"] = 1] = \"LF\";\n    /**\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\n     */\n    EndOfLinePreference[EndOfLinePreference[\"CRLF\"] = 2] = \"CRLF\";\n})(EndOfLinePreference || (EndOfLinePreference = {}));\n/**\n * End of line character preference.\n */\nvar EndOfLineSequence;\n(function (EndOfLineSequence) {\n    /**\n     * Use line feed (\\n) as the end of line character.\n     */\n    EndOfLineSequence[EndOfLineSequence[\"LF\"] = 0] = \"LF\";\n    /**\n     * Use carriage return and line feed (\\r\\n) as the end of line character.\n     */\n    EndOfLineSequence[EndOfLineSequence[\"CRLF\"] = 1] = \"CRLF\";\n})(EndOfLineSequence || (EndOfLineSequence = {}));\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nvar GlyphMarginLane;\n(function (GlyphMarginLane) {\n    GlyphMarginLane[GlyphMarginLane[\"Left\"] = 1] = \"Left\";\n    GlyphMarginLane[GlyphMarginLane[\"Center\"] = 2] = \"Center\";\n    GlyphMarginLane[GlyphMarginLane[\"Right\"] = 3] = \"Right\";\n})(GlyphMarginLane || (GlyphMarginLane = {}));\nvar standaloneEnums_HoverVerbosityAction;\n(function (HoverVerbosityAction) {\n    /**\n     * Increase the verbosity of the hover\n     */\n    HoverVerbosityAction[HoverVerbosityAction[\"Increase\"] = 0] = \"Increase\";\n    /**\n     * Decrease the verbosity of the hover\n     */\n    HoverVerbosityAction[HoverVerbosityAction[\"Decrease\"] = 1] = \"Decrease\";\n})(standaloneEnums_HoverVerbosityAction || (standaloneEnums_HoverVerbosityAction = {}));\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nvar IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\nvar InjectedTextCursorStops;\n(function (InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(InjectedTextCursorStops || (InjectedTextCursorStops = {}));\nvar standaloneEnums_InlayHintKind;\n(function (InlayHintKind) {\n    InlayHintKind[InlayHintKind[\"Type\"] = 1] = \"Type\";\n    InlayHintKind[InlayHintKind[\"Parameter\"] = 2] = \"Parameter\";\n})(standaloneEnums_InlayHintKind || (standaloneEnums_InlayHintKind = {}));\n/**\n * How an {@link InlineCompletionsProvider inline completion provider} was triggered.\n */\nvar standaloneEnums_InlineCompletionTriggerKind;\n(function (InlineCompletionTriggerKind) {\n    /**\n     * Completion was triggered automatically while editing.\n     * It is sufficient to return a single completion item in this case.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Automatic\"] = 0] = \"Automatic\";\n    /**\n     * Completion was triggered explicitly by a user gesture.\n     * Return multiple completion items to enable cycling through them.\n     */\n    InlineCompletionTriggerKind[InlineCompletionTriggerKind[\"Explicit\"] = 1] = \"Explicit\";\n})(standaloneEnums_InlineCompletionTriggerKind || (standaloneEnums_InlineCompletionTriggerKind = {}));\nvar standaloneEnums_InlineEditTriggerKind;\n(function (InlineEditTriggerKind) {\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    InlineEditTriggerKind[InlineEditTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(standaloneEnums_InlineEditTriggerKind || (standaloneEnums_InlineEditTriggerKind = {}));\n/**\n * Virtual Key Codes, the value does not hold any inherent meaning.\n * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx\n * But these are \"more general\", as they should work across browsers & OS`s.\n */\nvar KeyCode;\n(function (KeyCode) {\n    KeyCode[KeyCode[\"DependsOnKbLayout\"] = -1] = \"DependsOnKbLayout\";\n    /**\n     * Placed first to cover the 0 value of the enum.\n     */\n    KeyCode[KeyCode[\"Unknown\"] = 0] = \"Unknown\";\n    KeyCode[KeyCode[\"Backspace\"] = 1] = \"Backspace\";\n    KeyCode[KeyCode[\"Tab\"] = 2] = \"Tab\";\n    KeyCode[KeyCode[\"Enter\"] = 3] = \"Enter\";\n    KeyCode[KeyCode[\"Shift\"] = 4] = \"Shift\";\n    KeyCode[KeyCode[\"Ctrl\"] = 5] = \"Ctrl\";\n    KeyCode[KeyCode[\"Alt\"] = 6] = \"Alt\";\n    KeyCode[KeyCode[\"PauseBreak\"] = 7] = \"PauseBreak\";\n    KeyCode[KeyCode[\"CapsLock\"] = 8] = \"CapsLock\";\n    KeyCode[KeyCode[\"Escape\"] = 9] = \"Escape\";\n    KeyCode[KeyCode[\"Space\"] = 10] = \"Space\";\n    KeyCode[KeyCode[\"PageUp\"] = 11] = \"PageUp\";\n    KeyCode[KeyCode[\"PageDown\"] = 12] = \"PageDown\";\n    KeyCode[KeyCode[\"End\"] = 13] = \"End\";\n    KeyCode[KeyCode[\"Home\"] = 14] = \"Home\";\n    KeyCode[KeyCode[\"LeftArrow\"] = 15] = \"LeftArrow\";\n    KeyCode[KeyCode[\"UpArrow\"] = 16] = \"UpArrow\";\n    KeyCode[KeyCode[\"RightArrow\"] = 17] = \"RightArrow\";\n    KeyCode[KeyCode[\"DownArrow\"] = 18] = \"DownArrow\";\n    KeyCode[KeyCode[\"Insert\"] = 19] = \"Insert\";\n    KeyCode[KeyCode[\"Delete\"] = 20] = \"Delete\";\n    KeyCode[KeyCode[\"Digit0\"] = 21] = \"Digit0\";\n    KeyCode[KeyCode[\"Digit1\"] = 22] = \"Digit1\";\n    KeyCode[KeyCode[\"Digit2\"] = 23] = \"Digit2\";\n    KeyCode[KeyCode[\"Digit3\"] = 24] = \"Digit3\";\n    KeyCode[KeyCode[\"Digit4\"] = 25] = \"Digit4\";\n    KeyCode[KeyCode[\"Digit5\"] = 26] = \"Digit5\";\n    KeyCode[KeyCode[\"Digit6\"] = 27] = \"Digit6\";\n    KeyCode[KeyCode[\"Digit7\"] = 28] = \"Digit7\";\n    KeyCode[KeyCode[\"Digit8\"] = 29] = \"Digit8\";\n    KeyCode[KeyCode[\"Digit9\"] = 30] = \"Digit9\";\n    KeyCode[KeyCode[\"KeyA\"] = 31] = \"KeyA\";\n    KeyCode[KeyCode[\"KeyB\"] = 32] = \"KeyB\";\n    KeyCode[KeyCode[\"KeyC\"] = 33] = \"KeyC\";\n    KeyCode[KeyCode[\"KeyD\"] = 34] = \"KeyD\";\n    KeyCode[KeyCode[\"KeyE\"] = 35] = \"KeyE\";\n    KeyCode[KeyCode[\"KeyF\"] = 36] = \"KeyF\";\n    KeyCode[KeyCode[\"KeyG\"] = 37] = \"KeyG\";\n    KeyCode[KeyCode[\"KeyH\"] = 38] = \"KeyH\";\n    KeyCode[KeyCode[\"KeyI\"] = 39] = \"KeyI\";\n    KeyCode[KeyCode[\"KeyJ\"] = 40] = \"KeyJ\";\n    KeyCode[KeyCode[\"KeyK\"] = 41] = \"KeyK\";\n    KeyCode[KeyCode[\"KeyL\"] = 42] = \"KeyL\";\n    KeyCode[KeyCode[\"KeyM\"] = 43] = \"KeyM\";\n    KeyCode[KeyCode[\"KeyN\"] = 44] = \"KeyN\";\n    KeyCode[KeyCode[\"KeyO\"] = 45] = \"KeyO\";\n    KeyCode[KeyCode[\"KeyP\"] = 46] = \"KeyP\";\n    KeyCode[KeyCode[\"KeyQ\"] = 47] = \"KeyQ\";\n    KeyCode[KeyCode[\"KeyR\"] = 48] = \"KeyR\";\n    KeyCode[KeyCode[\"KeyS\"] = 49] = \"KeyS\";\n    KeyCode[KeyCode[\"KeyT\"] = 50] = \"KeyT\";\n    KeyCode[KeyCode[\"KeyU\"] = 51] = \"KeyU\";\n    KeyCode[KeyCode[\"KeyV\"] = 52] = \"KeyV\";\n    KeyCode[KeyCode[\"KeyW\"] = 53] = \"KeyW\";\n    KeyCode[KeyCode[\"KeyX\"] = 54] = \"KeyX\";\n    KeyCode[KeyCode[\"KeyY\"] = 55] = \"KeyY\";\n    KeyCode[KeyCode[\"KeyZ\"] = 56] = \"KeyZ\";\n    KeyCode[KeyCode[\"Meta\"] = 57] = \"Meta\";\n    KeyCode[KeyCode[\"ContextMenu\"] = 58] = \"ContextMenu\";\n    KeyCode[KeyCode[\"F1\"] = 59] = \"F1\";\n    KeyCode[KeyCode[\"F2\"] = 60] = \"F2\";\n    KeyCode[KeyCode[\"F3\"] = 61] = \"F3\";\n    KeyCode[KeyCode[\"F4\"] = 62] = \"F4\";\n    KeyCode[KeyCode[\"F5\"] = 63] = \"F5\";\n    KeyCode[KeyCode[\"F6\"] = 64] = \"F6\";\n    KeyCode[KeyCode[\"F7\"] = 65] = \"F7\";\n    KeyCode[KeyCode[\"F8\"] = 66] = \"F8\";\n    KeyCode[KeyCode[\"F9\"] = 67] = \"F9\";\n    KeyCode[KeyCode[\"F10\"] = 68] = \"F10\";\n    KeyCode[KeyCode[\"F11\"] = 69] = \"F11\";\n    KeyCode[KeyCode[\"F12\"] = 70] = \"F12\";\n    KeyCode[KeyCode[\"F13\"] = 71] = \"F13\";\n    KeyCode[KeyCode[\"F14\"] = 72] = \"F14\";\n    KeyCode[KeyCode[\"F15\"] = 73] = \"F15\";\n    KeyCode[KeyCode[\"F16\"] = 74] = \"F16\";\n    KeyCode[KeyCode[\"F17\"] = 75] = \"F17\";\n    KeyCode[KeyCode[\"F18\"] = 76] = \"F18\";\n    KeyCode[KeyCode[\"F19\"] = 77] = \"F19\";\n    KeyCode[KeyCode[\"F20\"] = 78] = \"F20\";\n    KeyCode[KeyCode[\"F21\"] = 79] = \"F21\";\n    KeyCode[KeyCode[\"F22\"] = 80] = \"F22\";\n    KeyCode[KeyCode[\"F23\"] = 81] = \"F23\";\n    KeyCode[KeyCode[\"F24\"] = 82] = \"F24\";\n    KeyCode[KeyCode[\"NumLock\"] = 83] = \"NumLock\";\n    KeyCode[KeyCode[\"ScrollLock\"] = 84] = \"ScrollLock\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the ';:' key\n     */\n    KeyCode[KeyCode[\"Semicolon\"] = 85] = \"Semicolon\";\n    /**\n     * For any country/region, the '+' key\n     * For the US standard keyboard, the '=+' key\n     */\n    KeyCode[KeyCode[\"Equal\"] = 86] = \"Equal\";\n    /**\n     * For any country/region, the ',' key\n     * For the US standard keyboard, the ',<' key\n     */\n    KeyCode[KeyCode[\"Comma\"] = 87] = \"Comma\";\n    /**\n     * For any country/region, the '-' key\n     * For the US standard keyboard, the '-_' key\n     */\n    KeyCode[KeyCode[\"Minus\"] = 88] = \"Minus\";\n    /**\n     * For any country/region, the '.' key\n     * For the US standard keyboard, the '.>' key\n     */\n    KeyCode[KeyCode[\"Period\"] = 89] = \"Period\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '/?' key\n     */\n    KeyCode[KeyCode[\"Slash\"] = 90] = \"Slash\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '`~' key\n     */\n    KeyCode[KeyCode[\"Backquote\"] = 91] = \"Backquote\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '[{' key\n     */\n    KeyCode[KeyCode[\"BracketLeft\"] = 92] = \"BracketLeft\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the '\\|' key\n     */\n    KeyCode[KeyCode[\"Backslash\"] = 93] = \"Backslash\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the ']}' key\n     */\n    KeyCode[KeyCode[\"BracketRight\"] = 94] = \"BracketRight\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     * For the US standard keyboard, the ''\"' key\n     */\n    KeyCode[KeyCode[\"Quote\"] = 95] = \"Quote\";\n    /**\n     * Used for miscellaneous characters; it can vary by keyboard.\n     */\n    KeyCode[KeyCode[\"OEM_8\"] = 96] = \"OEM_8\";\n    /**\n     * Either the angle bracket key or the backslash key on the RT 102-key keyboard.\n     */\n    KeyCode[KeyCode[\"IntlBackslash\"] = 97] = \"IntlBackslash\";\n    KeyCode[KeyCode[\"Numpad0\"] = 98] = \"Numpad0\";\n    KeyCode[KeyCode[\"Numpad1\"] = 99] = \"Numpad1\";\n    KeyCode[KeyCode[\"Numpad2\"] = 100] = \"Numpad2\";\n    KeyCode[KeyCode[\"Numpad3\"] = 101] = \"Numpad3\";\n    KeyCode[KeyCode[\"Numpad4\"] = 102] = \"Numpad4\";\n    KeyCode[KeyCode[\"Numpad5\"] = 103] = \"Numpad5\";\n    KeyCode[KeyCode[\"Numpad6\"] = 104] = \"Numpad6\";\n    KeyCode[KeyCode[\"Numpad7\"] = 105] = \"Numpad7\";\n    KeyCode[KeyCode[\"Numpad8\"] = 106] = \"Numpad8\";\n    KeyCode[KeyCode[\"Numpad9\"] = 107] = \"Numpad9\";\n    KeyCode[KeyCode[\"NumpadMultiply\"] = 108] = \"NumpadMultiply\";\n    KeyCode[KeyCode[\"NumpadAdd\"] = 109] = \"NumpadAdd\";\n    KeyCode[KeyCode[\"NUMPAD_SEPARATOR\"] = 110] = \"NUMPAD_SEPARATOR\";\n    KeyCode[KeyCode[\"NumpadSubtract\"] = 111] = \"NumpadSubtract\";\n    KeyCode[KeyCode[\"NumpadDecimal\"] = 112] = \"NumpadDecimal\";\n    KeyCode[KeyCode[\"NumpadDivide\"] = 113] = \"NumpadDivide\";\n    /**\n     * Cover all key codes when IME is processing input.\n     */\n    KeyCode[KeyCode[\"KEY_IN_COMPOSITION\"] = 114] = \"KEY_IN_COMPOSITION\";\n    KeyCode[KeyCode[\"ABNT_C1\"] = 115] = \"ABNT_C1\";\n    KeyCode[KeyCode[\"ABNT_C2\"] = 116] = \"ABNT_C2\";\n    KeyCode[KeyCode[\"AudioVolumeMute\"] = 117] = \"AudioVolumeMute\";\n    KeyCode[KeyCode[\"AudioVolumeUp\"] = 118] = \"AudioVolumeUp\";\n    KeyCode[KeyCode[\"AudioVolumeDown\"] = 119] = \"AudioVolumeDown\";\n    KeyCode[KeyCode[\"BrowserSearch\"] = 120] = \"BrowserSearch\";\n    KeyCode[KeyCode[\"BrowserHome\"] = 121] = \"BrowserHome\";\n    KeyCode[KeyCode[\"BrowserBack\"] = 122] = \"BrowserBack\";\n    KeyCode[KeyCode[\"BrowserForward\"] = 123] = \"BrowserForward\";\n    KeyCode[KeyCode[\"MediaTrackNext\"] = 124] = \"MediaTrackNext\";\n    KeyCode[KeyCode[\"MediaTrackPrevious\"] = 125] = \"MediaTrackPrevious\";\n    KeyCode[KeyCode[\"MediaStop\"] = 126] = \"MediaStop\";\n    KeyCode[KeyCode[\"MediaPlayPause\"] = 127] = \"MediaPlayPause\";\n    KeyCode[KeyCode[\"LaunchMediaPlayer\"] = 128] = \"LaunchMediaPlayer\";\n    KeyCode[KeyCode[\"LaunchMail\"] = 129] = \"LaunchMail\";\n    KeyCode[KeyCode[\"LaunchApp2\"] = 130] = \"LaunchApp2\";\n    /**\n     * VK_CLEAR, 0x0C, CLEAR key\n     */\n    KeyCode[KeyCode[\"Clear\"] = 131] = \"Clear\";\n    /**\n     * Placed last to cover the length of the enum.\n     * Please do not depend on this value!\n     */\n    KeyCode[KeyCode[\"MAX_VALUE\"] = 132] = \"MAX_VALUE\";\n})(KeyCode || (KeyCode = {}));\nvar MarkerSeverity;\n(function (MarkerSeverity) {\n    MarkerSeverity[MarkerSeverity[\"Hint\"] = 1] = \"Hint\";\n    MarkerSeverity[MarkerSeverity[\"Info\"] = 2] = \"Info\";\n    MarkerSeverity[MarkerSeverity[\"Warning\"] = 4] = \"Warning\";\n    MarkerSeverity[MarkerSeverity[\"Error\"] = 8] = \"Error\";\n})(MarkerSeverity || (MarkerSeverity = {}));\nvar MarkerTag;\n(function (MarkerTag) {\n    MarkerTag[MarkerTag[\"Unnecessary\"] = 1] = \"Unnecessary\";\n    MarkerTag[MarkerTag[\"Deprecated\"] = 2] = \"Deprecated\";\n})(MarkerTag || (MarkerTag = {}));\n/**\n * Position in the minimap to render the decoration.\n */\nvar MinimapPosition;\n(function (MinimapPosition) {\n    MinimapPosition[MinimapPosition[\"Inline\"] = 1] = \"Inline\";\n    MinimapPosition[MinimapPosition[\"Gutter\"] = 2] = \"Gutter\";\n})(MinimapPosition || (MinimapPosition = {}));\n/**\n * Section header style.\n */\nvar MinimapSectionHeaderStyle;\n(function (MinimapSectionHeaderStyle) {\n    MinimapSectionHeaderStyle[MinimapSectionHeaderStyle[\"Normal\"] = 1] = \"Normal\";\n    MinimapSectionHeaderStyle[MinimapSectionHeaderStyle[\"Underlined\"] = 2] = \"Underlined\";\n})(MinimapSectionHeaderStyle || (MinimapSectionHeaderStyle = {}));\n/**\n * Type of hit element with the mouse in the editor.\n */\nvar MouseTargetType;\n(function (MouseTargetType) {\n    /**\n     * Mouse is on top of an unknown element.\n     */\n    MouseTargetType[MouseTargetType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    /**\n     * Mouse is on top of the textarea used for input.\n     */\n    MouseTargetType[MouseTargetType[\"TEXTAREA\"] = 1] = \"TEXTAREA\";\n    /**\n     * Mouse is on top of the glyph margin\n     */\n    MouseTargetType[MouseTargetType[\"GUTTER_GLYPH_MARGIN\"] = 2] = \"GUTTER_GLYPH_MARGIN\";\n    /**\n     * Mouse is on top of the line numbers\n     */\n    MouseTargetType[MouseTargetType[\"GUTTER_LINE_NUMBERS\"] = 3] = \"GUTTER_LINE_NUMBERS\";\n    /**\n     * Mouse is on top of the line decorations\n     */\n    MouseTargetType[MouseTargetType[\"GUTTER_LINE_DECORATIONS\"] = 4] = \"GUTTER_LINE_DECORATIONS\";\n    /**\n     * Mouse is on top of the whitespace left in the gutter by a view zone.\n     */\n    MouseTargetType[MouseTargetType[\"GUTTER_VIEW_ZONE\"] = 5] = \"GUTTER_VIEW_ZONE\";\n    /**\n     * Mouse is on top of text in the content.\n     */\n    MouseTargetType[MouseTargetType[\"CONTENT_TEXT\"] = 6] = \"CONTENT_TEXT\";\n    /**\n     * Mouse is on top of empty space in the content (e.g. after line text or below last line)\n     */\n    MouseTargetType[MouseTargetType[\"CONTENT_EMPTY\"] = 7] = \"CONTENT_EMPTY\";\n    /**\n     * Mouse is on top of a view zone in the content.\n     */\n    MouseTargetType[MouseTargetType[\"CONTENT_VIEW_ZONE\"] = 8] = \"CONTENT_VIEW_ZONE\";\n    /**\n     * Mouse is on top of a content widget.\n     */\n    MouseTargetType[MouseTargetType[\"CONTENT_WIDGET\"] = 9] = \"CONTENT_WIDGET\";\n    /**\n     * Mouse is on top of the decorations overview ruler.\n     */\n    MouseTargetType[MouseTargetType[\"OVERVIEW_RULER\"] = 10] = \"OVERVIEW_RULER\";\n    /**\n     * Mouse is on top of a scrollbar.\n     */\n    MouseTargetType[MouseTargetType[\"SCROLLBAR\"] = 11] = \"SCROLLBAR\";\n    /**\n     * Mouse is on top of an overlay widget.\n     */\n    MouseTargetType[MouseTargetType[\"OVERLAY_WIDGET\"] = 12] = \"OVERLAY_WIDGET\";\n    /**\n     * Mouse is outside of the editor.\n     */\n    MouseTargetType[MouseTargetType[\"OUTSIDE_EDITOR\"] = 13] = \"OUTSIDE_EDITOR\";\n})(MouseTargetType || (MouseTargetType = {}));\nvar standaloneEnums_NewSymbolNameTag;\n(function (NewSymbolNameTag) {\n    NewSymbolNameTag[NewSymbolNameTag[\"AIGenerated\"] = 1] = \"AIGenerated\";\n})(standaloneEnums_NewSymbolNameTag || (standaloneEnums_NewSymbolNameTag = {}));\nvar standaloneEnums_NewSymbolNameTriggerKind;\n(function (NewSymbolNameTriggerKind) {\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Invoke\"] = 0] = \"Invoke\";\n    NewSymbolNameTriggerKind[NewSymbolNameTriggerKind[\"Automatic\"] = 1] = \"Automatic\";\n})(standaloneEnums_NewSymbolNameTriggerKind || (standaloneEnums_NewSymbolNameTriggerKind = {}));\n/**\n * A positioning preference for rendering overlay widgets.\n */\nvar OverlayWidgetPositionPreference;\n(function (OverlayWidgetPositionPreference) {\n    /**\n     * Position the overlay widget in the top right corner\n     */\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"TOP_RIGHT_CORNER\"] = 0] = \"TOP_RIGHT_CORNER\";\n    /**\n     * Position the overlay widget in the bottom right corner\n     */\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"BOTTOM_RIGHT_CORNER\"] = 1] = \"BOTTOM_RIGHT_CORNER\";\n    /**\n     * Position the overlay widget in the top center\n     */\n    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference[\"TOP_CENTER\"] = 2] = \"TOP_CENTER\";\n})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nvar OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(OverviewRulerLane || (OverviewRulerLane = {}));\n/**\n * How a partial acceptance was triggered.\n */\nvar PartialAcceptTriggerKind;\n(function (PartialAcceptTriggerKind) {\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Word\"] = 0] = \"Word\";\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Line\"] = 1] = \"Line\";\n    PartialAcceptTriggerKind[PartialAcceptTriggerKind[\"Suggest\"] = 2] = \"Suggest\";\n})(PartialAcceptTriggerKind || (PartialAcceptTriggerKind = {}));\nvar PositionAffinity;\n(function (PositionAffinity) {\n    /**\n     * Prefers the left most position.\n    */\n    PositionAffinity[PositionAffinity[\"Left\"] = 0] = \"Left\";\n    /**\n     * Prefers the right most position.\n    */\n    PositionAffinity[PositionAffinity[\"Right\"] = 1] = \"Right\";\n    /**\n     * No preference.\n    */\n    PositionAffinity[PositionAffinity[\"None\"] = 2] = \"None\";\n    /**\n     * If the given position is on injected text, prefers the position left of it.\n    */\n    PositionAffinity[PositionAffinity[\"LeftOfInjectedText\"] = 3] = \"LeftOfInjectedText\";\n    /**\n     * If the given position is on injected text, prefers the position right of it.\n    */\n    PositionAffinity[PositionAffinity[\"RightOfInjectedText\"] = 4] = \"RightOfInjectedText\";\n})(PositionAffinity || (PositionAffinity = {}));\nvar RenderLineNumbersType;\n(function (RenderLineNumbersType) {\n    RenderLineNumbersType[RenderLineNumbersType[\"Off\"] = 0] = \"Off\";\n    RenderLineNumbersType[RenderLineNumbersType[\"On\"] = 1] = \"On\";\n    RenderLineNumbersType[RenderLineNumbersType[\"Relative\"] = 2] = \"Relative\";\n    RenderLineNumbersType[RenderLineNumbersType[\"Interval\"] = 3] = \"Interval\";\n    RenderLineNumbersType[RenderLineNumbersType[\"Custom\"] = 4] = \"Custom\";\n})(RenderLineNumbersType || (RenderLineNumbersType = {}));\nvar RenderMinimap;\n(function (RenderMinimap) {\n    RenderMinimap[RenderMinimap[\"None\"] = 0] = \"None\";\n    RenderMinimap[RenderMinimap[\"Text\"] = 1] = \"Text\";\n    RenderMinimap[RenderMinimap[\"Blocks\"] = 2] = \"Blocks\";\n})(RenderMinimap || (RenderMinimap = {}));\nvar ScrollType;\n(function (ScrollType) {\n    ScrollType[ScrollType[\"Smooth\"] = 0] = \"Smooth\";\n    ScrollType[ScrollType[\"Immediate\"] = 1] = \"Immediate\";\n})(ScrollType || (ScrollType = {}));\nvar ScrollbarVisibility;\n(function (ScrollbarVisibility) {\n    ScrollbarVisibility[ScrollbarVisibility[\"Auto\"] = 1] = \"Auto\";\n    ScrollbarVisibility[ScrollbarVisibility[\"Hidden\"] = 2] = \"Hidden\";\n    ScrollbarVisibility[ScrollbarVisibility[\"Visible\"] = 3] = \"Visible\";\n})(ScrollbarVisibility || (ScrollbarVisibility = {}));\n/**\n * The direction of a selection.\n */\nvar SelectionDirection;\n(function (SelectionDirection) {\n    /**\n     * The selection starts above where it ends.\n     */\n    SelectionDirection[SelectionDirection[\"LTR\"] = 0] = \"LTR\";\n    /**\n     * The selection starts below where it ends.\n     */\n    SelectionDirection[SelectionDirection[\"RTL\"] = 1] = \"RTL\";\n})(SelectionDirection || (SelectionDirection = {}));\nvar ShowLightbulbIconMode;\n(function (ShowLightbulbIconMode) {\n    ShowLightbulbIconMode[\"Off\"] = \"off\";\n    ShowLightbulbIconMode[\"OnCode\"] = \"onCode\";\n    ShowLightbulbIconMode[\"On\"] = \"on\";\n})(ShowLightbulbIconMode || (ShowLightbulbIconMode = {}));\nvar standaloneEnums_SignatureHelpTriggerKind;\n(function (SignatureHelpTriggerKind) {\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"Invoke\"] = 1] = \"Invoke\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"TriggerCharacter\"] = 2] = \"TriggerCharacter\";\n    SignatureHelpTriggerKind[SignatureHelpTriggerKind[\"ContentChange\"] = 3] = \"ContentChange\";\n})(standaloneEnums_SignatureHelpTriggerKind || (standaloneEnums_SignatureHelpTriggerKind = {}));\n/**\n * A symbol kind.\n */\nvar SymbolKind;\n(function (SymbolKind) {\n    SymbolKind[SymbolKind[\"File\"] = 0] = \"File\";\n    SymbolKind[SymbolKind[\"Module\"] = 1] = \"Module\";\n    SymbolKind[SymbolKind[\"Namespace\"] = 2] = \"Namespace\";\n    SymbolKind[SymbolKind[\"Package\"] = 3] = \"Package\";\n    SymbolKind[SymbolKind[\"Class\"] = 4] = \"Class\";\n    SymbolKind[SymbolKind[\"Method\"] = 5] = \"Method\";\n    SymbolKind[SymbolKind[\"Property\"] = 6] = \"Property\";\n    SymbolKind[SymbolKind[\"Field\"] = 7] = \"Field\";\n    SymbolKind[SymbolKind[\"Constructor\"] = 8] = \"Constructor\";\n    SymbolKind[SymbolKind[\"Enum\"] = 9] = \"Enum\";\n    SymbolKind[SymbolKind[\"Interface\"] = 10] = \"Interface\";\n    SymbolKind[SymbolKind[\"Function\"] = 11] = \"Function\";\n    SymbolKind[SymbolKind[\"Variable\"] = 12] = \"Variable\";\n    SymbolKind[SymbolKind[\"Constant\"] = 13] = \"Constant\";\n    SymbolKind[SymbolKind[\"String\"] = 14] = \"String\";\n    SymbolKind[SymbolKind[\"Number\"] = 15] = \"Number\";\n    SymbolKind[SymbolKind[\"Boolean\"] = 16] = \"Boolean\";\n    SymbolKind[SymbolKind[\"Array\"] = 17] = \"Array\";\n    SymbolKind[SymbolKind[\"Object\"] = 18] = \"Object\";\n    SymbolKind[SymbolKind[\"Key\"] = 19] = \"Key\";\n    SymbolKind[SymbolKind[\"Null\"] = 20] = \"Null\";\n    SymbolKind[SymbolKind[\"EnumMember\"] = 21] = \"EnumMember\";\n    SymbolKind[SymbolKind[\"Struct\"] = 22] = \"Struct\";\n    SymbolKind[SymbolKind[\"Event\"] = 23] = \"Event\";\n    SymbolKind[SymbolKind[\"Operator\"] = 24] = \"Operator\";\n    SymbolKind[SymbolKind[\"TypeParameter\"] = 25] = \"TypeParameter\";\n})(SymbolKind || (SymbolKind = {}));\nvar SymbolTag;\n(function (SymbolTag) {\n    SymbolTag[SymbolTag[\"Deprecated\"] = 1] = \"Deprecated\";\n})(SymbolTag || (SymbolTag = {}));\n/**\n * The kind of animation in which the editor's cursor should be rendered.\n */\nvar TextEditorCursorBlinkingStyle;\n(function (TextEditorCursorBlinkingStyle) {\n    /**\n     * Hidden\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Hidden\"] = 0] = \"Hidden\";\n    /**\n     * Blinking\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Blink\"] = 1] = \"Blink\";\n    /**\n     * Blinking with smooth fading\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Smooth\"] = 2] = \"Smooth\";\n    /**\n     * Blinking with prolonged filled state and smooth fading\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Phase\"] = 3] = \"Phase\";\n    /**\n     * Expand collapse animation on the y axis\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Expand\"] = 4] = \"Expand\";\n    /**\n     * No-Blinking\n     */\n    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle[\"Solid\"] = 5] = \"Solid\";\n})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));\n/**\n * The style in which the editor's cursor should be rendered.\n */\nvar TextEditorCursorStyle;\n(function (TextEditorCursorStyle) {\n    /**\n     * As a vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Line\"] = 1] = \"Line\";\n    /**\n     * As a block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Block\"] = 2] = \"Block\";\n    /**\n     * As a horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"Underline\"] = 3] = \"Underline\";\n    /**\n     * As a thin vertical line (sitting between two characters).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"LineThin\"] = 4] = \"LineThin\";\n    /**\n     * As an outlined block (sitting on top of a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"BlockOutline\"] = 5] = \"BlockOutline\";\n    /**\n     * As a thin horizontal line (sitting under a character).\n     */\n    TextEditorCursorStyle[TextEditorCursorStyle[\"UnderlineThin\"] = 6] = \"UnderlineThin\";\n})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));\n/**\n * Describes the behavior of decorations when typing/editing near their edges.\n * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`\n */\nvar TrackedRangeStickiness;\n(function (TrackedRangeStickiness) {\n    TrackedRangeStickiness[TrackedRangeStickiness[\"AlwaysGrowsWhenTypingAtEdges\"] = 0] = \"AlwaysGrowsWhenTypingAtEdges\";\n    TrackedRangeStickiness[TrackedRangeStickiness[\"NeverGrowsWhenTypingAtEdges\"] = 1] = \"NeverGrowsWhenTypingAtEdges\";\n    TrackedRangeStickiness[TrackedRangeStickiness[\"GrowsOnlyWhenTypingBefore\"] = 2] = \"GrowsOnlyWhenTypingBefore\";\n    TrackedRangeStickiness[TrackedRangeStickiness[\"GrowsOnlyWhenTypingAfter\"] = 3] = \"GrowsOnlyWhenTypingAfter\";\n})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));\n/**\n * Describes how to indent wrapped lines.\n */\nvar WrappingIndent;\n(function (WrappingIndent) {\n    /**\n     * No indentation => wrapped lines begin at column 1.\n     */\n    WrappingIndent[WrappingIndent[\"None\"] = 0] = \"None\";\n    /**\n     * Same => wrapped lines get the same indentation as the parent.\n     */\n    WrappingIndent[WrappingIndent[\"Same\"] = 1] = \"Same\";\n    /**\n     * Indent => wrapped lines get +1 indentation toward the parent.\n     */\n    WrappingIndent[WrappingIndent[\"Indent\"] = 2] = \"Indent\";\n    /**\n     * DeepIndent => wrapped lines get +2 indentation toward the parent.\n     */\n    WrappingIndent[WrappingIndent[\"DeepIndent\"] = 3] = \"DeepIndent\";\n})(WrappingIndent || (WrappingIndent = {}));\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\nclass KeyMod {\n    static chord(firstPart, secondPart) {\n        return KeyChord(firstPart, secondPart);\n    }\n}\nKeyMod.CtrlCmd = 2048 /* ConstKeyMod.CtrlCmd */;\nKeyMod.Shift = 1024 /* ConstKeyMod.Shift */;\nKeyMod.Alt = 512 /* ConstKeyMod.Alt */;\nKeyMod.WinCtrl = 256 /* ConstKeyMod.WinCtrl */;\nfunction createMonacoBaseAPI() {\n    return {\n        editor: undefined, // undefined override expected here\n        languages: undefined, // undefined override expected here\n        CancellationTokenSource: CancellationTokenSource,\n        Emitter: Emitter,\n        KeyCode: KeyCode,\n        KeyMod: KeyMod,\n        Position: position_Position,\n        Range: range_Range,\n        Selection: Selection,\n        SelectionDirection: SelectionDirection,\n        MarkerSeverity: MarkerSeverity,\n        MarkerTag: MarkerTag,\n        Uri: uri_URI,\n        Token: Token\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/map.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar map_a, map_b;\nclass ResourceMapEntry {\n    constructor(uri, value) {\n        this.uri = uri;\n        this.value = value;\n    }\n}\nfunction isEntries(arg) {\n    return Array.isArray(arg);\n}\nclass ResourceMap {\n    constructor(arg, toKey) {\n        this[map_a] = 'ResourceMap';\n        if (arg instanceof ResourceMap) {\n            this.map = new Map(arg.map);\n            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\n        }\n        else if (isEntries(arg)) {\n            this.map = new Map();\n            this.toKey = toKey !== null && toKey !== void 0 ? toKey : ResourceMap.defaultToKey;\n            for (const [resource, value] of arg) {\n                this.set(resource, value);\n            }\n        }\n        else {\n            this.map = new Map();\n            this.toKey = arg !== null && arg !== void 0 ? arg : ResourceMap.defaultToKey;\n        }\n    }\n    set(resource, value) {\n        this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n        return this;\n    }\n    get(resource) {\n        var _c;\n        return (_c = this.map.get(this.toKey(resource))) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    has(resource) {\n        return this.map.has(this.toKey(resource));\n    }\n    get size() {\n        return this.map.size;\n    }\n    clear() {\n        this.map.clear();\n    }\n    delete(resource) {\n        return this.map.delete(this.toKey(resource));\n    }\n    forEach(clb, thisArg) {\n        if (typeof thisArg !== 'undefined') {\n            clb = clb.bind(thisArg);\n        }\n        for (const [_, entry] of this.map) {\n            clb(entry.value, entry.uri, this);\n        }\n    }\n    *values() {\n        for (const entry of this.map.values()) {\n            yield entry.value;\n        }\n    }\n    *keys() {\n        for (const entry of this.map.values()) {\n            yield entry.uri;\n        }\n    }\n    *entries() {\n        for (const entry of this.map.values()) {\n            yield [entry.uri, entry.value];\n        }\n    }\n    *[(map_a = Symbol.toStringTag, Symbol.iterator)]() {\n        for (const [, entry] of this.map) {\n            yield [entry.uri, entry.value];\n        }\n    }\n}\nResourceMap.defaultToKey = (resource) => resource.toString();\nclass LinkedMap {\n    constructor() {\n        this[map_b] = 'LinkedMap';\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        var _c;\n        return (_c = this._head) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    get last() {\n        var _c;\n        return (_c = this._tail) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    has(key) {\n        return this._map.has(key);\n    }\n    get(key, touch = 0 /* Touch.None */) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== 0 /* Touch.None */) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = 0 /* Touch.None */) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== 0 /* Touch.None */) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case 0 /* Touch.None */:\n                    this.addItemLast(item);\n                    break;\n                case 1 /* Touch.AsOld */:\n                    this.addItemFirst(item);\n                    break;\n                case 2 /* Touch.AsNew */:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw new Error(`LinkedMap got modified during iteration.`);\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [(map_b = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    trimNew(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._tail;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.previous;\n            currentSize--;\n        }\n        this._tail = current;\n        this._size = currentSize;\n        if (current) {\n            current.next = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            // This can only happen if size === 1 which is handled\n            // by the case above.\n            if (!item.next) {\n                throw new Error('Invalid list');\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            // This can only happen if size === 1 which is handled\n            // by the case above.\n            if (!item.previous) {\n                throw new Error('Invalid list');\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== 1 /* Touch.AsOld */ && touch !== 2 /* Touch.AsNew */)) {\n            return;\n        }\n        if (touch === 1 /* Touch.AsOld */) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === 2 /* Touch.AsNew */) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nclass Cache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get(key, touch = 2 /* Touch.AsNew */) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, 0 /* Touch.None */);\n    }\n    set(key, value) {\n        super.set(key, value, 2 /* Touch.AsNew */);\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trim(Math.round(this._limit * this._ratio));\n        }\n    }\n}\nclass LRUCache extends Cache {\n    constructor(limit, ratio = 1) {\n        super(limit, ratio);\n    }\n    trim(newSize) {\n        this.trimOld(newSize);\n    }\n    set(key, value) {\n        super.set(key, value);\n        this.checkTrim();\n        return this;\n    }\n}\n/**\n * A map that allows access both by keys and values.\n * **NOTE**: values need to be unique.\n */\nclass BidirectionalMap {\n    constructor(entries) {\n        this._m1 = new Map();\n        this._m2 = new Map();\n        if (entries) {\n            for (const [key, value] of entries) {\n                this.set(key, value);\n            }\n        }\n    }\n    clear() {\n        this._m1.clear();\n        this._m2.clear();\n    }\n    set(key, value) {\n        this._m1.set(key, value);\n        this._m2.set(value, key);\n    }\n    get(key) {\n        return this._m1.get(key);\n    }\n    getKey(value) {\n        return this._m2.get(value);\n    }\n    delete(key) {\n        const value = this._m1.get(key);\n        if (value === undefined) {\n            return false;\n        }\n        this._m1.delete(key);\n        this._m2.delete(value);\n        return true;\n    }\n    keys() {\n        return this._m1.keys();\n    }\n    values() {\n        return this._m1.values();\n    }\n}\nclass SetMap {\n    constructor() {\n        this.map = new Map();\n    }\n    add(key, value) {\n        let values = this.map.get(key);\n        if (!values) {\n            values = new Set();\n            this.map.set(key, values);\n        }\n        values.add(value);\n    }\n    delete(key, value) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.delete(value);\n        if (values.size === 0) {\n            this.map.delete(key);\n        }\n    }\n    forEach(key, fn) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.forEach(fn);\n    }\n    get(key) {\n        const values = this.map.get(key);\n        if (!values) {\n            return new Set();\n        }\n        return values;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/wordCharacterClassifier.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nclass WordCharacterClassifier extends CharacterClassifier {\n    constructor(wordSeparators, intlSegmenterLocales) {\n        super(0 /* WordCharacterClass.Regular */);\n        this._segmenter = null;\n        this._cachedLine = null;\n        this._cachedSegments = [];\n        this.intlSegmenterLocales = intlSegmenterLocales;\n        if (this.intlSegmenterLocales.length > 0) {\n            this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: 'word' });\n        }\n        else {\n            this._segmenter = null;\n        }\n        for (let i = 0, len = wordSeparators.length; i < len; i++) {\n            this.set(wordSeparators.charCodeAt(i), 2 /* WordCharacterClass.WordSeparator */);\n        }\n        this.set(32 /* CharCode.Space */, 1 /* WordCharacterClass.Whitespace */);\n        this.set(9 /* CharCode.Tab */, 1 /* WordCharacterClass.Whitespace */);\n    }\n    findPrevIntlWordBeforeOrAtOffset(line, offset) {\n        let candidate = null;\n        for (const segment of this._getIntlSegmenterWordsOnLine(line)) {\n            if (segment.index > offset) {\n                break;\n            }\n            candidate = segment;\n        }\n        return candidate;\n    }\n    findNextIntlWordAtOrAfterOffset(lineContent, offset) {\n        for (const segment of this._getIntlSegmenterWordsOnLine(lineContent)) {\n            if (segment.index < offset) {\n                continue;\n            }\n            return segment;\n        }\n        return null;\n    }\n    _getIntlSegmenterWordsOnLine(line) {\n        if (!this._segmenter) {\n            return [];\n        }\n        // Check if the line has changed from the previous call\n        if (this._cachedLine === line) {\n            return this._cachedSegments;\n        }\n        // Update the cache with the new line\n        this._cachedLine = line;\n        this._cachedSegments = this._filterWordSegments(this._segmenter.segment(line));\n        return this._cachedSegments;\n    }\n    _filterWordSegments(segments) {\n        const result = [];\n        for (const segment of segments) {\n            if (this._isWordLike(segment)) {\n                result.push(segment);\n            }\n        }\n        return result;\n    }\n    _isWordLike(segment) {\n        if (segment.isWordLike) {\n            return true;\n        }\n        return false;\n    }\n}\nconst wordClassifierCache = new LRUCache(10);\nfunction wordCharacterClassifier_getMapForWordSeparators(wordSeparators, intlSegmenterLocales) {\n    const key = `${wordSeparators}/${intlSegmenterLocales.join(',')}`;\n    let result = wordClassifierCache.get(key);\n    if (!result) {\n        result = new WordCharacterClassifier(wordSeparators, intlSegmenterLocales);\n        wordClassifierCache.set(key, result);\n    }\n    return result;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/model.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Vertical Lane in the overview ruler of the editor.\n */\nvar model_OverviewRulerLane;\n(function (OverviewRulerLane) {\n    OverviewRulerLane[OverviewRulerLane[\"Left\"] = 1] = \"Left\";\n    OverviewRulerLane[OverviewRulerLane[\"Center\"] = 2] = \"Center\";\n    OverviewRulerLane[OverviewRulerLane[\"Right\"] = 4] = \"Right\";\n    OverviewRulerLane[OverviewRulerLane[\"Full\"] = 7] = \"Full\";\n})(model_OverviewRulerLane || (model_OverviewRulerLane = {}));\n/**\n * Vertical Lane in the glyph margin of the editor.\n */\nvar model_GlyphMarginLane;\n(function (GlyphMarginLane) {\n    GlyphMarginLane[GlyphMarginLane[\"Left\"] = 1] = \"Left\";\n    GlyphMarginLane[GlyphMarginLane[\"Center\"] = 2] = \"Center\";\n    GlyphMarginLane[GlyphMarginLane[\"Right\"] = 3] = \"Right\";\n})(model_GlyphMarginLane || (model_GlyphMarginLane = {}));\nvar model_InjectedTextCursorStops;\n(function (InjectedTextCursorStops) {\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Both\"] = 0] = \"Both\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Right\"] = 1] = \"Right\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"Left\"] = 2] = \"Left\";\n    InjectedTextCursorStops[InjectedTextCursorStops[\"None\"] = 3] = \"None\";\n})(model_InjectedTextCursorStops || (model_InjectedTextCursorStops = {}));\nclass TextModelResolvedOptions {\n    get originalIndentSize() {\n        return this._indentSizeIsTabSize ? 'tabSize' : this.indentSize;\n    }\n    /**\n     * @internal\n     */\n    constructor(src) {\n        this._textModelResolvedOptionsBrand = undefined;\n        this.tabSize = Math.max(1, src.tabSize | 0);\n        if (src.indentSize === 'tabSize') {\n            this.indentSize = this.tabSize;\n            this._indentSizeIsTabSize = true;\n        }\n        else {\n            this.indentSize = Math.max(1, src.indentSize | 0);\n            this._indentSizeIsTabSize = false;\n        }\n        this.insertSpaces = Boolean(src.insertSpaces);\n        this.defaultEOL = src.defaultEOL | 0;\n        this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);\n        this.bracketPairColorizationOptions = src.bracketPairColorizationOptions;\n    }\n    /**\n     * @internal\n     */\n    equals(other) {\n        return (this.tabSize === other.tabSize\n            && this._indentSizeIsTabSize === other._indentSizeIsTabSize\n            && this.indentSize === other.indentSize\n            && this.insertSpaces === other.insertSpaces\n            && this.defaultEOL === other.defaultEOL\n            && this.trimAutoWhitespace === other.trimAutoWhitespace\n            && equals(this.bracketPairColorizationOptions, other.bracketPairColorizationOptions));\n    }\n    /**\n     * @internal\n     */\n    createChangeEvent(newOpts) {\n        return {\n            tabSize: this.tabSize !== newOpts.tabSize,\n            indentSize: this.indentSize !== newOpts.indentSize,\n            insertSpaces: this.insertSpaces !== newOpts.insertSpaces,\n            trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,\n        };\n    }\n}\nclass model_FindMatch {\n    /**\n     * @internal\n     */\n    constructor(range, matches) {\n        this._findMatchBrand = undefined;\n        this.range = range;\n        this.matches = matches;\n    }\n}\n/**\n * @internal\n */\nfunction isITextSnapshot(obj) {\n    return (obj && typeof obj.read === 'function');\n}\n/**\n * @internal\n */\nclass ValidAnnotatedEditOperation {\n    constructor(identifier, range, text, forceMoveMarkers, isAutoWhitespaceEdit, _isTracked) {\n        this.identifier = identifier;\n        this.range = range;\n        this.text = text;\n        this.forceMoveMarkers = forceMoveMarkers;\n        this.isAutoWhitespaceEdit = isAutoWhitespaceEdit;\n        this._isTracked = _isTracked;\n    }\n}\n/**\n * @internal\n */\nclass model_SearchData {\n    constructor(regex, wordSeparators, simpleSearch) {\n        this.regex = regex;\n        this.wordSeparators = wordSeparators;\n        this.simpleSearch = simpleSearch;\n    }\n}\n/**\n * @internal\n */\nclass ApplyEditsResult {\n    constructor(reverseEdits, changes, trimAutoWhitespaceLineNumbers) {\n        this.reverseEdits = reverseEdits;\n        this.changes = changes;\n        this.trimAutoWhitespaceLineNumbers = trimAutoWhitespaceLineNumbers;\n    }\n}\n/**\n * @internal\n */\nfunction shouldSynchronizeModel(model) {\n    return (!model.isTooLargeForSyncing() && !model.isForSimpleWidget);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/model/textModelSearch.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\nconst LIMIT_FIND_COUNT = 999;\nclass SearchParams {\n    constructor(searchString, isRegex, matchCase, wordSeparators) {\n        this.searchString = searchString;\n        this.isRegex = isRegex;\n        this.matchCase = matchCase;\n        this.wordSeparators = wordSeparators;\n    }\n    parseSearchRequest() {\n        if (this.searchString === '') {\n            return null;\n        }\n        // Try to create a RegExp out of the params\n        let multiline;\n        if (this.isRegex) {\n            multiline = isMultilineRegexSource(this.searchString);\n        }\n        else {\n            multiline = (this.searchString.indexOf('\\n') >= 0);\n        }\n        let regex = null;\n        try {\n            regex = strings.createRegExp(this.searchString, this.isRegex, {\n                matchCase: this.matchCase,\n                wholeWord: false,\n                multiline: multiline,\n                global: true,\n                unicode: true\n            });\n        }\n        catch (err) {\n            return null;\n        }\n        if (!regex) {\n            return null;\n        }\n        let canUseSimpleSearch = (!this.isRegex && !multiline);\n        if (canUseSimpleSearch && this.searchString.toLowerCase() !== this.searchString.toUpperCase()) {\n            // casing might make a difference\n            canUseSimpleSearch = this.matchCase;\n        }\n        return new SearchData(regex, this.wordSeparators ? getMapForWordSeparators(this.wordSeparators, []) : null, canUseSimpleSearch ? this.searchString : null);\n    }\n}\nfunction isMultilineRegexSource(searchString) {\n    if (!searchString || searchString.length === 0) {\n        return false;\n    }\n    for (let i = 0, len = searchString.length; i < len; i++) {\n        const chCode = searchString.charCodeAt(i);\n        if (chCode === 10 /* CharCode.LineFeed */) {\n            return true;\n        }\n        if (chCode === 92 /* CharCode.Backslash */) {\n            // move to next char\n            i++;\n            if (i >= len) {\n                // string ends with a \\\n                break;\n            }\n            const nextChCode = searchString.charCodeAt(i);\n            if (nextChCode === 110 /* CharCode.n */ || nextChCode === 114 /* CharCode.r */ || nextChCode === 87 /* CharCode.W */) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction createFindMatch(range, rawMatches, captureMatches) {\n    if (!captureMatches) {\n        return new FindMatch(range, null);\n    }\n    const matches = [];\n    for (let i = 0, len = rawMatches.length; i < len; i++) {\n        matches[i] = rawMatches[i];\n    }\n    return new FindMatch(range, matches);\n}\nclass LineFeedCounter {\n    constructor(text) {\n        const lineFeedsOffsets = [];\n        let lineFeedsOffsetsLen = 0;\n        for (let i = 0, textLen = text.length; i < textLen; i++) {\n            if (text.charCodeAt(i) === 10 /* CharCode.LineFeed */) {\n                lineFeedsOffsets[lineFeedsOffsetsLen++] = i;\n            }\n        }\n        this._lineFeedsOffsets = lineFeedsOffsets;\n    }\n    findLineFeedCountBeforeOffset(offset) {\n        const lineFeedsOffsets = this._lineFeedsOffsets;\n        let min = 0;\n        let max = lineFeedsOffsets.length - 1;\n        if (max === -1) {\n            // no line feeds\n            return 0;\n        }\n        if (offset <= lineFeedsOffsets[0]) {\n            // before first line feed\n            return 0;\n        }\n        while (min < max) {\n            const mid = min + ((max - min) / 2 >> 0);\n            if (lineFeedsOffsets[mid] >= offset) {\n                max = mid - 1;\n            }\n            else {\n                if (lineFeedsOffsets[mid + 1] >= offset) {\n                    // bingo!\n                    min = mid;\n                    max = mid;\n                }\n                else {\n                    min = mid + 1;\n                }\n            }\n        }\n        return min + 1;\n    }\n}\nclass TextModelSearch {\n    static findMatches(model, searchParams, searchRange, captureMatches, limitResultCount) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return [];\n        }\n        if (searchData.regex.multiline) {\n            return this._doFindMatchesMultiline(model, searchRange, new Searcher(searchData.wordSeparators, searchData.regex), captureMatches, limitResultCount);\n        }\n        return this._doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Multiline search always executes on the lines concatenated with \\n.\n     * We must therefore compensate for the count of \\n in case the model is CRLF\n     */\n    static _getMultilineMatchRange(model, deltaOffset, text, lfCounter, matchIndex, match0) {\n        let startOffset;\n        let lineFeedCountBeforeMatch = 0;\n        if (lfCounter) {\n            lineFeedCountBeforeMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex);\n            startOffset = deltaOffset + matchIndex + lineFeedCountBeforeMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            startOffset = deltaOffset + matchIndex;\n        }\n        let endOffset;\n        if (lfCounter) {\n            const lineFeedCountBeforeEndOfMatch = lfCounter.findLineFeedCountBeforeOffset(matchIndex + match0.length);\n            const lineFeedCountInMatch = lineFeedCountBeforeEndOfMatch - lineFeedCountBeforeMatch;\n            endOffset = startOffset + match0.length + lineFeedCountInMatch /* add as many \\r as there were \\n */;\n        }\n        else {\n            endOffset = startOffset + match0.length;\n        }\n        const startPosition = model.getPositionAt(startOffset);\n        const endPosition = model.getPositionAt(endOffset);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    static _doFindMatchesMultiline(model, searchRange, searcher, captureMatches, limitResultCount) {\n        const deltaOffset = model.getOffsetAt(searchRange.getStartPosition());\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(searchRange, 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        const result = [];\n        let counter = 0;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            result[counter++] = createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n            if (counter >= limitResultCount) {\n                return result;\n            }\n        }\n        return result;\n    }\n    static _doFindMatchesLineByLine(model, searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        // Early case for a search range that starts & stops on the same line number\n        if (searchRange.startLineNumber === searchRange.endLineNumber) {\n            const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        // Collect results from first line\n        const text = model.getLineContent(searchRange.startLineNumber).substring(searchRange.startColumn - 1);\n        resultLen = this._findMatchesInLine(searchData, text, searchRange.startLineNumber, searchRange.startColumn - 1, resultLen, result, captureMatches, limitResultCount);\n        // Collect results from middle lines\n        for (let lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && resultLen < limitResultCount; lineNumber++) {\n            resultLen = this._findMatchesInLine(searchData, model.getLineContent(lineNumber), lineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        // Collect results from last line\n        if (resultLen < limitResultCount) {\n            const text = model.getLineContent(searchRange.endLineNumber).substring(0, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, text, searchRange.endLineNumber, 0, resultLen, result, captureMatches, limitResultCount);\n        }\n        return result;\n    }\n    static _findMatchesInLine(searchData, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    static findNextMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindNextMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindNextMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const searchTextStart = new Position(searchStart.lineNumber, 1);\n        const deltaOffset = model.getOffsetAt(searchTextStart);\n        const lineCount = model.getLineCount();\n        // We always execute multiline search over the lines joined with \\n\n        // This makes it that \\n will match the EOL for both CRLF and LF models\n        // We compensate for offset errors in `_getMultilineMatchRange`\n        const text = model.getValueInRange(new Range(searchTextStart.lineNumber, searchTextStart.column, lineCount, model.getLineMaxColumn(lineCount)), 1 /* EndOfLinePreference.LF */);\n        const lfCounter = (model.getEOL() === '\\r\\n' ? new LineFeedCounter(text) : null);\n        searcher.reset(searchStart.column - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(this._getMultilineMatchRange(model, deltaOffset, text, lfCounter, m.index, m[0]), m, captureMatches);\n        }\n        if (searchStart.lineNumber !== 1 || searchStart.column !== 1) {\n            // Try again from the top\n            return this._doFindNextMatchMultiline(model, new Position(1, 1), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindNextMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber);\n        const r = this._findFirstMatchInLine(searcher, text, startLineNumber, searchStart.column, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (startLineNumber + i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findFirstMatchInLine(searcher, text, lineIndex + 1, 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findFirstMatchInLine(searcher, text, lineNumber, fromColumn, captureMatches) {\n        // Set regex to search from column\n        searcher.reset(fromColumn - 1);\n        const m = searcher.next(text);\n        if (m) {\n            return createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return null;\n    }\n    static findPreviousMatch(model, searchParams, searchStart, captureMatches) {\n        const searchData = searchParams.parseSearchRequest();\n        if (!searchData) {\n            return null;\n        }\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        if (searchData.regex.multiline) {\n            return this._doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches);\n        }\n        return this._doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches);\n    }\n    static _doFindPreviousMatchMultiline(model, searchStart, searcher, captureMatches) {\n        const matches = this._doFindMatchesMultiline(model, new Range(1, 1, searchStart.lineNumber, searchStart.column), searcher, captureMatches, 10 * LIMIT_FIND_COUNT);\n        if (matches.length > 0) {\n            return matches[matches.length - 1];\n        }\n        const lineCount = model.getLineCount();\n        if (searchStart.lineNumber !== lineCount || searchStart.column !== model.getLineMaxColumn(lineCount)) {\n            // Try again with all content\n            return this._doFindPreviousMatchMultiline(model, new Position(lineCount, model.getLineMaxColumn(lineCount)), searcher, captureMatches);\n        }\n        return null;\n    }\n    static _doFindPreviousMatchLineByLine(model, searchStart, searcher, captureMatches) {\n        const lineCount = model.getLineCount();\n        const startLineNumber = searchStart.lineNumber;\n        // Look in first line\n        const text = model.getLineContent(startLineNumber).substring(0, searchStart.column - 1);\n        const r = this._findLastMatchInLine(searcher, text, startLineNumber, captureMatches);\n        if (r) {\n            return r;\n        }\n        for (let i = 1; i <= lineCount; i++) {\n            const lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;\n            const text = model.getLineContent(lineIndex + 1);\n            const r = this._findLastMatchInLine(searcher, text, lineIndex + 1, captureMatches);\n            if (r) {\n                return r;\n            }\n        }\n        return null;\n    }\n    static _findLastMatchInLine(searcher, text, lineNumber, captureMatches) {\n        let bestResult = null;\n        let m;\n        searcher.reset(0);\n        while ((m = searcher.next(text))) {\n            bestResult = createFindMatch(new Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length), m, captureMatches);\n        }\n        return bestResult;\n    }\n}\nfunction leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex === 0) {\n        // Match starts at start of string\n        return true;\n    }\n    const charBefore = text.charCodeAt(matchStartIndex - 1);\n    if (wordSeparators.get(charBefore) !== 0 /* WordCharacterClass.Regular */) {\n        // The character before the match is a word separator\n        return true;\n    }\n    if (charBefore === 13 /* CharCode.CarriageReturn */ || charBefore === 10 /* CharCode.LineFeed */) {\n        // The character before the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const firstCharInMatch = text.charCodeAt(matchStartIndex);\n        if (wordSeparators.get(firstCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The first character inside the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    if (matchStartIndex + matchLength === textLength) {\n        // Match ends at end of string\n        return true;\n    }\n    const charAfter = text.charCodeAt(matchStartIndex + matchLength);\n    if (wordSeparators.get(charAfter) !== 0 /* WordCharacterClass.Regular */) {\n        // The character after the match is a word separator\n        return true;\n    }\n    if (charAfter === 13 /* CharCode.CarriageReturn */ || charAfter === 10 /* CharCode.LineFeed */) {\n        // The character after the match is line break or carriage return.\n        return true;\n    }\n    if (matchLength > 0) {\n        const lastCharInMatch = text.charCodeAt(matchStartIndex + matchLength - 1);\n        if (wordSeparators.get(lastCharInMatch) !== 0 /* WordCharacterClass.Regular */) {\n            // The last character in the match is a word separator\n            return true;\n        }\n    }\n    return false;\n}\nfunction isValidMatch(wordSeparators, text, textLength, matchStartIndex, matchLength) {\n    return (leftIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength)\n        && rightIsWordBounday(wordSeparators, text, textLength, matchStartIndex, matchLength));\n}\nclass Searcher {\n    constructor(wordSeparators, searchRegex) {\n        this._wordSeparators = wordSeparators;\n        this._searchRegex = searchRegex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    reset(lastIndex) {\n        this._searchRegex.lastIndex = lastIndex;\n        this._prevMatchStartIndex = -1;\n        this._prevMatchLength = 0;\n    }\n    next(text) {\n        const textLength = text.length;\n        let m;\n        do {\n            if (this._prevMatchStartIndex + this._prevMatchLength === textLength) {\n                // Reached the end of the line\n                return null;\n            }\n            m = this._searchRegex.exec(text);\n            if (!m) {\n                return null;\n            }\n            const matchStartIndex = m.index;\n            const matchLength = m[0].length;\n            if (matchStartIndex === this._prevMatchStartIndex && matchLength === this._prevMatchLength) {\n                if (matchLength === 0) {\n                    // the search result is an empty string and won't advance `regex.lastIndex`, so `regex.exec` will stuck here\n                    // we attempt to recover from that by advancing by two if surrogate pair found and by one otherwise\n                    if (getNextCodePoint(text, textLength, this._searchRegex.lastIndex) > 0xFFFF) {\n                        this._searchRegex.lastIndex += 2;\n                    }\n                    else {\n                        this._searchRegex.lastIndex += 1;\n                    }\n                    continue;\n                }\n                // Exit early if the regex matches the same range twice\n                return null;\n            }\n            this._prevMatchStartIndex = matchStartIndex;\n            this._prevMatchLength = matchLength;\n            if (!this._wordSeparators || isValidMatch(this._wordSeparators, text, textLength, matchStartIndex, matchLength)) {\n                return m;\n            }\n        } while (m);\n        return null;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/assert.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.\n *\n * @deprecated Use `assert(...)` instead.\n * This method is usually used like this:\n * ```ts\n * import * as assert from 'vs/base/common/assert';\n * assert.ok(...);\n * ```\n *\n * However, `assert` in that example is a user chosen name.\n * There is no tooling for generating such an import statement.\n * Thus, the `assert(...)` function should be used instead.\n */\nfunction ok(value, message) {\n    if (!value) {\n        throw new Error(message ? `Assertion failed (${message})` : 'Assertion Failed');\n    }\n}\nfunction assertNever(value, message = 'Unreachable') {\n    throw new Error(message);\n}\n/**\n * Like assert, but doesn't throw.\n */\nfunction softAssert(condition) {\n    if (!condition) {\n        onUnexpectedError(new BugIndicatingError('Soft Assertion Failed'));\n    }\n}\n/**\n * condition must be side-effect free!\n */\nfunction assert_assertFn(condition) {\n    if (!condition()) {\n        // eslint-disable-next-line no-debugger\n        debugger;\n        // Reevaluate `condition` again to make debugging easier\n        condition();\n        errors_onUnexpectedError(new errors_BugIndicatingError('Assertion Failed'));\n    }\n}\nfunction assert_checkAdjacentItems(items, predicate) {\n    let i = 0;\n    while (i < items.length - 1) {\n        const a = items[i];\n        const b = items[i + 1];\n        if (!predicate(a, b)) {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\nclass UnicodeTextModelHighlighter {\n    static computeUnicodeHighlights(model, options, range) {\n        const startLine = range ? range.startLineNumber : 1;\n        const endLine = range ? range.endLineNumber : model.getLineCount();\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const candidates = codePointHighlighter.getCandidateCodePoints();\n        let regex;\n        if (candidates === 'allNonBasicAscii') {\n            regex = new RegExp('[^\\\\t\\\\n\\\\r\\\\x20-\\\\x7E]', 'g');\n        }\n        else {\n            regex = new RegExp(`${buildRegExpCharClassExpr(Array.from(candidates))}`, 'g');\n        }\n        const searcher = new Searcher(null, regex);\n        const ranges = [];\n        let hasMore = false;\n        let m;\n        let ambiguousCharacterCount = 0;\n        let invisibleCharacterCount = 0;\n        let nonBasicAsciiCharacterCount = 0;\n        forLoop: for (let lineNumber = startLine, lineCount = endLine; lineNumber <= lineCount; lineNumber++) {\n            const lineContent = model.getLineContent(lineNumber);\n            const lineLength = lineContent.length;\n            // Reset regex to search from the beginning\n            searcher.reset(0);\n            do {\n                m = searcher.next(lineContent);\n                if (m) {\n                    let startIndex = m.index;\n                    let endIndex = m.index + m[0].length;\n                    // Extend range to entire code point\n                    if (startIndex > 0) {\n                        const charCodeBefore = lineContent.charCodeAt(startIndex - 1);\n                        if (isHighSurrogate(charCodeBefore)) {\n                            startIndex--;\n                        }\n                    }\n                    if (endIndex + 1 < lineLength) {\n                        const charCodeBefore = lineContent.charCodeAt(endIndex - 1);\n                        if (isHighSurrogate(charCodeBefore)) {\n                            endIndex++;\n                        }\n                    }\n                    const str = lineContent.substring(startIndex, endIndex);\n                    let word = getWordAtText(startIndex + 1, DEFAULT_WORD_REGEXP, lineContent, 0);\n                    if (word && word.endColumn <= startIndex + 1) {\n                        // The word does not include the problematic character, ignore the word\n                        word = null;\n                    }\n                    const highlightReason = codePointHighlighter.shouldHighlightNonBasicASCII(str, word ? word.word : null);\n                    if (highlightReason !== 0 /* SimpleHighlightReason.None */) {\n                        if (highlightReason === 3 /* SimpleHighlightReason.Ambiguous */) {\n                            ambiguousCharacterCount++;\n                        }\n                        else if (highlightReason === 2 /* SimpleHighlightReason.Invisible */) {\n                            invisibleCharacterCount++;\n                        }\n                        else if (highlightReason === 1 /* SimpleHighlightReason.NonBasicASCII */) {\n                            nonBasicAsciiCharacterCount++;\n                        }\n                        else {\n                            assertNever(highlightReason);\n                        }\n                        const MAX_RESULT_LENGTH = 1000;\n                        if (ranges.length >= MAX_RESULT_LENGTH) {\n                            hasMore = true;\n                            break forLoop;\n                        }\n                        ranges.push(new range_Range(lineNumber, startIndex + 1, lineNumber, endIndex + 1));\n                    }\n                }\n            } while (m);\n        }\n        return {\n            ranges,\n            hasMore,\n            ambiguousCharacterCount,\n            invisibleCharacterCount,\n            nonBasicAsciiCharacterCount\n        };\n    }\n    static computeUnicodeHighlightReason(char, options) {\n        const codePointHighlighter = new CodePointHighlighter(options);\n        const reason = codePointHighlighter.shouldHighlightNonBasicASCII(char, null);\n        switch (reason) {\n            case 0 /* SimpleHighlightReason.None */:\n                return null;\n            case 2 /* SimpleHighlightReason.Invisible */:\n                return { kind: 1 /* UnicodeHighlighterReasonKind.Invisible */ };\n            case 3 /* SimpleHighlightReason.Ambiguous */: {\n                const codePoint = char.codePointAt(0);\n                const primaryConfusable = codePointHighlighter.ambiguousCharacters.getPrimaryConfusable(codePoint);\n                const notAmbiguousInLocales = AmbiguousCharacters.getLocales().filter((l) => !AmbiguousCharacters.getInstance(new Set([...options.allowedLocales, l])).isAmbiguous(codePoint));\n                return { kind: 0 /* UnicodeHighlighterReasonKind.Ambiguous */, confusableWith: String.fromCodePoint(primaryConfusable), notAmbiguousInLocales };\n            }\n            case 1 /* SimpleHighlightReason.NonBasicASCII */:\n                return { kind: 2 /* UnicodeHighlighterReasonKind.NonBasicAscii */ };\n        }\n    }\n}\nfunction buildRegExpCharClassExpr(codePoints, flags) {\n    const src = `[${escapeRegExpCharacters(codePoints.map((i) => String.fromCodePoint(i)).join(''))}]`;\n    return src;\n}\nclass CodePointHighlighter {\n    constructor(options) {\n        this.options = options;\n        this.allowedCodePoints = new Set(options.allowedCodePoints);\n        this.ambiguousCharacters = AmbiguousCharacters.getInstance(new Set(options.allowedLocales));\n    }\n    getCandidateCodePoints() {\n        if (this.options.nonBasicASCII) {\n            return 'allNonBasicAscii';\n        }\n        const set = new Set();\n        if (this.options.invisibleCharacters) {\n            for (const cp of InvisibleCharacters.codePoints) {\n                if (!isAllowedInvisibleCharacter(String.fromCodePoint(cp))) {\n                    set.add(cp);\n                }\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            for (const cp of this.ambiguousCharacters.getConfusableCodePoints()) {\n                set.add(cp);\n            }\n        }\n        for (const cp of this.allowedCodePoints) {\n            set.delete(cp);\n        }\n        return set;\n    }\n    shouldHighlightNonBasicASCII(character, wordContext) {\n        const codePoint = character.codePointAt(0);\n        if (this.allowedCodePoints.has(codePoint)) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.nonBasicASCII) {\n            return 1 /* SimpleHighlightReason.NonBasicASCII */;\n        }\n        let hasBasicASCIICharacters = false;\n        let hasNonConfusableNonBasicAsciiCharacter = false;\n        if (wordContext) {\n            for (const char of wordContext) {\n                const codePoint = char.codePointAt(0);\n                const isBasicASCII = strings_isBasicASCII(char);\n                hasBasicASCIICharacters = hasBasicASCIICharacters || isBasicASCII;\n                if (!isBasicASCII &&\n                    !this.ambiguousCharacters.isAmbiguous(codePoint) &&\n                    !InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                    hasNonConfusableNonBasicAsciiCharacter = true;\n                }\n            }\n        }\n        if (\n        /* Don't allow mixing weird looking characters with ASCII */ !hasBasicASCIICharacters &&\n            /* Is there an obviously weird looking character? */ hasNonConfusableNonBasicAsciiCharacter) {\n            return 0 /* SimpleHighlightReason.None */;\n        }\n        if (this.options.invisibleCharacters) {\n            // TODO check for emojis\n            if (!isAllowedInvisibleCharacter(character) && InvisibleCharacters.isInvisibleCharacter(codePoint)) {\n                return 2 /* SimpleHighlightReason.Invisible */;\n            }\n        }\n        if (this.options.ambiguousCharacters) {\n            if (this.ambiguousCharacters.isAmbiguous(codePoint)) {\n                return 3 /* SimpleHighlightReason.Ambiguous */;\n            }\n        }\n        return 0 /* SimpleHighlightReason.None */;\n    }\n}\nfunction isAllowedInvisibleCharacter(character) {\n    return character === ' ' || character === '\\n' || character === '\\t';\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputer.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass LinesDiff {\n    constructor(changes, \n    /**\n     * Sorted by original line ranges.\n     * The original line ranges and the modified line ranges must be disjoint (but can be touching).\n     */\n    moves, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.changes = changes;\n        this.moves = moves;\n        this.hitTimeout = hitTimeout;\n    }\n}\nclass MovedText {\n    constructor(lineRangeMapping, changes) {\n        this.lineRangeMapping = lineRangeMapping;\n        this.changes = changes;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/offsetRange.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * A range of offsets (0-based).\n*/\nclass OffsetRange {\n    static addRange(range, sortedRanges) {\n        let i = 0;\n        while (i < sortedRanges.length && sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < sortedRanges.length && sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, sortedRanges[j - 1].endExclusive);\n            sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    static tryCreate(start, endExclusive) {\n        if (start > endExclusive) {\n            return undefined;\n        }\n        return new OffsetRange(start, endExclusive);\n    }\n    static ofLength(length) {\n        return new OffsetRange(0, length);\n    }\n    static ofStartAndLength(start, length) {\n        return new OffsetRange(start, start + length);\n    }\n    constructor(start, endExclusive) {\n        this.start = start;\n        this.endExclusive = endExclusive;\n        if (start > endExclusive) {\n            throw new errors_BugIndicatingError(`Invalid range: ${this.toString()}`);\n        }\n    }\n    get isEmpty() {\n        return this.start === this.endExclusive;\n    }\n    delta(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive + offset);\n    }\n    deltaStart(offset) {\n        return new OffsetRange(this.start + offset, this.endExclusive);\n    }\n    deltaEnd(offset) {\n        return new OffsetRange(this.start, this.endExclusive + offset);\n    }\n    get length() {\n        return this.endExclusive - this.start;\n    }\n    toString() {\n        return `[${this.start}, ${this.endExclusive})`;\n    }\n    contains(offset) {\n        return this.start <= offset && offset < this.endExclusive;\n    }\n    /**\n     * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)\n     * The joined range is the smallest range that contains both ranges.\n     */\n    join(other) {\n        return new OffsetRange(Math.min(this.start, other.start), Math.max(this.endExclusive, other.endExclusive));\n    }\n    /**\n     * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)\n     *\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        if (start <= end) {\n            return new OffsetRange(start, end);\n        }\n        return undefined;\n    }\n    intersects(other) {\n        const start = Math.max(this.start, other.start);\n        const end = Math.min(this.endExclusive, other.endExclusive);\n        return start < end;\n    }\n    isBefore(other) {\n        return this.endExclusive <= other.start;\n    }\n    isAfter(other) {\n        return this.start >= other.endExclusive;\n    }\n    slice(arr) {\n        return arr.slice(this.start, this.endExclusive);\n    }\n    substring(str) {\n        return str.substring(this.start, this.endExclusive);\n    }\n    /**\n     * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.\n     * The range must not be empty.\n     */\n    clip(value) {\n        if (this.isEmpty) {\n            throw new errors_BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        return Math.max(this.start, Math.min(this.endExclusive - 1, value));\n    }\n    /**\n     * Returns `r := value + k * length` such that `r` is contained in this range.\n     * The range must not be empty.\n     *\n     * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.\n     */\n    clipCyclic(value) {\n        if (this.isEmpty) {\n            throw new errors_BugIndicatingError(`Invalid clipping range: ${this.toString()}`);\n        }\n        if (value < this.start) {\n            return this.endExclusive - ((this.start - value) % this.length);\n        }\n        if (value >= this.endExclusive) {\n            return this.start + ((value - this.start) % this.length);\n        }\n        return value;\n    }\n    forEach(f) {\n        for (let i = this.start; i < this.endExclusive; i++) {\n            f(i);\n        }\n    }\n}\nclass OffsetRangeSet {\n    constructor() {\n        this._sortedRanges = [];\n    }\n    addRange(range) {\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive < range.start) {\n            i++;\n        }\n        let j = i;\n        while (j < this._sortedRanges.length && this._sortedRanges[j].start <= range.endExclusive) {\n            j++;\n        }\n        if (i === j) {\n            this._sortedRanges.splice(i, 0, range);\n        }\n        else {\n            const start = Math.min(range.start, this._sortedRanges[i].start);\n            const end = Math.max(range.endExclusive, this._sortedRanges[j - 1].endExclusive);\n            this._sortedRanges.splice(i, j - i, new OffsetRange(start, end));\n        }\n    }\n    toString() {\n        return this._sortedRanges.map(r => r.toString()).join(', ');\n    }\n    /**\n     * Returns of there is a value that is contained in this instance and the given range.\n     */\n    intersectsStrict(other) {\n        // TODO use binary search\n        let i = 0;\n        while (i < this._sortedRanges.length && this._sortedRanges[i].endExclusive <= other.start) {\n            i++;\n        }\n        return i < this._sortedRanges.length && this._sortedRanges[i].start < other.endExclusive;\n    }\n    intersectWithRange(other) {\n        // TODO use binary search + slice\n        const result = new OffsetRangeSet();\n        for (const range of this._sortedRanges) {\n            const intersection = range.intersect(other);\n            if (intersection) {\n                result.addRange(intersection);\n            }\n        }\n        return result;\n    }\n    intersectWithRangeLength(other) {\n        return this.intersectWithRange(other).length;\n    }\n    get length() {\n        return this._sortedRanges.reduce((prev, cur) => prev + cur.length, 0);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/arraysFind.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction findLast(array, predicate) {\n    const idx = findLastIdx(array, predicate);\n    if (idx === -1) {\n        return undefined;\n    }\n    return array[idx];\n}\nfunction findLastIdx(array, predicate, fromIndex = array.length - 1) {\n    for (let i = fromIndex; i >= 0; i--) {\n        const element = array[i];\n        if (predicate(element)) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `undefined` if no item matches, otherwise the last item that matches the predicate.\n */\nfunction findLastMonotonous(array, predicate) {\n    const idx = findLastIdxMonotonous(array, predicate);\n    return idx === -1 ? undefined : array[idx];\n}\n/**\n * Finds the last item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n *\n * @returns `startIdx - 1` if predicate is false for all items, otherwise the index of the last item that matches the predicate.\n */\nfunction findLastIdxMonotonous(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            i = k + 1;\n        }\n        else {\n            j = k;\n        }\n    }\n    return i - 1;\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `undefined` if no item matches, otherwise the first item that matches the predicate.\n */\nfunction findFirstMonotonous(array, predicate) {\n    const idx = findFirstIdxMonotonousOrArrLen(array, predicate);\n    return idx === array.length ? undefined : array[idx];\n}\n/**\n * Finds the first item where predicate is true using binary search.\n * `predicate` must be monotonous, i.e. `arr.map(predicate)` must be like `[false, ..., false, true, ..., true]`!\n *\n * @returns `endIdxEx` if predicate is false for all items, otherwise the index of the first item that matches the predicate.\n */\nfunction findFirstIdxMonotonousOrArrLen(array, predicate, startIdx = 0, endIdxEx = array.length) {\n    let i = startIdx;\n    let j = endIdxEx;\n    while (i < j) {\n        const k = Math.floor((i + j) / 2);\n        if (predicate(array[k])) {\n            j = k;\n        }\n        else {\n            i = k + 1;\n        }\n    }\n    return i;\n}\n/**\n * Use this when\n * * You have a sorted array\n * * You query this array with a monotonous predicate to find the last item that has a certain property.\n * * You query this array multiple times with monotonous predicates that get weaker and weaker.\n */\nclass MonotonousArray {\n    constructor(_array) {\n        this._array = _array;\n        this._findLastMonotonousLastIdx = 0;\n    }\n    /**\n     * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!\n     * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.\n     */\n    findLastMonotonous(predicate) {\n        if (MonotonousArray.assertInvariants) {\n            if (this._prevFindLastPredicate) {\n                for (const item of this._array) {\n                    if (this._prevFindLastPredicate(item) && !predicate(item)) {\n                        throw new Error('MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.');\n                    }\n                }\n            }\n            this._prevFindLastPredicate = predicate;\n        }\n        const idx = findLastIdxMonotonous(this._array, predicate, this._findLastMonotonousLastIdx);\n        this._findLastMonotonousLastIdx = idx + 1;\n        return idx === -1 ? undefined : this._array[idx];\n    }\n}\nMonotonousArray.assertInvariants = false;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nfunction findFirstMax(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) > 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nfunction findLastMax(array, comparator) {\n    if (array.length === 0) {\n        return undefined;\n    }\n    let max = array[0];\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, max) >= 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nfunction findFirstMin(array, comparator) {\n    return findFirstMax(array, (a, b) => -comparator(a, b));\n}\nfunction findMaxIdx(array, comparator) {\n    if (array.length === 0) {\n        return -1;\n    }\n    let maxIdx = 0;\n    for (let i = 1; i < array.length; i++) {\n        const item = array[i];\n        if (comparator(item, array[maxIdx]) > 0) {\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n/**\n * Returns the first mapped value of the array which is not undefined.\n */\nfunction mapFindFirst(items, mapFn) {\n    for (const value of items) {\n        const mapped = mapFn(value);\n        if (mapped !== undefined) {\n            return mapped;\n        }\n    }\n    return undefined;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/lineRange.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n/**\n * A range of lines (1-based).\n */\nclass LineRange {\n    static fromRangeInclusive(range) {\n        return new LineRange(range.startLineNumber, range.endLineNumber + 1);\n    }\n    /**\n     * @param lineRanges An array of sorted line ranges.\n     */\n    static joinMany(lineRanges) {\n        if (lineRanges.length === 0) {\n            return [];\n        }\n        let result = new LineRangeSet(lineRanges[0].slice());\n        for (let i = 1; i < lineRanges.length; i++) {\n            result = result.getUnion(new LineRangeSet(lineRanges[i].slice()));\n        }\n        return result.ranges;\n    }\n    static join(lineRanges) {\n        if (lineRanges.length === 0) {\n            throw new errors_BugIndicatingError('lineRanges cannot be empty');\n        }\n        let startLineNumber = lineRanges[0].startLineNumber;\n        let endLineNumberExclusive = lineRanges[0].endLineNumberExclusive;\n        for (let i = 1; i < lineRanges.length; i++) {\n            startLineNumber = Math.min(startLineNumber, lineRanges[i].startLineNumber);\n            endLineNumberExclusive = Math.max(endLineNumberExclusive, lineRanges[i].endLineNumberExclusive);\n        }\n        return new LineRange(startLineNumber, endLineNumberExclusive);\n    }\n    static ofLength(startLineNumber, length) {\n        return new LineRange(startLineNumber, startLineNumber + length);\n    }\n    /**\n     * @internal\n     */\n    static deserialize(lineRange) {\n        return new LineRange(lineRange[0], lineRange[1]);\n    }\n    constructor(startLineNumber, endLineNumberExclusive) {\n        if (startLineNumber > endLineNumberExclusive) {\n            throw new errors_BugIndicatingError(`startLineNumber ${startLineNumber} cannot be after endLineNumberExclusive ${endLineNumberExclusive}`);\n        }\n        this.startLineNumber = startLineNumber;\n        this.endLineNumberExclusive = endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range contains the given line number.\n     */\n    contains(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Indicates if this line range is empty.\n     */\n    get isEmpty() {\n        return this.startLineNumber === this.endLineNumberExclusive;\n    }\n    /**\n     * Moves this line range by the given offset of line numbers.\n     */\n    delta(offset) {\n        return new LineRange(this.startLineNumber + offset, this.endLineNumberExclusive + offset);\n    }\n    deltaLength(offset) {\n        return new LineRange(this.startLineNumber, this.endLineNumberExclusive + offset);\n    }\n    /**\n     * The number of lines this line range spans.\n     */\n    get length() {\n        return this.endLineNumberExclusive - this.startLineNumber;\n    }\n    /**\n     * Creates a line range that combines this and the given line range.\n     */\n    join(other) {\n        return new LineRange(Math.min(this.startLineNumber, other.startLineNumber), Math.max(this.endLineNumberExclusive, other.endLineNumberExclusive));\n    }\n    toString() {\n        return `[${this.startLineNumber},${this.endLineNumberExclusive})`;\n    }\n    /**\n     * The resulting range is empty if the ranges do not intersect, but touch.\n     * If the ranges don't even touch, the result is undefined.\n     */\n    intersect(other) {\n        const startLineNumber = Math.max(this.startLineNumber, other.startLineNumber);\n        const endLineNumberExclusive = Math.min(this.endLineNumberExclusive, other.endLineNumberExclusive);\n        if (startLineNumber <= endLineNumberExclusive) {\n            return new LineRange(startLineNumber, endLineNumberExclusive);\n        }\n        return undefined;\n    }\n    intersectsStrict(other) {\n        return this.startLineNumber < other.endLineNumberExclusive && other.startLineNumber < this.endLineNumberExclusive;\n    }\n    overlapOrTouch(other) {\n        return this.startLineNumber <= other.endLineNumberExclusive && other.startLineNumber <= this.endLineNumberExclusive;\n    }\n    equals(b) {\n        return this.startLineNumber === b.startLineNumber && this.endLineNumberExclusive === b.endLineNumberExclusive;\n    }\n    toInclusiveRange() {\n        if (this.isEmpty) {\n            return null;\n        }\n        return new range_Range(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);\n    }\n    /**\n     * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!\n    */\n    toExclusiveRange() {\n        return new range_Range(this.startLineNumber, 1, this.endLineNumberExclusive, 1);\n    }\n    mapToLineArray(f) {\n        const result = [];\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            result.push(f(lineNumber));\n        }\n        return result;\n    }\n    forEach(f) {\n        for (let lineNumber = this.startLineNumber; lineNumber < this.endLineNumberExclusive; lineNumber++) {\n            f(lineNumber);\n        }\n    }\n    /**\n     * @internal\n     */\n    serialize() {\n        return [this.startLineNumber, this.endLineNumberExclusive];\n    }\n    includes(lineNumber) {\n        return this.startLineNumber <= lineNumber && lineNumber < this.endLineNumberExclusive;\n    }\n    /**\n     * Converts this 1-based line range to a 0-based offset range (subtracts 1!).\n     * @internal\n     */\n    toOffsetRange() {\n        return new OffsetRange(this.startLineNumber - 1, this.endLineNumberExclusive - 1);\n    }\n}\nclass LineRangeSet {\n    constructor(\n    /**\n     * Sorted by start line number.\n     * No two line ranges are touching or intersecting.\n     */\n    _normalizedRanges = []) {\n        this._normalizedRanges = _normalizedRanges;\n    }\n    get ranges() {\n        return this._normalizedRanges;\n    }\n    addRange(range) {\n        if (range.length === 0) {\n            return;\n        }\n        // Idea: Find joinRange such that:\n        // replaceRange = _normalizedRanges.replaceRange(joinRange, range.joinAll(joinRange.map(idx => this._normalizedRanges[idx])))\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            // If there is no element that touches range, then joinRangeStartIdx === joinRangeEndIdxExclusive and that value is the index of the element after range\n            this._normalizedRanges.splice(joinRangeStartIdx, 0, range);\n        }\n        else if (joinRangeStartIdx === joinRangeEndIdxExclusive - 1) {\n            // Else, there is an element that touches range and in this case it is both the first and last element. Thus we can replace it\n            const joinRange = this._normalizedRanges[joinRangeStartIdx];\n            this._normalizedRanges[joinRangeStartIdx] = joinRange.join(range);\n        }\n        else {\n            // First and last element are different - we need to replace the entire range\n            const joinRange = this._normalizedRanges[joinRangeStartIdx].join(this._normalizedRanges[joinRangeEndIdxExclusive - 1]).join(range);\n            this._normalizedRanges.splice(joinRangeStartIdx, joinRangeEndIdxExclusive - joinRangeStartIdx, joinRange);\n        }\n    }\n    contains(lineNumber) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber <= lineNumber);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > lineNumber;\n    }\n    intersects(range) {\n        const rangeThatStartsBeforeEnd = findLastMonotonous(this._normalizedRanges, r => r.startLineNumber < range.endLineNumberExclusive);\n        return !!rangeThatStartsBeforeEnd && rangeThatStartsBeforeEnd.endLineNumberExclusive > range.startLineNumber;\n    }\n    getUnion(other) {\n        if (this._normalizedRanges.length === 0) {\n            return other;\n        }\n        if (other._normalizedRanges.length === 0) {\n            return this;\n        }\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        let current = null;\n        while (i1 < this._normalizedRanges.length || i2 < other._normalizedRanges.length) {\n            let next = null;\n            if (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n                const lineRange1 = this._normalizedRanges[i1];\n                const lineRange2 = other._normalizedRanges[i2];\n                if (lineRange1.startLineNumber < lineRange2.startLineNumber) {\n                    next = lineRange1;\n                    i1++;\n                }\n                else {\n                    next = lineRange2;\n                    i2++;\n                }\n            }\n            else if (i1 < this._normalizedRanges.length) {\n                next = this._normalizedRanges[i1];\n                i1++;\n            }\n            else {\n                next = other._normalizedRanges[i2];\n                i2++;\n            }\n            if (current === null) {\n                current = next;\n            }\n            else {\n                if (current.endLineNumberExclusive >= next.startLineNumber) {\n                    // merge\n                    current = new LineRange(current.startLineNumber, Math.max(current.endLineNumberExclusive, next.endLineNumberExclusive));\n                }\n                else {\n                    // push\n                    result.push(current);\n                    current = next;\n                }\n            }\n        }\n        if (current !== null) {\n            result.push(current);\n        }\n        return new LineRangeSet(result);\n    }\n    /**\n     * Subtracts all ranges in this set from `range` and returns the result.\n     */\n    subtractFrom(range) {\n        // idx of first element that touches range or that is after range\n        const joinRangeStartIdx = findFirstIdxMonotonousOrArrLen(this._normalizedRanges, r => r.endLineNumberExclusive >= range.startLineNumber);\n        // idx of element after { last element that touches range or that is before range }\n        const joinRangeEndIdxExclusive = findLastIdxMonotonous(this._normalizedRanges, r => r.startLineNumber <= range.endLineNumberExclusive) + 1;\n        if (joinRangeStartIdx === joinRangeEndIdxExclusive) {\n            return new LineRangeSet([range]);\n        }\n        const result = [];\n        let startLineNumber = range.startLineNumber;\n        for (let i = joinRangeStartIdx; i < joinRangeEndIdxExclusive; i++) {\n            const r = this._normalizedRanges[i];\n            if (r.startLineNumber > startLineNumber) {\n                result.push(new LineRange(startLineNumber, r.startLineNumber));\n            }\n            startLineNumber = r.endLineNumberExclusive;\n        }\n        if (startLineNumber < range.endLineNumberExclusive) {\n            result.push(new LineRange(startLineNumber, range.endLineNumberExclusive));\n        }\n        return new LineRangeSet(result);\n    }\n    toString() {\n        return this._normalizedRanges.map(r => r.toString()).join(', ');\n    }\n    getIntersection(other) {\n        const result = [];\n        let i1 = 0;\n        let i2 = 0;\n        while (i1 < this._normalizedRanges.length && i2 < other._normalizedRanges.length) {\n            const r1 = this._normalizedRanges[i1];\n            const r2 = other._normalizedRanges[i2];\n            const i = r1.intersect(r2);\n            if (i && !i.isEmpty) {\n                result.push(i);\n            }\n            if (r1.endLineNumberExclusive < r2.endLineNumberExclusive) {\n                i1++;\n            }\n            else {\n                i2++;\n            }\n        }\n        return new LineRangeSet(result);\n    }\n    getWithDelta(value) {\n        return new LineRangeSet(this._normalizedRanges.map(r => r.delta(value)));\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/textLength.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n/**\n * Represents a non-negative length of text in terms of line and column count.\n*/\nclass textLength_TextLength {\n    static betweenPositions(position1, position2) {\n        if (position1.lineNumber === position2.lineNumber) {\n            return new textLength_TextLength(0, position2.column - position1.column);\n        }\n        else {\n            return new textLength_TextLength(position2.lineNumber - position1.lineNumber, position2.column - 1);\n        }\n    }\n    static ofRange(range) {\n        return textLength_TextLength.betweenPositions(range.getStartPosition(), range.getEndPosition());\n    }\n    static ofText(text) {\n        let line = 0;\n        let column = 0;\n        for (const c of text) {\n            if (c === '\\n') {\n                line++;\n                column = 0;\n            }\n            else {\n                column++;\n            }\n        }\n        return new textLength_TextLength(line, column);\n    }\n    constructor(lineCount, columnCount) {\n        this.lineCount = lineCount;\n        this.columnCount = columnCount;\n    }\n    isGreaterThanOrEqualTo(other) {\n        if (this.lineCount !== other.lineCount) {\n            return this.lineCount > other.lineCount;\n        }\n        return this.columnCount >= other.columnCount;\n    }\n    createRange(startPosition) {\n        if (this.lineCount === 0) {\n            return new range_Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column + this.columnCount);\n        }\n        else {\n            return new range_Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    addToPosition(position) {\n        if (this.lineCount === 0) {\n            return new position_Position(position.lineNumber, position.column + this.columnCount);\n        }\n        else {\n            return new position_Position(position.lineNumber + this.lineCount, this.columnCount + 1);\n        }\n    }\n    toString() {\n        return `${this.lineCount},${this.columnCount}`;\n    }\n}\ntextLength_TextLength.zero = new textLength_TextLength(0, 0);\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/positionToOffset.js\n\n\nclass PositionOffsetTransformer {\n    constructor(text) {\n        this.text = text;\n        this.lineStartOffsetByLineIdx = [];\n        this.lineStartOffsetByLineIdx.push(0);\n        for (let i = 0; i < text.length; i++) {\n            if (text.charAt(i) === '\\n') {\n                this.lineStartOffsetByLineIdx.push(i + 1);\n            }\n        }\n    }\n    getOffset(position) {\n        return this.lineStartOffsetByLineIdx[position.lineNumber - 1] + position.column - 1;\n    }\n    getOffsetRange(range) {\n        return new OffsetRange(this.getOffset(range.getStartPosition()), this.getOffset(range.getEndPosition()));\n    }\n    get textLength() {\n        const lineIdx = this.lineStartOffsetByLineIdx.length - 1;\n        return new textLength_TextLength(lineIdx, this.text.length - this.lineStartOffsetByLineIdx[lineIdx]);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/core/textEdit.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nclass textEdit_TextEdit {\n    constructor(edits) {\n        this.edits = edits;\n        assertFn(() => checkAdjacentItems(edits, (a, b) => a.range.getEndPosition().isBeforeOrEqual(b.range.getStartPosition())));\n    }\n    apply(text) {\n        let result = '';\n        let lastEditEnd = new Position(1, 1);\n        for (const edit of this.edits) {\n            const editRange = edit.range;\n            const editStart = editRange.getStartPosition();\n            const editEnd = editRange.getEndPosition();\n            const r = rangeFromPositions(lastEditEnd, editStart);\n            if (!r.isEmpty()) {\n                result += text.getValueOfRange(r);\n            }\n            result += edit.text;\n            lastEditEnd = editEnd;\n        }\n        const r = rangeFromPositions(lastEditEnd, text.endPositionExclusive);\n        if (!r.isEmpty()) {\n            result += text.getValueOfRange(r);\n        }\n        return result;\n    }\n    applyToString(str) {\n        const strText = new StringText(str);\n        return this.apply(strText);\n    }\n    getNewRanges() {\n        const newRanges = [];\n        let previousEditEndLineNumber = 0;\n        let lineOffset = 0;\n        let columnOffset = 0;\n        for (const edit of this.edits) {\n            const textLength = TextLength.ofText(edit.text);\n            const newRangeStart = Position.lift({\n                lineNumber: edit.range.startLineNumber + lineOffset,\n                column: edit.range.startColumn + (edit.range.startLineNumber === previousEditEndLineNumber ? columnOffset : 0)\n            });\n            const newRange = textLength.createRange(newRangeStart);\n            newRanges.push(newRange);\n            lineOffset = newRange.endLineNumber - edit.range.endLineNumber;\n            columnOffset = newRange.endColumn - edit.range.endColumn;\n            previousEditEndLineNumber = edit.range.endLineNumber;\n        }\n        return newRanges;\n    }\n}\nclass SingleTextEdit {\n    constructor(range, text) {\n        this.range = range;\n        this.text = text;\n    }\n}\nfunction rangeFromPositions(start, end) {\n    if (start.lineNumber === end.lineNumber && start.column === Number.MAX_SAFE_INTEGER) {\n        return Range.fromPositions(end, end);\n    }\n    else if (!start.isBeforeOrEqual(end)) {\n        throw new BugIndicatingError('start must be before end');\n    }\n    return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n}\nclass AbstractText {\n    get endPositionExclusive() {\n        return this.length.addToPosition(new position_Position(1, 1));\n    }\n}\nclass StringText extends AbstractText {\n    constructor(value) {\n        super();\n        this.value = value;\n        this._t = new PositionOffsetTransformer(this.value);\n    }\n    getValueOfRange(range) {\n        return this._t.getOffsetRange(range).substring(this.value);\n    }\n    get length() {\n        return this._t.textLength;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/rangeMapping.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n */\nclass LineRangeMapping {\n    static inverse(mapping, originalLineCount, modifiedLineCount) {\n        const result = [];\n        let lastOriginalEndLineNumber = 1;\n        let lastModifiedEndLineNumber = 1;\n        for (const m of mapping) {\n            const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, m.original.startLineNumber), new LineRange(lastModifiedEndLineNumber, m.modified.startLineNumber));\n            if (!r.modified.isEmpty) {\n                result.push(r);\n            }\n            lastOriginalEndLineNumber = m.original.endLineNumberExclusive;\n            lastModifiedEndLineNumber = m.modified.endLineNumberExclusive;\n        }\n        const r = new LineRangeMapping(new LineRange(lastOriginalEndLineNumber, originalLineCount + 1), new LineRange(lastModifiedEndLineNumber, modifiedLineCount + 1));\n        if (!r.modified.isEmpty) {\n            result.push(r);\n        }\n        return result;\n    }\n    static clip(mapping, originalRange, modifiedRange) {\n        const result = [];\n        for (const m of mapping) {\n            const original = m.original.intersect(originalRange);\n            const modified = m.modified.intersect(modifiedRange);\n            if (original && !original.isEmpty && modified && !modified.isEmpty) {\n                result.push(new LineRangeMapping(original, modified));\n            }\n        }\n        return result;\n    }\n    constructor(originalRange, modifiedRange) {\n        this.original = originalRange;\n        this.modified = modifiedRange;\n    }\n    toString() {\n        return `{${this.original.toString()}->${this.modified.toString()}}`;\n    }\n    flip() {\n        return new LineRangeMapping(this.modified, this.original);\n    }\n    join(other) {\n        return new LineRangeMapping(this.original.join(other.original), this.modified.join(other.modified));\n    }\n    /**\n     * This method assumes that the LineRangeMapping describes a valid diff!\n     * I.e. if one range is empty, the other range cannot be the entire document.\n     * It avoids various problems when the line range points to non-existing line-numbers.\n    */\n    toRangeMapping() {\n        const origInclusiveRange = this.original.toInclusiveRange();\n        const modInclusiveRange = this.modified.toInclusiveRange();\n        if (origInclusiveRange && modInclusiveRange) {\n            return new RangeMapping(origInclusiveRange, modInclusiveRange);\n        }\n        else if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {\n            if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1)) {\n                // If one line range starts at 1, the other one must start at 1 as well.\n                throw new errors_BugIndicatingError('not a valid diff');\n            }\n            // Because one range is empty and both ranges start at line 1, none of the ranges can cover all lines.\n            // Thus, `endLineNumberExclusive` is a valid line number.\n            return new RangeMapping(new range_Range(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new range_Range(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));\n        }\n        else {\n            // We can assume here that both startLineNumbers are greater than 1.\n            return new RangeMapping(new range_Range(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new range_Range(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));\n        }\n    }\n}\n/**\n * Maps a line range in the original text model to a line range in the modified text model.\n * Also contains inner range mappings.\n */\nclass DetailedLineRangeMapping extends LineRangeMapping {\n    static fromRangeMappings(rangeMappings) {\n        const originalRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.originalRange)));\n        const modifiedRange = LineRange.join(rangeMappings.map(r => LineRange.fromRangeInclusive(r.modifiedRange)));\n        return new DetailedLineRangeMapping(originalRange, modifiedRange, rangeMappings);\n    }\n    constructor(originalRange, modifiedRange, innerChanges) {\n        super(originalRange, modifiedRange);\n        this.innerChanges = innerChanges;\n    }\n    flip() {\n        var _a;\n        return new DetailedLineRangeMapping(this.modified, this.original, (_a = this.innerChanges) === null || _a === void 0 ? void 0 : _a.map(c => c.flip()));\n    }\n    withInnerChangesFromLineRanges() {\n        return new DetailedLineRangeMapping(this.original, this.modified, [this.toRangeMapping()]);\n    }\n}\n/**\n * Maps a range in the original text model to a range in the modified text model.\n */\nclass RangeMapping {\n    constructor(originalRange, modifiedRange) {\n        this.originalRange = originalRange;\n        this.modifiedRange = modifiedRange;\n    }\n    toString() {\n        return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;\n    }\n    flip() {\n        return new RangeMapping(this.modifiedRange, this.originalRange);\n    }\n    /**\n     * Creates a single text edit that describes the change from the original to the modified text.\n    */\n    toTextEdit(modified) {\n        const newText = modified.getValueOfRange(this.modifiedRange);\n        return new SingleTextEdit(this.originalRange, newText);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/legacyLinesDiffComputer.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nclass LegacyLinesDiffComputer {\n    computeDiff(originalLines, modifiedLines, options) {\n        var _a;\n        const diffComputer = new DiffComputer(originalLines, modifiedLines, {\n            maxComputationTime: options.maxComputationTimeMs,\n            shouldIgnoreTrimWhitespace: options.ignoreTrimWhitespace,\n            shouldComputeCharChanges: true,\n            shouldMakePrettyDiff: true,\n            shouldPostProcessCharChanges: true,\n        });\n        const result = diffComputer.computeDiff();\n        const changes = [];\n        let lastChange = null;\n        for (const c of result.changes) {\n            let originalRange;\n            if (c.originalEndLineNumber === 0) {\n                // Insertion\n                originalRange = new LineRange(c.originalStartLineNumber + 1, c.originalStartLineNumber + 1);\n            }\n            else {\n                originalRange = new LineRange(c.originalStartLineNumber, c.originalEndLineNumber + 1);\n            }\n            let modifiedRange;\n            if (c.modifiedEndLineNumber === 0) {\n                // Deletion\n                modifiedRange = new LineRange(c.modifiedStartLineNumber + 1, c.modifiedStartLineNumber + 1);\n            }\n            else {\n                modifiedRange = new LineRange(c.modifiedStartLineNumber, c.modifiedEndLineNumber + 1);\n            }\n            let change = new DetailedLineRangeMapping(originalRange, modifiedRange, (_a = c.charChanges) === null || _a === void 0 ? void 0 : _a.map(c => new RangeMapping(new range_Range(c.originalStartLineNumber, c.originalStartColumn, c.originalEndLineNumber, c.originalEndColumn), new range_Range(c.modifiedStartLineNumber, c.modifiedStartColumn, c.modifiedEndLineNumber, c.modifiedEndColumn))));\n            if (lastChange) {\n                if (lastChange.modified.endLineNumberExclusive === change.modified.startLineNumber\n                    || lastChange.original.endLineNumberExclusive === change.original.startLineNumber) {\n                    // join touching diffs. Probably moving diffs up/down in the algorithm causes touching diffs.\n                    change = new DetailedLineRangeMapping(lastChange.original.join(change.original), lastChange.modified.join(change.modified), lastChange.innerChanges && change.innerChanges ?\n                        lastChange.innerChanges.concat(change.innerChanges) : undefined);\n                    changes.pop();\n                }\n            }\n            changes.push(change);\n            lastChange = change;\n        }\n        assert_assertFn(() => {\n            return assert_checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n                // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n                m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n                m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n        });\n        return new LinesDiff(changes, [], result.quitEarly);\n    }\n}\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n            if (!shouldIgnoreTrimWhitespace && index < endIndex) {\n                // Add \\n if trim whitespace is not ignored\n                charCodes[len] = 10 /* CharCode.LineFeed */;\n                lineNumbers[len] = index + 1;\n                columns[len] = lineContent.length + 1;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    toString() {\n        return ('[' + this._charCodes.map((s, idx) => (s === 10 /* CharCode.LineFeed */ ? '\\\\n' : String.fromCharCode(s)) + `-(${this._lineNumbers[idx]},${this._columns[idx]})`).join(', ') + ']');\n    }\n    _assertIndex(index, arr) {\n        if (index < 0 || index >= arr.length) {\n            throw new Error(`Illegal index`);\n        }\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        if (i > 0 && i === this._lineNumbers.length) {\n            // the start line number of the element after the last element\n            // is the end line number of the last element\n            return this.getEndLineNumber(i - 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        return this._lineNumbers[i];\n    }\n    getEndLineNumber(i) {\n        if (i === -1) {\n            // the end line number of the element before the first element\n            // is the start line number of the first element\n            return this.getStartLineNumber(i + 1);\n        }\n        this._assertIndex(i, this._lineNumbers);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return this._lineNumbers[i] + 1;\n        }\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        if (i > 0 && i === this._columns.length) {\n            // the start column of the element after the last element\n            // is the end column of the last element\n            return this.getEndColumn(i - 1);\n        }\n        this._assertIndex(i, this._columns);\n        return this._columns[i];\n    }\n    getEndColumn(i) {\n        if (i === -1) {\n            // the end column of the element before the first element\n            // is the start column of the first element\n            return this.getStartColumn(i + 1);\n        }\n        this._assertIndex(i, this._columns);\n        if (this._charCodes[i] === 10 /* CharCode.LineFeed */) {\n            return 1;\n        }\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        const originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n        const originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n        const originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        const originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        const modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n        const modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n        const modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        const modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            if (originalCharSequence.getElements().length > 0 && modifiedCharSequence.getElements().length > 0) {\n                let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n                if (shouldPostProcessCharChanges) {\n                    rawChanges = postProcessCharChanges(rawChanges);\n                }\n                charChanges = [];\n                for (let i = 0, length = rawChanges.length; i < length; i++) {\n                    charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n                }\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nclass DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: undefined\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber === originalLineNumber && prevChange.modifiedEndLineNumber === modifiedLineNumber) {\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/diffAlgorithm.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nclass DiffAlgorithmResult {\n    static trivial(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], false);\n    }\n    static trivialTimedOut(seq1, seq2) {\n        return new DiffAlgorithmResult([new SequenceDiff(OffsetRange.ofLength(seq1.length), OffsetRange.ofLength(seq2.length))], true);\n    }\n    constructor(diffs, \n    /**\n     * Indicates if the time out was reached.\n     * In that case, the diffs might be an approximation and the user should be asked to rerun the diff with more time.\n     */\n    hitTimeout) {\n        this.diffs = diffs;\n        this.hitTimeout = hitTimeout;\n    }\n}\nclass SequenceDiff {\n    static invert(sequenceDiffs, doc1Length) {\n        const result = [];\n        forEachAdjacent(sequenceDiffs, (a, b) => {\n            result.push(SequenceDiff.fromOffsetPairs(a ? a.getEndExclusives() : OffsetPair.zero, b ? b.getStarts() : new OffsetPair(doc1Length, (a ? a.seq2Range.endExclusive - a.seq1Range.endExclusive : 0) + doc1Length)));\n        });\n        return result;\n    }\n    static fromOffsetPairs(start, endExclusive) {\n        return new SequenceDiff(new OffsetRange(start.offset1, endExclusive.offset1), new OffsetRange(start.offset2, endExclusive.offset2));\n    }\n    constructor(seq1Range, seq2Range) {\n        this.seq1Range = seq1Range;\n        this.seq2Range = seq2Range;\n    }\n    swap() {\n        return new SequenceDiff(this.seq2Range, this.seq1Range);\n    }\n    toString() {\n        return `${this.seq1Range} <-> ${this.seq2Range}`;\n    }\n    join(other) {\n        return new SequenceDiff(this.seq1Range.join(other.seq1Range), this.seq2Range.join(other.seq2Range));\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.delta(offset), this.seq2Range.delta(offset));\n    }\n    deltaStart(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaStart(offset), this.seq2Range.deltaStart(offset));\n    }\n    deltaEnd(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new SequenceDiff(this.seq1Range.deltaEnd(offset), this.seq2Range.deltaEnd(offset));\n    }\n    intersect(other) {\n        const i1 = this.seq1Range.intersect(other.seq1Range);\n        const i2 = this.seq2Range.intersect(other.seq2Range);\n        if (!i1 || !i2) {\n            return undefined;\n        }\n        return new SequenceDiff(i1, i2);\n    }\n    getStarts() {\n        return new OffsetPair(this.seq1Range.start, this.seq2Range.start);\n    }\n    getEndExclusives() {\n        return new OffsetPair(this.seq1Range.endExclusive, this.seq2Range.endExclusive);\n    }\n}\nclass OffsetPair {\n    constructor(offset1, offset2) {\n        this.offset1 = offset1;\n        this.offset2 = offset2;\n    }\n    toString() {\n        return `${this.offset1} <-> ${this.offset2}`;\n    }\n    delta(offset) {\n        if (offset === 0) {\n            return this;\n        }\n        return new OffsetPair(this.offset1 + offset, this.offset2 + offset);\n    }\n    equals(other) {\n        return this.offset1 === other.offset1 && this.offset2 === other.offset2;\n    }\n}\nOffsetPair.zero = new OffsetPair(0, 0);\nOffsetPair.max = new OffsetPair(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\nclass InfiniteTimeout {\n    isValid() {\n        return true;\n    }\n}\nInfiniteTimeout.instance = new InfiniteTimeout();\nclass DateTimeout {\n    constructor(timeout) {\n        this.timeout = timeout;\n        this.startTime = Date.now();\n        this.valid = true;\n        if (timeout <= 0) {\n            throw new errors_BugIndicatingError('timeout must be positive');\n        }\n    }\n    // Recommendation: Set a log-point `{this.disable()}` in the body\n    isValid() {\n        const valid = Date.now() - this.startTime < this.timeout;\n        if (!valid && this.valid) {\n            this.valid = false; // timeout reached\n            // eslint-disable-next-line no-debugger\n            debugger; // WARNING: Most likely debugging caused the timeout. Call `this.disable()` to continue without timing out.\n        }\n        return this.valid;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/utils.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass Array2D {\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n        this.array = [];\n        this.array = new Array(width * height);\n    }\n    get(x, y) {\n        return this.array[x + y * this.width];\n    }\n    set(x, y, value) {\n        this.array[x + y * this.width] = value;\n    }\n}\nfunction isSpace(charCode) {\n    return charCode === 32 /* CharCode.Space */ || charCode === 9 /* CharCode.Tab */;\n}\nclass LineRangeFragment {\n    static getKey(chr) {\n        let key = this.chrKeys.get(chr);\n        if (key === undefined) {\n            key = this.chrKeys.size;\n            this.chrKeys.set(chr, key);\n        }\n        return key;\n    }\n    constructor(range, lines, source) {\n        this.range = range;\n        this.lines = lines;\n        this.source = source;\n        this.histogram = [];\n        let counter = 0;\n        for (let i = range.startLineNumber - 1; i < range.endLineNumberExclusive - 1; i++) {\n            const line = lines[i];\n            for (let j = 0; j < line.length; j++) {\n                counter++;\n                const chr = line[j];\n                const key = LineRangeFragment.getKey(chr);\n                this.histogram[key] = (this.histogram[key] || 0) + 1;\n            }\n            counter++;\n            const key = LineRangeFragment.getKey('\\n');\n            this.histogram[key] = (this.histogram[key] || 0) + 1;\n        }\n        this.totalCount = counter;\n    }\n    computeSimilarity(other) {\n        var _a, _b;\n        let sumDifferences = 0;\n        const maxLength = Math.max(this.histogram.length, other.histogram.length);\n        for (let i = 0; i < maxLength; i++) {\n            sumDifferences += Math.abs(((_a = this.histogram[i]) !== null && _a !== void 0 ? _a : 0) - ((_b = other.histogram[i]) !== null && _b !== void 0 ? _b : 0));\n        }\n        return 1 - (sumDifferences / (this.totalCount + other.totalCount));\n    }\n}\nLineRangeFragment.chrKeys = new Map();\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/dynamicProgrammingDiffing.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n/**\n * A O(MN) diffing algorithm that supports a score function.\n * The algorithm can be improved by processing the 2d array diagonally.\n*/\nclass DynamicProgrammingDiffing {\n    compute(sequence1, sequence2, timeout = InfiniteTimeout.instance, equalityScore) {\n        if (sequence1.length === 0 || sequence2.length === 0) {\n            return DiffAlgorithmResult.trivial(sequence1, sequence2);\n        }\n        /**\n         * lcsLengths.get(i, j): Length of the longest common subsequence of sequence1.substring(0, i + 1) and sequence2.substring(0, j + 1).\n         */\n        const lcsLengths = new Array2D(sequence1.length, sequence2.length);\n        const directions = new Array2D(sequence1.length, sequence2.length);\n        const lengths = new Array2D(sequence1.length, sequence2.length);\n        // ==== Initializing lcsLengths ====\n        for (let s1 = 0; s1 < sequence1.length; s1++) {\n            for (let s2 = 0; s2 < sequence2.length; s2++) {\n                if (!timeout.isValid()) {\n                    return DiffAlgorithmResult.trivialTimedOut(sequence1, sequence2);\n                }\n                const horizontalLen = s1 === 0 ? 0 : lcsLengths.get(s1 - 1, s2);\n                const verticalLen = s2 === 0 ? 0 : lcsLengths.get(s1, s2 - 1);\n                let extendedSeqScore;\n                if (sequence1.getElement(s1) === sequence2.getElement(s2)) {\n                    if (s1 === 0 || s2 === 0) {\n                        extendedSeqScore = 0;\n                    }\n                    else {\n                        extendedSeqScore = lcsLengths.get(s1 - 1, s2 - 1);\n                    }\n                    if (s1 > 0 && s2 > 0 && directions.get(s1 - 1, s2 - 1) === 3) {\n                        // Prefer consecutive diagonals\n                        extendedSeqScore += lengths.get(s1 - 1, s2 - 1);\n                    }\n                    extendedSeqScore += (equalityScore ? equalityScore(s1, s2) : 1);\n                }\n                else {\n                    extendedSeqScore = -1;\n                }\n                const newValue = Math.max(horizontalLen, verticalLen, extendedSeqScore);\n                if (newValue === extendedSeqScore) {\n                    // Prefer diagonals\n                    const prevLen = s1 > 0 && s2 > 0 ? lengths.get(s1 - 1, s2 - 1) : 0;\n                    lengths.set(s1, s2, prevLen + 1);\n                    directions.set(s1, s2, 3);\n                }\n                else if (newValue === horizontalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 1);\n                }\n                else if (newValue === verticalLen) {\n                    lengths.set(s1, s2, 0);\n                    directions.set(s1, s2, 2);\n                }\n                lcsLengths.set(s1, s2, newValue);\n            }\n        }\n        // ==== Backtracking ====\n        const result = [];\n        let lastAligningPosS1 = sequence1.length;\n        let lastAligningPosS2 = sequence2.length;\n        function reportDecreasingAligningPositions(s1, s2) {\n            if (s1 + 1 !== lastAligningPosS1 || s2 + 1 !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(s1 + 1, lastAligningPosS1), new OffsetRange(s2 + 1, lastAligningPosS2)));\n            }\n            lastAligningPosS1 = s1;\n            lastAligningPosS2 = s2;\n        }\n        let s1 = sequence1.length - 1;\n        let s2 = sequence2.length - 1;\n        while (s1 >= 0 && s2 >= 0) {\n            if (directions.get(s1, s2) === 3) {\n                reportDecreasingAligningPositions(s1, s2);\n                s1--;\n                s2--;\n            }\n            else {\n                if (directions.get(s1, s2) === 1) {\n                    s1--;\n                }\n                else {\n                    s2--;\n                }\n            }\n        }\n        reportDecreasingAligningPositions(-1, -1);\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/algorithms/myersDiffAlgorithm.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n/**\n * An O(ND) diff algorithm that has a quadratic space worst-case complexity.\n*/\nclass MyersDiffAlgorithm {\n    compute(seq1, seq2, timeout = InfiniteTimeout.instance) {\n        // These are common special cases.\n        // The early return improves performance dramatically.\n        if (seq1.length === 0 || seq2.length === 0) {\n            return DiffAlgorithmResult.trivial(seq1, seq2);\n        }\n        const seqX = seq1; // Text on the x axis\n        const seqY = seq2; // Text on the y axis\n        function getXAfterSnake(x, y) {\n            while (x < seqX.length && y < seqY.length && seqX.getElement(x) === seqY.getElement(y)) {\n                x++;\n                y++;\n            }\n            return x;\n        }\n        let d = 0;\n        // V[k]: X value of longest d-line that ends in diagonal k.\n        // d-line: path from (0,0) to (x,y) that uses exactly d non-diagonals.\n        // diagonal k: Set of points (x,y) with x-y = k.\n        // k=1 -> (1,0),(2,1)\n        const V = new FastInt32Array();\n        V.set(0, getXAfterSnake(0, 0));\n        const paths = new FastArrayNegativeIndices();\n        paths.set(0, V.get(0) === 0 ? null : new SnakePath(null, 0, 0, V.get(0)));\n        let k = 0;\n        loop: while (true) {\n            d++;\n            if (!timeout.isValid()) {\n                return DiffAlgorithmResult.trivialTimedOut(seqX, seqY);\n            }\n            // The paper has `for (k = -d; k <= d; k += 2)`, but we can ignore diagonals that cannot influence the result.\n            const lowerBound = -Math.min(d, seqY.length + (d % 2));\n            const upperBound = Math.min(d, seqX.length + (d % 2));\n            for (k = lowerBound; k <= upperBound; k += 2) {\n                let step = 0;\n                // We can use the X values of (d-1)-lines to compute X value of the longest d-lines.\n                const maxXofDLineTop = k === upperBound ? -1 : V.get(k + 1); // We take a vertical non-diagonal (add a symbol in seqX)\n                const maxXofDLineLeft = k === lowerBound ? -1 : V.get(k - 1) + 1; // We take a horizontal non-diagonal (+1 x) (delete a symbol in seqX)\n                step++;\n                const x = Math.min(Math.max(maxXofDLineTop, maxXofDLineLeft), seqX.length);\n                const y = x - k;\n                step++;\n                if (x > seqX.length || y > seqY.length) {\n                    // This diagonal is irrelevant for the result.\n                    // TODO: Don't pay the cost for this in the next iteration.\n                    continue;\n                }\n                const newMaxX = getXAfterSnake(x, y);\n                V.set(k, newMaxX);\n                const lastPath = x === maxXofDLineTop ? paths.get(k + 1) : paths.get(k - 1);\n                paths.set(k, newMaxX !== x ? new SnakePath(lastPath, x, y, newMaxX - x) : lastPath);\n                if (V.get(k) === seqX.length && V.get(k) - k === seqY.length) {\n                    break loop;\n                }\n            }\n        }\n        let path = paths.get(k);\n        const result = [];\n        let lastAligningPosS1 = seqX.length;\n        let lastAligningPosS2 = seqY.length;\n        while (true) {\n            const endX = path ? path.x + path.length : 0;\n            const endY = path ? path.y + path.length : 0;\n            if (endX !== lastAligningPosS1 || endY !== lastAligningPosS2) {\n                result.push(new SequenceDiff(new OffsetRange(endX, lastAligningPosS1), new OffsetRange(endY, lastAligningPosS2)));\n            }\n            if (!path) {\n                break;\n            }\n            lastAligningPosS1 = path.x;\n            lastAligningPosS2 = path.y;\n            path = path.prev;\n        }\n        result.reverse();\n        return new DiffAlgorithmResult(result, false);\n    }\n}\nclass SnakePath {\n    constructor(prev, x, y, length) {\n        this.prev = prev;\n        this.x = x;\n        this.y = y;\n        this.length = length;\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastInt32Array {\n    constructor() {\n        this.positiveArr = new Int32Array(10);\n        this.negativeArr = new Int32Array(10);\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            if (idx >= this.negativeArr.length) {\n                const arr = this.negativeArr;\n                this.negativeArr = new Int32Array(arr.length * 2);\n                this.negativeArr.set(arr);\n            }\n            this.negativeArr[idx] = value;\n        }\n        else {\n            if (idx >= this.positiveArr.length) {\n                const arr = this.positiveArr;\n                this.positiveArr = new Int32Array(arr.length * 2);\n                this.positiveArr.set(arr);\n            }\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n/**\n * An array that supports fast negative indices.\n*/\nclass FastArrayNegativeIndices {\n    constructor() {\n        this.positiveArr = [];\n        this.negativeArr = [];\n    }\n    get(idx) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            return this.negativeArr[idx];\n        }\n        else {\n            return this.positiveArr[idx];\n        }\n    }\n    set(idx, value) {\n        if (idx < 0) {\n            idx = -idx - 1;\n            this.negativeArr[idx] = value;\n        }\n        else {\n            this.positiveArr[idx] = value;\n        }\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/linesSliceCharSequence.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\nclass LinesSliceCharSequence {\n    constructor(lines, lineRange, considerWhitespaceChanges) {\n        // This slice has to have lineRange.length many \\n! (otherwise diffing against an empty slice will be problematic)\n        // (Unless it covers the entire document, in that case the other slice also has to cover the entire document ands it's okay)\n        this.lines = lines;\n        this.considerWhitespaceChanges = considerWhitespaceChanges;\n        this.elements = [];\n        this.firstCharOffsetByLine = [];\n        // To account for trimming\n        this.additionalOffsetByLine = [];\n        // If the slice covers the end, but does not start at the beginning, we include just the \\n of the previous line.\n        let trimFirstLineFully = false;\n        if (lineRange.start > 0 && lineRange.endExclusive >= lines.length) {\n            lineRange = new OffsetRange(lineRange.start - 1, lineRange.endExclusive);\n            trimFirstLineFully = true;\n        }\n        this.lineRange = lineRange;\n        this.firstCharOffsetByLine[0] = 0;\n        for (let i = this.lineRange.start; i < this.lineRange.endExclusive; i++) {\n            let line = lines[i];\n            let offset = 0;\n            if (trimFirstLineFully) {\n                offset = line.length;\n                line = '';\n                trimFirstLineFully = false;\n            }\n            else if (!considerWhitespaceChanges) {\n                const trimmedStartLine = line.trimStart();\n                offset = line.length - trimmedStartLine.length;\n                line = trimmedStartLine.trimEnd();\n            }\n            this.additionalOffsetByLine.push(offset);\n            for (let i = 0; i < line.length; i++) {\n                this.elements.push(line.charCodeAt(i));\n            }\n            // Don't add an \\n that does not exist in the document.\n            if (i < lines.length - 1) {\n                this.elements.push('\\n'.charCodeAt(0));\n                this.firstCharOffsetByLine[i - this.lineRange.start + 1] = this.elements.length;\n            }\n        }\n        // To account for the last line\n        this.additionalOffsetByLine.push(0);\n    }\n    toString() {\n        return `Slice: \"${this.text}\"`;\n    }\n    get text() {\n        return this.getText(new OffsetRange(0, this.length));\n    }\n    getText(range) {\n        return this.elements.slice(range.start, range.endExclusive).map(e => String.fromCharCode(e)).join('');\n    }\n    getElement(offset) {\n        return this.elements[offset];\n    }\n    get length() {\n        return this.elements.length;\n    }\n    getBoundaryScore(length) {\n        //   a   b   c   ,           d   e   f\n        // 11  0   0   12  15  6   13  0   0   11\n        const prevCategory = getCategory(length > 0 ? this.elements[length - 1] : -1);\n        const nextCategory = getCategory(length < this.elements.length ? this.elements[length] : -1);\n        if (prevCategory === 7 /* CharBoundaryCategory.LineBreakCR */ && nextCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // don't break between \\r and \\n\n            return 0;\n        }\n        if (prevCategory === 8 /* CharBoundaryCategory.LineBreakLF */) {\n            // prefer the linebreak before the change\n            return 150;\n        }\n        let score = 0;\n        if (prevCategory !== nextCategory) {\n            score += 10;\n            if (prevCategory === 0 /* CharBoundaryCategory.WordLower */ && nextCategory === 1 /* CharBoundaryCategory.WordUpper */) {\n                score += 1;\n            }\n        }\n        score += getCategoryBoundaryScore(prevCategory);\n        score += getCategoryBoundaryScore(nextCategory);\n        return score;\n    }\n    translateOffset(offset) {\n        // find smallest i, so that lineBreakOffsets[i] <= offset using binary search\n        if (this.lineRange.isEmpty) {\n            return new position_Position(this.lineRange.start + 1, 1);\n        }\n        const i = findLastIdxMonotonous(this.firstCharOffsetByLine, (value) => value <= offset);\n        return new position_Position(this.lineRange.start + i + 1, offset - this.firstCharOffsetByLine[i] + this.additionalOffsetByLine[i] + 1);\n    }\n    translateRange(range) {\n        return range_Range.fromPositions(this.translateOffset(range.start), this.translateOffset(range.endExclusive));\n    }\n    /**\n     * Finds the word that contains the character at the given offset\n     */\n    findWordContaining(offset) {\n        if (offset < 0 || offset >= this.elements.length) {\n            return undefined;\n        }\n        if (!isWordChar(this.elements[offset])) {\n            return undefined;\n        }\n        // find start\n        let start = offset;\n        while (start > 0 && isWordChar(this.elements[start - 1])) {\n            start--;\n        }\n        // find end\n        let end = offset;\n        while (end < this.elements.length && isWordChar(this.elements[end])) {\n            end++;\n        }\n        return new OffsetRange(start, end);\n    }\n    countLinesIn(range) {\n        return this.translateOffset(range.endExclusive).lineNumber - this.translateOffset(range.start).lineNumber;\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.elements[offset1] === this.elements[offset2];\n    }\n    extendToFullLines(range) {\n        var _a, _b;\n        const start = (_a = findLastMonotonous(this.firstCharOffsetByLine, x => x <= range.start)) !== null && _a !== void 0 ? _a : 0;\n        const end = (_b = findFirstMonotonous(this.firstCharOffsetByLine, x => range.endExclusive <= x)) !== null && _b !== void 0 ? _b : this.elements.length;\n        return new OffsetRange(start, end);\n    }\n}\nfunction isWordChar(charCode) {\n    return charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */\n        || charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */\n        || charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */;\n}\nconst score = {\n    [0 /* CharBoundaryCategory.WordLower */]: 0,\n    [1 /* CharBoundaryCategory.WordUpper */]: 0,\n    [2 /* CharBoundaryCategory.WordNumber */]: 0,\n    [3 /* CharBoundaryCategory.End */]: 10,\n    [4 /* CharBoundaryCategory.Other */]: 2,\n    [5 /* CharBoundaryCategory.Separator */]: 30,\n    [6 /* CharBoundaryCategory.Space */]: 3,\n    [7 /* CharBoundaryCategory.LineBreakCR */]: 10,\n    [8 /* CharBoundaryCategory.LineBreakLF */]: 10,\n};\nfunction getCategoryBoundaryScore(category) {\n    return score[category];\n}\nfunction getCategory(charCode) {\n    if (charCode === 10 /* CharCode.LineFeed */) {\n        return 8 /* CharBoundaryCategory.LineBreakLF */;\n    }\n    else if (charCode === 13 /* CharCode.CarriageReturn */) {\n        return 7 /* CharBoundaryCategory.LineBreakCR */;\n    }\n    else if (isSpace(charCode)) {\n        return 6 /* CharBoundaryCategory.Space */;\n    }\n    else if (charCode >= 97 /* CharCode.a */ && charCode <= 122 /* CharCode.z */) {\n        return 0 /* CharBoundaryCategory.WordLower */;\n    }\n    else if (charCode >= 65 /* CharCode.A */ && charCode <= 90 /* CharCode.Z */) {\n        return 1 /* CharBoundaryCategory.WordUpper */;\n    }\n    else if (charCode >= 48 /* CharCode.Digit0 */ && charCode <= 57 /* CharCode.Digit9 */) {\n        return 2 /* CharBoundaryCategory.WordNumber */;\n    }\n    else if (charCode === -1) {\n        return 3 /* CharBoundaryCategory.End */;\n    }\n    else if (charCode === 44 /* CharCode.Comma */ || charCode === 59 /* CharCode.Semicolon */) {\n        return 5 /* CharBoundaryCategory.Separator */;\n    }\n    else {\n        return 4 /* CharBoundaryCategory.Other */;\n    }\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/computeMovedLines.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\nfunction computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout) {\n    let { moves, excludedChanges } = computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout);\n    if (!timeout.isValid()) {\n        return [];\n    }\n    const filteredChanges = changes.filter(c => !excludedChanges.has(c));\n    const unchangedMoves = computeUnchangedMoves(filteredChanges, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout);\n    pushMany(moves, unchangedMoves);\n    moves = joinCloseConsecutiveMoves(moves);\n    // Ignore too short moves\n    moves = moves.filter(current => {\n        const lines = current.original.toOffsetRange().slice(originalLines).map(l => l.trim());\n        const originalText = lines.join('\\n');\n        return originalText.length >= 15 && countWhere(lines, l => l.length >= 2) >= 2;\n    });\n    moves = removeMovesInSameDiff(changes, moves);\n    return moves;\n}\nfunction countWhere(arr, predicate) {\n    let count = 0;\n    for (const t of arr) {\n        if (predicate(t)) {\n            count++;\n        }\n    }\n    return count;\n}\nfunction computeMovesFromSimpleDeletionsToSimpleInsertions(changes, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const deletions = changes\n        .filter(c => c.modified.isEmpty && c.original.length >= 3)\n        .map(d => new LineRangeFragment(d.original, originalLines, d));\n    const insertions = new Set(changes\n        .filter(c => c.original.isEmpty && c.modified.length >= 3)\n        .map(d => new LineRangeFragment(d.modified, modifiedLines, d)));\n    const excludedChanges = new Set();\n    for (const deletion of deletions) {\n        let highestSimilarity = -1;\n        let best;\n        for (const insertion of insertions) {\n            const similarity = deletion.computeSimilarity(insertion);\n            if (similarity > highestSimilarity) {\n                highestSimilarity = similarity;\n                best = insertion;\n            }\n        }\n        if (highestSimilarity > 0.90 && best) {\n            insertions.delete(best);\n            moves.push(new LineRangeMapping(deletion.range, best.range));\n            excludedChanges.add(deletion.source);\n            excludedChanges.add(best.source);\n        }\n        if (!timeout.isValid()) {\n            return { moves, excludedChanges };\n        }\n    }\n    return { moves, excludedChanges };\n}\nfunction computeUnchangedMoves(changes, hashedOriginalLines, hashedModifiedLines, originalLines, modifiedLines, timeout) {\n    const moves = [];\n    const original3LineHashes = new SetMap();\n    for (const change of changes) {\n        for (let i = change.original.startLineNumber; i < change.original.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedOriginalLines[i - 1]}:${hashedOriginalLines[i + 1 - 1]}:${hashedOriginalLines[i + 2 - 1]}`;\n            original3LineHashes.add(key, { range: new LineRange(i, i + 3) });\n        }\n    }\n    const possibleMappings = [];\n    changes.sort(compareBy(c => c.modified.startLineNumber, numberComparator));\n    for (const change of changes) {\n        let lastMappings = [];\n        for (let i = change.modified.startLineNumber; i < change.modified.endLineNumberExclusive - 2; i++) {\n            const key = `${hashedModifiedLines[i - 1]}:${hashedModifiedLines[i + 1 - 1]}:${hashedModifiedLines[i + 2 - 1]}`;\n            const currentModifiedRange = new LineRange(i, i + 3);\n            const nextMappings = [];\n            original3LineHashes.forEach(key, ({ range }) => {\n                for (const lastMapping of lastMappings) {\n                    // does this match extend some last match?\n                    if (lastMapping.originalLineRange.endLineNumberExclusive + 1 === range.endLineNumberExclusive &&\n                        lastMapping.modifiedLineRange.endLineNumberExclusive + 1 === currentModifiedRange.endLineNumberExclusive) {\n                        lastMapping.originalLineRange = new LineRange(lastMapping.originalLineRange.startLineNumber, range.endLineNumberExclusive);\n                        lastMapping.modifiedLineRange = new LineRange(lastMapping.modifiedLineRange.startLineNumber, currentModifiedRange.endLineNumberExclusive);\n                        nextMappings.push(lastMapping);\n                        return;\n                    }\n                }\n                const mapping = {\n                    modifiedLineRange: currentModifiedRange,\n                    originalLineRange: range,\n                };\n                possibleMappings.push(mapping);\n                nextMappings.push(mapping);\n            });\n            lastMappings = nextMappings;\n        }\n        if (!timeout.isValid()) {\n            return [];\n        }\n    }\n    possibleMappings.sort(reverseOrder(compareBy(m => m.modifiedLineRange.length, numberComparator)));\n    const modifiedSet = new LineRangeSet();\n    const originalSet = new LineRangeSet();\n    for (const mapping of possibleMappings) {\n        const diffOrigToMod = mapping.modifiedLineRange.startLineNumber - mapping.originalLineRange.startLineNumber;\n        const modifiedSections = modifiedSet.subtractFrom(mapping.modifiedLineRange);\n        const originalTranslatedSections = originalSet.subtractFrom(mapping.originalLineRange).getWithDelta(diffOrigToMod);\n        const modifiedIntersectedSections = modifiedSections.getIntersection(originalTranslatedSections);\n        for (const s of modifiedIntersectedSections.ranges) {\n            if (s.length < 3) {\n                continue;\n            }\n            const modifiedLineRange = s;\n            const originalLineRange = s.delta(-diffOrigToMod);\n            moves.push(new LineRangeMapping(originalLineRange, modifiedLineRange));\n            modifiedSet.addRange(modifiedLineRange);\n            originalSet.addRange(originalLineRange);\n        }\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const monotonousChanges = new MonotonousArray(changes);\n    for (let i = 0; i < moves.length; i++) {\n        const move = moves[i];\n        const firstTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber <= move.original.startLineNumber);\n        const firstTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber <= move.modified.startLineNumber);\n        const linesAbove = Math.max(move.original.startLineNumber - firstTouchingChangeOrig.original.startLineNumber, move.modified.startLineNumber - firstTouchingChangeMod.modified.startLineNumber);\n        const lastTouchingChangeOrig = monotonousChanges.findLastMonotonous(c => c.original.startLineNumber < move.original.endLineNumberExclusive);\n        const lastTouchingChangeMod = findLastMonotonous(changes, c => c.modified.startLineNumber < move.modified.endLineNumberExclusive);\n        const linesBelow = Math.max(lastTouchingChangeOrig.original.endLineNumberExclusive - move.original.endLineNumberExclusive, lastTouchingChangeMod.modified.endLineNumberExclusive - move.modified.endLineNumberExclusive);\n        let extendToTop;\n        for (extendToTop = 0; extendToTop < linesAbove; extendToTop++) {\n            const origLine = move.original.startLineNumber - extendToTop - 1;\n            const modLine = move.modified.startLineNumber - extendToTop - 1;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToTop > 0) {\n            originalSet.addRange(new LineRange(move.original.startLineNumber - extendToTop, move.original.startLineNumber));\n            modifiedSet.addRange(new LineRange(move.modified.startLineNumber - extendToTop, move.modified.startLineNumber));\n        }\n        let extendToBottom;\n        for (extendToBottom = 0; extendToBottom < linesBelow; extendToBottom++) {\n            const origLine = move.original.endLineNumberExclusive + extendToBottom;\n            const modLine = move.modified.endLineNumberExclusive + extendToBottom;\n            if (origLine > originalLines.length || modLine > modifiedLines.length) {\n                break;\n            }\n            if (modifiedSet.contains(modLine) || originalSet.contains(origLine)) {\n                break;\n            }\n            if (!areLinesSimilar(originalLines[origLine - 1], modifiedLines[modLine - 1], timeout)) {\n                break;\n            }\n        }\n        if (extendToBottom > 0) {\n            originalSet.addRange(new LineRange(move.original.endLineNumberExclusive, move.original.endLineNumberExclusive + extendToBottom));\n            modifiedSet.addRange(new LineRange(move.modified.endLineNumberExclusive, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n        if (extendToTop > 0 || extendToBottom > 0) {\n            moves[i] = new LineRangeMapping(new LineRange(move.original.startLineNumber - extendToTop, move.original.endLineNumberExclusive + extendToBottom), new LineRange(move.modified.startLineNumber - extendToTop, move.modified.endLineNumberExclusive + extendToBottom));\n        }\n    }\n    return moves;\n}\nfunction areLinesSimilar(line1, line2, timeout) {\n    if (line1.trim() === line2.trim()) {\n        return true;\n    }\n    if (line1.length > 300 && line2.length > 300) {\n        return false;\n    }\n    const myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    const result = myersDiffingAlgorithm.compute(new LinesSliceCharSequence([line1], new OffsetRange(0, 1), false), new LinesSliceCharSequence([line2], new OffsetRange(0, 1), false), timeout);\n    let commonNonSpaceCharCount = 0;\n    const inverted = SequenceDiff.invert(result.diffs, line1.length);\n    for (const seq of inverted) {\n        seq.seq1Range.forEach(idx => {\n            if (!isSpace(line1.charCodeAt(idx))) {\n                commonNonSpaceCharCount++;\n            }\n        });\n    }\n    function countNonWsChars(str) {\n        let count = 0;\n        for (let i = 0; i < line1.length; i++) {\n            if (!isSpace(str.charCodeAt(i))) {\n                count++;\n            }\n        }\n        return count;\n    }\n    const longerLineLength = countNonWsChars(line1.length > line2.length ? line1 : line2);\n    const r = commonNonSpaceCharCount / longerLineLength > 0.6 && longerLineLength > 10;\n    return r;\n}\nfunction joinCloseConsecutiveMoves(moves) {\n    if (moves.length === 0) {\n        return moves;\n    }\n    moves.sort(compareBy(m => m.original.startLineNumber, numberComparator));\n    const result = [moves[0]];\n    for (let i = 1; i < moves.length; i++) {\n        const last = result[result.length - 1];\n        const current = moves[i];\n        const originalDist = current.original.startLineNumber - last.original.endLineNumberExclusive;\n        const modifiedDist = current.modified.startLineNumber - last.modified.endLineNumberExclusive;\n        const currentMoveAfterLast = originalDist >= 0 && modifiedDist >= 0;\n        if (currentMoveAfterLast && originalDist + modifiedDist <= 2) {\n            result[result.length - 1] = last.join(current);\n            continue;\n        }\n        result.push(current);\n    }\n    return result;\n}\nfunction removeMovesInSameDiff(changes, moves) {\n    const changesMonotonous = new MonotonousArray(changes);\n    moves = moves.filter(m => {\n        const diffBeforeEndOfMoveOriginal = changesMonotonous.findLastMonotonous(c => c.original.startLineNumber < m.original.endLineNumberExclusive)\n            || new LineRangeMapping(new LineRange(1, 1), new LineRange(1, 1));\n        const diffBeforeEndOfMoveModified = findLastMonotonous(changes, c => c.modified.startLineNumber < m.modified.endLineNumberExclusive);\n        const differentDiffs = diffBeforeEndOfMoveOriginal !== diffBeforeEndOfMoveModified;\n        return differentDiffs;\n    });\n    return moves;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/heuristicSequenceOptimizations.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\nfunction optimizeSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    let result = sequenceDiffs;\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    // Sometimes, calling this function twice improves the result.\n    // Uncomment the second invocation and run the tests to see the difference.\n    result = joinSequenceDiffsByShifting(sequence1, sequence2, result);\n    result = shiftSequenceDiffs(sequence1, sequence2, result);\n    return result;\n}\n/**\n * This function fixes issues like this:\n * ```\n * import { Baz, Bar } from \"foo\";\n * ```\n * <->\n * ```\n * import { Baz, Bar, Foo } from \"foo\";\n * ```\n * Computed diff: [ {Add \",\" after Bar}, {Add \"Foo \" after space} }\n * Improved diff: [{Add \", Foo\" after Bar}]\n */\nfunction joinSequenceDiffsByShifting(sequence1, sequence2, sequenceDiffs) {\n    if (sequenceDiffs.length === 0) {\n        return sequenceDiffs;\n    }\n    const result = [];\n    result.push(sequenceDiffs[0]);\n    // First move them all to the left as much as possible and join them if possible\n    for (let i = 1; i < sequenceDiffs.length; i++) {\n        const prevResult = result[result.length - 1];\n        let cur = sequenceDiffs[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = cur.seq1Range.start - prevResult.seq1Range.endExclusive;\n            let d;\n            for (d = 1; d <= length; d++) {\n                if (sequence1.getElement(cur.seq1Range.start - d) !== sequence1.getElement(cur.seq1Range.endExclusive - d) ||\n                    sequence2.getElement(cur.seq2Range.start - d) !== sequence2.getElement(cur.seq2Range.endExclusive - d)) {\n                    break;\n                }\n            }\n            d--;\n            if (d === length) {\n                // Merge previous and current diff\n                result[result.length - 1] = new SequenceDiff(new OffsetRange(prevResult.seq1Range.start, cur.seq1Range.endExclusive - length), new OffsetRange(prevResult.seq2Range.start, cur.seq2Range.endExclusive - length));\n                continue;\n            }\n            cur = cur.delta(-d);\n        }\n        result.push(cur);\n    }\n    const result2 = [];\n    // Then move them all to the right and join them again if possible\n    for (let i = 0; i < result.length - 1; i++) {\n        const nextResult = result[i + 1];\n        let cur = result[i];\n        if (cur.seq1Range.isEmpty || cur.seq2Range.isEmpty) {\n            const length = nextResult.seq1Range.start - cur.seq1Range.endExclusive;\n            let d;\n            for (d = 0; d < length; d++) {\n                if (!sequence1.isStronglyEqual(cur.seq1Range.start + d, cur.seq1Range.endExclusive + d) ||\n                    !sequence2.isStronglyEqual(cur.seq2Range.start + d, cur.seq2Range.endExclusive + d)) {\n                    break;\n                }\n            }\n            if (d === length) {\n                // Merge previous and current diff, write to result!\n                result[i + 1] = new SequenceDiff(new OffsetRange(cur.seq1Range.start + length, nextResult.seq1Range.endExclusive), new OffsetRange(cur.seq2Range.start + length, nextResult.seq2Range.endExclusive));\n                continue;\n            }\n            if (d > 0) {\n                cur = cur.delta(d);\n            }\n        }\n        result2.push(cur);\n    }\n    if (result.length > 0) {\n        result2.push(result[result.length - 1]);\n    }\n    return result2;\n}\n// align character level diffs at whitespace characters\n// import { IBar } from \"foo\";\n// import { I[Arr, I]Bar } from \"foo\";\n// ->\n// import { [IArr, ]IBar } from \"foo\";\n// import { ITransaction, observableValue, transaction } from 'vs/base/common/observable';\n// import { ITransaction, observable[FromEvent, observable]Value, transaction } from 'vs/base/common/observable';\n// ->\n// import { ITransaction, [observableFromEvent, ]observableValue, transaction } from 'vs/base/common/observable';\n// collectBrackets(level + 1, levelPerBracketType);\n// collectBrackets(level + 1, levelPerBracket[ + 1, levelPerBracket]Type);\n// ->\n// collectBrackets(level + 1, [levelPerBracket + 1, ]levelPerBracketType);\nfunction shiftSequenceDiffs(sequence1, sequence2, sequenceDiffs) {\n    if (!sequence1.getBoundaryScore || !sequence2.getBoundaryScore) {\n        return sequenceDiffs;\n    }\n    for (let i = 0; i < sequenceDiffs.length; i++) {\n        const prevDiff = (i > 0 ? sequenceDiffs[i - 1] : undefined);\n        const diff = sequenceDiffs[i];\n        const nextDiff = (i + 1 < sequenceDiffs.length ? sequenceDiffs[i + 1] : undefined);\n        const seq1ValidRange = new OffsetRange(prevDiff ? prevDiff.seq1Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq1Range.start - 1 : sequence1.length);\n        const seq2ValidRange = new OffsetRange(prevDiff ? prevDiff.seq2Range.endExclusive + 1 : 0, nextDiff ? nextDiff.seq2Range.start - 1 : sequence2.length);\n        if (diff.seq1Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange);\n        }\n        else if (diff.seq2Range.isEmpty) {\n            sequenceDiffs[i] = shiftDiffToBetterPosition(diff.swap(), sequence2, sequence1, seq2ValidRange, seq1ValidRange).swap();\n        }\n    }\n    return sequenceDiffs;\n}\nfunction shiftDiffToBetterPosition(diff, sequence1, sequence2, seq1ValidRange, seq2ValidRange) {\n    const maxShiftLimit = 100; // To prevent performance issues\n    // don't touch previous or next!\n    let deltaBefore = 1;\n    while (diff.seq1Range.start - deltaBefore >= seq1ValidRange.start &&\n        diff.seq2Range.start - deltaBefore >= seq2ValidRange.start &&\n        sequence2.isStronglyEqual(diff.seq2Range.start - deltaBefore, diff.seq2Range.endExclusive - deltaBefore) && deltaBefore < maxShiftLimit) {\n        deltaBefore++;\n    }\n    deltaBefore--;\n    let deltaAfter = 0;\n    while (diff.seq1Range.start + deltaAfter < seq1ValidRange.endExclusive &&\n        diff.seq2Range.endExclusive + deltaAfter < seq2ValidRange.endExclusive &&\n        sequence2.isStronglyEqual(diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter) && deltaAfter < maxShiftLimit) {\n        deltaAfter++;\n    }\n    if (deltaBefore === 0 && deltaAfter === 0) {\n        return diff;\n    }\n    // Visualize `[sequence1.text, diff.seq1Range.start + deltaAfter]`\n    // and `[sequence2.text, diff.seq2Range.start + deltaAfter, diff.seq2Range.endExclusive + deltaAfter]`\n    let bestDelta = 0;\n    let bestScore = -1;\n    // find best scored delta\n    for (let delta = -deltaBefore; delta <= deltaAfter; delta++) {\n        const seq2OffsetStart = diff.seq2Range.start + delta;\n        const seq2OffsetEndExclusive = diff.seq2Range.endExclusive + delta;\n        const seq1Offset = diff.seq1Range.start + delta;\n        const score = sequence1.getBoundaryScore(seq1Offset) + sequence2.getBoundaryScore(seq2OffsetStart) + sequence2.getBoundaryScore(seq2OffsetEndExclusive);\n        if (score > bestScore) {\n            bestScore = score;\n            bestDelta = delta;\n        }\n    }\n    return diff.delta(bestDelta);\n}\nfunction removeShortMatches(sequence1, sequence2, sequenceDiffs) {\n    const result = [];\n    for (const s of sequenceDiffs) {\n        const last = result[result.length - 1];\n        if (!last) {\n            result.push(s);\n            continue;\n        }\n        if (s.seq1Range.start - last.seq1Range.endExclusive <= 2 || s.seq2Range.start - last.seq2Range.endExclusive <= 2) {\n            result[result.length - 1] = new SequenceDiff(last.seq1Range.join(s.seq1Range), last.seq2Range.join(s.seq2Range));\n        }\n        else {\n            result.push(s);\n        }\n    }\n    return result;\n}\nfunction extendDiffsToEntireWordIfAppropriate(sequence1, sequence2, sequenceDiffs) {\n    const equalMappings = SequenceDiff.invert(sequenceDiffs, sequence1.length);\n    const additional = [];\n    let lastPoint = new OffsetPair(0, 0);\n    function scanWord(pair, equalMapping) {\n        if (pair.offset1 < lastPoint.offset1 || pair.offset2 < lastPoint.offset2) {\n            return;\n        }\n        const w1 = sequence1.findWordContaining(pair.offset1);\n        const w2 = sequence2.findWordContaining(pair.offset2);\n        if (!w1 || !w2) {\n            return;\n        }\n        let w = new SequenceDiff(w1, w2);\n        const equalPart = w.intersect(equalMapping);\n        let equalChars1 = equalPart.seq1Range.length;\n        let equalChars2 = equalPart.seq2Range.length;\n        // The words do not touch previous equals mappings, as we would have processed them already.\n        // But they might touch the next ones.\n        while (equalMappings.length > 0) {\n            const next = equalMappings[0];\n            const intersects = next.seq1Range.intersects(w.seq1Range) || next.seq2Range.intersects(w.seq2Range);\n            if (!intersects) {\n                break;\n            }\n            const v1 = sequence1.findWordContaining(next.seq1Range.start);\n            const v2 = sequence2.findWordContaining(next.seq2Range.start);\n            // Because there is an intersection, we know that the words are not empty.\n            const v = new SequenceDiff(v1, v2);\n            const equalPart = v.intersect(next);\n            equalChars1 += equalPart.seq1Range.length;\n            equalChars2 += equalPart.seq2Range.length;\n            w = w.join(v);\n            if (w.seq1Range.endExclusive >= next.seq1Range.endExclusive) {\n                // The word extends beyond the next equal mapping.\n                equalMappings.shift();\n            }\n            else {\n                break;\n            }\n        }\n        if (equalChars1 + equalChars2 < (w.seq1Range.length + w.seq2Range.length) * 2 / 3) {\n            additional.push(w);\n        }\n        lastPoint = w.getEndExclusives();\n    }\n    while (equalMappings.length > 0) {\n        const next = equalMappings.shift();\n        if (next.seq1Range.isEmpty) {\n            continue;\n        }\n        scanWord(next.getStarts(), next);\n        // The equal parts are not empty, so -1 gives us a character that is equal in both parts.\n        scanWord(next.getEndExclusives().delta(-1), next);\n    }\n    const merged = mergeSequenceDiffs(sequenceDiffs, additional);\n    return merged;\n}\nfunction mergeSequenceDiffs(sequenceDiffs1, sequenceDiffs2) {\n    const result = [];\n    while (sequenceDiffs1.length > 0 || sequenceDiffs2.length > 0) {\n        const sd1 = sequenceDiffs1[0];\n        const sd2 = sequenceDiffs2[0];\n        let next;\n        if (sd1 && (!sd2 || sd1.seq1Range.start < sd2.seq1Range.start)) {\n            next = sequenceDiffs1.shift();\n        }\n        else {\n            next = sequenceDiffs2.shift();\n        }\n        if (result.length > 0 && result[result.length - 1].seq1Range.endExclusive >= next.seq1Range.start) {\n            result[result.length - 1] = result[result.length - 1].join(next);\n        }\n        else {\n            result.push(next);\n        }\n    }\n    return result;\n}\nfunction removeVeryShortMatchingLinesBetweenDiffs(sequence1, _sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedText = sequence1.getText(unchangedRange);\n                const unchangedTextWithoutWs = unchangedText.replace(/\\s/g, '');\n                if (unchangedTextWithoutWs.length <= 4\n                    && (before.seq1Range.length + before.seq2Range.length > 5 || after.seq1Range.length + after.seq2Range.length > 5)) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    return diffs;\n}\nfunction removeVeryShortMatchingTextBetweenLongDiffs(sequence1, sequence2, sequenceDiffs) {\n    let diffs = sequenceDiffs;\n    if (diffs.length === 0) {\n        return diffs;\n    }\n    let counter = 0;\n    let shouldRepeat;\n    do {\n        shouldRepeat = false;\n        const result = [\n            diffs[0]\n        ];\n        for (let i = 1; i < diffs.length; i++) {\n            const cur = diffs[i];\n            const lastResult = result[result.length - 1];\n            function shouldJoinDiffs(before, after) {\n                const unchangedRange = new OffsetRange(lastResult.seq1Range.endExclusive, cur.seq1Range.start);\n                const unchangedLineCount = sequence1.countLinesIn(unchangedRange);\n                if (unchangedLineCount > 5 || unchangedRange.length > 500) {\n                    return false;\n                }\n                const unchangedText = sequence1.getText(unchangedRange).trim();\n                if (unchangedText.length > 20 || unchangedText.split(/\\r\\n|\\r|\\n/).length > 1) {\n                    return false;\n                }\n                const beforeLineCount1 = sequence1.countLinesIn(before.seq1Range);\n                const beforeSeq1Length = before.seq1Range.length;\n                const beforeLineCount2 = sequence2.countLinesIn(before.seq2Range);\n                const beforeSeq2Length = before.seq2Range.length;\n                const afterLineCount1 = sequence1.countLinesIn(after.seq1Range);\n                const afterSeq1Length = after.seq1Range.length;\n                const afterLineCount2 = sequence2.countLinesIn(after.seq2Range);\n                const afterSeq2Length = after.seq2Range.length;\n                // TODO: Maybe a neural net can be used to derive the result from these numbers\n                const max = 2 * 40 + 50;\n                function cap(v) {\n                    return Math.min(v, max);\n                }\n                if (Math.pow(Math.pow(cap(beforeLineCount1 * 40 + beforeSeq1Length), 1.5) + Math.pow(cap(beforeLineCount2 * 40 + beforeSeq2Length), 1.5), 1.5)\n                    + Math.pow(Math.pow(cap(afterLineCount1 * 40 + afterSeq1Length), 1.5) + Math.pow(cap(afterLineCount2 * 40 + afterSeq2Length), 1.5), 1.5) > ((max ** 1.5) ** 1.5) * 1.3) {\n                    return true;\n                }\n                return false;\n            }\n            const shouldJoin = shouldJoinDiffs(lastResult, cur);\n            if (shouldJoin) {\n                shouldRepeat = true;\n                result[result.length - 1] = result[result.length - 1].join(cur);\n            }\n            else {\n                result.push(cur);\n            }\n        }\n        diffs = result;\n    } while (counter++ < 10 && shouldRepeat);\n    const newDiffs = [];\n    // Remove short suffixes/prefixes\n    forEachWithNeighbors(diffs, (prev, cur, next) => {\n        let newDiff = cur;\n        function shouldMarkAsChanged(text) {\n            return text.length > 0 && text.trim().length <= 3 && cur.seq1Range.length + cur.seq2Range.length > 100;\n        }\n        const fullRange1 = sequence1.extendToFullLines(cur.seq1Range);\n        const prefix = sequence1.getText(new OffsetRange(fullRange1.start, cur.seq1Range.start));\n        if (shouldMarkAsChanged(prefix)) {\n            newDiff = newDiff.deltaStart(-prefix.length);\n        }\n        const suffix = sequence1.getText(new OffsetRange(cur.seq1Range.endExclusive, fullRange1.endExclusive));\n        if (shouldMarkAsChanged(suffix)) {\n            newDiff = newDiff.deltaEnd(suffix.length);\n        }\n        const availableSpace = SequenceDiff.fromOffsetPairs(prev ? prev.getEndExclusives() : OffsetPair.zero, next ? next.getStarts() : OffsetPair.max);\n        const result = newDiff.intersect(availableSpace);\n        if (newDiffs.length > 0 && result.getStarts().equals(newDiffs[newDiffs.length - 1].getEndExclusives())) {\n            newDiffs[newDiffs.length - 1] = newDiffs[newDiffs.length - 1].join(result);\n        }\n        else {\n            newDiffs.push(result);\n        }\n    });\n    return newDiffs;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/lineSequence.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass lineSequence_LineSequence {\n    constructor(trimmedHash, lines) {\n        this.trimmedHash = trimmedHash;\n        this.lines = lines;\n    }\n    getElement(offset) {\n        return this.trimmedHash[offset];\n    }\n    get length() {\n        return this.trimmedHash.length;\n    }\n    getBoundaryScore(length) {\n        const indentationBefore = length === 0 ? 0 : getIndentation(this.lines[length - 1]);\n        const indentationAfter = length === this.lines.length ? 0 : getIndentation(this.lines[length]);\n        return 1000 - (indentationBefore + indentationAfter);\n    }\n    getText(range) {\n        return this.lines.slice(range.start, range.endExclusive).join('\\n');\n    }\n    isStronglyEqual(offset1, offset2) {\n        return this.lines[offset1] === this.lines[offset2];\n    }\n}\nfunction getIndentation(str) {\n    let i = 0;\n    while (i < str.length && (str.charCodeAt(i) === 32 /* CharCode.Space */ || str.charCodeAt(i) === 9 /* CharCode.Tab */)) {\n        i++;\n    }\n    return i;\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/defaultLinesDiffComputer/defaultLinesDiffComputer.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass DefaultLinesDiffComputer {\n    constructor() {\n        this.dynamicProgrammingDiffing = new DynamicProgrammingDiffing();\n        this.myersDiffingAlgorithm = new MyersDiffAlgorithm();\n    }\n    computeDiff(originalLines, modifiedLines, options) {\n        if (originalLines.length <= 1 && arrays_equals(originalLines, modifiedLines, (a, b) => a === b)) {\n            return new LinesDiff([], [], false);\n        }\n        if (originalLines.length === 1 && originalLines[0].length === 0 || modifiedLines.length === 1 && modifiedLines[0].length === 0) {\n            return new LinesDiff([\n                new DetailedLineRangeMapping(new LineRange(1, originalLines.length + 1), new LineRange(1, modifiedLines.length + 1), [\n                    new RangeMapping(new range_Range(1, 1, originalLines.length, originalLines[originalLines.length - 1].length + 1), new range_Range(1, 1, modifiedLines.length, modifiedLines[modifiedLines.length - 1].length + 1))\n                ])\n            ], [], false);\n        }\n        const timeout = options.maxComputationTimeMs === 0 ? InfiniteTimeout.instance : new DateTimeout(options.maxComputationTimeMs);\n        const considerWhitespaceChanges = !options.ignoreTrimWhitespace;\n        const perfectHashes = new Map();\n        function getOrCreateHash(text) {\n            let hash = perfectHashes.get(text);\n            if (hash === undefined) {\n                hash = perfectHashes.size;\n                perfectHashes.set(text, hash);\n            }\n            return hash;\n        }\n        const originalLinesHashes = originalLines.map((l) => getOrCreateHash(l.trim()));\n        const modifiedLinesHashes = modifiedLines.map((l) => getOrCreateHash(l.trim()));\n        const sequence1 = new lineSequence_LineSequence(originalLinesHashes, originalLines);\n        const sequence2 = new lineSequence_LineSequence(modifiedLinesHashes, modifiedLines);\n        const lineAlignmentResult = (() => {\n            if (sequence1.length + sequence2.length < 1700) {\n                // Use the improved algorithm for small files\n                return this.dynamicProgrammingDiffing.compute(sequence1, sequence2, timeout, (offset1, offset2) => originalLines[offset1] === modifiedLines[offset2]\n                    ? modifiedLines[offset2].length === 0\n                        ? 0.1\n                        : 1 + Math.log(1 + modifiedLines[offset2].length)\n                    : 0.99);\n            }\n            return this.myersDiffingAlgorithm.compute(sequence1, sequence2, timeout);\n        })();\n        let lineAlignments = lineAlignmentResult.diffs;\n        let hitTimeout = lineAlignmentResult.hitTimeout;\n        lineAlignments = optimizeSequenceDiffs(sequence1, sequence2, lineAlignments);\n        lineAlignments = removeVeryShortMatchingLinesBetweenDiffs(sequence1, sequence2, lineAlignments);\n        const alignments = [];\n        const scanForWhitespaceChanges = (equalLinesCount) => {\n            if (!considerWhitespaceChanges) {\n                return;\n            }\n            for (let i = 0; i < equalLinesCount; i++) {\n                const seq1Offset = seq1LastStart + i;\n                const seq2Offset = seq2LastStart + i;\n                if (originalLines[seq1Offset] !== modifiedLines[seq2Offset]) {\n                    // This is because of whitespace changes, diff these lines\n                    const characterDiffs = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(new OffsetRange(seq1Offset, seq1Offset + 1), new OffsetRange(seq2Offset, seq2Offset + 1)), timeout, considerWhitespaceChanges);\n                    for (const a of characterDiffs.mappings) {\n                        alignments.push(a);\n                    }\n                    if (characterDiffs.hitTimeout) {\n                        hitTimeout = true;\n                    }\n                }\n            }\n        };\n        let seq1LastStart = 0;\n        let seq2LastStart = 0;\n        for (const diff of lineAlignments) {\n            assert_assertFn(() => diff.seq1Range.start - seq1LastStart === diff.seq2Range.start - seq2LastStart);\n            const equalLinesCount = diff.seq1Range.start - seq1LastStart;\n            scanForWhitespaceChanges(equalLinesCount);\n            seq1LastStart = diff.seq1Range.endExclusive;\n            seq2LastStart = diff.seq2Range.endExclusive;\n            const characterDiffs = this.refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges);\n            if (characterDiffs.hitTimeout) {\n                hitTimeout = true;\n            }\n            for (const a of characterDiffs.mappings) {\n                alignments.push(a);\n            }\n        }\n        scanForWhitespaceChanges(originalLines.length - seq1LastStart);\n        const changes = lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines);\n        let moves = [];\n        if (options.computeMoves) {\n            moves = this.computeMoves(changes, originalLines, modifiedLines, originalLinesHashes, modifiedLinesHashes, timeout, considerWhitespaceChanges);\n        }\n        // Make sure all ranges are valid\n        assert_assertFn(() => {\n            function validatePosition(pos, lines) {\n                if (pos.lineNumber < 1 || pos.lineNumber > lines.length) {\n                    return false;\n                }\n                const line = lines[pos.lineNumber - 1];\n                if (pos.column < 1 || pos.column > line.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            function validateRange(range, lines) {\n                if (range.startLineNumber < 1 || range.startLineNumber > lines.length + 1) {\n                    return false;\n                }\n                if (range.endLineNumberExclusive < 1 || range.endLineNumberExclusive > lines.length + 1) {\n                    return false;\n                }\n                return true;\n            }\n            for (const c of changes) {\n                if (!c.innerChanges) {\n                    return false;\n                }\n                for (const ic of c.innerChanges) {\n                    const valid = validatePosition(ic.modifiedRange.getStartPosition(), modifiedLines) && validatePosition(ic.modifiedRange.getEndPosition(), modifiedLines) &&\n                        validatePosition(ic.originalRange.getStartPosition(), originalLines) && validatePosition(ic.originalRange.getEndPosition(), originalLines);\n                    if (!valid) {\n                        return false;\n                    }\n                }\n                if (!validateRange(c.modified, modifiedLines) || !validateRange(c.original, originalLines)) {\n                    return false;\n                }\n            }\n            return true;\n        });\n        return new LinesDiff(changes, moves, hitTimeout);\n    }\n    computeMoves(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout, considerWhitespaceChanges) {\n        const moves = computeMovedLines(changes, originalLines, modifiedLines, hashedOriginalLines, hashedModifiedLines, timeout);\n        const movesWithDiffs = moves.map(m => {\n            const moveChanges = this.refineDiff(originalLines, modifiedLines, new SequenceDiff(m.original.toOffsetRange(), m.modified.toOffsetRange()), timeout, considerWhitespaceChanges);\n            const mappings = lineRangeMappingFromRangeMappings(moveChanges.mappings, originalLines, modifiedLines, true);\n            return new MovedText(m, mappings);\n        });\n        return movesWithDiffs;\n    }\n    refineDiff(originalLines, modifiedLines, diff, timeout, considerWhitespaceChanges) {\n        const slice1 = new LinesSliceCharSequence(originalLines, diff.seq1Range, considerWhitespaceChanges);\n        const slice2 = new LinesSliceCharSequence(modifiedLines, diff.seq2Range, considerWhitespaceChanges);\n        const diffResult = slice1.length + slice2.length < 500\n            ? this.dynamicProgrammingDiffing.compute(slice1, slice2, timeout)\n            : this.myersDiffingAlgorithm.compute(slice1, slice2, timeout);\n        let diffs = diffResult.diffs;\n        diffs = optimizeSequenceDiffs(slice1, slice2, diffs);\n        diffs = extendDiffsToEntireWordIfAppropriate(slice1, slice2, diffs);\n        diffs = removeShortMatches(slice1, slice2, diffs);\n        diffs = removeVeryShortMatchingTextBetweenLongDiffs(slice1, slice2, diffs);\n        const result = diffs.map((d) => new RangeMapping(slice1.translateRange(d.seq1Range), slice2.translateRange(d.seq2Range)));\n        // Assert: result applied on original should be the same as diff applied to original\n        return {\n            mappings: result,\n            hitTimeout: diffResult.hitTimeout,\n        };\n    }\n}\nfunction lineRangeMappingFromRangeMappings(alignments, originalLines, modifiedLines, dontAssertStartLine = false) {\n    const changes = [];\n    for (const g of groupAdjacentBy(alignments.map(a => getLineRangeMapping(a, originalLines, modifiedLines)), (a1, a2) => a1.original.overlapOrTouch(a2.original)\n        || a1.modified.overlapOrTouch(a2.modified))) {\n        const first = g[0];\n        const last = g[g.length - 1];\n        changes.push(new DetailedLineRangeMapping(first.original.join(last.original), first.modified.join(last.modified), g.map(a => a.innerChanges[0])));\n    }\n    assert_assertFn(() => {\n        if (!dontAssertStartLine && changes.length > 0) {\n            if (changes[0].modified.startLineNumber !== changes[0].original.startLineNumber) {\n                return false;\n            }\n            if (modifiedLines.length - changes[changes.length - 1].modified.endLineNumberExclusive !== originalLines.length - changes[changes.length - 1].original.endLineNumberExclusive) {\n                return false;\n            }\n        }\n        return assert_checkAdjacentItems(changes, (m1, m2) => m2.original.startLineNumber - m1.original.endLineNumberExclusive === m2.modified.startLineNumber - m1.modified.endLineNumberExclusive &&\n            // There has to be an unchanged line in between (otherwise both diffs should have been joined)\n            m1.original.endLineNumberExclusive < m2.original.startLineNumber &&\n            m1.modified.endLineNumberExclusive < m2.modified.startLineNumber);\n    });\n    return changes;\n}\nfunction getLineRangeMapping(rangeMapping, originalLines, modifiedLines) {\n    let lineStartDelta = 0;\n    let lineEndDelta = 0;\n    // rangeMapping describes the edit that replaces `rangeMapping.originalRange` with `newText := getText(modifiedLines, rangeMapping.modifiedRange)`.\n    // original: ]xxx \\n <- this line is not modified\n    // modified: ]xx  \\n\n    if (rangeMapping.modifiedRange.endColumn === 1 && rangeMapping.originalRange.endColumn === 1\n        && rangeMapping.originalRange.startLineNumber + lineStartDelta <= rangeMapping.originalRange.endLineNumber\n        && rangeMapping.modifiedRange.startLineNumber + lineStartDelta <= rangeMapping.modifiedRange.endLineNumber) {\n        // We can only do this if the range is not empty yet\n        lineEndDelta = -1;\n    }\n    // original: xxx[ \\n <- this line is not modified\n    // modified: xxx[ \\n\n    if (rangeMapping.modifiedRange.startColumn - 1 >= modifiedLines[rangeMapping.modifiedRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startColumn - 1 >= originalLines[rangeMapping.originalRange.startLineNumber - 1].length\n        && rangeMapping.originalRange.startLineNumber <= rangeMapping.originalRange.endLineNumber + lineEndDelta\n        && rangeMapping.modifiedRange.startLineNumber <= rangeMapping.modifiedRange.endLineNumber + lineEndDelta) {\n        // We can only do this if the range is not empty yet\n        lineStartDelta = 1;\n    }\n    const originalLineRange = new LineRange(rangeMapping.originalRange.startLineNumber + lineStartDelta, rangeMapping.originalRange.endLineNumber + 1 + lineEndDelta);\n    const modifiedLineRange = new LineRange(rangeMapping.modifiedRange.startLineNumber + lineStartDelta, rangeMapping.modifiedRange.endLineNumber + 1 + lineEndDelta);\n    return new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, [rangeMapping]);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/diff/linesDiffComputers.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nconst linesDiffComputers = {\n    getLegacy: () => new LegacyLinesDiffComputer(),\n    getDefault: () => new DefaultLinesDiffComputer(),\n};\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/base/common/color.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction roundFloat(number, decimalPoints) {\n    const decimal = Math.pow(10, decimalPoints);\n    return Math.round(number * decimal) / decimal;\n}\nclass RGBA {\n    constructor(r, g, b, a = 1) {\n        this._rgbaBrand = undefined;\n        this.r = Math.min(255, Math.max(0, r)) | 0;\n        this.g = Math.min(255, Math.max(0, g)) | 0;\n        this.b = Math.min(255, Math.max(0, b)) | 0;\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n    }\n    static equals(a, b) {\n        return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;\n    }\n}\nclass HSLA {\n    constructor(h, s, l, a) {\n        this._hslaBrand = undefined;\n        this.h = Math.max(Math.min(360, h), 0) | 0;\n        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n        this.l = roundFloat(Math.max(Math.min(1, l), 0), 3);\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n    }\n    static equals(a, b) {\n        return a.h === b.h && a.s === b.s && a.l === b.l && a.a === b.a;\n    }\n    /**\n     * Converts an RGB color value to HSL. Conversion formula\n     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n     * Assumes r, g, and b are contained in the set [0, 255] and\n     * returns h in the set [0, 360], s, and l in the set [0, 1].\n     */\n    static fromRGBA(rgba) {\n        const r = rgba.r / 255;\n        const g = rgba.g / 255;\n        const b = rgba.b / 255;\n        const a = rgba.a;\n        const max = Math.max(r, g, b);\n        const min = Math.min(r, g, b);\n        let h = 0;\n        let s = 0;\n        const l = (min + max) / 2;\n        const chroma = max - min;\n        if (chroma > 0) {\n            s = Math.min((l <= 0.5 ? chroma / (2 * l) : chroma / (2 - (2 * l))), 1);\n            switch (max) {\n                case r:\n                    h = (g - b) / chroma + (g < b ? 6 : 0);\n                    break;\n                case g:\n                    h = (b - r) / chroma + 2;\n                    break;\n                case b:\n                    h = (r - g) / chroma + 4;\n                    break;\n            }\n            h *= 60;\n            h = Math.round(h);\n        }\n        return new HSLA(h, s, l, a);\n    }\n    static _hue2rgb(p, q, t) {\n        if (t < 0) {\n            t += 1;\n        }\n        if (t > 1) {\n            t -= 1;\n        }\n        if (t < 1 / 6) {\n            return p + (q - p) * 6 * t;\n        }\n        if (t < 1 / 2) {\n            return q;\n        }\n        if (t < 2 / 3) {\n            return p + (q - p) * (2 / 3 - t) * 6;\n        }\n        return p;\n    }\n    /**\n     * Converts an HSL color value to RGB. Conversion formula\n     * adapted from http://en.wikipedia.org/wiki/HSL_color_space.\n     * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and\n     * returns r, g, and b in the set [0, 255].\n     */\n    static toRGBA(hsla) {\n        const h = hsla.h / 360;\n        const { s, l, a } = hsla;\n        let r, g, b;\n        if (s === 0) {\n            r = g = b = l; // achromatic\n        }\n        else {\n            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n            const p = 2 * l - q;\n            r = HSLA._hue2rgb(p, q, h + 1 / 3);\n            g = HSLA._hue2rgb(p, q, h);\n            b = HSLA._hue2rgb(p, q, h - 1 / 3);\n        }\n        return new RGBA(Math.round(r * 255), Math.round(g * 255), Math.round(b * 255), a);\n    }\n}\nclass HSVA {\n    constructor(h, s, v, a) {\n        this._hsvaBrand = undefined;\n        this.h = Math.max(Math.min(360, h), 0) | 0;\n        this.s = roundFloat(Math.max(Math.min(1, s), 0), 3);\n        this.v = roundFloat(Math.max(Math.min(1, v), 0), 3);\n        this.a = roundFloat(Math.max(Math.min(1, a), 0), 3);\n    }\n    static equals(a, b) {\n        return a.h === b.h && a.s === b.s && a.v === b.v && a.a === b.a;\n    }\n    // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm\n    static fromRGBA(rgba) {\n        const r = rgba.r / 255;\n        const g = rgba.g / 255;\n        const b = rgba.b / 255;\n        const cmax = Math.max(r, g, b);\n        const cmin = Math.min(r, g, b);\n        const delta = cmax - cmin;\n        const s = cmax === 0 ? 0 : (delta / cmax);\n        let m;\n        if (delta === 0) {\n            m = 0;\n        }\n        else if (cmax === r) {\n            m = ((((g - b) / delta) % 6) + 6) % 6;\n        }\n        else if (cmax === g) {\n            m = ((b - r) / delta) + 2;\n        }\n        else {\n            m = ((r - g) / delta) + 4;\n        }\n        return new HSVA(Math.round(m * 60), s, cmax, rgba.a);\n    }\n    // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm\n    static toRGBA(hsva) {\n        const { h, s, v, a } = hsva;\n        const c = v * s;\n        const x = c * (1 - Math.abs((h / 60) % 2 - 1));\n        const m = v - c;\n        let [r, g, b] = [0, 0, 0];\n        if (h < 60) {\n            r = c;\n            g = x;\n        }\n        else if (h < 120) {\n            r = x;\n            g = c;\n        }\n        else if (h < 180) {\n            g = c;\n            b = x;\n        }\n        else if (h < 240) {\n            g = x;\n            b = c;\n        }\n        else if (h < 300) {\n            r = x;\n            b = c;\n        }\n        else if (h <= 360) {\n            r = c;\n            b = x;\n        }\n        r = Math.round((r + m) * 255);\n        g = Math.round((g + m) * 255);\n        b = Math.round((b + m) * 255);\n        return new RGBA(r, g, b, a);\n    }\n}\nclass Color {\n    static fromHex(hex) {\n        return Color.Format.CSS.parseHex(hex) || Color.red;\n    }\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        if (!a || !b) {\n            return false;\n        }\n        return a.equals(b);\n    }\n    get hsla() {\n        if (this._hsla) {\n            return this._hsla;\n        }\n        else {\n            return HSLA.fromRGBA(this.rgba);\n        }\n    }\n    get hsva() {\n        if (this._hsva) {\n            return this._hsva;\n        }\n        return HSVA.fromRGBA(this.rgba);\n    }\n    constructor(arg) {\n        if (!arg) {\n            throw new Error('Color needs a value');\n        }\n        else if (arg instanceof RGBA) {\n            this.rgba = arg;\n        }\n        else if (arg instanceof HSLA) {\n            this._hsla = arg;\n            this.rgba = HSLA.toRGBA(arg);\n        }\n        else if (arg instanceof HSVA) {\n            this._hsva = arg;\n            this.rgba = HSVA.toRGBA(arg);\n        }\n        else {\n            throw new Error('Invalid color ctor argument');\n        }\n    }\n    equals(other) {\n        return !!other && RGBA.equals(this.rgba, other.rgba) && HSLA.equals(this.hsla, other.hsla) && HSVA.equals(this.hsva, other.hsva);\n    }\n    /**\n     * http://www.w3.org/TR/WCAG20/#relativeluminancedef\n     * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.\n     */\n    getRelativeLuminance() {\n        const R = Color._relativeLuminanceForComponent(this.rgba.r);\n        const G = Color._relativeLuminanceForComponent(this.rgba.g);\n        const B = Color._relativeLuminanceForComponent(this.rgba.b);\n        const luminance = 0.2126 * R + 0.7152 * G + 0.0722 * B;\n        return roundFloat(luminance, 4);\n    }\n    static _relativeLuminanceForComponent(color) {\n        const c = color / 255;\n        return (c <= 0.03928) ? c / 12.92 : Math.pow(((c + 0.055) / 1.055), 2.4);\n    }\n    /**\n     *\thttp://24ways.org/2010/calculating-color-contrast\n     *  Return 'true' if lighter color otherwise 'false'\n     */\n    isLighter() {\n        const yiq = (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1000;\n        return yiq >= 128;\n    }\n    isLighterThan(another) {\n        const lum1 = this.getRelativeLuminance();\n        const lum2 = another.getRelativeLuminance();\n        return lum1 > lum2;\n    }\n    isDarkerThan(another) {\n        const lum1 = this.getRelativeLuminance();\n        const lum2 = another.getRelativeLuminance();\n        return lum1 < lum2;\n    }\n    lighten(factor) {\n        return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * factor, this.hsla.a));\n    }\n    darken(factor) {\n        return new Color(new HSLA(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * factor, this.hsla.a));\n    }\n    transparent(factor) {\n        const { r, g, b, a } = this.rgba;\n        return new Color(new RGBA(r, g, b, a * factor));\n    }\n    isTransparent() {\n        return this.rgba.a === 0;\n    }\n    isOpaque() {\n        return this.rgba.a === 1;\n    }\n    opposite() {\n        return new Color(new RGBA(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));\n    }\n    makeOpaque(opaqueBackground) {\n        if (this.isOpaque() || opaqueBackground.rgba.a !== 1) {\n            // only allow to blend onto a non-opaque color onto a opaque color\n            return this;\n        }\n        const { r, g, b, a } = this.rgba;\n        // https://stackoverflow.com/questions/12228548/finding-equivalent-color-with-opacity\n        return new Color(new RGBA(opaqueBackground.rgba.r - a * (opaqueBackground.rgba.r - r), opaqueBackground.rgba.g - a * (opaqueBackground.rgba.g - g), opaqueBackground.rgba.b - a * (opaqueBackground.rgba.b - b), 1));\n    }\n    toString() {\n        if (!this._toString) {\n            this._toString = Color.Format.CSS.format(this);\n        }\n        return this._toString;\n    }\n    static getLighterColor(of, relative, factor) {\n        if (of.isLighterThan(relative)) {\n            return of;\n        }\n        factor = factor ? factor : 0.5;\n        const lum1 = of.getRelativeLuminance();\n        const lum2 = relative.getRelativeLuminance();\n        factor = factor * (lum2 - lum1) / lum2;\n        return of.lighten(factor);\n    }\n    static getDarkerColor(of, relative, factor) {\n        if (of.isDarkerThan(relative)) {\n            return of;\n        }\n        factor = factor ? factor : 0.5;\n        const lum1 = of.getRelativeLuminance();\n        const lum2 = relative.getRelativeLuminance();\n        factor = factor * (lum1 - lum2) / lum1;\n        return of.darken(factor);\n    }\n}\nColor.white = new Color(new RGBA(255, 255, 255, 1));\nColor.black = new Color(new RGBA(0, 0, 0, 1));\nColor.red = new Color(new RGBA(255, 0, 0, 1));\nColor.blue = new Color(new RGBA(0, 0, 255, 1));\nColor.green = new Color(new RGBA(0, 255, 0, 1));\nColor.cyan = new Color(new RGBA(0, 255, 255, 1));\nColor.lightgrey = new Color(new RGBA(211, 211, 211, 1));\nColor.transparent = new Color(new RGBA(0, 0, 0, 0));\n(function (Color) {\n    let Format;\n    (function (Format) {\n        let CSS;\n        (function (CSS) {\n            function formatRGB(color) {\n                if (color.rgba.a === 1) {\n                    return `rgb(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b})`;\n                }\n                return Color.Format.CSS.formatRGBA(color);\n            }\n            CSS.formatRGB = formatRGB;\n            function formatRGBA(color) {\n                return `rgba(${color.rgba.r}, ${color.rgba.g}, ${color.rgba.b}, ${+(color.rgba.a).toFixed(2)})`;\n            }\n            CSS.formatRGBA = formatRGBA;\n            function formatHSL(color) {\n                if (color.hsla.a === 1) {\n                    return `hsl(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%)`;\n                }\n                return Color.Format.CSS.formatHSLA(color);\n            }\n            CSS.formatHSL = formatHSL;\n            function formatHSLA(color) {\n                return `hsla(${color.hsla.h}, ${(color.hsla.s * 100).toFixed(2)}%, ${(color.hsla.l * 100).toFixed(2)}%, ${color.hsla.a.toFixed(2)})`;\n            }\n            CSS.formatHSLA = formatHSLA;\n            function _toTwoDigitHex(n) {\n                const r = n.toString(16);\n                return r.length !== 2 ? '0' + r : r;\n            }\n            /**\n             * Formats the color as #RRGGBB\n             */\n            function formatHex(color) {\n                return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}`;\n            }\n            CSS.formatHex = formatHex;\n            /**\n             * Formats the color as #RRGGBBAA\n             * If 'compact' is set, colors without transparancy will be printed as #RRGGBB\n             */\n            function formatHexA(color, compact = false) {\n                if (compact && color.rgba.a === 1) {\n                    return Color.Format.CSS.formatHex(color);\n                }\n                return `#${_toTwoDigitHex(color.rgba.r)}${_toTwoDigitHex(color.rgba.g)}${_toTwoDigitHex(color.rgba.b)}${_toTwoDigitHex(Math.round(color.rgba.a * 255))}`;\n            }\n            CSS.formatHexA = formatHexA;\n            /**\n             * The default format will use HEX if opaque and RGBA otherwise.\n             */\n            function format(color) {\n                if (color.isOpaque()) {\n                    return Color.Format.CSS.formatHex(color);\n                }\n                return Color.Format.CSS.formatRGBA(color);\n            }\n            CSS.format = format;\n            /**\n             * Converts an Hex color value to a Color.\n             * returns r, g, and b are contained in the set [0, 255]\n             * @param hex string (#RGB, #RGBA, #RRGGBB or #RRGGBBAA).\n             */\n            function parseHex(hex) {\n                const length = hex.length;\n                if (length === 0) {\n                    // Invalid color\n                    return null;\n                }\n                if (hex.charCodeAt(0) !== 35 /* CharCode.Hash */) {\n                    // Does not begin with a #\n                    return null;\n                }\n                if (length === 7) {\n                    // #RRGGBB format\n                    const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n                    const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n                    const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n                    return new Color(new RGBA(r, g, b, 1));\n                }\n                if (length === 9) {\n                    // #RRGGBBAA format\n                    const r = 16 * _parseHexDigit(hex.charCodeAt(1)) + _parseHexDigit(hex.charCodeAt(2));\n                    const g = 16 * _parseHexDigit(hex.charCodeAt(3)) + _parseHexDigit(hex.charCodeAt(4));\n                    const b = 16 * _parseHexDigit(hex.charCodeAt(5)) + _parseHexDigit(hex.charCodeAt(6));\n                    const a = 16 * _parseHexDigit(hex.charCodeAt(7)) + _parseHexDigit(hex.charCodeAt(8));\n                    return new Color(new RGBA(r, g, b, a / 255));\n                }\n                if (length === 4) {\n                    // #RGB format\n                    const r = _parseHexDigit(hex.charCodeAt(1));\n                    const g = _parseHexDigit(hex.charCodeAt(2));\n                    const b = _parseHexDigit(hex.charCodeAt(3));\n                    return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b));\n                }\n                if (length === 5) {\n                    // #RGBA format\n                    const r = _parseHexDigit(hex.charCodeAt(1));\n                    const g = _parseHexDigit(hex.charCodeAt(2));\n                    const b = _parseHexDigit(hex.charCodeAt(3));\n                    const a = _parseHexDigit(hex.charCodeAt(4));\n                    return new Color(new RGBA(16 * r + r, 16 * g + g, 16 * b + b, (16 * a + a) / 255));\n                }\n                // Invalid color\n                return null;\n            }\n            CSS.parseHex = parseHex;\n            function _parseHexDigit(charCode) {\n                switch (charCode) {\n                    case 48 /* CharCode.Digit0 */: return 0;\n                    case 49 /* CharCode.Digit1 */: return 1;\n                    case 50 /* CharCode.Digit2 */: return 2;\n                    case 51 /* CharCode.Digit3 */: return 3;\n                    case 52 /* CharCode.Digit4 */: return 4;\n                    case 53 /* CharCode.Digit5 */: return 5;\n                    case 54 /* CharCode.Digit6 */: return 6;\n                    case 55 /* CharCode.Digit7 */: return 7;\n                    case 56 /* CharCode.Digit8 */: return 8;\n                    case 57 /* CharCode.Digit9 */: return 9;\n                    case 97 /* CharCode.a */: return 10;\n                    case 65 /* CharCode.A */: return 10;\n                    case 98 /* CharCode.b */: return 11;\n                    case 66 /* CharCode.B */: return 11;\n                    case 99 /* CharCode.c */: return 12;\n                    case 67 /* CharCode.C */: return 12;\n                    case 100 /* CharCode.d */: return 13;\n                    case 68 /* CharCode.D */: return 13;\n                    case 101 /* CharCode.e */: return 14;\n                    case 69 /* CharCode.E */: return 14;\n                    case 102 /* CharCode.f */: return 15;\n                    case 70 /* CharCode.F */: return 15;\n                }\n                return 0;\n            }\n        })(CSS = Format.CSS || (Format.CSS = {}));\n    })(Format = Color.Format || (Color.Format = {}));\n})(Color || (Color = {}));\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/languages/defaultDocumentColorsComputer.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nfunction _parseCaptureGroups(captureGroups) {\n    const values = [];\n    for (const captureGroup of captureGroups) {\n        const parsedNumber = Number(captureGroup);\n        if (parsedNumber || parsedNumber === 0 && captureGroup.replace(/\\s/g, '') !== '') {\n            values.push(parsedNumber);\n        }\n    }\n    return values;\n}\nfunction _toIColor(r, g, b, a) {\n    return {\n        red: r / 255,\n        blue: b / 255,\n        green: g / 255,\n        alpha: a\n    };\n}\nfunction _findRange(model, match) {\n    const index = match.index;\n    const length = match[0].length;\n    if (!index) {\n        return;\n    }\n    const startPosition = model.positionAt(index);\n    const range = {\n        startLineNumber: startPosition.lineNumber,\n        startColumn: startPosition.column,\n        endLineNumber: startPosition.lineNumber,\n        endColumn: startPosition.column + length\n    };\n    return range;\n}\nfunction _findHexColorInformation(range, hexValue) {\n    if (!range) {\n        return;\n    }\n    const parsedHexColor = Color.Format.CSS.parseHex(hexValue);\n    if (!parsedHexColor) {\n        return;\n    }\n    return {\n        range: range,\n        color: _toIColor(parsedHexColor.rgba.r, parsedHexColor.rgba.g, parsedHexColor.rgba.b, parsedHexColor.rgba.a)\n    };\n}\nfunction _findRGBColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    return {\n        range: range,\n        color: _toIColor(parsedRegex[0], parsedRegex[1], parsedRegex[2], isAlpha ? parsedRegex[3] : 1)\n    };\n}\nfunction _findHSLColorInformation(range, matches, isAlpha) {\n    if (!range || matches.length !== 1) {\n        return;\n    }\n    const match = matches[0];\n    const captureGroups = match.values();\n    const parsedRegex = _parseCaptureGroups(captureGroups);\n    const colorEquivalent = new Color(new HSLA(parsedRegex[0], parsedRegex[1] / 100, parsedRegex[2] / 100, isAlpha ? parsedRegex[3] : 1));\n    return {\n        range: range,\n        color: _toIColor(colorEquivalent.rgba.r, colorEquivalent.rgba.g, colorEquivalent.rgba.b, colorEquivalent.rgba.a)\n    };\n}\nfunction _findMatches(model, regex) {\n    if (typeof model === 'string') {\n        return [...model.matchAll(regex)];\n    }\n    else {\n        return model.findMatches(regex);\n    }\n}\nfunction computeColors(model) {\n    const result = [];\n    // Early validation for RGB and HSL\n    const initialValidationRegex = /\\b(rgb|rgba|hsl|hsla)(\\([0-9\\s,.\\%]*\\))|(#)([A-Fa-f0-9]{3})\\b|(#)([A-Fa-f0-9]{4})\\b|(#)([A-Fa-f0-9]{6})\\b|(#)([A-Fa-f0-9]{8})\\b/gm;\n    const initialValidationMatches = _findMatches(model, initialValidationRegex);\n    // Potential colors have been found, validate the parameters\n    if (initialValidationMatches.length > 0) {\n        for (const initialMatch of initialValidationMatches) {\n            const initialCaptureGroups = initialMatch.filter(captureGroup => captureGroup !== undefined);\n            const colorScheme = initialCaptureGroups[1];\n            const colorParameters = initialCaptureGroups[2];\n            if (!colorParameters) {\n                continue;\n            }\n            let colorInformation;\n            if (colorScheme === 'rgb') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'rgba') {\n                const regexParameters = /^\\(\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findRGBColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === 'hsl') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), false);\n            }\n            else if (colorScheme === 'hsla') {\n                const regexParameters = /^\\(\\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(100|\\d{1,2}[.]\\d*|\\d{1,2})%\\s*,\\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\\s*\\)$/gm;\n                colorInformation = _findHSLColorInformation(_findRange(model, initialMatch), _findMatches(colorParameters, regexParameters), true);\n            }\n            else if (colorScheme === '#') {\n                colorInformation = _findHexColorInformation(_findRange(model, initialMatch), colorScheme + colorParameters);\n            }\n            if (colorInformation) {\n                result.push(colorInformation);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Returns an array of all default document colors in the provided document\n */\nfunction computeDefaultDocumentColors(model) {\n    if (!model || typeof model.getValue !== 'function' || typeof model.positionAt !== 'function') {\n        // Unknown caller!\n        return [];\n    }\n    return computeColors(model);\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst markRegex = new RegExp('\\\\bMARK:\\\\s*(.*)$', 'd');\nconst trimDashesRegex = /^-+|-+$/g;\n/**\n * Find section headers in the model.\n *\n * @param model the text model to search in\n * @param options options to search with\n * @returns an array of section headers\n */\nfunction findSectionHeaders(model, options) {\n    var _a;\n    let headers = [];\n    if (options.findRegionSectionHeaders && ((_a = options.foldingRules) === null || _a === void 0 ? void 0 : _a.markers)) {\n        const regionHeaders = collectRegionHeaders(model, options);\n        headers = headers.concat(regionHeaders);\n    }\n    if (options.findMarkSectionHeaders) {\n        const markHeaders = collectMarkHeaders(model);\n        headers = headers.concat(markHeaders);\n    }\n    return headers;\n}\nfunction collectRegionHeaders(model, options) {\n    const regionHeaders = [];\n    const endLineNumber = model.getLineCount();\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        const match = lineContent.match(options.foldingRules.markers.start);\n        if (match) {\n            const range = { startLineNumber: lineNumber, startColumn: match[0].length + 1, endLineNumber: lineNumber, endColumn: lineContent.length + 1 };\n            if (range.endColumn > range.startColumn) {\n                const sectionHeader = {\n                    range,\n                    ...getHeaderText(lineContent.substring(match[0].length)),\n                    shouldBeInComments: false\n                };\n                if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n                    regionHeaders.push(sectionHeader);\n                }\n            }\n        }\n    }\n    return regionHeaders;\n}\nfunction collectMarkHeaders(model) {\n    const markHeaders = [];\n    const endLineNumber = model.getLineCount();\n    for (let lineNumber = 1; lineNumber <= endLineNumber; lineNumber++) {\n        const lineContent = model.getLineContent(lineNumber);\n        addMarkHeaderIfFound(lineContent, lineNumber, markHeaders);\n    }\n    return markHeaders;\n}\nfunction addMarkHeaderIfFound(lineContent, lineNumber, sectionHeaders) {\n    markRegex.lastIndex = 0;\n    const match = markRegex.exec(lineContent);\n    if (match) {\n        const column = match.indices[1][0] + 1;\n        const endColumn = match.indices[1][1] + 1;\n        const range = { startLineNumber: lineNumber, startColumn: column, endLineNumber: lineNumber, endColumn: endColumn };\n        if (range.endColumn > range.startColumn) {\n            const sectionHeader = {\n                range,\n                ...getHeaderText(match[1]),\n                shouldBeInComments: true\n            };\n            if (sectionHeader.text || sectionHeader.hasSeparatorLine) {\n                sectionHeaders.push(sectionHeader);\n            }\n        }\n    }\n}\nfunction getHeaderText(text) {\n    text = text.trim();\n    const hasSeparatorLine = text.startsWith('-');\n    text = text.replace(trimDashesRegex, '');\n    return { text, hasSeparatorLine };\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @internal\n */\nclass MirrorModel extends MirrorTextModel {\n    get uri() {\n        return this._uri;\n    }\n    get eol() {\n        return this._eol;\n    }\n    getValue() {\n        return this.getText();\n    }\n    findMatches(regex) {\n        const matches = [];\n        for (let i = 0; i < this._lines.length; i++) {\n            const line = this._lines[i];\n            const offsetToAdd = this.offsetAt(new position_Position(i + 1, 1));\n            const iteratorOverMatches = line.matchAll(regex);\n            for (const match of iteratorOverMatches) {\n                if (match.index || match.index === 0) {\n                    match.index = match.index + offsetToAdd;\n                }\n                matches.push(match);\n            }\n        }\n        return matches;\n    }\n    getLinesContent() {\n        return this._lines.slice(0);\n    }\n    getLineCount() {\n        return this._lines.length;\n    }\n    getLineContent(lineNumber) {\n        return this._lines[lineNumber - 1];\n    }\n    getWordAtPosition(position, wordDefinition) {\n        const wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);\n        if (wordAtText) {\n            return new range_Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);\n        }\n        return null;\n    }\n    words(wordDefinition) {\n        const lines = this._lines;\n        const wordenize = this._wordenize.bind(this);\n        let lineNumber = 0;\n        let lineText = '';\n        let wordRangesIdx = 0;\n        let wordRanges = [];\n        return {\n            *[Symbol.iterator]() {\n                while (true) {\n                    if (wordRangesIdx < wordRanges.length) {\n                        const value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);\n                        wordRangesIdx += 1;\n                        yield value;\n                    }\n                    else {\n                        if (lineNumber < lines.length) {\n                            lineText = lines[lineNumber];\n                            wordRanges = wordenize(lineText, wordDefinition);\n                            wordRangesIdx = 0;\n                            lineNumber += 1;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                }\n            }\n        };\n    }\n    getLineWords(lineNumber, wordDefinition) {\n        const content = this._lines[lineNumber - 1];\n        const ranges = this._wordenize(content, wordDefinition);\n        const words = [];\n        for (const range of ranges) {\n            words.push({\n                word: content.substring(range.start, range.end),\n                startColumn: range.start + 1,\n                endColumn: range.end + 1\n            });\n        }\n        return words;\n    }\n    _wordenize(content, wordDefinition) {\n        const result = [];\n        let match;\n        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure\n        while (match = wordDefinition.exec(content)) {\n            if (match[0].length === 0) {\n                // it did match the empty string\n                break;\n            }\n            result.push({ start: match.index, end: match.index + match[0].length });\n        }\n        return result;\n    }\n    getValueInRange(range) {\n        range = this._validateRange(range);\n        if (range.startLineNumber === range.endLineNumber) {\n            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);\n        }\n        const lineEnding = this._eol;\n        const startLineIndex = range.startLineNumber - 1;\n        const endLineIndex = range.endLineNumber - 1;\n        const resultLines = [];\n        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));\n        for (let i = startLineIndex + 1; i < endLineIndex; i++) {\n            resultLines.push(this._lines[i]);\n        }\n        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));\n        return resultLines.join(lineEnding);\n    }\n    offsetAt(position) {\n        position = this._validatePosition(position);\n        this._ensureLineStarts();\n        return this._lineStarts.getPrefixSum(position.lineNumber - 2) + (position.column - 1);\n    }\n    positionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        this._ensureLineStarts();\n        const out = this._lineStarts.getIndexOf(offset);\n        const lineLength = this._lines[out.index].length;\n        // Ensure we return a valid position\n        return {\n            lineNumber: 1 + out.index,\n            column: 1 + Math.min(out.remainder, lineLength)\n        };\n    }\n    _validateRange(range) {\n        const start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });\n        const end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });\n        if (start.lineNumber !== range.startLineNumber\n            || start.column !== range.startColumn\n            || end.lineNumber !== range.endLineNumber\n            || end.column !== range.endColumn) {\n            return {\n                startLineNumber: start.lineNumber,\n                startColumn: start.column,\n                endLineNumber: end.lineNumber,\n                endColumn: end.column\n            };\n        }\n        return range;\n    }\n    _validatePosition(position) {\n        if (!position_Position.isIPosition(position)) {\n            throw new Error('bad position');\n        }\n        let { lineNumber, column } = position;\n        let hasChanged = false;\n        if (lineNumber < 1) {\n            lineNumber = 1;\n            column = 1;\n            hasChanged = true;\n        }\n        else if (lineNumber > this._lines.length) {\n            lineNumber = this._lines.length;\n            column = this._lines[lineNumber - 1].length + 1;\n            hasChanged = true;\n        }\n        else {\n            const maxCharacter = this._lines[lineNumber - 1].length + 1;\n            if (column < 1) {\n                column = 1;\n                hasChanged = true;\n            }\n            else if (column > maxCharacter) {\n                column = maxCharacter;\n                hasChanged = true;\n            }\n        }\n        if (!hasChanged) {\n            return position;\n        }\n        else {\n            return { lineNumber, column };\n        }\n    }\n}\n/**\n * @internal\n */\nclass EditorSimpleWorker {\n    constructor(host, foreignModuleFactory) {\n        this._host = host;\n        this._models = Object.create(null);\n        this._foreignModuleFactory = foreignModuleFactory;\n        this._foreignModule = null;\n    }\n    dispose() {\n        this._models = Object.create(null);\n    }\n    _getModel(uri) {\n        return this._models[uri];\n    }\n    _getModels() {\n        const all = [];\n        Object.keys(this._models).forEach((key) => all.push(this._models[key]));\n        return all;\n    }\n    acceptNewModel(data) {\n        this._models[data.url] = new MirrorModel(uri_URI.parse(data.url), data.lines, data.EOL, data.versionId);\n    }\n    acceptModelChanged(strURL, e) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        const model = this._models[strURL];\n        model.onEvents(e);\n    }\n    acceptRemovedModel(strURL) {\n        if (!this._models[strURL]) {\n            return;\n        }\n        delete this._models[strURL];\n    }\n    async computeUnicodeHighlights(url, options, range) {\n        const model = this._getModel(url);\n        if (!model) {\n            return { ranges: [], hasMore: false, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };\n        }\n        return UnicodeTextModelHighlighter.computeUnicodeHighlights(model, options, range);\n    }\n    async findSectionHeaders(url, options) {\n        const model = this._getModel(url);\n        if (!model) {\n            return [];\n        }\n        return findSectionHeaders(model, options);\n    }\n    // ---- BEGIN diff --------------------------------------------------------------------------\n    async computeDiff(originalUrl, modifiedUrl, options, algorithm) {\n        const original = this._getModel(originalUrl);\n        const modified = this._getModel(modifiedUrl);\n        if (!original || !modified) {\n            return null;\n        }\n        const result = EditorSimpleWorker.computeDiff(original, modified, options, algorithm);\n        return result;\n    }\n    static computeDiff(originalTextModel, modifiedTextModel, options, algorithm) {\n        const diffAlgorithm = algorithm === 'advanced' ? linesDiffComputers.getDefault() : linesDiffComputers.getLegacy();\n        const originalLines = originalTextModel.getLinesContent();\n        const modifiedLines = modifiedTextModel.getLinesContent();\n        const result = diffAlgorithm.computeDiff(originalLines, modifiedLines, options);\n        const identical = (result.changes.length > 0 ? false : this._modelsAreIdentical(originalTextModel, modifiedTextModel));\n        function getLineChanges(changes) {\n            return changes.map(m => {\n                var _a;\n                return ([m.original.startLineNumber, m.original.endLineNumberExclusive, m.modified.startLineNumber, m.modified.endLineNumberExclusive, (_a = m.innerChanges) === null || _a === void 0 ? void 0 : _a.map(m => [\n                        m.originalRange.startLineNumber,\n                        m.originalRange.startColumn,\n                        m.originalRange.endLineNumber,\n                        m.originalRange.endColumn,\n                        m.modifiedRange.startLineNumber,\n                        m.modifiedRange.startColumn,\n                        m.modifiedRange.endLineNumber,\n                        m.modifiedRange.endColumn,\n                    ])]);\n            });\n        }\n        return {\n            identical,\n            quitEarly: result.hitTimeout,\n            changes: getLineChanges(result.changes),\n            moves: result.moves.map(m => ([\n                m.lineRangeMapping.original.startLineNumber,\n                m.lineRangeMapping.original.endLineNumberExclusive,\n                m.lineRangeMapping.modified.startLineNumber,\n                m.lineRangeMapping.modified.endLineNumberExclusive,\n                getLineChanges(m.changes)\n            ])),\n        };\n    }\n    static _modelsAreIdentical(original, modified) {\n        const originalLineCount = original.getLineCount();\n        const modifiedLineCount = modified.getLineCount();\n        if (originalLineCount !== modifiedLineCount) {\n            return false;\n        }\n        for (let line = 1; line <= originalLineCount; line++) {\n            const originalLine = original.getLineContent(line);\n            const modifiedLine = modified.getLineContent(line);\n            if (originalLine !== modifiedLine) {\n                return false;\n            }\n        }\n        return true;\n    }\n    async computeMoreMinimalEdits(modelUrl, edits, pretty) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return edits;\n        }\n        const result = [];\n        let lastEol = undefined;\n        edits = edits.slice(0).sort((a, b) => {\n            if (a.range && b.range) {\n                return range_Range.compareRangesUsingStarts(a.range, b.range);\n            }\n            // eol only changes should go to the end\n            const aRng = a.range ? 0 : 1;\n            const bRng = b.range ? 0 : 1;\n            return aRng - bRng;\n        });\n        // merge adjacent edits\n        let writeIndex = 0;\n        for (let readIndex = 1; readIndex < edits.length; readIndex++) {\n            if (range_Range.getEndPosition(edits[writeIndex].range).equals(range_Range.getStartPosition(edits[readIndex].range))) {\n                edits[writeIndex].range = range_Range.fromPositions(range_Range.getStartPosition(edits[writeIndex].range), range_Range.getEndPosition(edits[readIndex].range));\n                edits[writeIndex].text += edits[readIndex].text;\n            }\n            else {\n                writeIndex++;\n                edits[writeIndex] = edits[readIndex];\n            }\n        }\n        edits.length = writeIndex + 1;\n        for (let { range, text, eol } of edits) {\n            if (typeof eol === 'number') {\n                lastEol = eol;\n            }\n            if (range_Range.isEmpty(range) && !text) {\n                // empty change\n                continue;\n            }\n            const original = model.getValueInRange(range);\n            text = text.replace(/\\r\\n|\\n|\\r/g, model.eol);\n            if (original === text) {\n                // noop\n                continue;\n            }\n            // make sure diff won't take too long\n            if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {\n                result.push({ range, text });\n                continue;\n            }\n            // compute diff between original and edit.text\n            const changes = stringDiff(original, text, pretty);\n            const editOffset = model.offsetAt(range_Range.lift(range).getStartPosition());\n            for (const change of changes) {\n                const start = model.positionAt(editOffset + change.originalStart);\n                const end = model.positionAt(editOffset + change.originalStart + change.originalLength);\n                const newEdit = {\n                    text: text.substr(change.modifiedStart, change.modifiedLength),\n                    range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }\n                };\n                if (model.getValueInRange(newEdit.range) !== newEdit.text) {\n                    result.push(newEdit);\n                }\n            }\n        }\n        if (typeof lastEol === 'number') {\n            result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });\n        }\n        return result;\n    }\n    // ---- END minimal edits ---------------------------------------------------------------\n    async computeLinks(modelUrl) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return computeLinks(model);\n    }\n    // --- BEGIN default document colors -----------------------------------------------------------\n    async computeDefaultDocumentColors(modelUrl) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        return computeDefaultDocumentColors(model);\n    }\n    async textualSuggest(modelUrls, leadingWord, wordDef, wordDefFlags) {\n        const sw = new StopWatch();\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        const seen = new Set();\n        outer: for (const url of modelUrls) {\n            const model = this._getModel(url);\n            if (!model) {\n                continue;\n            }\n            for (const word of model.words(wordDefRegExp)) {\n                if (word === leadingWord || !isNaN(Number(word))) {\n                    continue;\n                }\n                seen.add(word);\n                if (seen.size > EditorSimpleWorker._suggestionsLimit) {\n                    break outer;\n                }\n            }\n        }\n        return { words: Array.from(seen), duration: sw.elapsed() };\n    }\n    // ---- END suggest --------------------------------------------------------------------------\n    //#region -- word ranges --\n    async computeWordRanges(modelUrl, range, wordDef, wordDefFlags) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return Object.create(null);\n        }\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        const result = Object.create(null);\n        for (let line = range.startLineNumber; line < range.endLineNumber; line++) {\n            const words = model.getLineWords(line, wordDefRegExp);\n            for (const word of words) {\n                if (!isNaN(Number(word.word))) {\n                    continue;\n                }\n                let array = result[word.word];\n                if (!array) {\n                    array = [];\n                    result[word.word] = array;\n                }\n                array.push({\n                    startLineNumber: line,\n                    startColumn: word.startColumn,\n                    endLineNumber: line,\n                    endColumn: word.endColumn\n                });\n            }\n        }\n        return result;\n    }\n    //#endregion\n    async navigateValueSet(modelUrl, range, up, wordDef, wordDefFlags) {\n        const model = this._getModel(modelUrl);\n        if (!model) {\n            return null;\n        }\n        const wordDefRegExp = new RegExp(wordDef, wordDefFlags);\n        if (range.startColumn === range.endColumn) {\n            range = {\n                startLineNumber: range.startLineNumber,\n                startColumn: range.startColumn,\n                endLineNumber: range.endLineNumber,\n                endColumn: range.endColumn + 1\n            };\n        }\n        const selectionText = model.getValueInRange(range);\n        const wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);\n        if (!wordRange) {\n            return null;\n        }\n        const word = model.getValueInRange(wordRange);\n        const result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);\n        return result;\n    }\n    // ---- BEGIN foreign module support --------------------------------------------------------------------------\n    loadForeignModule(moduleId, createData, foreignHostMethods) {\n        const proxyMethodRequest = (method, args) => {\n            return this._host.fhr(method, args);\n        };\n        const foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);\n        const ctx = {\n            host: foreignHost,\n            getMirrorModels: () => {\n                return this._getModels();\n            }\n        };\n        if (this._foreignModuleFactory) {\n            this._foreignModule = this._foreignModuleFactory(ctx, createData);\n            // static foreing module\n            return Promise.resolve(getAllMethodNames(this._foreignModule));\n        }\n        // ESM-comment-begin\n        // \t\treturn new Promise<any>((resolve, reject) => {\n        // \t\t\trequire([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {\n        // \t\t\t\tthis._foreignModule = foreignModule.create(ctx, createData);\n        // \n        // \t\t\t\tresolve(getAllMethodNames(this._foreignModule));\n        // \n        // \t\t\t}, reject);\n        // \t\t});\n        // ESM-comment-end\n        // ESM-uncomment-begin\n        return Promise.reject(new Error(`Unexpected usage`));\n        // ESM-uncomment-end\n    }\n    // foreign method request\n    fmr(method, args) {\n        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {\n            return Promise.reject(new Error('Missing requestHandler or method: ' + method));\n        }\n        try {\n            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    }\n}\n// ---- END diff --------------------------------------------------------------------------\n// ---- BEGIN minimal edits ---------------------------------------------------------------\nEditorSimpleWorker._diffLimit = 100000;\n// ---- BEGIN suggest --------------------------------------------------------------------------\nEditorSimpleWorker._suggestionsLimit = 10000;\n/**\n * Called on the worker side\n * @internal\n */\nfunction editorSimpleWorker_create(host) {\n    return new EditorSimpleWorker(host, null);\n}\nif (typeof importScripts === 'function') {\n    // Running in a web worker\n    globalThis.monaco = createMonacoBaseAPI();\n}\n\n;// CONCATENATED MODULE: ./node_modules/monaco-editor/esm/vs/editor/editor.worker.js\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n\nlet initialized = false;\nfunction initialize(foreignModule) {\n    if (initialized) {\n        return;\n    }\n    initialized = true;\n    const simpleWorker = new SimpleWorkerServer((msg) => {\n        globalThis.postMessage(msg);\n    }, (host) => new EditorSimpleWorker(host, foreignModule));\n    globalThis.onmessage = (e) => {\n        simpleWorker.onmessage(e.data);\n    };\n}\nglobalThis.onmessage = (e) => {\n    // Ignore first message in this case and initialize if not yet initialized\n    if (!initialized) {\n        initialize(null);\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0EsU0FBUyx3QkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtREFBbUQ7QUFDdkU7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkNBQTJDLEtBQUs7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSx5QkFBa0I7QUFDL0I7QUFDQTtBQUNBLG9DQUFvQyx5QkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTLG1DQUF3QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQixvQkFBb0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0Qjs7O0FDM0k4QjtBQUNsQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsbUNBQW1DLG9CQUFVO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvQkFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1AsUUFBUSxRQUFRO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGtCQUFrQjtBQUN2RTtBQUNPO0FBQ1AsbUJBQW1CLHNCQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGtCQUFrQjtBQUN0RTtBQUNBO0FBQ0E7QUFDTyxTQUFTLHNCQUFZO0FBQzVCO0FBQ0EsaUJBQWlCLG1DQUF3QjtBQUN6QztBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOEJBQThCO0FBQzVEO0FBQ0EsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNPLE1BQU0sb0JBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQVUsd0JBQXdCLGVBQWU7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCZ0Q7QUFDVztBQUNvQztBQUNsRDtBQUNGO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHVCQUF1QixvQkFBVTtBQUNqQztBQUNBO0FBQ0Esb0JBQW9CLHVDQUF1QztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLFNBQVMsNkJBQTZCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDcHVDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1RTtB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O0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOzs7QUNqUTdEO0FBQ0E7QUFDQTtBQUNBO0FBQzZDO0FBQ0w7QUFDakM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RCw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLElBQUksRUFBRSw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGFBQWE7QUFDMUM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFlBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFlBQVk7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksV0FBTztBQUNuQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxXQUFPO0FBQ25CO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLGVBQWUsV0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQUs7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFLO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBSztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFdBQUs7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFLO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsV0FBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sU0FBUyxhQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsdUJBQXVCO0FBQ3ZCLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDRCQUE0QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDNEM7QUFDNUM7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixDQUFDO0FBQ007QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxPQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdCQUFnQixZQUFZLG9CQUFvQjtBQUNoRDtBQUNBOzs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsZ0JBQWdCLG1DQUFtQztBQUNuRDtBQUNBO0FBQ0EsZ0JBQWdCLGtDQUFrQztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLHNCQUFzQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsU0FBUyxtQkFBbUIsWUFBWTtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNNO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUM5QjtBQUNQO0FBQ0E7QUFDQTs7O0FDblhBO0FBQ0E7QUFDQTtBQUNBO0FBQ3lDO0FBQ047QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDTyx3QkFBd0IsV0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEO0FBQ25EO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4Q0FBOEM7QUFDL0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQ3BDLElBQUksb0NBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxvQ0FBb0IsS0FBSyxvQ0FBb0IsS0FBSztBQUNyRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDOUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwREFBMEQ7QUFDcEQsSUFBSSw2QkFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsNkJBQWEsS0FBSyw2QkFBYSxLQUFLO0FBQ3ZDO0FBQ0EsV0FBVyw0REFBNEQ7QUFDdkU7QUFDTyxJQUFJLDJDQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLDJDQUEyQixLQUFLLDJDQUEyQixLQUFLO0FBQzVELElBQUkscUNBQXFCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxxQ0FBcUIsS0FBSyxxQ0FBcUIsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDcEI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDbEM7QUFDUDtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzND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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxLQUFFO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGFBQWEsS0FBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFFO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9qQkE7QUFDQTtBQUNBO0FBQ0E7QUFDdUQ7QUFDUTtBQUN4RCxzQ0FBc0MsbUJBQW1CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLHFCQUFxQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUNqQyxTQUFTLCtDQUF1QjtBQUN2QyxtQkFBbUIsZUFBZSxHQUFHLCtCQUErQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NEO0FBQ3REO0FBQ0E7QUFDQTtBQUNPLElBQUksdUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsdUJBQWlCLEtBQUssdUJBQWlCLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ08sSUFBSSxxQkFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxxQkFBZSxLQUFLLHFCQUFlLEtBQUs7QUFDcEMsSUFBSSw2QkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSw2QkFBdUIsS0FBSyw2QkFBdUIsS0FBSztBQUNwRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSxlQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSxnQkFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7O0FDcElBO0FBQ0E7QUFDQTtBQUNBO0FBQzJEO0FBQ2tCO0FBQzlCO0FBQ047QUFDVztBQUNwRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxTQUFTO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxTQUFTO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsYUFBYTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHdFQUF3RTtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdKQUFnSjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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LHVCQUF1QjtBQUNoRCwwQkFBMEIsd0JBQXdCO0FBQ2xEOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsYUFBYTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxhQUFhLElBQUksYUFBYSxJQUFJLGFBQWE7QUFDakY7QUFDQTtB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O0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxTQUFTLHlCQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQzs7O0FDbmhCQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRTtBQUNFO0FBQzdFO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixrQkFBa0I7QUFDL0M7QUFDQSxLQUFLLGdCQUFnQixrQkFBa0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2Vycm9ycy5qcz9mZGNjIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZnVuY3Rpb25hbC5qcz8wYmZiIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vaXRlcmF0b3IuanM/MjU4YSIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2xpZmVjeWNsZS5qcz9hNjY2Iiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vbGlua2VkTGlzdC5qcz9kYjg4Iiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vc3RvcHdhdGNoLmpzP2U1OGUiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9ldmVudC5qcz8zMDhmIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vb2JqZWN0cy5qcz9hYTNkIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvbmxzLmpzP2RmZjciLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9wbGF0Zm9ybS5qcz8zMGRiIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY2FjaGUuanM/YWJhZCIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2xhenkuanM/NDFkMiIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3N0cmluZ3MuanM/Mzc0MiIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3dvcmtlci9zaW1wbGVXb3JrZXIuanM/MWIxZiIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2RpZmYvZGlmZkNoYW5nZS5qcz8xNWYxIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vaGFzaC5qcz9lZGE3Iiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vZGlmZi9kaWZmLmpzPzFiMGUiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9wcm9jZXNzLmpzP2MzMTciLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9wYXRoLmpzPzMyYjgiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi91cmkuanM/NmQ4ZSIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS9wb3NpdGlvbi5qcz83MDYxIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3JhbmdlLmpzPzZhODkiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9hcnJheXMuanM/ZThlMyIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL3VpbnQuanM/MDk5ZCIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvcHJlZml4U3VtQ29tcHV0ZXIuanM/NGZmNSIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbW9kZWwvbWlycm9yVGV4dE1vZGVsLmpzP2E0MTEiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvd29yZEhlbHBlci5qcz84NzliIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL2NoYXJhY3RlckNsYXNzaWZpZXIuanM/MzE3MCIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbGFuZ3VhZ2VzL2xpbmtDb21wdXRlci5qcz85N2JiIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9sYW5ndWFnZXMvc3VwcG9ydHMvaW5wbGFjZVJlcGxhY2VTdXBwb3J0LmpzP2VmNWQiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9jYW5jZWxsYXRpb24uanM/MjUwNCIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2tleUNvZGVzLmpzP2ZlNDUiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvc2VsZWN0aW9uLmpzPzgwMjUiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi90eXBlcy5qcz9lZjhlIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY29kaWNvbnNVdGlsLmpzP2Y4MmYiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9jb2RpY29uc0xpYnJhcnkuanM/NDUwNyIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2NvZGljb25zLmpzPzU2MWEiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3Rva2VuaXphdGlvblJlZ2lzdHJ5LmpzPzRhNjIiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2xhbmd1YWdlcy5qcz8yZTVhIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zdGFuZGFsb25lL3N0YW5kYWxvbmVFbnVtcy5qcz82ODgxIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JCYXNlQXBpLmpzPzQyNGEiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9tYXAuanM/NDAzNSIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS93b3JkQ2hhcmFjdGVyQ2xhc3NpZmllci5qcz81NjRlIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC5qcz8zMzUyIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9tb2RlbC90ZXh0TW9kZWxTZWFyY2guanM/OGMwMiIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2UvY29tbW9uL2Fzc2VydC5qcz8xNTY5Iiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy91bmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXIuanM/ODVjNiIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9saW5lc0RpZmZDb21wdXRlci5qcz84ZjAwIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL29mZnNldFJhbmdlLmpzP2VmZjIiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi9hcnJheXNGaW5kLmpzPzA2ODYiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvbGluZVJhbmdlLmpzPzU0NzUiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2NvcmUvdGV4dExlbmd0aC5qcz9jODI3Iiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9jb3JlL3Bvc2l0aW9uVG9PZmZzZXQuanM/OWI3NSIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vY29yZS90ZXh0RWRpdC5qcz8wNjM1Iiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL3JhbmdlTWFwcGluZy5qcz81NTllIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2xlZ2FjeUxpbmVzRGlmZkNvbXB1dGVyLmpzP2IxMzMiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyL2FsZ29yaXRobXMvZGlmZkFsZ29yaXRobS5qcz80ZTk5Iiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci91dGlscy5qcz9jNDJkIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9hbGdvcml0aG1zL2R5bmFtaWNQcm9ncmFtbWluZ0RpZmZpbmcuanM/MWViNSIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvYWxnb3JpdGhtcy9teWVyc0RpZmZBbGdvcml0aG0uanM/NWVmNiIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvbGluZXNTbGljZUNoYXJTZXF1ZW5jZS5qcz81OGY5Iiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9jb21wdXRlTW92ZWRMaW5lcy5qcz9lNTZmIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci9oZXVyaXN0aWNTZXF1ZW5jZU9wdGltaXphdGlvbnMuanM/MGRkNSIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vZGlmZi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvbGluZVNlcXVlbmNlLmpzP2I1NzIiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL2RpZmYvZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyL2RlZmF1bHRMaW5lc0RpZmZDb21wdXRlci5qcz8yYjQ1Iiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9kaWZmL2xpbmVzRGlmZkNvbXB1dGVycy5qcz8wYjgzIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vY29sb3IuanM/Y2ViOCIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vbGFuZ3VhZ2VzL2RlZmF1bHREb2N1bWVudENvbG9yc0NvbXB1dGVyLmpzP2JiMWYiLCJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2ZpbmRTZWN0aW9uSGVhZGVycy5qcz83YzgxIiwid2VicGFjazovL3NhbmRib3gvLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JTaW1wbGVXb3JrZXIuanM/Y2NmNiIsIndlYnBhY2s6Ly9zYW5kYm94Ly4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9lZGl0b3Iud29ya2VyLmpzP2U1MDAiXSwic291cmNlc0NvbnRlbnQiOlsiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBBdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IG9uIEV2ZW50RW1pdHRlciBieSBpbXBsZW1lbnRpbmcgYSBzdWJzZXQgb2YgdGhlIGludGVyZmFjZS5cbmV4cG9ydCBjbGFzcyBFcnJvckhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLnVuZXhwZWN0ZWRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVycm9yTm9UZWxlbWV0cnkuaXNFcnJvck5vVGVsZW1ldHJ5KGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3JOb1RlbGVtZXRyeShlLm1lc3NhZ2UgKyAnXFxuXFxuJyArIGUuc3RhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlLm1lc3NhZ2UgKyAnXFxuXFxuJyArIGUuc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVtaXQoZSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgbGlzdGVuZXIoZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvblVuZXhwZWN0ZWRFcnJvcihlKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZEVycm9ySGFuZGxlcihlKTtcbiAgICAgICAgdGhpcy5lbWl0KGUpO1xuICAgIH1cbiAgICAvLyBGb3IgZXh0ZXJuYWwgZXJyb3JzLCB3ZSBkb24ndCB3YW50IHRoZSBsaXN0ZW5lcnMgdG8gYmUgY2FsbGVkXG4gICAgb25VbmV4cGVjdGVkRXh0ZXJuYWxFcnJvcihlKSB7XG4gICAgICAgIHRoaXMudW5leHBlY3RlZEVycm9ySGFuZGxlcihlKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgZXJyb3JIYW5kbGVyID0gbmV3IEVycm9ySGFuZGxlcigpO1xuZXhwb3J0IGZ1bmN0aW9uIG9uVW5leHBlY3RlZEVycm9yKGUpIHtcbiAgICAvLyBpZ25vcmUgZXJyb3JzIGZyb20gY2FuY2VsbGVkIHByb21pc2VzXG4gICAgaWYgKCFpc0NhbmNlbGxhdGlvbkVycm9yKGUpKSB7XG4gICAgICAgIGVycm9ySGFuZGxlci5vblVuZXhwZWN0ZWRFcnJvcihlKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpIHtcbiAgICAvLyBpZ25vcmUgZXJyb3JzIGZyb20gY2FuY2VsbGVkIHByb21pc2VzXG4gICAgaWYgKCFpc0NhbmNlbGxhdGlvbkVycm9yKGUpKSB7XG4gICAgICAgIGVycm9ySGFuZGxlci5vblVuZXhwZWN0ZWRFeHRlcm5hbEVycm9yKGUpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbihlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgbmFtZSwgbWVzc2FnZSB9ID0gZXJyb3I7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gZXJyb3Iuc3RhY2t0cmFjZSB8fCBlcnJvci5zdGFjaztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRpc0Vycm9yOiB0cnVlLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICBzdGFjayxcbiAgICAgICAgICAgIG5vVGVsZW1ldHJ5OiBFcnJvck5vVGVsZW1ldHJ5LmlzRXJyb3JOb1RlbGVtZXRyeShlcnJvcilcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGFzIGlzXG4gICAgcmV0dXJuIGVycm9yO1xufVxuY29uc3QgY2FuY2VsZWROYW1lID0gJ0NhbmNlbGVkJztcbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBlcnJvciBpcyBhIHByb21pc2UgaW4gY2FuY2VsZWQgc3RhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2FuY2VsbGF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDYW5jZWxsYXRpb25FcnJvcikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gY2FuY2VsZWROYW1lICYmIGVycm9yLm1lc3NhZ2UgPT09IGNhbmNlbGVkTmFtZTtcbn1cbi8vICEhIUlNUE9SVEFOVCEhIVxuLy8gRG8gTk9UIGNoYW5nZSB0aGlzIGNsYXNzIGJlY2F1c2UgaXQgaXMgYWxzbyB1c2VkIGFzIGFuIEFQSS10eXBlLlxuZXhwb3J0IGNsYXNzIENhbmNlbGxhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihjYW5jZWxlZE5hbWUpO1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLm1lc3NhZ2U7XG4gICAgfVxufVxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rIENhbmNlbGxhdGlvbkVycm9yIGBuZXcgQ2FuY2VsbGF0aW9uRXJyb3IoKWB9IGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbGVkKCkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKGNhbmNlbGVkTmFtZSk7XG4gICAgZXJyb3IubmFtZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlsbGVnYWxBcmd1bWVudChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihgSWxsZWdhbCBhcmd1bWVudDogJHtuYW1lfWApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSWxsZWdhbCBhcmd1bWVudCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpbGxlZ2FsU3RhdGUobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYElsbGVnYWwgc3RhdGU6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0lsbGVnYWwgc3RhdGUnKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTm90U3VwcG9ydGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcignTm90U3VwcG9ydGVkJyk7XG4gICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBFcnJvciB0aGF0IHdoZW4gdGhyb3duIHdvbid0IGJlIGxvZ2dlZCBpbiB0ZWxlbWV0cnkgYXMgYW4gdW5oYW5kbGVkIGVycm9yLlxuICovXG5leHBvcnQgY2xhc3MgRXJyb3JOb1RlbGVtZXRyeSBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICAgICAgc3VwZXIobXNnKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvZGVFeHBlY3RlZEVycm9yJztcbiAgICB9XG4gICAgc3RhdGljIGZyb21FcnJvcihlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yTm9UZWxlbWV0cnkpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEVycm9yTm9UZWxlbWV0cnkoKTtcbiAgICAgICAgcmVzdWx0Lm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgcmVzdWx0LnN0YWNrID0gZXJyLnN0YWNrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzdGF0aWMgaXNFcnJvck5vVGVsZW1ldHJ5KGVycikge1xuICAgICAgICByZXR1cm4gZXJyLm5hbWUgPT09ICdDb2RlRXhwZWN0ZWRFcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGVycm9yIGluZGljYXRlcyBhIGJ1Zy5cbiAqIERvIG5vdCB0aHJvdyB0aGlzIGZvciBpbnZhbGlkIHVzZXIgaW5wdXQuXG4gKiBPbmx5IGNhdGNoIHRoaXMgZXJyb3IgdG8gcmVjb3ZlciBncmFjZWZ1bGx5IGZyb20gYnVncy5cbiAqL1xuZXhwb3J0IGNsYXNzIEJ1Z0luZGljYXRpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ0FuIHVuZXhwZWN0ZWQgYnVnIG9jY3VycmVkLicpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQnVnSW5kaWNhdGluZ0Vycm9yLnByb3RvdHlwZSk7XG4gICAgICAgIC8vIEJlY2F1c2Ugd2Uga25vdyBmb3Igc3VyZSBvbmx5IGJ1Z2d5IGNvZGUgdGhyb3dzIHRoaXMsXG4gICAgICAgIC8vIHdlIGRlZmluaXRlbHkgd2FudCB0byBicmVhayBoZXJlIGFuZCBmaXggdGhlIGJ1Zy5cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgIC8vIGRlYnVnZ2VyO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBHaXZlbiBhIGZ1bmN0aW9uLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyBvbmx5IGNhbGxpbmcgdGhhdCBmdW5jdGlvbiBvbmNlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2luZ2xlQ2FsbEZ1bmN0aW9uKGZuLCBmbkRpZFJ1bkNhbGxiYWNrKSB7XG4gICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgIGxldCBkaWRDYWxsID0gZmFsc2U7XG4gICAgbGV0IHJlc3VsdDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGlkQ2FsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBkaWRDYWxsID0gdHJ1ZTtcbiAgICAgICAgaWYgKGZuRGlkUnVuQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZm4uYXBwbHkoX3RoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBmbkRpZFJ1bkNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmbi5hcHBseShfdGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCB2YXIgSXRlcmFibGU7XG4oZnVuY3Rpb24gKEl0ZXJhYmxlKSB7XG4gICAgZnVuY3Rpb24gaXModGhpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaW5nICYmIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHRoaW5nW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICAgIEl0ZXJhYmxlLmlzID0gaXM7XG4gICAgY29uc3QgX2VtcHR5ID0gT2JqZWN0LmZyZWV6ZShbXSk7XG4gICAgZnVuY3Rpb24gZW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBfZW1wdHk7XG4gICAgfVxuICAgIEl0ZXJhYmxlLmVtcHR5ID0gZW1wdHk7XG4gICAgZnVuY3Rpb24qIHNpbmdsZShlbGVtZW50KSB7XG4gICAgICAgIHlpZWxkIGVsZW1lbnQ7XG4gICAgfVxuICAgIEl0ZXJhYmxlLnNpbmdsZSA9IHNpbmdsZTtcbiAgICBmdW5jdGlvbiB3cmFwKGl0ZXJhYmxlT3JFbGVtZW50KSB7XG4gICAgICAgIGlmIChpcyhpdGVyYWJsZU9yRWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVyYWJsZU9yRWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzaW5nbGUoaXRlcmFibGVPckVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEl0ZXJhYmxlLndyYXAgPSB3cmFwO1xuICAgIGZ1bmN0aW9uIGZyb20oaXRlcmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlIHx8IF9lbXB0eTtcbiAgICB9XG4gICAgSXRlcmFibGUuZnJvbSA9IGZyb207XG4gICAgZnVuY3Rpb24qIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB5aWVsZCBhcnJheVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBJdGVyYWJsZS5yZXZlcnNlID0gcmV2ZXJzZTtcbiAgICBmdW5jdGlvbiBpc0VtcHR5KGl0ZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiAhaXRlcmFibGUgfHwgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS5kb25lID09PSB0cnVlO1xuICAgIH1cbiAgICBJdGVyYWJsZS5pc0VtcHR5ID0gaXNFbXB0eTtcbiAgICBmdW5jdGlvbiBmaXJzdChpdGVyYWJsZSkge1xuICAgICAgICByZXR1cm4gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpLm5leHQoKS52YWx1ZTtcbiAgICB9XG4gICAgSXRlcmFibGUuZmlyc3QgPSBmaXJzdDtcbiAgICBmdW5jdGlvbiBzb21lKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBJdGVyYWJsZS5zb21lID0gc29tZTtcbiAgICBmdW5jdGlvbiBmaW5kKGl0ZXJhYmxlLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgSXRlcmFibGUuZmluZCA9IGZpbmQ7XG4gICAgZnVuY3Rpb24qIGZpbHRlcihpdGVyYWJsZSwgcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgSXRlcmFibGUuZmlsdGVyID0gZmlsdGVyO1xuICAgIGZ1bmN0aW9uKiBtYXAoaXRlcmFibGUsIGZuKSB7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpdGVyYWJsZSkge1xuICAgICAgICAgICAgeWllbGQgZm4oZWxlbWVudCwgaW5kZXgrKyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSXRlcmFibGUubWFwID0gbWFwO1xuICAgIGZ1bmN0aW9uKiBjb25jYXQoLi4uaXRlcmFibGVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlcmFibGUgb2YgaXRlcmFibGVzKSB7XG4gICAgICAgICAgICB5aWVsZCogaXRlcmFibGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgSXRlcmFibGUuY29uY2F0ID0gY29uY2F0O1xuICAgIGZ1bmN0aW9uIHJlZHVjZShpdGVyYWJsZSwgcmVkdWNlciwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHJlZHVjZXIodmFsdWUsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgSXRlcmFibGUucmVkdWNlID0gcmVkdWNlO1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gaXRlcmFibGUgc2xpY2Ugb2YgdGhlIGFycmF5LCB3aXRoIHRoZSBzYW1lIHNlbWFudGljcyBhcyBgYXJyYXkuc2xpY2UoKWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24qIHNsaWNlKGFyciwgZnJvbSwgdG8gPSBhcnIubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmcm9tIDwgMCkge1xuICAgICAgICAgICAgZnJvbSArPSBhcnIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0byA8IDApIHtcbiAgICAgICAgICAgIHRvICs9IGFyci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodG8gPiBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0byA9IGFyci5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGZyb20gPCB0bzsgZnJvbSsrKSB7XG4gICAgICAgICAgICB5aWVsZCBhcnJbZnJvbV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgSXRlcmFibGUuc2xpY2UgPSBzbGljZTtcbiAgICAvKipcbiAgICAgKiBDb25zdW1lcyBgYXRNb3N0YCBlbGVtZW50cyBmcm9tIGl0ZXJhYmxlIGFuZCByZXR1cm5zIHRoZSBjb25zdW1lZCBlbGVtZW50cyxcbiAgICAgKiBhbmQgYW4gaXRlcmFibGUgZm9yIHRoZSByZXN0IG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb25zdW1lKGl0ZXJhYmxlLCBhdE1vc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgICAgY29uc3QgY29uc3VtZWQgPSBbXTtcbiAgICAgICAgaWYgKGF0TW9zdCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtjb25zdW1lZCwgaXRlcmFibGVdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0TW9zdDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbY29uc3VtZWQsIEl0ZXJhYmxlLmVtcHR5KCldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3VtZWQucHVzaChuZXh0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2NvbnN1bWVkLCB7IFtTeW1ib2wuaXRlcmF0b3JdKCkgeyByZXR1cm4gaXRlcmF0b3I7IH0gfV07XG4gICAgfVxuICAgIEl0ZXJhYmxlLmNvbnN1bWUgPSBjb25zdW1lO1xuICAgIGFzeW5jIGZ1bmN0aW9uIGFzeW5jVG9BcnJheShpdGVyYWJsZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGl0ZXJhYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIEl0ZXJhYmxlLmFzeW5jVG9BcnJheSA9IGFzeW5jVG9BcnJheTtcbn0pKEl0ZXJhYmxlIHx8IChJdGVyYWJsZSA9IHt9KSk7XG4iLCJpbXBvcnQgeyBjcmVhdGVTaW5nbGVDYWxsRnVuY3Rpb24gfSBmcm9tICcuL2Z1bmN0aW9uYWwuanMnO1xuaW1wb3J0IHsgSXRlcmFibGUgfSBmcm9tICcuL2l0ZXJhdG9yLmpzJztcbi8vICNyZWdpb24gRGlzcG9zYWJsZSBUcmFja2luZ1xuLyoqXG4gKiBFbmFibGVzIGxvZ2dpbmcgb2YgcG90ZW50aWFsbHkgbGVha2VkIGRpc3Bvc2FibGVzLlxuICpcbiAqIEEgZGlzcG9zYWJsZSBpcyBjb25zaWRlcmVkIGxlYWtlZCBpZiBpdCBpcyBub3QgZGlzcG9zZWQgb3Igbm90IHJlZ2lzdGVyZWQgYXMgdGhlIGNoaWxkIG9mXG4gKiBhbm90aGVyIGRpc3Bvc2FibGUuIFRoaXMgdHJhY2tpbmcgaXMgdmVyeSBzaW1wbGUgYW4gb25seSB3b3JrcyBmb3IgY2xhc3NlcyB0aGF0IGVpdGhlclxuICogZXh0ZW5kIERpc3Bvc2FibGUgb3IgdXNlIGEgRGlzcG9zYWJsZVN0b3JlLiBUaGlzIG1lYW5zIHRoZXJlIGFyZSBhIGxvdCBvZiBmYWxzZSBwb3NpdGl2ZXMuXG4gKi9cbmNvbnN0IFRSQUNLX0RJU1BPU0FCTEVTID0gZmFsc2U7XG5sZXQgZGlzcG9zYWJsZVRyYWNrZXIgPSBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIHNldERpc3Bvc2FibGVUcmFja2VyKHRyYWNrZXIpIHtcbiAgICBkaXNwb3NhYmxlVHJhY2tlciA9IHRyYWNrZXI7XG59XG5pZiAoVFJBQ0tfRElTUE9TQUJMRVMpIHtcbiAgICBjb25zdCBfX2lzX2Rpc3Bvc2FibGVfdHJhY2tlZF9fID0gJ19faXNfZGlzcG9zYWJsZV90cmFja2VkX18nO1xuICAgIHNldERpc3Bvc2FibGVUcmFja2VyKG5ldyBjbGFzcyB7XG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh4KSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IG5ldyBFcnJvcignUG90ZW50aWFsbHkgbGVha2VkIGRpc3Bvc2FibGUnKS5zdGFjaztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICgheFtfX2lzX2Rpc3Bvc2FibGVfdHJhY2tlZF9fXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMzAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0UGFyZW50KGNoaWxkLCBwYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gRGlzcG9zYWJsZS5Ob25lKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRbX19pc19kaXNwb3NhYmxlX3RyYWNrZWRfX10gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXJrQXNEaXNwb3NlZChkaXNwb3NhYmxlKSB7XG4gICAgICAgICAgICBpZiAoZGlzcG9zYWJsZSAmJiBkaXNwb3NhYmxlICE9PSBEaXNwb3NhYmxlLk5vbmUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlW19faXNfZGlzcG9zYWJsZV90cmFja2VkX19dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFya0FzU2luZ2xldG9uKGRpc3Bvc2FibGUpIHsgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyYWNrRGlzcG9zYWJsZSh4KSB7XG4gICAgZGlzcG9zYWJsZVRyYWNrZXIgPT09IG51bGwgfHwgZGlzcG9zYWJsZVRyYWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpc3Bvc2FibGVUcmFja2VyLnRyYWNrRGlzcG9zYWJsZSh4KTtcbiAgICByZXR1cm4geDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQXNEaXNwb3NlZChkaXNwb3NhYmxlKSB7XG4gICAgZGlzcG9zYWJsZVRyYWNrZXIgPT09IG51bGwgfHwgZGlzcG9zYWJsZVRyYWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpc3Bvc2FibGVUcmFja2VyLm1hcmtBc0Rpc3Bvc2VkKGRpc3Bvc2FibGUpO1xufVxuZnVuY3Rpb24gc2V0UGFyZW50T2ZEaXNwb3NhYmxlKGNoaWxkLCBwYXJlbnQpIHtcbiAgICBkaXNwb3NhYmxlVHJhY2tlciA9PT0gbnVsbCB8fCBkaXNwb3NhYmxlVHJhY2tlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlzcG9zYWJsZVRyYWNrZXIuc2V0UGFyZW50KGNoaWxkLCBwYXJlbnQpO1xufVxuZnVuY3Rpb24gc2V0UGFyZW50T2ZEaXNwb3NhYmxlcyhjaGlsZHJlbiwgcGFyZW50KSB7XG4gICAgaWYgKCFkaXNwb3NhYmxlVHJhY2tlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgZGlzcG9zYWJsZVRyYWNrZXIuc2V0UGFyZW50KGNoaWxkLCBwYXJlbnQpO1xuICAgIH1cbn1cbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgdGhlIGdpdmVuIG9iamVjdCBpcyBhIHNpbmdsZXRvbiB3aGljaCBkb2VzIG5vdCBuZWVkIHRvIGJlIGRpc3Bvc2VkLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXJrQXNTaW5nbGV0b24oc2luZ2xldG9uKSB7XG4gICAgZGlzcG9zYWJsZVRyYWNrZXIgPT09IG51bGwgfHwgZGlzcG9zYWJsZVRyYWNrZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRpc3Bvc2FibGVUcmFja2VyLm1hcmtBc1NpbmdsZXRvbihzaW5nbGV0b24pO1xuICAgIHJldHVybiBzaW5nbGV0b247XG59XG4vKipcbiAqIENoZWNrIGlmIGB0aGluZ2AgaXMge0BsaW5rIElEaXNwb3NhYmxlIGRpc3Bvc2FibGV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEaXNwb3NhYmxlKHRoaW5nKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGluZyA9PT0gJ29iamVjdCcgJiYgdGhpbmcgIT09IG51bGwgJiYgdHlwZW9mIHRoaW5nLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicgJiYgdGhpbmcuZGlzcG9zZS5sZW5ndGggPT09IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gZGlzcG9zZShhcmcpIHtcbiAgICBpZiAoSXRlcmFibGUuaXMoYXJnKSkge1xuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBkIG9mIGFyZykge1xuICAgICAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3JzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZ2dyZWdhdGVFcnJvcihlcnJvcnMsICdFbmNvdW50ZXJlZCBlcnJvcnMgd2hpbGUgZGlzcG9zaW5nIG9mIHN0b3JlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKSA/IFtdIDogYXJnO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmcpIHtcbiAgICAgICAgYXJnLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIGFyZztcbiAgICB9XG59XG4vKipcbiAqIENvbWJpbmUgbXVsdGlwbGUgZGlzcG9zYWJsZSB2YWx1ZXMgaW50byBhIHNpbmdsZSB7QGxpbmsgSURpc3Bvc2FibGV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZWREaXNwb3NhYmxlKC4uLmRpc3Bvc2FibGVzKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdG9EaXNwb3NhYmxlKCgpID0+IGRpc3Bvc2UoZGlzcG9zYWJsZXMpKTtcbiAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGVzKGRpc3Bvc2FibGVzLCBwYXJlbnQpO1xuICAgIHJldHVybiBwYXJlbnQ7XG59XG4vKipcbiAqIFR1cm4gYSBmdW5jdGlvbiB0aGF0IGltcGxlbWVudHMgZGlzcG9zZSBpbnRvIGFuIHtAbGluayBJRGlzcG9zYWJsZX0uXG4gKlxuICogQHBhcmFtIGZuIENsZWFuIHVwIGZ1bmN0aW9uLCBndWFyYW50ZWVkIHRvIGJlIGNhbGxlZCBvbmx5ICoqb25jZSoqLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9EaXNwb3NhYmxlKGZuKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRyYWNrRGlzcG9zYWJsZSh7XG4gICAgICAgIGRpc3Bvc2U6IGNyZWF0ZVNpbmdsZUNhbGxGdW5jdGlvbigoKSA9PiB7XG4gICAgICAgICAgICBtYXJrQXNEaXNwb3NlZChzZWxmKTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0pXG4gICAgfSk7XG4gICAgcmV0dXJuIHNlbGY7XG59XG4vKipcbiAqIE1hbmFnZXMgYSBjb2xsZWN0aW9uIG9mIGRpc3Bvc2FibGUgdmFsdWVzLlxuICpcbiAqIFRoaXMgaXMgdGhlIHByZWZlcnJlZCB3YXkgdG8gbWFuYWdlIG11bHRpcGxlIGRpc3Bvc2FibGVzLiBBIGBEaXNwb3NhYmxlU3RvcmVgIGlzIHNhZmVyIHRvIHdvcmsgd2l0aCB0aGFuIGFuXG4gKiBgSURpc3Bvc2FibGVbXWAgYXMgaXQgY29uc2lkZXJzIGVkZ2UgY2FzZXMsIHN1Y2ggYXMgcmVnaXN0ZXJpbmcgdGhlIHNhbWUgdmFsdWUgbXVsdGlwbGUgdGltZXMgb3IgYWRkaW5nIGFuIGl0ZW0gdG8gYVxuICogc3RvcmUgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRpc3Bvc2VkIG9mLlxuICovXG5leHBvcnQgY2xhc3MgRGlzcG9zYWJsZVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdG9EaXNwb3NlID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRyYWNrRGlzcG9zYWJsZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZSBvZiBhbGwgcmVnaXN0ZXJlZCBkaXNwb3NhYmxlcyBhbmQgbWFyayB0aGlzIG9iamVjdCBhcyBkaXNwb3NlZC5cbiAgICAgKlxuICAgICAqIEFueSBmdXR1cmUgZGlzcG9zYWJsZXMgYWRkZWQgdG8gdGhpcyBvYmplY3Qgd2lsbCBiZSBkaXNwb3NlZCBvZiBvbiBgYWRkYC5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5faXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtBc0Rpc3Bvc2VkKHRoaXMpO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGlzIG9iamVjdCBoYXMgYmVlbiBkaXNwb3NlZCBvZi5cbiAgICAgKi9cbiAgICBnZXQgaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2Ugb2YgYWxsIHJlZ2lzdGVyZWQgZGlzcG9zYWJsZXMgYnV0IGRvIG5vdCBtYXJrIHRoaXMgb2JqZWN0IGFzIGRpc3Bvc2VkLlxuICAgICAqL1xuICAgIGNsZWFyKCkge1xuICAgICAgICBpZiAodGhpcy5fdG9EaXNwb3NlLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlzcG9zZSh0aGlzLl90b0Rpc3Bvc2UpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5fdG9EaXNwb3NlLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkIGEgbmV3IHtAbGluayBJRGlzcG9zYWJsZSBkaXNwb3NhYmxlfSB0byB0aGUgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBhZGQobykge1xuICAgICAgICBpZiAoIW8pIHtcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWdpc3RlciBhIGRpc3Bvc2FibGUgb24gaXRzZWxmIScpO1xuICAgICAgICB9XG4gICAgICAgIHNldFBhcmVudE9mRGlzcG9zYWJsZShvLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIGlmICghRGlzcG9zYWJsZVN0b3JlLkRJU0FCTEVfRElTUE9TRURfV0FSTklORykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IoJ1RyeWluZyB0byBhZGQgYSBkaXNwb3NhYmxlIHRvIGEgRGlzcG9zYWJsZVN0b3JlIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBkaXNwb3NlZCBvZi4gVGhlIGFkZGVkIG9iamVjdCB3aWxsIGJlIGxlYWtlZCEnKS5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90b0Rpc3Bvc2UuYWRkKG8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmcm9tIHRoZSBzdG9yZSwgYnV0IGRvZXMgbm90IGRpc3Bvc2UgaXQuXG4gICAgICovXG4gICAgZGVsZXRlQW5kTGVhayhvKSB7XG4gICAgICAgIGlmICghbykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90b0Rpc3Bvc2UuaGFzKG8pKSB7XG4gICAgICAgICAgICB0aGlzLl90b0Rpc3Bvc2UuZGVsZXRlKG8pO1xuICAgICAgICAgICAgc2V0UGFyZW50T2ZEaXNwb3NhYmxlKG8sIG51bGwpO1xuICAgICAgICB9XG4gICAgfVxufVxuRGlzcG9zYWJsZVN0b3JlLkRJU0FCTEVfRElTUE9TRURfV0FSTklORyA9IGZhbHNlO1xuLyoqXG4gKiBBYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhIHtAbGluayBJRGlzcG9zYWJsZSBkaXNwb3NhYmxlfSBvYmplY3QuXG4gKlxuICogU3ViY2xhc3NlcyBjYW4ge0BsaW5rY29kZSBfcmVnaXN0ZXJ9IGRpc3Bvc2FibGVzIHRoYXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAgd2hlbiB0aGlzIG9iamVjdCBpcyBkaXNwb3NlZCBvZi5cbiAqL1xuZXhwb3J0IGNsYXNzIERpc3Bvc2FibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9zdG9yZSA9IG5ldyBEaXNwb3NhYmxlU3RvcmUoKTtcbiAgICAgICAgdHJhY2tEaXNwb3NhYmxlKHRoaXMpO1xuICAgICAgICBzZXRQYXJlbnRPZkRpc3Bvc2FibGUodGhpcy5fc3RvcmUsIHRoaXMpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBtYXJrQXNEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fc3RvcmUuZGlzcG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGBvYCB0byB0aGUgY29sbGVjdGlvbiBvZiBkaXNwb3NhYmxlcyBtYW5hZ2VkIGJ5IHRoaXMgb2JqZWN0LlxuICAgICAqL1xuICAgIF9yZWdpc3RlcihvKSB7XG4gICAgICAgIGlmIChvID09PSB0aGlzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWdpc3RlciBhIGRpc3Bvc2FibGUgb24gaXRzZWxmIScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9yZS5hZGQobyk7XG4gICAgfVxufVxuLyoqXG4gKiBBIGRpc3Bvc2FibGUgdGhhdCBkb2VzIG5vdGhpbmcgd2hlbiBpdCBpcyBkaXNwb3NlZCBvZi5cbiAqXG4gKiBUT0RPOiBUaGlzIHNob3VsZCBub3QgYmUgYSBzdGF0aWMgcHJvcGVydHkuXG4gKi9cbkRpc3Bvc2FibGUuTm9uZSA9IE9iamVjdC5mcmVlemUoeyBkaXNwb3NlKCkgeyB9IH0pO1xuLyoqXG4gKiBNYW5hZ2VzIHRoZSBsaWZlY3ljbGUgb2YgYSBkaXNwb3NhYmxlIHZhbHVlIHRoYXQgbWF5IGJlIGNoYW5nZWQuXG4gKlxuICogVGhpcyBlbnN1cmVzIHRoYXQgd2hlbiB0aGUgZGlzcG9zYWJsZSB2YWx1ZSBpcyBjaGFuZ2VkLCB0aGUgcHJldmlvdXNseSBoZWxkIGRpc3Bvc2FibGUgaXMgZGlzcG9zZWQgb2YuIFlvdSBjYW5cbiAqIGFsc28gcmVnaXN0ZXIgYSBgTXV0YWJsZURpc3Bvc2FibGVgIG9uIGEgYERpc3Bvc2FibGVgIHRvIGVuc3VyZSBpdCBpcyBhdXRvbWF0aWNhbGx5IGNsZWFuZWQgdXAuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdXRhYmxlRGlzcG9zYWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdHJhY2tEaXNwb3NhYmxlKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Rpc3Bvc2VkID8gdW5kZWZpbmVkIDogdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkIHx8IHZhbHVlID09PSB0aGlzLl92YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuX3ZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHNldFBhcmVudE9mRGlzcG9zYWJsZSh2YWx1ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBzdG9yZWQgdmFsdWUgYW5kIGRpc3Bvc2VkIG9mIHRoZSBwcmV2aW91c2x5IHN0b3JlZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgbWFya0FzRGlzcG9zZWQodGhpcyk7XG4gICAgICAgIChfYSA9IHRoaXMuX3ZhbHVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVmQ291bnRlZERpc3Bvc2FibGUge1xuICAgIGNvbnN0cnVjdG9yKF9kaXNwb3NhYmxlKSB7XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2FibGUgPSBfZGlzcG9zYWJsZTtcbiAgICAgICAgdGhpcy5fY291bnRlciA9IDE7XG4gICAgfVxuICAgIGFjcXVpcmUoKSB7XG4gICAgICAgIHRoaXMuX2NvdW50ZXIrKztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbGVhc2UoKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2NvdW50ZXIgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBJbW1vcnRhbFJlZmVyZW5jZSB7XG4gICAgY29uc3RydWN0b3Iob2JqZWN0KSB7XG4gICAgICAgIHRoaXMub2JqZWN0ID0gb2JqZWN0O1xuICAgIH1cbiAgICBkaXNwb3NlKCkgeyB9XG59XG4vKipcbiAqIEEgbWFwIHRoZSBtYW5hZ2VzIHRoZSBsaWZlY3ljbGUgb2YgdGhlIHZhbHVlcyB0aGF0IGl0IHN0b3Jlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIERpc3Bvc2FibGVNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9zdG9yZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICB0cmFja0Rpc3Bvc2FibGUodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIG9mIGFsbCBzdG9yZWQgdmFsdWVzIGFuZCBtYXJrIHRoaXMgb2JqZWN0IGFzIGRpc3Bvc2VkLlxuICAgICAqXG4gICAgICogVHJ5aW5nIHRvIHVzZSB0aGlzIG9iamVjdCBhZnRlciBpdCBoYXMgYmVlbiBkaXNwb3NlZCBvZiBpcyBhbiBlcnJvci5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBtYXJrQXNEaXNwb3NlZCh0aGlzKTtcbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYXJBbmREaXNwb3NlQWxsKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIG9mIGFsbCBzdG9yZWQgdmFsdWVzIGFuZCBjbGVhciB0aGUgbWFwLCBidXQgRE8gTk9UIG1hcmsgdGhpcyBvYmplY3QgYXMgZGlzcG9zZWQuXG4gICAgICovXG4gICAgY2xlYXJBbmREaXNwb3NlQWxsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0b3JlLnNpemUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGlzcG9zZSh0aGlzLl9zdG9yZS52YWx1ZXMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9yZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlLmdldChrZXkpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgc2tpcERpc3Bvc2VPbk92ZXJ3cml0ZSA9IGZhbHNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihuZXcgRXJyb3IoJ1RyeWluZyB0byBhZGQgYSBkaXNwb3NhYmxlIHRvIGEgRGlzcG9zYWJsZU1hcCB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQgb2YuIFRoZSBhZGRlZCBvYmplY3Qgd2lsbCBiZSBsZWFrZWQhJykuc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2tpcERpc3Bvc2VPbk92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgKF9hID0gdGhpcy5fc3RvcmUuZ2V0KGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RvcmUuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGUgdGhlIHZhbHVlIHN0b3JlZCBmb3IgYGtleWAgZnJvbSB0aGlzIG1hcCBhbmQgYWxzbyBkaXNwb3NlIG9mIGl0LlxuICAgICAqL1xuICAgIGRlbGV0ZUFuZERpc3Bvc2Uoa2V5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy5fc3RvcmUuZ2V0KGtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuX3N0b3JlLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmNsYXNzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uZXh0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIHRoaXMucHJldiA9IE5vZGUuVW5kZWZpbmVkO1xuICAgIH1cbn1cbk5vZGUuVW5kZWZpbmVkID0gbmV3IE5vZGUodW5kZWZpbmVkKTtcbmV4cG9ydCBjbGFzcyBMaW5rZWRMaXN0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZmlyc3QgPSBOb2RlLlVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbGFzdCA9IE5vZGUuVW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlyc3QgPT09IE5vZGUuVW5kZWZpbmVkO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLl9maXJzdDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IE5vZGUuVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gbm9kZS5uZXh0O1xuICAgICAgICAgICAgbm9kZS5wcmV2ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgICAgICBub2RlLm5leHQgPSBOb2RlLlVuZGVmaW5lZDtcbiAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZpcnN0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2xhc3QgPSBOb2RlLlVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgfVxuICAgIHVuc2hpZnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KGVsZW1lbnQsIGZhbHNlKTtcbiAgICB9XG4gICAgcHVzaChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnQoZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuICAgIF9pbnNlcnQoZWxlbWVudCwgYXRUaGVFbmQpIHtcbiAgICAgICAgY29uc3QgbmV3Tm9kZSA9IG5ldyBOb2RlKGVsZW1lbnQpO1xuICAgICAgICBpZiAodGhpcy5fZmlyc3QgPT09IE5vZGUuVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9maXJzdCA9IG5ld05vZGU7XG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gbmV3Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhdFRoZUVuZCkge1xuICAgICAgICAgICAgLy8gcHVzaFxuICAgICAgICAgICAgY29uc3Qgb2xkTGFzdCA9IHRoaXMuX2xhc3Q7XG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIG5ld05vZGUucHJldiA9IG9sZExhc3Q7XG4gICAgICAgICAgICBvbGRMYXN0Lm5leHQgPSBuZXdOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdW5zaGlmdFxuICAgICAgICAgICAgY29uc3Qgb2xkRmlyc3QgPSB0aGlzLl9maXJzdDtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gbmV3Tm9kZTtcbiAgICAgICAgICAgIG5ld05vZGUubmV4dCA9IG9sZEZpcnN0O1xuICAgICAgICAgICAgb2xkRmlyc3QucHJldiA9IG5ld05vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2l6ZSArPSAxO1xuICAgICAgICBsZXQgZGlkUmVtb3ZlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWRpZFJlbW92ZSkge1xuICAgICAgICAgICAgICAgIGRpZFJlbW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzaGlmdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2ZpcnN0ID09PSBOb2RlLlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuX2ZpcnN0LmVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdmUodGhpcy5fZmlyc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwb3AoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sYXN0ID09PSBOb2RlLlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuX2xhc3QuZWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZSh0aGlzLl9sYXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3JlbW92ZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnByZXYgIT09IE5vZGUuVW5kZWZpbmVkICYmIG5vZGUubmV4dCAhPT0gTm9kZS5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG1pZGRsZVxuICAgICAgICAgICAgY29uc3QgYW5jaG9yID0gbm9kZS5wcmV2O1xuICAgICAgICAgICAgYW5jaG9yLm5leHQgPSBub2RlLm5leHQ7XG4gICAgICAgICAgICBub2RlLm5leHQucHJldiA9IGFuY2hvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnByZXYgPT09IE5vZGUuVW5kZWZpbmVkICYmIG5vZGUubmV4dCA9PT0gTm9kZS5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgbm9kZVxuICAgICAgICAgICAgdGhpcy5fZmlyc3QgPSBOb2RlLlVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuX2xhc3QgPSBOb2RlLlVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5leHQgPT09IE5vZGUuVW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBsYXN0XG4gICAgICAgICAgICB0aGlzLl9sYXN0ID0gdGhpcy5fbGFzdC5wcmV2O1xuICAgICAgICAgICAgdGhpcy5fbGFzdC5uZXh0ID0gTm9kZS5VbmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wcmV2ID09PSBOb2RlLlVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gZmlyc3RcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0ID0gdGhpcy5fZmlyc3QubmV4dDtcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0LnByZXYgPSBOb2RlLlVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb25lXG4gICAgICAgIHRoaXMuX3NpemUgLT0gMTtcbiAgICB9XG4gICAgKltTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX2ZpcnN0O1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gTm9kZS5VbmRlZmluZWQpIHtcbiAgICAgICAgICAgIHlpZWxkIG5vZGUuZWxlbWVudDtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmNvbnN0IGhhc1BlcmZvcm1hbmNlTm93ID0gKGdsb2JhbFRoaXMucGVyZm9ybWFuY2UgJiYgdHlwZW9mIGdsb2JhbFRoaXMucGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nKTtcbmV4cG9ydCBjbGFzcyBTdG9wV2F0Y2gge1xuICAgIHN0YXRpYyBjcmVhdGUoaGlnaFJlc29sdXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdG9wV2F0Y2goaGlnaFJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihoaWdoUmVzb2x1dGlvbikge1xuICAgICAgICB0aGlzLl9ub3cgPSBoYXNQZXJmb3JtYW5jZU5vdyAmJiBoaWdoUmVzb2x1dGlvbiA9PT0gZmFsc2UgPyBEYXRlLm5vdyA6IGdsb2JhbFRoaXMucGVyZm9ybWFuY2Uubm93LmJpbmQoZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSk7XG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IHRoaXMuX25vdygpO1xuICAgICAgICB0aGlzLl9zdG9wVGltZSA9IC0xO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLl9zdG9wVGltZSA9IHRoaXMuX25vdygpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gdGhpcy5fbm93KCk7XG4gICAgICAgIHRoaXMuX3N0b3BUaW1lID0gLTE7XG4gICAgfVxuICAgIGVsYXBzZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdG9wVGltZSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdG9wVGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbm93KCkgLSB0aGlzLl9zdGFydFRpbWU7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgb25VbmV4cGVjdGVkRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVTaW5nbGVDYWxsRnVuY3Rpb24gfSBmcm9tICcuL2Z1bmN0aW9uYWwuanMnO1xuaW1wb3J0IHsgY29tYmluZWREaXNwb3NhYmxlLCBEaXNwb3NhYmxlLCBEaXNwb3NhYmxlU3RvcmUsIHRvRGlzcG9zYWJsZSB9IGZyb20gJy4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IExpbmtlZExpc3QgfSBmcm9tICcuL2xpbmtlZExpc3QuanMnO1xuaW1wb3J0IHsgU3RvcFdhdGNoIH0gZnJvbSAnLi9zdG9wd2F0Y2guanMnO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFVuY29tbWVudCB0aGUgbmV4dCBsaW5lIHRvIHByaW50IHdhcm5pbmdzIHdoZW5ldmVyIGEgbGlzdGVuZXIgaXMgR0MnZWQgd2l0aG91dCBoYXZpbmcgYmVlbiBkaXNwb3NlZC4gVGhpcyBpcyBhIExFQUsuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgX2VuYWJsZUxpc3RlbmVyR0NlZFdhcm5pbmcgPSBmYWxzZTtcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBVbmNvbW1lbnQgdGhlIG5leHQgbGluZSB0byBwcmludCB3YXJuaW5ncyB3aGVuZXZlciBhbiBlbWl0dGVyIHdpdGggbGlzdGVuZXJzIGlzIGRpc3Bvc2VkLiBUaGF0IGlzIGEgc2lnbiBvZiBjb2RlIHNtZWxsLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNvbnN0IF9lbmFibGVEaXNwb3NlV2l0aExpc3RlbmVyV2FybmluZyA9IGZhbHNlO1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFVuY29tbWVudCB0aGUgbmV4dCBsaW5lIHRvIHByaW50IHdhcm5pbmdzIHdoZW5ldmVyIGEgc25hcHNob3R0ZWQgZXZlbnQgaXMgdXNlZCByZXBlYXRlZGx5IHdpdGhvdXQgY2xlYW51cC5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L3ZzY29kZS9pc3N1ZXMvMTQyODUxXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY29uc3QgX2VuYWJsZVNuYXBzaG90UG90ZW50aWFsTGVha1dhcm5pbmcgPSBmYWxzZTtcbmV4cG9ydCB2YXIgRXZlbnQ7XG4oZnVuY3Rpb24gKEV2ZW50KSB7XG4gICAgRXZlbnQuTm9uZSA9ICgpID0+IERpc3Bvc2FibGUuTm9uZTtcbiAgICBmdW5jdGlvbiBfYWRkTGVha2FnZVRyYWNlTG9naWMob3B0aW9ucykge1xuICAgICAgICBpZiAoX2VuYWJsZVNuYXBzaG90UG90ZW50aWFsTGVha1dhcm5pbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25EaWRBZGRMaXN0ZW5lcjogb3JpZ0xpc3RlbmVyRGlkQWRkIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBTdGFja3RyYWNlLmNyZWF0ZSgpO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIG9wdGlvbnMub25EaWRBZGRMaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3NuYXBzaG90dGVkIGVtaXR0ZXIgTElLRUxZIHVzZWQgcHVibGljIGFuZCBTSE9VTEQgSEFWRSBCRUVOIGNyZWF0ZWQgd2l0aCBEaXNwb3NhYmxlU3RvcmUuIHNuYXBzaG90dGVkIGhlcmUnKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHJpbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3JpZ0xpc3RlbmVyRGlkQWRkID09PSBudWxsIHx8IG9yaWdMaXN0ZW5lckRpZEFkZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ0xpc3RlbmVyRGlkQWRkKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGV2ZW50LCByZXR1cm5zIGFub3RoZXIgZXZlbnQgd2hpY2ggZGVib3VuY2VzIGNhbGxzIGFuZCBkZWZlcnMgdGhlIGxpc3RlbmVycyB0byBhIGxhdGVyIHRhc2sgdmlhIGEgc2hhcmVkXG4gICAgICogYHNldFRpbWVvdXRgLiBUaGUgZXZlbnQgaXMgY29udmVydGVkIGludG8gYSBzaWduYWwgKGBFdmVudDx2b2lkPmApIHRvIGF2b2lkIGFkZGl0aW9uYWwgb2JqZWN0IGNyZWF0aW9uIGFzIGFcbiAgICAgKiByZXN1bHQgb2YgbWVyZ2luZyBldmVudHMgYW5kIHRvIHRyeSBwcmV2ZW50IHJhY2UgY29uZGl0aW9ucyB0aGF0IGNvdWxkIGFyaXNlIHdoZW4gdXNpbmcgcmVsYXRlZCBkZWZlcnJlZCBhbmRcbiAgICAgKiBub24tZGVmZXJyZWQgZXZlbnRzLlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGRlZmVycmluZyBub24tY3JpdGljYWwgd29yayAoZWcuIGdlbmVyYWwgVUkgdXBkYXRlcykgdG8gZW5zdXJlIGl0IGRvZXMgbm90IGJsb2NrIGNyaXRpY2FsIHdvcmtcbiAgICAgKiAoZWcuIGxhdGVuY3kgb2Yga2V5cHJlc3MgdG8gdGV4dCByZW5kZXJlZCkuXG4gICAgICpcbiAgICAgKiAqTk9URSogdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYEV2ZW50YCBhbmQgaXQgTVVTVCBiZSBjYWxsZWQgd2l0aCBhIGBEaXNwb3NhYmxlU3RvcmVgIHdoZW5ldmVyIHRoZSByZXR1cm5lZFxuICAgICAqIGV2ZW50IGlzIGFjY2Vzc2libGUgdG8gXCJ0aGlyZCBwYXJ0aWVzXCIsIGUuZyB0aGUgZXZlbnQgaXMgYSBwdWJsaWMgcHJvcGVydHkuIE90aGVyd2lzZSBhIGxlYWtlZCBsaXN0ZW5lciBvbiB0aGVcbiAgICAgKiByZXR1cm5lZCBldmVudCBjYXVzZXMgdGhpcyB1dGlsaXR5IHRvIGxlYWsgYSBsaXN0ZW5lciBvbiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBmb3IgdGhlIG5ldyBldmVudC5cbiAgICAgKiBAcGFyYW0gZGlzcG9zYWJsZSBBIGRpc3Bvc2FibGUgc3RvcmUgdG8gYWRkIHRoZSBuZXcgRXZlbnRFbWl0dGVyIHRvLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlZmVyKGV2ZW50LCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIHJldHVybiBkZWJvdW5jZShldmVudCwgKCkgPT4gdm9pZCAwLCAwLCB1bmRlZmluZWQsIHRydWUsIHVuZGVmaW5lZCwgZGlzcG9zYWJsZSk7XG4gICAgfVxuICAgIEV2ZW50LmRlZmVyID0gZGVmZXI7XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gZXZlbnQsIHJldHVybnMgYW5vdGhlciBldmVudCB3aGljaCBvbmx5IGZpcmVzIG9uY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBmb3IgdGhlIG5ldyBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbmNlKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiAobGlzdGVuZXIsIHRoaXNBcmdzID0gbnVsbCwgZGlzcG9zYWJsZXMpID0+IHtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcywgaW4gY2FzZSB0aGUgZXZlbnQgZmlyZXMgZHVyaW5nIHRoZSBsaXN0ZW5lciBjYWxsXG4gICAgICAgICAgICBsZXQgZGlkRmlyZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc3VsdCA9IGV2ZW50KGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaWRGaXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaWRGaXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGUpO1xuICAgICAgICAgICAgfSwgbnVsbCwgZGlzcG9zYWJsZXMpO1xuICAgICAgICAgICAgaWYgKGRpZEZpcmUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRXZlbnQub25jZSA9IG9uY2U7XG4gICAgLyoqXG4gICAgICogTWFwcyBhbiBldmVudCBvZiBvbmUgdHlwZSBpbnRvIGFuIGV2ZW50IG9mIGFub3RoZXIgdHlwZSB1c2luZyBhIG1hcHBpbmcgZnVuY3Rpb24sIHNpbWlsYXIgdG8gaG93XG4gICAgICogYEFycmF5LnByb3RvdHlwZS5tYXBgIHdvcmtzLlxuICAgICAqXG4gICAgICogKk5PVEUqIHRoYXQgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGBFdmVudGAgYW5kIGl0IE1VU1QgYmUgY2FsbGVkIHdpdGggYSBgRGlzcG9zYWJsZVN0b3JlYCB3aGVuZXZlciB0aGUgcmV0dXJuZWRcbiAgICAgKiBldmVudCBpcyBhY2Nlc3NpYmxlIHRvIFwidGhpcmQgcGFydGllc1wiLCBlLmcgdGhlIGV2ZW50IGlzIGEgcHVibGljIHByb3BlcnR5LiBPdGhlcndpc2UgYSBsZWFrZWQgbGlzdGVuZXIgb24gdGhlXG4gICAgICogcmV0dXJuZWQgZXZlbnQgY2F1c2VzIHRoaXMgdXRpbGl0eSB0byBsZWFrIGEgbGlzdGVuZXIgb24gdGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBzb3VyY2UgZm9yIHRoZSBuZXcgZXZlbnQuXG4gICAgICogQHBhcmFtIG1hcCBUaGUgbWFwcGluZyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gZGlzcG9zYWJsZSBBIGRpc3Bvc2FibGUgc3RvcmUgdG8gYWRkIHRoZSBuZXcgRXZlbnRFbWl0dGVyIHRvLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChldmVudCwgbWFwLCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdCgobGlzdGVuZXIsIHRoaXNBcmdzID0gbnVsbCwgZGlzcG9zYWJsZXMpID0+IGV2ZW50KGkgPT4gbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgbWFwKGkpKSwgbnVsbCwgZGlzcG9zYWJsZXMpLCBkaXNwb3NhYmxlKTtcbiAgICB9XG4gICAgRXZlbnQubWFwID0gbWFwO1xuICAgIC8qKlxuICAgICAqIFdyYXBzIGFuIGV2ZW50IGluIGFub3RoZXIgZXZlbnQgdGhhdCBwZXJmb3JtcyBzb21lIGZ1bmN0aW9uIG9uIHRoZSBldmVudCBvYmplY3QgYmVmb3JlIGZpcmluZy5cbiAgICAgKlxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldmVudCBUaGUgZXZlbnQgc291cmNlIGZvciB0aGUgbmV3IGV2ZW50LlxuICAgICAqIEBwYXJhbSBlYWNoIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIG9uIHRoZSBldmVudCBvYmplY3QuXG4gICAgICogQHBhcmFtIGRpc3Bvc2FibGUgQSBkaXNwb3NhYmxlIHN0b3JlIHRvIGFkZCB0aGUgbmV3IEV2ZW50RW1pdHRlciB0by5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoKGV2ZW50LCBlYWNoLCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIHJldHVybiBzbmFwc2hvdCgobGlzdGVuZXIsIHRoaXNBcmdzID0gbnVsbCwgZGlzcG9zYWJsZXMpID0+IGV2ZW50KGkgPT4geyBlYWNoKGkpOyBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBpKTsgfSwgbnVsbCwgZGlzcG9zYWJsZXMpLCBkaXNwb3NhYmxlKTtcbiAgICB9XG4gICAgRXZlbnQuZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgZnVuY3Rpb24gZmlsdGVyKGV2ZW50LCBmaWx0ZXIsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIHNuYXBzaG90KChsaXN0ZW5lciwgdGhpc0FyZ3MgPSBudWxsLCBkaXNwb3NhYmxlcykgPT4gZXZlbnQoZSA9PiBmaWx0ZXIoZSkgJiYgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgZSksIG51bGwsIGRpc3Bvc2FibGVzKSwgZGlzcG9zYWJsZSk7XG4gICAgfVxuICAgIEV2ZW50LmZpbHRlciA9IGZpbHRlcjtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBldmVudCwgcmV0dXJucyB0aGUgc2FtZSBldmVudCBidXQgdHlwZWQgYXMgYEV2ZW50PHZvaWQ+YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduYWwoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBFdmVudC5zaWduYWwgPSBzaWduYWw7XG4gICAgZnVuY3Rpb24gYW55KC4uLmV2ZW50cykge1xuICAgICAgICByZXR1cm4gKGxpc3RlbmVyLCB0aGlzQXJncyA9IG51bGwsIGRpc3Bvc2FibGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXNwb3NhYmxlID0gY29tYmluZWREaXNwb3NhYmxlKC4uLmV2ZW50cy5tYXAoZXZlbnQgPT4gZXZlbnQoZSA9PiBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCBlKSkpKTtcbiAgICAgICAgICAgIHJldHVybiBhZGRBbmRSZXR1cm5EaXNwb3NhYmxlKGRpc3Bvc2FibGUsIGRpc3Bvc2FibGVzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRXZlbnQuYW55ID0gYW55O1xuICAgIC8qKlxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoZXZlbnQsIG1lcmdlLCBpbml0aWFsLCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBpbml0aWFsO1xuICAgICAgICByZXR1cm4gbWFwKGV2ZW50LCBlID0+IHtcbiAgICAgICAgICAgIG91dHB1dCA9IG1lcmdlKG91dHB1dCwgZSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LCBkaXNwb3NhYmxlKTtcbiAgICB9XG4gICAgRXZlbnQucmVkdWNlID0gcmVkdWNlO1xuICAgIGZ1bmN0aW9uIHNuYXBzaG90KGV2ZW50LCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIGxldCBsaXN0ZW5lcjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIgPSBldmVudChlbWl0dGVyLmZpcmUsIGVtaXR0ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyKCkge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyID09PSBudWxsIHx8IGxpc3RlbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsaXN0ZW5lci5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghZGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgX2FkZExlYWthZ2VUcmFjZUxvZ2ljKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgRW1pdHRlcihvcHRpb25zKTtcbiAgICAgICAgZGlzcG9zYWJsZSA9PT0gbnVsbCB8fCBkaXNwb3NhYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkaXNwb3NhYmxlLmFkZChlbWl0dGVyKTtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIElEaXNwb3NhYmxlIHRvIHRoZSBzdG9yZSBpZiBpdCdzIHNldCwgYW5kIHJldHVybnMgaXQuIFVzZWZ1bCB0b1xuICAgICAqIEV2ZW50IGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZEFuZFJldHVybkRpc3Bvc2FibGUoZCwgc3RvcmUpIHtcbiAgICAgICAgaWYgKHN0b3JlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHN0b3JlLnB1c2goZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIHN0b3JlLmFkZChkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZXZlbnQsIG1lcmdlLCBkZWxheSA9IDEwMCwgbGVhZGluZyA9IGZhbHNlLCBmbHVzaE9uTGlzdGVuZXJSZW1vdmUgPSBmYWxzZSwgbGVha1dhcm5pbmdUaHJlc2hvbGQsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgbGV0IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgbGV0IG91dHB1dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IGhhbmRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG51bURlYm91bmNlZENhbGxzID0gMDtcbiAgICAgICAgbGV0IGRvRmlyZTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxlYWtXYXJuaW5nVGhyZXNob2xkLFxuICAgICAgICAgICAgb25XaWxsQWRkRmlyc3RMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24gPSBldmVudChjdXIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBudW1EZWJvdW5jZWRDYWxscysrO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSBtZXJnZShvdXRwdXQsIGN1cik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWFkaW5nICYmICFoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXR0ZXIuZmlyZShvdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRvRmlyZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9vdXRwdXQgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxlYWRpbmcgfHwgbnVtRGVib3VuY2VkQ2FsbHMgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1pdHRlci5maXJlKF9vdXRwdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbnVtRGVib3VuY2VkQ2FsbHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBzZXRUaW1lb3V0KGRvRmlyZSwgZGVsYXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzayhkb0ZpcmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25XaWxsUmVtb3ZlTGlzdGVuZXIoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsdXNoT25MaXN0ZW5lclJlbW92ZSAmJiBudW1EZWJvdW5jZWRDYWxscyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZG9GaXJlID09PSBudWxsIHx8IGRvRmlyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZG9GaXJlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyKCkge1xuICAgICAgICAgICAgICAgIGRvRmlyZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoIWRpc3Bvc2FibGUpIHtcbiAgICAgICAgICAgIF9hZGRMZWFrYWdlVHJhY2VMb2dpYyhvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gbmV3IEVtaXR0ZXIob3B0aW9ucyk7XG4gICAgICAgIGRpc3Bvc2FibGUgPT09IG51bGwgfHwgZGlzcG9zYWJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGlzcG9zYWJsZS5hZGQoZW1pdHRlcik7XG4gICAgICAgIHJldHVybiBlbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBFdmVudC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICAgIC8qKlxuICAgICAqIERlYm91bmNlcyBhbiBldmVudCwgZmlyaW5nIGFmdGVyIHNvbWUgZGVsYXkgKGRlZmF1bHQ9MCkgd2l0aCBhbiBhcnJheSBvZiBhbGwgZXZlbnQgb3JpZ2luYWwgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqICpOT1RFKiB0aGF0IHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbiBgRXZlbnRgIGFuZCBpdCBNVVNUIGJlIGNhbGxlZCB3aXRoIGEgYERpc3Bvc2FibGVTdG9yZWAgd2hlbmV2ZXIgdGhlIHJldHVybmVkXG4gICAgICogZXZlbnQgaXMgYWNjZXNzaWJsZSB0byBcInRoaXJkIHBhcnRpZXNcIiwgZS5nIHRoZSBldmVudCBpcyBhIHB1YmxpYyBwcm9wZXJ0eS4gT3RoZXJ3aXNlIGEgbGVha2VkIGxpc3RlbmVyIG9uIHRoZVxuICAgICAqIHJldHVybmVkIGV2ZW50IGNhdXNlcyB0aGlzIHV0aWxpdHkgdG8gbGVhayBhIGxpc3RlbmVyIG9uIHRoZSBvcmlnaW5hbCBldmVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhY2N1bXVsYXRlKGV2ZW50LCBkZWxheSA9IDAsIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgcmV0dXJuIEV2ZW50LmRlYm91bmNlKGV2ZW50LCAobGFzdCwgZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3QucHVzaChlKTtcbiAgICAgICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgICB9LCBkZWxheSwgdW5kZWZpbmVkLCB0cnVlLCB1bmRlZmluZWQsIGRpc3Bvc2FibGUpO1xuICAgIH1cbiAgICBFdmVudC5hY2N1bXVsYXRlID0gYWNjdW11bGF0ZTtcbiAgICAvKipcbiAgICAgKiBGaWx0ZXJzIGFuIGV2ZW50IHN1Y2ggdGhhdCBzb21lIGNvbmRpdGlvbiBpcyBfbm90XyBtZXQgbW9yZSB0aGFuIG9uY2UgaW4gYSByb3csIGVmZmVjdGl2ZWx5IGVuc3VyaW5nIGR1cGxpY2F0ZVxuICAgICAqIGV2ZW50IG9iamVjdHMgZnJvbSBkaWZmZXJlbnQgc291cmNlcyBkbyBub3QgZmlyZSB0aGUgc2FtZSBldmVudCBvYmplY3QuXG4gICAgICpcbiAgICAgKiAqTk9URSogdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYEV2ZW50YCBhbmQgaXQgTVVTVCBiZSBjYWxsZWQgd2l0aCBhIGBEaXNwb3NhYmxlU3RvcmVgIHdoZW5ldmVyIHRoZSByZXR1cm5lZFxuICAgICAqIGV2ZW50IGlzIGFjY2Vzc2libGUgdG8gXCJ0aGlyZCBwYXJ0aWVzXCIsIGUuZyB0aGUgZXZlbnQgaXMgYSBwdWJsaWMgcHJvcGVydHkuIE90aGVyd2lzZSBhIGxlYWtlZCBsaXN0ZW5lciBvbiB0aGVcbiAgICAgKiByZXR1cm5lZCBldmVudCBjYXVzZXMgdGhpcyB1dGlsaXR5IHRvIGxlYWsgYSBsaXN0ZW5lciBvbiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBmb3IgdGhlIG5ldyBldmVudC5cbiAgICAgKiBAcGFyYW0gZXF1YWxzIFRoZSBlcXVhbGl0eSBjb25kaXRpb24uXG4gICAgICogQHBhcmFtIGRpc3Bvc2FibGUgQSBkaXNwb3NhYmxlIHN0b3JlIHRvIGFkZCB0aGUgbmV3IEV2ZW50RW1pdHRlciB0by5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogLy8gRmlyZSBvbmx5IG9uZSB0aW1lIHdoZW4gYSBzaW5nbGUgd2luZG93IGlzIG9wZW5lZCBvciBmb2N1c2VkXG4gICAgICogRXZlbnQubGF0Y2goRXZlbnQuYW55KG9uRGlkT3BlbldpbmRvdywgb25EaWRGb2N1c1dpbmRvdykpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF0Y2goZXZlbnQsIGVxdWFscyA9IChhLCBiKSA9PiBhID09PSBiLCBkaXNwb3NhYmxlKSB7XG4gICAgICAgIGxldCBmaXJzdENhbGwgPSB0cnVlO1xuICAgICAgICBsZXQgY2FjaGU7XG4gICAgICAgIHJldHVybiBmaWx0ZXIoZXZlbnQsIHZhbHVlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEVtaXQgPSBmaXJzdENhbGwgfHwgIWVxdWFscyh2YWx1ZSwgY2FjaGUpO1xuICAgICAgICAgICAgZmlyc3RDYWxsID0gZmFsc2U7XG4gICAgICAgICAgICBjYWNoZSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHNob3VsZEVtaXQ7XG4gICAgICAgIH0sIGRpc3Bvc2FibGUpO1xuICAgIH1cbiAgICBFdmVudC5sYXRjaCA9IGxhdGNoO1xuICAgIC8qKlxuICAgICAqIFNwbGl0cyBhbiBldmVudCB3aG9zZSBwYXJhbWV0ZXIgaXMgYSB1bmlvbiB0eXBlIGludG8gMiBzZXBhcmF0ZSBldmVudHMgZm9yIGVhY2ggdHlwZSBpbiB0aGUgdW5pb24uXG4gICAgICpcbiAgICAgKiAqTk9URSogdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYEV2ZW50YCBhbmQgaXQgTVVTVCBiZSBjYWxsZWQgd2l0aCBhIGBEaXNwb3NhYmxlU3RvcmVgIHdoZW5ldmVyIHRoZSByZXR1cm5lZFxuICAgICAqIGV2ZW50IGlzIGFjY2Vzc2libGUgdG8gXCJ0aGlyZCBwYXJ0aWVzXCIsIGUuZyB0aGUgZXZlbnQgaXMgYSBwdWJsaWMgcHJvcGVydHkuIE90aGVyd2lzZSBhIGxlYWtlZCBsaXN0ZW5lciBvbiB0aGVcbiAgICAgKiByZXR1cm5lZCBldmVudCBjYXVzZXMgdGhpcyB1dGlsaXR5IHRvIGxlYWsgYSBsaXN0ZW5lciBvbiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXIgfCB1bmRlZmluZWQ+KCkuZXZlbnQ7XG4gICAgICogY29uc3QgW251bWJlckV2ZW50LCB1bmRlZmluZWRFdmVudF0gPSBFdmVudC5zcGxpdChldmVudCwgaXNVbmRlZmluZWQpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IFRoZSBldmVudCBzb3VyY2UgZm9yIHRoZSBuZXcgZXZlbnQuXG4gICAgICogQHBhcmFtIGlzVCBBIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyB3aGF0IGV2ZW50IGlzIG9mIHRoZSBmaXJzdCB0eXBlLlxuICAgICAqIEBwYXJhbSBkaXNwb3NhYmxlIEEgZGlzcG9zYWJsZSBzdG9yZSB0byBhZGQgdGhlIG5ldyBFdmVudEVtaXR0ZXIgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3BsaXQoZXZlbnQsIGlzVCwgZGlzcG9zYWJsZSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRXZlbnQuZmlsdGVyKGV2ZW50LCBpc1QsIGRpc3Bvc2FibGUpLFxuICAgICAgICAgICAgRXZlbnQuZmlsdGVyKGV2ZW50LCBlID0+ICFpc1QoZSksIGRpc3Bvc2FibGUpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBFdmVudC5zcGxpdCA9IHNwbGl0O1xuICAgIC8qKlxuICAgICAqIEJ1ZmZlcnMgYW4gZXZlbnQgdW50aWwgaXQgaGFzIGEgbGlzdGVuZXIgYXR0YWNoZWQuXG4gICAgICpcbiAgICAgKiAqTk9URSogdGhhdCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gYEV2ZW50YCBhbmQgaXQgTVVTVCBiZSBjYWxsZWQgd2l0aCBhIGBEaXNwb3NhYmxlU3RvcmVgIHdoZW5ldmVyIHRoZSByZXR1cm5lZFxuICAgICAqIGV2ZW50IGlzIGFjY2Vzc2libGUgdG8gXCJ0aGlyZCBwYXJ0aWVzXCIsIGUuZyB0aGUgZXZlbnQgaXMgYSBwdWJsaWMgcHJvcGVydHkuIE90aGVyd2lzZSBhIGxlYWtlZCBsaXN0ZW5lciBvbiB0aGVcbiAgICAgKiByZXR1cm5lZCBldmVudCBjYXVzZXMgdGhpcyB1dGlsaXR5IHRvIGxlYWsgYSBsaXN0ZW5lciBvbiB0aGUgb3JpZ2luYWwgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBmb3IgdGhlIG5ldyBldmVudC5cbiAgICAgKiBAcGFyYW0gZmx1c2hBZnRlclRpbWVvdXQgRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGZsdXNoIHRoZSBidWZmZXIgYWZ0ZXIgYSB0aW1lb3V0IGltbWVkaWF0ZWx5IG9yIGFmdGVyIGFcbiAgICAgKiBgc2V0VGltZW91dGAgd2hlbiB0aGUgZmlyc3QgZXZlbnQgbGlzdGVuZXIgaXMgYWRkZWQuXG4gICAgICogQHBhcmFtIF9idWZmZXIgSW50ZXJuYWw6IEEgc291cmNlIGV2ZW50IGFycmF5IHVzZWQgZm9yIHRlc3RzLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBTdGFydCBhY2N1bXVsYXRpbmcgZXZlbnRzLCB3aGVuIHRoZSBmaXJzdCBsaXN0ZW5lciBpcyBhdHRhY2hlZCwgZmx1c2hcbiAgICAgKiAvLyB0aGUgZXZlbnQgYWZ0ZXIgYSB0aW1lb3V0IHN1Y2ggdGhhdCBtdWx0aXBsZSBsaXN0ZW5lcnMgYXR0YWNoZWQgYmVmb3JlXG4gICAgICogLy8gdGhlIHRpbWVvdXQgd291bGQgcmVjZWl2ZSB0aGUgZXZlbnRcbiAgICAgKiB0aGlzLm9uSW5zdGFsbEV4dGVuc2lvbiA9IEV2ZW50LmJ1ZmZlcihzZXJ2aWNlLm9uSW5zdGFsbEV4dGVuc2lvbiwgdHJ1ZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gYnVmZmVyKGV2ZW50LCBmbHVzaEFmdGVyVGltZW91dCA9IGZhbHNlLCBfYnVmZmVyID0gW10sIGRpc3Bvc2FibGUpIHtcbiAgICAgICAgbGV0IGJ1ZmZlciA9IF9idWZmZXIuc2xpY2UoKTtcbiAgICAgICAgbGV0IGxpc3RlbmVyID0gZXZlbnQoZSA9PiB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnB1c2goZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbWl0dGVyLmZpcmUoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgZGlzcG9zYWJsZS5hZGQobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsdXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgYnVmZmVyID09PSBudWxsIHx8IGJ1ZmZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnVmZmVyLmZvckVhY2goZSA9PiBlbWl0dGVyLmZpcmUoZSkpO1xuICAgICAgICAgICAgYnVmZmVyID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcbiAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGV2ZW50KGUgPT4gZW1pdHRlci5maXJlKGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3Bvc2FibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FibGUuYWRkKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRpZEFkZEZpcnN0TGlzdGVuZXIoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmx1c2hBZnRlclRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRpZFJlbW92ZUxhc3RMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZGlzcG9zYWJsZSkge1xuICAgICAgICAgICAgZGlzcG9zYWJsZS5hZGQoZW1pdHRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIEV2ZW50LmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAvKipcbiAgICAgKiBXcmFwcyB0aGUgZXZlbnQgaW4gYW4ge0BsaW5rIElDaGFpbmFibGVFdmVudH0sIGFsbG93aW5nIGEgbW9yZSBmdW5jdGlvbmFsIHByb2dyYW1taW5nIHN0eWxlLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiAvLyBOb3JtYWxcbiAgICAgKiBjb25zdCBvbkVudGVyUHJlc3NOb3JtYWwgPSBFdmVudC5maWx0ZXIoXG4gICAgICogICBFdmVudC5tYXAob25LZXlQcmVzcy5ldmVudCwgZSA9PiBuZXcgU3RhbmRhcmRLZXlib2FyZEV2ZW50KGUpKSxcbiAgICAgKiAgIGUua2V5Q29kZSA9PT0gS2V5Q29kZS5FbnRlclxuICAgICAqICkuZXZlbnQ7XG4gICAgICpcbiAgICAgKiAvLyBVc2luZyBjaGFpblxuICAgICAqIGNvbnN0IG9uRW50ZXJQcmVzc0NoYWluID0gRXZlbnQuY2hhaW4ob25LZXlQcmVzcy5ldmVudCwgJCA9PiAkXG4gICAgICogICAubWFwKGUgPT4gbmV3IFN0YW5kYXJkS2V5Ym9hcmRFdmVudChlKSlcbiAgICAgKiAgIC5maWx0ZXIoZSA9PiBlLmtleUNvZGUgPT09IEtleUNvZGUuRW50ZXIpXG4gICAgICogKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbihldmVudCwgc3l0aGVuc2l6ZSkge1xuICAgICAgICBjb25zdCBmbiA9IChsaXN0ZW5lciwgdGhpc0FyZ3MsIGRpc3Bvc2FibGVzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjcyA9IHN5dGhlbnNpemUobmV3IENoYWluYWJsZVN5bnRoZXNpcygpKTtcbiAgICAgICAgICAgIHJldHVybiBldmVudChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjcy5ldmFsdWF0ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gSGFsdENoYWluYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZCwgZGlzcG9zYWJsZXMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm47XG4gICAgfVxuICAgIEV2ZW50LmNoYWluID0gY2hhaW47XG4gICAgY29uc3QgSGFsdENoYWluYWJsZSA9IFN5bWJvbCgnSGFsdENoYWluYWJsZScpO1xuICAgIGNsYXNzIENoYWluYWJsZVN5bnRoZXNpcyB7XG4gICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIG1hcChmbikge1xuICAgICAgICAgICAgdGhpcy5zdGVwcy5wdXNoKGZuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZvckVhY2goZm4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RlcHMucHVzaCh2ID0+IHtcbiAgICAgICAgICAgICAgICBmbih2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyKGZuKSB7XG4gICAgICAgICAgICB0aGlzLnN0ZXBzLnB1c2godiA9PiBmbih2KSA/IHYgOiBIYWx0Q2hhaW5hYmxlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJlZHVjZShtZXJnZSwgaW5pdGlhbCkge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpbml0aWFsO1xuICAgICAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHYgPT4ge1xuICAgICAgICAgICAgICAgIGxhc3QgPSBtZXJnZShsYXN0LCB2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgbGF0Y2goZXF1YWxzID0gKGEsIGIpID0+IGEgPT09IGIpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdENhbGwgPSB0cnVlO1xuICAgICAgICAgICAgbGV0IGNhY2hlO1xuICAgICAgICAgICAgdGhpcy5zdGVwcy5wdXNoKHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRFbWl0ID0gZmlyc3RDYWxsIHx8ICFlcXVhbHModmFsdWUsIGNhY2hlKTtcbiAgICAgICAgICAgICAgICBmaXJzdENhbGwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjYWNoZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaG91bGRFbWl0ID8gdmFsdWUgOiBIYWx0Q2hhaW5hYmxlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBldmFsdWF0ZSh2YWx1ZSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIHRoaXMuc3RlcHMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0ZXAodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSGFsdENoYWluYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiB7QGxpbmsgRXZlbnR9IGZyb20gYSBub2RlIGV2ZW50IGVtaXR0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbU5vZGVFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXZlbnROYW1lLCBtYXAgPSBpZCA9PiBpZCkge1xuICAgICAgICBjb25zdCBmbiA9ICguLi5hcmdzKSA9PiByZXN1bHQuZmlyZShtYXAoLi4uYXJncykpO1xuICAgICAgICBjb25zdCBvbkZpcnN0TGlzdGVuZXJBZGQgPSAoKSA9PiBlbWl0dGVyLm9uKGV2ZW50TmFtZSwgZm4pO1xuICAgICAgICBjb25zdCBvbkxhc3RMaXN0ZW5lclJlbW92ZSA9ICgpID0+IGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBmbik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBFbWl0dGVyKHsgb25XaWxsQWRkRmlyc3RMaXN0ZW5lcjogb25GaXJzdExpc3RlbmVyQWRkLCBvbkRpZFJlbW92ZUxhc3RMaXN0ZW5lcjogb25MYXN0TGlzdGVuZXJSZW1vdmUgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuZXZlbnQ7XG4gICAgfVxuICAgIEV2ZW50LmZyb21Ob2RlRXZlbnRFbWl0dGVyID0gZnJvbU5vZGVFdmVudEVtaXR0ZXI7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiB7QGxpbmsgRXZlbnR9IGZyb20gYSBET00gZXZlbnQgZW1pdHRlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmcm9tRE9NRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGV2ZW50TmFtZSwgbWFwID0gaWQgPT4gaWQpIHtcbiAgICAgICAgY29uc3QgZm4gPSAoLi4uYXJncykgPT4gcmVzdWx0LmZpcmUobWFwKC4uLmFyZ3MpKTtcbiAgICAgICAgY29uc3Qgb25GaXJzdExpc3RlbmVyQWRkID0gKCkgPT4gZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgZm4pO1xuICAgICAgICBjb25zdCBvbkxhc3RMaXN0ZW5lclJlbW92ZSA9ICgpID0+IGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGZuKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEVtaXR0ZXIoeyBvbldpbGxBZGRGaXJzdExpc3RlbmVyOiBvbkZpcnN0TGlzdGVuZXJBZGQsIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyOiBvbkxhc3RMaXN0ZW5lclJlbW92ZSB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5ldmVudDtcbiAgICB9XG4gICAgRXZlbnQuZnJvbURPTUV2ZW50RW1pdHRlciA9IGZyb21ET01FdmVudEVtaXR0ZXI7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHByb21pc2Ugb3V0IG9mIGFuIGV2ZW50LCB1c2luZyB0aGUge0BsaW5rIEV2ZW50Lm9uY2V9IGhlbHBlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1Byb21pc2UoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gb25jZShldmVudCkocmVzb2x2ZSkpO1xuICAgIH1cbiAgICBFdmVudC50b1Byb21pc2UgPSB0b1Byb21pc2U7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBldmVudCBvdXQgb2YgYSBwcm9taXNlIHRoYXQgZmlyZXMgb25jZSB3aGVuIHRoZSBwcm9taXNlIGlzXG4gICAgICogcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0IG9mIHRoZSBwcm9taXNlIG9yIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21Qcm9taXNlKHByb21pc2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgcHJvbWlzZS50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICByZXN1bHQuZmlyZShyZXMpO1xuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICByZXN1bHQuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0LmV2ZW50O1xuICAgIH1cbiAgICBFdmVudC5mcm9tUHJvbWlzZSA9IGZyb21Qcm9taXNlO1xuICAgIGZ1bmN0aW9uIHJ1bkFuZFN1YnNjcmliZShldmVudCwgaGFuZGxlciwgaW5pdGlhbCkge1xuICAgICAgICBoYW5kbGVyKGluaXRpYWwpO1xuICAgICAgICByZXR1cm4gZXZlbnQoZSA9PiBoYW5kbGVyKGUpKTtcbiAgICB9XG4gICAgRXZlbnQucnVuQW5kU3Vic2NyaWJlID0gcnVuQW5kU3Vic2NyaWJlO1xuICAgIGNsYXNzIEVtaXR0ZXJPYnNlcnZlciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKF9vYnNlcnZhYmxlLCBzdG9yZSkge1xuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZSA9IF9vYnNlcnZhYmxlO1xuICAgICAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgICAgICB0aGlzLl9oYXNDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXI6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgX29ic2VydmFibGUuYWRkT2JzZXJ2ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkRpZFJlbW92ZUxhc3RMaXN0ZW5lcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBfb2JzZXJ2YWJsZS5yZW1vdmVPYnNlcnZlcih0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCFzdG9yZSkge1xuICAgICAgICAgICAgICAgIF9hZGRMZWFrYWdlVHJhY2VMb2dpYyhvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuYWRkKHRoaXMuZW1pdHRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYmVnaW5VcGRhdGUoX29ic2VydmFibGUpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydChfb2JzZXJ2YWJsZSA9PT0gdGhpcy5vYnMpO1xuICAgICAgICAgICAgdGhpcy5fY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVBvc3NpYmxlQ2hhbmdlKF9vYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAvLyBhc3NlcnQoX29ic2VydmFibGUgPT09IHRoaXMub2JzKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVDaGFuZ2UoX29ic2VydmFibGUsIF9jaGFuZ2UpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydChfb2JzZXJ2YWJsZSA9PT0gdGhpcy5vYnMpO1xuICAgICAgICAgICAgdGhpcy5faGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZW5kVXBkYXRlKF9vYnNlcnZhYmxlKSB7XG4gICAgICAgICAgICAvLyBhc3NlcnQoX29ic2VydmFibGUgPT09IHRoaXMub2JzKTtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50ZXItLTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudGVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2YWJsZS5yZXBvcnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXR0ZXIuZmlyZSh0aGlzLl9vYnNlcnZhYmxlLmdldCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBldmVudCBlbWl0dGVyIHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgb2JzZXJ2YWJsZSBjaGFuZ2VzLlxuICAgICAqIEVhY2ggbGlzdGVuZXJzIHN1YnNjcmliZXMgdG8gdGhlIGVtaXR0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbU9ic2VydmFibGUob2JzLCBzdG9yZSkge1xuICAgICAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBFbWl0dGVyT2JzZXJ2ZXIob2JzLCBzdG9yZSk7XG4gICAgICAgIHJldHVybiBvYnNlcnZlci5lbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBFdmVudC5mcm9tT2JzZXJ2YWJsZSA9IGZyb21PYnNlcnZhYmxlO1xuICAgIC8qKlxuICAgICAqIEVhY2ggbGlzdGVuZXIgaXMgYXR0YWNoZWQgdG8gdGhlIG9ic2VydmFibGUgZGlyZWN0bHkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbU9ic2VydmFibGVMaWdodChvYnNlcnZhYmxlKSB7XG4gICAgICAgIHJldHVybiAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIGxldCBkaWRDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0ge1xuICAgICAgICAgICAgICAgIGJlZ2luVXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kVXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUucmVwb3J0Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpZENoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBoYW5kbGVQb3NzaWJsZUNoYW5nZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9vcFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGFuZGxlQ2hhbmdlKCkge1xuICAgICAgICAgICAgICAgICAgICBkaWRDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvYnNlcnZhYmxlLmFkZE9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgICAgIG9ic2VydmFibGUucmVwb3J0Q2hhbmdlcygpO1xuICAgICAgICAgICAgY29uc3QgZGlzcG9zYWJsZSA9IHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlKCkge1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlLnJlbW92ZU9ic2VydmVyKG9ic2VydmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRpc3Bvc2FibGVzIGluc3RhbmNlb2YgRGlzcG9zYWJsZVN0b3JlKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMuYWRkKGRpc3Bvc2FibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShkaXNwb3NhYmxlcykpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKGRpc3Bvc2FibGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpc3Bvc2FibGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIEV2ZW50LmZyb21PYnNlcnZhYmxlTGlnaHQgPSBmcm9tT2JzZXJ2YWJsZUxpZ2h0O1xufSkoRXZlbnQgfHwgKEV2ZW50ID0ge30pKTtcbmV4cG9ydCBjbGFzcyBFdmVudFByb2ZpbGluZyB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmludm9jYXRpb25Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuZWxhcHNlZE92ZXJhbGwgPSAwO1xuICAgICAgICB0aGlzLmR1cmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLm5hbWUgPSBgJHtuYW1lfV8ke0V2ZW50UHJvZmlsaW5nLl9pZFBvb2wrK31gO1xuICAgICAgICBFdmVudFByb2ZpbGluZy5hbGwuYWRkKHRoaXMpO1xuICAgIH1cbiAgICBzdGFydChsaXN0ZW5lckNvdW50KSB7XG4gICAgICAgIHRoaXMuX3N0b3BXYXRjaCA9IG5ldyBTdG9wV2F0Y2goKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BXYXRjaCkge1xuICAgICAgICAgICAgY29uc3QgZWxhcHNlZCA9IHRoaXMuX3N0b3BXYXRjaC5lbGFwc2VkKCk7XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9ucy5wdXNoKGVsYXBzZWQpO1xuICAgICAgICAgICAgdGhpcy5lbGFwc2VkT3ZlcmFsbCArPSBlbGFwc2VkO1xuICAgICAgICAgICAgdGhpcy5pbnZvY2F0aW9uQ291bnQgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuX3N0b3BXYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbkV2ZW50UHJvZmlsaW5nLmFsbCA9IG5ldyBTZXQoKTtcbkV2ZW50UHJvZmlsaW5nLl9pZFBvb2wgPSAwO1xubGV0IF9nbG9iYWxMZWFrV2FybmluZ1RocmVzaG9sZCA9IC0xO1xuY2xhc3MgTGVha2FnZU1vbml0b3Ige1xuICAgIGNvbnN0cnVjdG9yKF9lcnJvckhhbmRsZXIsIHRocmVzaG9sZCwgbmFtZSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMTgpLnNsaWNlKDIsIDUpKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ySGFuZGxlciA9IF9lcnJvckhhbmRsZXI7XG4gICAgICAgIHRoaXMudGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLl93YXJuQ291bnRkb3duID0gMDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLl9zdGFja3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGVhcigpO1xuICAgIH1cbiAgICBjaGVjayhzdGFjaywgbGlzdGVuZXJDb3VudCkge1xuICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLnRocmVzaG9sZDtcbiAgICAgICAgaWYgKHRocmVzaG9sZCA8PSAwIHx8IGxpc3RlbmVyQ291bnQgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9zdGFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb3VudCA9ICh0aGlzLl9zdGFja3MuZ2V0KHN0YWNrLnZhbHVlKSB8fCAwKTtcbiAgICAgICAgdGhpcy5fc3RhY2tzLnNldChzdGFjay52YWx1ZSwgY291bnQgKyAxKTtcbiAgICAgICAgdGhpcy5fd2FybkNvdW50ZG93biAtPSAxO1xuICAgICAgICBpZiAodGhpcy5fd2FybkNvdW50ZG93biA8PSAwKSB7XG4gICAgICAgICAgICAvLyBvbmx5IHdhcm4gb24gZmlyc3QgZXhjZWVkIGFuZCB0aGVuIGV2ZXJ5IHRpbWUgdGhlIGxpbWl0XG4gICAgICAgICAgICAvLyBpcyBleGNlZWRlZCBieSA1MCUgYWdhaW5cbiAgICAgICAgICAgIHRoaXMuX3dhcm5Db3VudGRvd24gPSB0aHJlc2hvbGQgKiAwLjU7XG4gICAgICAgICAgICBjb25zdCBbdG9wU3RhY2ssIHRvcENvdW50XSA9IHRoaXMuZ2V0TW9zdEZyZXF1ZW50U3RhY2soKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgWyR7dGhpcy5uYW1lfV0gcG90ZW50aWFsIGxpc3RlbmVyIExFQUsgZGV0ZWN0ZWQsIGhhdmluZyAke2xpc3RlbmVyQ291bnR9IGxpc3RlbmVycyBhbHJlYWR5LiBNT1NUIGZyZXF1ZW50IGxpc3RlbmVyICgke3RvcENvdW50fSk6YDtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybih0b3BTdGFjayk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBMaXN0ZW5lckxlYWtFcnJvcihtZXNzYWdlLCB0b3BTdGFjayk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvckhhbmRsZXIoZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb3VudCA9ICh0aGlzLl9zdGFja3MuZ2V0KHN0YWNrLnZhbHVlKSB8fCAwKTtcbiAgICAgICAgICAgIHRoaXMuX3N0YWNrcy5zZXQoc3RhY2sudmFsdWUsIGNvdW50IC0gMSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldE1vc3RGcmVxdWVudFN0YWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3N0YWNrcykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG9wU3RhY2s7XG4gICAgICAgIGxldCB0b3BDb3VudCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgW3N0YWNrLCBjb3VudF0gb2YgdGhpcy5fc3RhY2tzKSB7XG4gICAgICAgICAgICBpZiAoIXRvcFN0YWNrIHx8IHRvcENvdW50IDwgY291bnQpIHtcbiAgICAgICAgICAgICAgICB0b3BTdGFjayA9IFtzdGFjaywgY291bnRdO1xuICAgICAgICAgICAgICAgIHRvcENvdW50ID0gY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcFN0YWNrO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrdHJhY2Uge1xuICAgIHN0YXRpYyBjcmVhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2t0cmFjZSgoX2EgPSBlcnIuc3RhY2spICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBwcmludCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKHRoaXMudmFsdWUuc3BsaXQoJ1xcbicpLnNsaWNlKDIpLmpvaW4oJ1xcbicpKTtcbiAgICB9XG59XG4vLyBlcnJvciB0aGF0IGlzIGxvZ2dlZCB3aGVuIGdvaW5nIG92ZXIgdGhlIGNvbmZpZ3VyZWQgbGlzdGVuZXIgdGhyZXNob2xkXG5leHBvcnQgY2xhc3MgTGlzdGVuZXJMZWFrRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhY2spIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdMaXN0ZW5lckxlYWtFcnJvcic7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBzdGFjaztcbiAgICB9XG59XG4vLyBTRVZFUkUgZXJyb3IgdGhhdCBpcyBsb2dnZWQgd2hlbiBoYXZpbmcgZ29uZSB3YXkgb3ZlciB0aGUgY29uZmlndXJlZCBsaXN0ZW5lclxuLy8gdGhyZXNob2xkIHNvIHRoYXQgdGhlIGVtaXR0ZXIgcmVmdXNlcyB0byBhY2NlcHQgbW9yZSBsaXN0ZW5lcnNcbmV4cG9ydCBjbGFzcyBMaXN0ZW5lclJlZnVzYWxFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGFjaykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0xpc3RlbmVyUmVmdXNhbEVycm9yJztcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgIH1cbn1cbmNsYXNzIFVuaXF1ZUNvbnRhaW5lciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbmNvbnN0IGNvbXBhY3Rpb25UaHJlc2hvbGQgPSAyO1xuY29uc3QgZm9yRWFjaExpc3RlbmVyID0gKGxpc3RlbmVycywgZm4pID0+IHtcbiAgICBpZiAobGlzdGVuZXJzIGluc3RhbmNlb2YgVW5pcXVlQ29udGFpbmVyKSB7XG4gICAgICAgIGZuKGxpc3RlbmVycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbCA9IGxpc3RlbmVyc1tpXTtcbiAgICAgICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgICAgICAgZm4obCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgX2xpc3RlbmVyRmluYWxpemVycyA9IF9lbmFibGVMaXN0ZW5lckdDZWRXYXJuaW5nXG4gICAgPyBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoaGVsZFZhbHVlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBoZWxkVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1tMRUFLSU5HIExJU1RFTkVSXSBHQ1xcJ2VkIGEgbGlzdGVuZXIgdGhhdCB3YXMgTk9UIHlldCBkaXNwb3NlZC4gVGhpcyBpcyB3aGVyZSBpcyB3YXMgY3JlYXRlZDonKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihoZWxkVmFsdWUpO1xuICAgICAgICB9XG4gICAgfSlcbiAgICA6IHVuZGVmaW5lZDtcbi8qKlxuICogVGhlIEVtaXR0ZXIgY2FuIGJlIHVzZWQgdG8gZXhwb3NlIGFuIEV2ZW50IHRvIHRoZSBwdWJsaWNcbiAqIHRvIGZpcmUgaXQgZnJvbSB0aGUgaW5zaWRlcy5cbiAqIFNhbXBsZTpcbiAgICBjbGFzcyBEb2N1bWVudCB7XG5cbiAgICAgICAgcHJpdmF0ZSByZWFkb25seSBfb25EaWRDaGFuZ2UgPSBuZXcgRW1pdHRlcjwodmFsdWU6c3RyaW5nKT0+YW55PigpO1xuXG4gICAgICAgIHB1YmxpYyBvbkRpZENoYW5nZSA9IHRoaXMuX29uRGlkQ2hhbmdlLmV2ZW50O1xuXG4gICAgICAgIC8vIGdldHRlci1zdHlsZVxuICAgICAgICAvLyBnZXQgb25EaWRDaGFuZ2UoKTogRXZlbnQ8KHZhbHVlOnN0cmluZyk9PmFueT4ge1xuICAgICAgICAvLyBcdHJldHVybiB0aGlzLl9vbkRpZENoYW5nZS5ldmVudDtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIHByaXZhdGUgX2RvSXQoKSB7XG4gICAgICAgICAgICAvLy4uLlxuICAgICAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2UuZmlyZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gKi9cbmV4cG9ydCBjbGFzcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2xlYWthZ2VNb24gPSAoX2dsb2JhbExlYWtXYXJuaW5nVGhyZXNob2xkID4gMCB8fCAoKF9hID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlYWtXYXJuaW5nVGhyZXNob2xkKSlcbiAgICAgICAgICAgID8gbmV3IExlYWthZ2VNb25pdG9yKChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vbkxpc3RlbmVyRXJyb3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG9uVW5leHBlY3RlZEVycm9yLCAoX2QgPSAoX2MgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubGVha1dhcm5pbmdUaHJlc2hvbGQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IF9nbG9iYWxMZWFrV2FybmluZ1RocmVzaG9sZCkgOlxuICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9wZXJmTW9uID0gKChfZSA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5fcHJvZk5hbWUpID8gbmV3IEV2ZW50UHJvZmlsaW5nKHRoaXMuX29wdGlvbnMuX3Byb2ZOYW1lKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZGVsaXZlcnlRdWV1ZSA9IChfZiA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5kZWxpdmVyeVF1ZXVlO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICghdGhpcy5fZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIEl0IGlzIGJhZCB0byBoYXZlIGxpc3RlbmVycyBhdCB0aGUgdGltZSBvZiBkaXNwb3NpbmcgYW4gZW1pdHRlciwgaXQgaXMgd29yc3QgdG8gaGF2ZSBsaXN0ZW5lcnMga2VlcCB0aGUgZW1pdHRlclxuICAgICAgICAgICAgLy8gYWxpdmUgdmlhIHRoZSByZWZlcmVuY2UgdGhhdCdzIGVtYmVkZGVkIGluIHRoZWlyIGRpc3Bvc2FibGVzLiBUaGVyZWZvcmUgd2UgbG9vcCBvdmVyIGFsbCByZW1haW5pbmcgbGlzdGVuZXJzIGFuZFxuICAgICAgICAgICAgLy8gdW5zZXQgdGhlaXIgc3Vic2NyaXB0aW9ucy9kaXNwb3NhYmxlcy4gTG9vcGluZyBhbmQgYmxhbWluZyByZW1haW5pbmcgbGlzdGVuZXJzIGlzIGRvbmUgb24gbmV4dCB0aWNrIGJlY2F1c2UgdGhlXG4gICAgICAgICAgICAvLyB0aGUgZm9sbG93aW5nIHByb2dyYW1taW5nIHBhdHRlcm4gaXMgdmVyeSBwb3B1bGFyOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGNvbnN0IHNvbWVNb2RlbCA9IHRoaXMuX2Rpc3Bvc2FibGVzLmFkZChuZXcgTW9kZWxPYmplY3QoKSk7IC8vICgxKSBjcmVhdGUgYW5kIHJlZ2lzdGVyIG1vZGVsXG4gICAgICAgICAgICAvLyB0aGlzLl9kaXNwb3NhYmxlcy5hZGQoc29tZU1vZGVsLm9uRGlkQ2hhbmdlKCgpID0+IHsgLi4uIH0pOyAvLyAoMikgc3Vic2NyaWJlIGFuZCByZWdpc3RlciBtb2RlbC1ldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgLy8gLi4ubGF0ZXIuLi5cbiAgICAgICAgICAgIC8vIHRoaXMuX2Rpc3Bvc2FibGVzLmRpc3Bvc2UoKTsgZGlzcG9zZXMgKDEpIHRoZW4gKDIpOiBkb24ndCB3YXJuIGFmdGVyICgxKSBidXQgYWZ0ZXIgdGhlIFwib3ZlcmFsbCBkaXNwb3NlXCIgaXMgZG9uZVxuICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9kZWxpdmVyeVF1ZXVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudCkgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWxpdmVyeVF1ZXVlLnJlc2V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9lbmFibGVEaXNwb3NlV2l0aExpc3RlbmVyV2FybmluZykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2hMaXN0ZW5lcihsaXN0ZW5lcnMsIGwgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBsLnN0YWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJpbnQoKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAoX2MgPSAoX2IgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iub25EaWRSZW1vdmVMYXN0TGlzdGVuZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKTtcbiAgICAgICAgICAgIChfZCA9IHRoaXMuX2xlYWthZ2VNb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIHRoZSBwdWJsaWMgdG8gYWxsb3cgdG8gc3Vic2NyaWJlXG4gICAgICogdG8gZXZlbnRzIGZyb20gdGhpcyBFbWl0dGVyXG4gICAgICovXG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMuX2V2ZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5fZXZlbnQgPSAoY2FsbGJhY2ssIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xlYWthZ2VNb24gJiYgdGhpcy5fc2l6ZSA+IHRoaXMuX2xlYWthZ2VNb24udGhyZXNob2xkICoqIDIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYFske3RoaXMuX2xlYWthZ2VNb24ubmFtZX1dIFJFRlVTRVMgdG8gYWNjZXB0IG5ldyBsaXN0ZW5lcnMgYmVjYXVzZSBpdCBleGNlZWRlZCBpdHMgdGhyZXNob2xkIGJ5IGZhciAoJHt0aGlzLl9zaXplfSB2cyAke3RoaXMuX2xlYWthZ2VNb24udGhyZXNob2xkfSlgO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0dXBsZSA9IChfYSA9IHRoaXMuX2xlYWthZ2VNb24uZ2V0TW9zdEZyZXF1ZW50U3RhY2soKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogWydVTktOT1dOIHN0YWNrJywgLTFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IExpc3RlbmVyUmVmdXNhbEVycm9yKGAke21lc3NhZ2V9LiBISU5UOiBTdGFjayBzaG93cyBtb3N0IGZyZXF1ZW50IGxpc3RlbmVyICgke3R1cGxlWzFdfS10aW1lcylgLCB0dXBsZVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKChfYiA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vbkxpc3RlbmVyRXJyb3IpIHx8IG9uVW5leHBlY3RlZEVycm9yO1xuICAgICAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIERpc3Bvc2FibGUuTm9uZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9kaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIC8vIHRvZG86IHNob3VsZCB3ZSB3YXJuIGlmIGEgbGlzdGVuZXIgaXMgYWRkZWQgdG8gYSBkaXNwb3NlZCBlbWl0dGVyPyBUaGlzIGhhcHBlbnMgb2Z0ZW5cbiAgICAgICAgICAgICAgICByZXR1cm4gRGlzcG9zYWJsZS5Ob25lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXNBcmdzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjay5iaW5kKHRoaXNBcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lZCA9IG5ldyBVbmlxdWVDb250YWluZXIoY2FsbGJhY2spO1xuICAgICAgICAgICAgbGV0IHJlbW92ZU1vbml0b3I7XG4gICAgICAgICAgICBsZXQgc3RhY2s7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGVha2FnZU1vbiAmJiB0aGlzLl9zaXplID49IE1hdGguY2VpbCh0aGlzLl9sZWFrYWdlTW9uLnRocmVzaG9sZCAqIDAuMikpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBhbmQgcmVjb3JkIHRoaXMgZW1pdHRlciBmb3IgcG90ZW50aWFsIGxlYWthZ2VcbiAgICAgICAgICAgICAgICBjb250YWluZWQuc3RhY2sgPSBTdGFja3RyYWNlLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgIHJlbW92ZU1vbml0b3IgPSB0aGlzLl9sZWFrYWdlTW9uLmNoZWNrKGNvbnRhaW5lZC5zdGFjaywgdGhpcy5fc2l6ZSArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9lbmFibGVEaXNwb3NlV2l0aExpc3RlbmVyV2FybmluZykge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lZC5zdGFjayA9IHN0YWNrICE9PSBudWxsICYmIHN0YWNrICE9PSB2b2lkIDAgPyBzdGFjayA6IFN0YWNrdHJhY2UuY3JlYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIChfZCA9IChfYyA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5vbldpbGxBZGRGaXJzdExpc3RlbmVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gY29udGFpbmVkO1xuICAgICAgICAgICAgICAgIChfZiA9IChfZSA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5vbkRpZEFkZEZpcnN0TGlzdGVuZXIpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2xpc3RlbmVycyBpbnN0YW5jZW9mIFVuaXF1ZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgICAgIChfZyA9IHRoaXMuX2RlbGl2ZXJ5UXVldWUpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6ICh0aGlzLl9kZWxpdmVyeVF1ZXVlID0gbmV3IEV2ZW50RGVsaXZlcnlRdWV1ZVByaXZhdGUoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW3RoaXMuX2xpc3RlbmVycywgY29udGFpbmVkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGNvbnRhaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zaXplKys7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0b0Rpc3Bvc2FibGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIF9saXN0ZW5lckZpbmFsaXplcnMgPT09IG51bGwgfHwgX2xpc3RlbmVyRmluYWxpemVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2xpc3RlbmVyRmluYWxpemVycy51bnJlZ2lzdGVyKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlTW9uaXRvciA9PT0gbnVsbCB8fCByZW1vdmVNb25pdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW1vdmVNb25pdG9yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIoY29udGFpbmVkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGRpc3Bvc2FibGVzIGluc3RhbmNlb2YgRGlzcG9zYWJsZVN0b3JlKSB7XG4gICAgICAgICAgICAgICAgZGlzcG9zYWJsZXMuYWRkKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2FibGVzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfbGlzdGVuZXJGaW5hbGl6ZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjay5zcGxpdCgnXFxuJykuc2xpY2UoMikuam9pbignXFxuJykudHJpbSgpO1xuICAgICAgICAgICAgICAgIF9saXN0ZW5lckZpbmFsaXplcnMucmVnaXN0ZXIocmVzdWx0LCBzdGFjaywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnQ7XG4gICAgfVxuICAgIF9yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIChfYiA9IChfYSA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbldpbGxSZW1vdmVMaXN0ZW5lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBleHBlY3RlZCBpZiBhIGxpc3RlbmVyIGdldHMgZGlzcG9zZWRcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgKF9kID0gKF9jID0gdGhpcy5fb3B0aW9ucykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLm9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaXplID4gMSB3aGljaCByZXF1aXJlcyB0aGF0IGxpc3RlbmVycyBiZSBhIGxpc3Q6XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcbiAgICAgICAgY29uc3QgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdkaXNwb3NlZD8nLCB0aGlzLl9kaXNwb3NlZCk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnc2l6ZT8nLCB0aGlzLl9zaXplKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdhcnI/JywgSlNPTi5zdHJpbmdpZnkodGhpcy5fbGlzdGVuZXJzKSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byBkaXNwb3NlIHVua25vd24gbGlzdGVuZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zaXplLS07XG4gICAgICAgIGxpc3RlbmVyc1tpbmRleF0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGFkanVzdERlbGl2ZXJ5UXVldWUgPSB0aGlzLl9kZWxpdmVyeVF1ZXVlLmN1cnJlbnQgPT09IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9zaXplICogY29tcGFjdGlvblRocmVzaG9sZCA8PSBsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzW24rK10gPSBsaXN0ZW5lcnNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFkanVzdERlbGl2ZXJ5UXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGVsaXZlcnlRdWV1ZS5lbmQtLTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG4gPCB0aGlzLl9kZWxpdmVyeVF1ZXVlLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlbGl2ZXJ5UXVldWUuaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdGVuZXJzLmxlbmd0aCA9IG47XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2RlbGl2ZXIobGlzdGVuZXIsIHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9ICgoX2EgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub25MaXN0ZW5lckVycm9yKSB8fCBvblVuZXhwZWN0ZWRFcnJvcjtcbiAgICAgICAgaWYgKCFlcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnZhbHVlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGlzdGVuZXIudmFsdWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIERlbGl2ZXJzIGl0ZW1zIGluIHRoZSBxdWV1ZS4gQXNzdW1lcyB0aGUgcXVldWUgaXMgcmVhZHkgdG8gZ28uICovXG4gICAgX2RlbGl2ZXJRdWV1ZShkcSkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSBkcS5jdXJyZW50Ll9saXN0ZW5lcnM7XG4gICAgICAgIHdoaWxlIChkcS5pIDwgZHEuZW5kKSB7XG4gICAgICAgICAgICAvLyBpbXBvcnRhbnQ6IGRxLmkgaXMgaW5jcmVtZW50ZWQgYmVmb3JlIGNhbGxpbmcgZGVsaXZlcigpIGJlY2F1c2UgaXQgbWlnaHQgcmVlbnRlciBkZWxpdmVyUXVldWUoKVxuICAgICAgICAgICAgdGhpcy5fZGVsaXZlcihsaXN0ZW5lcnNbZHEuaSsrXSwgZHEudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGRxLnJlc2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIGtlcHQgcHJpdmF0ZSB0byBmaXJlIGFuIGV2ZW50IHRvXG4gICAgICogc3Vic2NyaWJlcnNcbiAgICAgKi9cbiAgICBmaXJlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuX2RlbGl2ZXJ5UXVldWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9kZWxpdmVyUXVldWUodGhpcy5fZGVsaXZlcnlRdWV1ZSk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLl9wZXJmTW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3RvcCgpOyAvLyBsYXN0IGZpcmUoKSB3aWxsIGhhdmUgc3RhcnRpbmcgcGVyZm1vbiwgc3RvcCBpdCBiZWZvcmUgc3RhcnRpbmcgdGhlIG5leHQgZGlzcGF0Y2hcbiAgICAgICAgfVxuICAgICAgICAoX2MgPSB0aGlzLl9wZXJmTW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RhcnQodGhpcy5fc2l6ZSk7XG4gICAgICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2xpc3RlbmVycyBpbnN0YW5jZW9mIFVuaXF1ZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fZGVsaXZlcih0aGlzLl9saXN0ZW5lcnMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRxID0gdGhpcy5fZGVsaXZlcnlRdWV1ZTtcbiAgICAgICAgICAgIGRxLmVucXVldWUodGhpcywgZXZlbnQsIHRoaXMuX2xpc3RlbmVycy5sZW5ndGgpO1xuICAgICAgICAgICAgdGhpcy5fZGVsaXZlclF1ZXVlKGRxKTtcbiAgICAgICAgfVxuICAgICAgICAoX2QgPSB0aGlzLl9wZXJmTW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc3RvcCgpO1xuICAgIH1cbiAgICBoYXNMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplID4gMDtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgY3JlYXRlRXZlbnREZWxpdmVyeVF1ZXVlID0gKCkgPT4gbmV3IEV2ZW50RGVsaXZlcnlRdWV1ZVByaXZhdGUoKTtcbmNsYXNzIEV2ZW50RGVsaXZlcnlRdWV1ZVByaXZhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5kZXggaW4gY3VycmVudCdzIGxpc3RlbmVyIGxpc3QuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmkgPSAtMTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXN0IGluZGV4IGluIHRoZSBsaXN0ZW5lcidzIGxpc3QgdG8gZGVsaXZlci5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZW5kID0gMDtcbiAgICB9XG4gICAgZW5xdWV1ZShlbWl0dGVyLCB2YWx1ZSwgZW5kKSB7XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgICAgIHRoaXMuZW5kID0gZW5kO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBlbWl0dGVyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmkgPSB0aGlzLmVuZDsgLy8gZm9yY2UgYW55IGN1cnJlbnQgZW1pc3Npb24gbG9vcCB0byBzdG9wLCBtYWlubHkgZm9yIGR1cmluZyBkaXNwb3NlXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUGF1c2VhYmxlRW1pdHRlciBleHRlbmRzIEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gMDtcbiAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gICAgICAgIHRoaXMuX21lcmdlRm4gPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVyZ2U7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLl9pc1BhdXNlZCsrO1xuICAgIH1cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCAhPT0gMCAmJiAtLXRoaXMuX2lzUGF1c2VkID09PSAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWVyZ2VGbikge1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgbWVyZ2UgZnVuY3Rpb24gdG8gY3JlYXRlIGEgc2luZ2xlIGNvbXBvc2l0ZVxuICAgICAgICAgICAgICAgIC8vIGV2ZW50LiBtYWtlIGEgY29weSBpbiBjYXNlIGZpcmluZyBwYXVzZXMgdGhpcyBlbWl0dGVyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2V2ZW50UXVldWUuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnRzID0gQXJyYXkuZnJvbSh0aGlzLl9ldmVudFF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRRdWV1ZS5jbGVhcigpO1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5maXJlKHRoaXMuX21lcmdlRm4oZXZlbnRzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbWVyZ2luZywgZmlyZSBlYWNoIGV2ZW50IGluZGl2aWR1YWxseSBhbmQgdGVzdFxuICAgICAgICAgICAgICAgIC8vIHRoYXQgdGhpcyBlbWl0dGVyIGlzbid0IHBhdXNlZCBoYWxmd2F5IHRocm91Z2hcbiAgICAgICAgICAgICAgICB3aGlsZSAoIXRoaXMuX2lzUGF1c2VkICYmIHRoaXMuX2V2ZW50UXVldWUuc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5maXJlKHRoaXMuX2V2ZW50UXVldWUuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50UXVldWUucHVzaChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdXBlci5maXJlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBEZWJvdW5jZUVtaXR0ZXIgZXh0ZW5kcyBQYXVzZWFibGVFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuX2RlbGF5ID0gKF9hID0gb3B0aW9ucy5kZWxheSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTAwO1xuICAgIH1cbiAgICBmaXJlKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5faGFuZGxlKSB7XG4gICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIH0sIHRoaXMuX2RlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5maXJlKGV2ZW50KTtcbiAgICB9XG59XG4vKipcbiAqIEFuIGVtaXR0ZXIgd2hpY2ggcXVldWUgYWxsIGV2ZW50cyBhbmQgdGhlbiBwcm9jZXNzIHRoZW0gYXQgdGhlXG4gKiBlbmQgb2YgdGhlIGV2ZW50IGxvb3AuXG4gKi9cbmV4cG9ydCBjbGFzcyBNaWNyb3Rhc2tFbWl0dGVyIGV4dGVuZHMgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fcXVldWVkRXZlbnRzID0gW107XG4gICAgICAgIHRoaXMuX21lcmdlRm4gPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWVyZ2U7XG4gICAgfVxuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0xpc3RlbmVycygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcXVldWVkRXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5fcXVldWVkRXZlbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tZXJnZUZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmZpcmUodGhpcy5fbWVyZ2VGbih0aGlzLl9xdWV1ZWRFdmVudHMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlZEV2ZW50cy5mb3JFYWNoKGUgPT4gc3VwZXIuZmlyZShlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlZEV2ZW50cyA9IFtdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFuIGV2ZW50IGVtaXR0ZXIgdGhhdCBtdWx0aXBsZXhlcyBtYW55IGV2ZW50cyBpbnRvIGEgc2luZ2xlIGV2ZW50LlxuICpcbiAqIEBleGFtcGxlIExpc3RlbiB0byB0aGUgYG9uRGF0YWAgZXZlbnQgb2YgYWxsIGBUaGluZ2BzLCBkeW5hbWljYWxseSBhZGRpbmcgYW5kIHJlbW92aW5nIGBUaGluZ2BzXG4gKiB0byB0aGUgbXVsdGlwbGV4ZXIgYXMgbmVlZGVkLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IGFueXRoaW5nRGF0YU11bHRpcGxleGVyID0gbmV3IEV2ZW50TXVsdGlwbGV4ZXI8eyBkYXRhOiBzdHJpbmcgfT4oKTtcbiAqXG4gKiBjb25zdCB0aGluZ0xpc3RlbmVycyA9IERpc3Bvc2FibGVNYXA8VGhpbmcsIElEaXNwb3NhYmxlPigpO1xuICpcbiAqIHRoaW5nU2VydmljZS5vbkRpZEFkZFRoaW5nKHRoaW5nID0+IHtcbiAqICAgdGhpbmdMaXN0ZW5lcnMuc2V0KHRoaW5nLCBhbnl0aGluZ0RhdGFNdWx0aXBsZXhlci5hZGQodGhpbmcub25EYXRhKTtcbiAqIH0pO1xuICogdGhpbmdTZXJ2aWNlLm9uRGlkUmVtb3ZlVGhpbmcodGhpbmcgPT4ge1xuICogICB0aGluZ0xpc3RlbmVycy5kZWxldGVBbmREaXNwb3NlKHRoaW5nKTtcbiAqIH0pO1xuICpcbiAqIGFueXRoaW5nRGF0YU11bHRpcGxleGVyLmV2ZW50KGUgPT4ge1xuICogICBjb25zb2xlLmxvZygnU29tZXRoaW5nIGZpcmVkIGRhdGEgJyArIGUuZGF0YSlcbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudE11bHRpcGxleGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5oYXNMaXN0ZW5lcnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoe1xuICAgICAgICAgICAgb25XaWxsQWRkRmlyc3RMaXN0ZW5lcjogKCkgPT4gdGhpcy5vbkZpcnN0TGlzdGVuZXJBZGQoKSxcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyOiAoKSA9PiB0aGlzLm9uTGFzdExpc3RlbmVyUmVtb3ZlKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBldmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgYWRkKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGUgPSB7IGV2ZW50OiBldmVudCwgbGlzdGVuZXI6IG51bGwgfTtcbiAgICAgICAgdGhpcy5ldmVudHMucHVzaChlKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmhvb2soZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzcG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMudW5ob29rKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5ldmVudHMuaW5kZXhPZihlKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdG9EaXNwb3NhYmxlKGNyZWF0ZVNpbmdsZUNhbGxGdW5jdGlvbihkaXNwb3NlKSk7XG4gICAgfVxuICAgIG9uRmlyc3RMaXN0ZW5lckFkZCgpIHtcbiAgICAgICAgdGhpcy5oYXNMaXN0ZW5lcnMgPSB0cnVlO1xuICAgICAgICB0aGlzLmV2ZW50cy5mb3JFYWNoKGUgPT4gdGhpcy5ob29rKGUpKTtcbiAgICB9XG4gICAgb25MYXN0TGlzdGVuZXJSZW1vdmUoKSB7XG4gICAgICAgIHRoaXMuaGFzTGlzdGVuZXJzID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXZlbnRzLmZvckVhY2goZSA9PiB0aGlzLnVuaG9vayhlKSk7XG4gICAgfVxuICAgIGhvb2soZSkge1xuICAgICAgICBlLmxpc3RlbmVyID0gZS5ldmVudChyID0+IHRoaXMuZW1pdHRlci5maXJlKHIpKTtcbiAgICB9XG4gICAgdW5ob29rKGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBlLmxpc3RlbmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgICAgICBlLmxpc3RlbmVyID0gbnVsbDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgIChfYSA9IGUubGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBFdmVudEJ1ZmZlcmVyIGlzIHVzZWZ1bCBpbiBzaXR1YXRpb25zIGluIHdoaWNoIHlvdSB3YW50XG4gKiB0byBkZWxheSBmaXJpbmcgeW91ciBldmVudHMgZHVyaW5nIHNvbWUgY29kZS5cbiAqIFlvdSBjYW4gd3JhcCB0aGF0IGNvZGUgYW5kIGJlIHN1cmUgdGhhdCB0aGUgZXZlbnQgd2lsbCBub3RcbiAqIGJlIGZpcmVkIGR1cmluZyB0aGF0IHdyYXAuXG4gKlxuICogYGBgXG4gKiBjb25zdCBlbWl0dGVyOiBFbWl0dGVyO1xuICogY29uc3QgZGVsYXllciA9IG5ldyBFdmVudERlbGF5ZXIoKTtcbiAqIGNvbnN0IGRlbGF5ZWRFdmVudCA9IGRlbGF5ZXIud3JhcEV2ZW50KGVtaXR0ZXIuZXZlbnQpO1xuICpcbiAqIGRlbGF5ZWRFdmVudChjb25zb2xlLmxvZyk7XG4gKlxuICogZGVsYXllci5idWZmZXJFdmVudHMoKCkgPT4ge1xuICogICBlbWl0dGVyLmZpcmUoKTsgLy8gZXZlbnQgd2lsbCBub3QgYmUgZmlyZWQgeWV0XG4gKiB9KTtcbiAqXG4gKiAvLyBldmVudCB3aWxsIG9ubHkgYmUgZmlyZWQgYXQgdGhpcyBwb2ludFxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBFdmVudEJ1ZmZlcmVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgfVxuICAgIHdyYXBFdmVudChldmVudCwgcmVkdWNlLCBpbml0aWFsKSB7XG4gICAgICAgIHJldHVybiAobGlzdGVuZXIsIHRoaXNBcmdzLCBkaXNwb3NhYmxlcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50KGkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhW3RoaXMuZGF0YS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAvLyBOb24tcmVkdWNlIHNjZW5hcmlvXG4gICAgICAgICAgICAgICAgaWYgKCFyZWR1Y2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnVmZmVyaW5nIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuYnVmZmVycy5wdXNoKCgpID0+IGxpc3RlbmVyLmNhbGwodGhpc0FyZ3MsIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdCBidWZmZXJpbmcgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgaSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWR1Y2Ugc2NlbmFyaW9cbiAgICAgICAgICAgICAgICBjb25zdCByZWR1Y2VEYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAvLyBOb3QgYnVmZmVyaW5nIGNhc2VcbiAgICAgICAgICAgICAgICBpZiAoIXJlZHVjZURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogSXMgdGhlcmUgYSB3YXkgdG8gY2FjaGUgdGhpcyByZWR1Y2UgY2FsbCBmb3IgYWxsIGxpc3RlbmVycz9cbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJncywgcmVkdWNlKGluaXRpYWwsIGkpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCdWZmZXJpbmcgY2FzZVxuICAgICAgICAgICAgICAgIChfYSA9IHJlZHVjZURhdGEuaXRlbXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChyZWR1Y2VEYXRhLml0ZW1zID0gW10pO1xuICAgICAgICAgICAgICAgIHJlZHVjZURhdGEuaXRlbXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlRGF0YS5idWZmZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbmNsdWRlIGEgc2luZ2xlIGJ1ZmZlcmVkIGZ1bmN0aW9uIHRoYXQgd2lsbCByZWR1Y2UgYWxsIGV2ZW50cyB3aGVuIHdlJ3JlIGRvbmUgYnVmZmVyaW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBkYXRhLmJ1ZmZlcnMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjYWNoZSB0aGUgcmVkdWNlZCByZXN1bHQgc28gdGhhdCB0aGUgdmFsdWUgY2FuIGJlIHNoYXJlZCBhY3Jvc3MgYWxsIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gcmVkdWNlRGF0YS5yZWR1Y2VkUmVzdWx0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAocmVkdWNlRGF0YS5yZWR1Y2VkUmVzdWx0ID0gaW5pdGlhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVkdWNlRGF0YS5pdGVtcy5yZWR1Y2UocmVkdWNlLCBpbml0aWFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVkdWNlRGF0YS5pdGVtcy5yZWR1Y2UocmVkdWNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmdzLCByZWR1Y2VEYXRhLnJlZHVjZWRSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB1bmRlZmluZWQsIGRpc3Bvc2FibGVzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVmZmVyRXZlbnRzKGZuKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB7IGJ1ZmZlcnM6IG5ldyBBcnJheSgpIH07XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKGRhdGEpO1xuICAgICAgICBjb25zdCByID0gZm4oKTtcbiAgICAgICAgdGhpcy5kYXRhLnBvcCgpO1xuICAgICAgICBkYXRhLmJ1ZmZlcnMuZm9yRWFjaChmbHVzaCA9PiBmbHVzaCgpKTtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxufVxuLyoqXG4gKiBBIFJlbGF5IGlzIGFuIGV2ZW50IGZvcndhcmRlciB3aGljaCBmdW5jdGlvbnMgYXMgYSByZXBsdWdhYmJsZSBldmVudCBwaXBlLlxuICogT25jZSBjcmVhdGVkLCB5b3UgY2FuIGNvbm5lY3QgYW4gaW5wdXQgZXZlbnQgdG8gaXQgYW5kIGl0IHdpbGwgc2ltcGx5IGZvcndhcmRcbiAqIGV2ZW50cyBmcm9tIHRoYXQgaW5wdXQgZXZlbnQgdGhyb3VnaCBpdHMgb3duIGBldmVudGAgcHJvcGVydHkuIFRoZSBgaW5wdXRgXG4gKiBjYW4gYmUgY2hhbmdlZCBhdCBhbnkgcG9pbnQgaW4gdGltZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFJlbGF5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnB1dEV2ZW50ID0gRXZlbnQuTm9uZTtcbiAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIgPSBEaXNwb3NhYmxlLk5vbmU7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcbiAgICAgICAgICAgIG9uRGlkQWRkRmlyc3RMaXN0ZW5lcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RXZlbnRMaXN0ZW5lciA9IHRoaXMuaW5wdXRFdmVudCh0aGlzLmVtaXR0ZXIuZmlyZSwgdGhpcy5lbWl0dGVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRpZFJlbW92ZUxhc3RMaXN0ZW5lcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ldmVudCA9IHRoaXMuZW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgc2V0IGlucHV0KGV2ZW50KSB7XG4gICAgICAgIHRoaXMuaW5wdXRFdmVudCA9IGV2ZW50O1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFdmVudExpc3RlbmVyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRFdmVudExpc3RlbmVyID0gZXZlbnQodGhpcy5lbWl0dGVyLmZpcmUsIHRoaXMuZW1pdHRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5pbnB1dEV2ZW50TGlzdGVuZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmVtaXR0ZXIuZGlzcG9zZSgpO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgaXNUeXBlZEFycmF5LCBpc09iamVjdCwgaXNVbmRlZmluZWRPck51bGwgfSBmcm9tICcuL3R5cGVzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmUob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBBcnJheS5pc0FycmF5KG9iaikgPyBbXSA6IHt9O1xuICAgIE9iamVjdC5lbnRyaWVzKG9iaikuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyA/IGRlZXBDbG9uZSh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBGcmVlemUob2JqKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgY29uc3Qgc3RhY2sgPSBbb2JqXTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBvYmogPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICBPYmplY3QuZnJlZXplKG9iaik7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgICAgICAgICAgaWYgKF9oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBvYmpba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdvYmplY3QnICYmICFPYmplY3QuaXNGcm96ZW4ocHJvcCkgJiYgIWlzVHlwZWRBcnJheShwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKHByb3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuY29uc3QgX2hhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUFuZENoYW5nZShvYmosIGNoYW5nZXIpIHtcbiAgICByZXR1cm4gX2Nsb25lQW5kQ2hhbmdlKG9iaiwgY2hhbmdlciwgbmV3IFNldCgpKTtcbn1cbmZ1bmN0aW9uIF9jbG9uZUFuZENoYW5nZShvYmosIGNoYW5nZXIsIHNlZW4pIHtcbiAgICBpZiAoaXNVbmRlZmluZWRPck51bGwob2JqKSkge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gY2hhbmdlcihvYmopO1xuICAgIGlmICh0eXBlb2YgY2hhbmdlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgY29uc3QgcjEgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIG9iaikge1xuICAgICAgICAgICAgcjEucHVzaChfY2xvbmVBbmRDaGFuZ2UoZSwgY2hhbmdlciwgc2VlbikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByMTtcbiAgICB9XG4gICAgaWYgKGlzT2JqZWN0KG9iaikpIHtcbiAgICAgICAgaWYgKHNlZW4uaGFzKG9iaikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNsb25lIHJlY3Vyc2l2ZSBkYXRhLXN0cnVjdHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIHNlZW4uYWRkKG9iaik7XG4gICAgICAgIGNvbnN0IHIyID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaTIgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoX2hhc093blByb3BlcnR5LmNhbGwob2JqLCBpMikpIHtcbiAgICAgICAgICAgICAgICByMltpMl0gPSBfY2xvbmVBbmRDaGFuZ2Uob2JqW2kyXSwgY2hhbmdlciwgc2Vlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2Vlbi5kZWxldGUob2JqKTtcbiAgICAgICAgcmV0dXJuIHIyO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuLyoqXG4gKiBDb3BpZXMgYWxsIHByb3BlcnRpZXMgb2Ygc291cmNlIGludG8gZGVzdGluYXRpb24uIFRoZSBvcHRpb25hbCBwYXJhbWV0ZXIgXCJvdmVyd3JpdGVcIiBhbGxvd3MgdG8gY29udHJvbFxuICogaWYgZXhpc3RpbmcgcHJvcGVydGllcyBvbiB0aGUgZGVzdGluYXRpb24gc2hvdWxkIGJlIG92ZXJ3cml0dGVuIG9yIG5vdC4gRGVmYXVsdHMgdG8gdHJ1ZSAob3ZlcndyaXRlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1peGluKGRlc3RpbmF0aW9uLCBzb3VyY2UsIG92ZXJ3cml0ZSA9IHRydWUpIHtcbiAgICBpZiAoIWlzT2JqZWN0KGRlc3RpbmF0aW9uKSkge1xuICAgICAgICByZXR1cm4gc291cmNlO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgICBPYmplY3Qua2V5cyhzb3VyY2UpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgaW4gZGVzdGluYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChkZXN0aW5hdGlvbltrZXldKSAmJiBpc09iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1peGluKGRlc3RpbmF0aW9uW2tleV0sIHNvdXJjZVtrZXldLCBvdmVyd3JpdGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb25ba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFscyhvbmUsIG90aGVyKSB7XG4gICAgaWYgKG9uZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChvbmUgPT09IG51bGwgfHwgb25lID09PSB1bmRlZmluZWQgfHwgb3RoZXIgPT09IG51bGwgfHwgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb25lICE9PSB0eXBlb2Ygb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9uZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKEFycmF5LmlzQXJyYXkob25lKSkgIT09IChBcnJheS5pc0FycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaTtcbiAgICBsZXQga2V5O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9uZSkpIHtcbiAgICAgICAgaWYgKG9uZS5sZW5ndGggIT09IG90aGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtpXSwgb3RoZXJbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBvbmVLZXlzID0gW107XG4gICAgICAgIGZvciAoa2V5IGluIG9uZSkge1xuICAgICAgICAgICAgb25lS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgb25lS2V5cy5zb3J0KCk7XG4gICAgICAgIGNvbnN0IG90aGVyS2V5cyA9IFtdO1xuICAgICAgICBmb3IgKGtleSBpbiBvdGhlcikge1xuICAgICAgICAgICAgb3RoZXJLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBvdGhlcktleXMuc29ydCgpO1xuICAgICAgICBpZiAoIWVxdWFscyhvbmVLZXlzLCBvdGhlcktleXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9uZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghZXF1YWxzKG9uZVtvbmVLZXlzW2ldXSwgb3RoZXJbb25lS2V5c1tpXV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFsbFByb3BlcnR5TmFtZXMob2JqKSB7XG4gICAgbGV0IHJlcyA9IFtdO1xuICAgIHdoaWxlIChPYmplY3QucHJvdG90eXBlICE9PSBvYmopIHtcbiAgICAgICAgcmVzID0gcmVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmopKTtcbiAgICAgICAgb2JqID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWxsTWV0aG9kTmFtZXMob2JqKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IFtdO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBnZXRBbGxQcm9wZXJ0eU5hbWVzKG9iaikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmpbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1ldGhvZHMucHVzaChwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm94eU9iamVjdChtZXRob2ROYW1lcywgaW52b2tlKSB7XG4gICAgY29uc3QgY3JlYXRlUHJveHlNZXRob2QgPSAobWV0aG9kKSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2UobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAoY29uc3QgbWV0aG9kTmFtZSBvZiBtZXRob2ROYW1lcykge1xuICAgICAgICByZXN1bHRbbWV0aG9kTmFtZV0gPSBjcmVhdGVQcm94eU1ldGhvZChtZXRob2ROYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xubGV0IGlzUHNldWRvID0gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQubG9jYXRpb24gJiYgZG9jdW1lbnQubG9jYXRpb24uaGFzaC5pbmRleE9mKCdwc2V1ZG89dHJ1ZScpID49IDApO1xuY29uc3QgREVGQVVMVF9UQUcgPSAnaS1kZWZhdWx0JztcbmZ1bmN0aW9uIF9mb3JtYXQobWVzc2FnZSwgYXJncykge1xuICAgIGxldCByZXN1bHQ7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlc3VsdCA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBtZXNzYWdlLnJlcGxhY2UoL1xceyhcXGQrKVxcfS9nLCAobWF0Y2gsIHJlc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcmVzdFswXTtcbiAgICAgICAgICAgIGNvbnN0IGFyZyA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1hdGNoO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8IGFyZyA9PT0gdm9pZCAwIHx8IGFyZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFN0cmluZyhhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc1BzZXVkbykge1xuICAgICAgICAvLyBGRjNCIGFuZCBGRjNEIGlzIHRoZSBVbmljb2RlIHplbmtha3UgcmVwcmVzZW50YXRpb24gZm9yIFsgYW5kIF1cbiAgICAgICAgcmVzdWx0ID0gJ1xcdUZGM0InICsgcmVzdWx0LnJlcGxhY2UoL1thb3VlaV0vZywgJyQmJCYnKSArICdcXHVGRjNEJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRMYW5ndWFnZUZvck1vZHVsZShjb25maWcsIG5hbWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gY29uZmlnW25hbWVdO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVzdWx0ID0gY29uZmlnWycqJ107XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGVuZFdpdGhTbGFzaChwYXRoKSB7XG4gICAgaWYgKHBhdGguY2hhckF0KHBhdGgubGVuZ3RoIC0gMSkgPT09ICcvJykge1xuICAgICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGggKyAnLyc7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRNZXNzYWdlc0Zyb21UcmFuc2xhdGlvbnNTZXJ2aWNlKHRyYW5zbGF0aW9uU2VydmljZVVybCwgbGFuZ3VhZ2UsIG5hbWUpIHtcbiAgICBjb25zdCB1cmwgPSBlbmRXaXRoU2xhc2godHJhbnNsYXRpb25TZXJ2aWNlVXJsKSArIGVuZFdpdGhTbGFzaChsYW5ndWFnZSkgKyAndnNjb2RlLycgKyBlbmRXaXRoU2xhc2gobmFtZSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsKTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7cmVzLnN0YXR1c30gLSAke3Jlcy5zdGF0dXNUZXh0fWApO1xufVxuZnVuY3Rpb24gY3JlYXRlU2NvcGVkTG9jYWxpemUoc2NvcGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGlkeCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJlc3RBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICAgICAgcmV0dXJuIF9mb3JtYXQoc2NvcGVbaWR4XSwgcmVzdEFyZ3MpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTY29wZWRMb2NhbGl6ZTIoc2NvcGUpIHtcbiAgICByZXR1cm4gKGlkeCwgZGVmYXVsdFZhbHVlLCAuLi5hcmdzKSA9PiAoe1xuICAgICAgICB2YWx1ZTogX2Zvcm1hdChzY29wZVtpZHhdLCBhcmdzKSxcbiAgICAgICAgb3JpZ2luYWw6IF9mb3JtYXQoZGVmYXVsdFZhbHVlLCBhcmdzKVxuICAgIH0pO1xufVxuLyoqXG4gKiBAc2tpcE1hbmdsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxpemUoZGF0YSwgbWVzc2FnZSwgLi4uYXJncykge1xuICAgIHJldHVybiBfZm9ybWF0KG1lc3NhZ2UsIGFyZ3MpO1xufVxuLyoqXG4gKiBAc2tpcE1hbmdsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9jYWxpemUyKGRhdGEsIG1lc3NhZ2UsIC4uLmFyZ3MpIHtcbiAgICBjb25zdCBvcmlnaW5hbCA9IF9mb3JtYXQobWVzc2FnZSwgYXJncyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IG9yaWdpbmFsLFxuICAgICAgICBvcmlnaW5hbFxuICAgIH07XG59XG4vKipcbiAqIEBza2lwTWFuZ2xlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb25maWd1cmVkRGVmYXVsdExvY2FsZShfKSB7XG4gICAgLy8gVGhpcyByZXR1cm5zIHVuZGVmaW5lZCBiZWNhdXNlIHRoaXMgaW1wbGVtZW50YXRpb24gaXNuJ3QgdXNlZCBhbmQgaXMgb3ZlcndyaXR0ZW4gYnkgdGhlIGxvYWRlclxuICAgIC8vIHdoZW4gbG9hZGVkLlxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vKipcbiAqIEBza2lwTWFuZ2xlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQc2V1ZG9UcmFuc2xhdGlvbih2YWx1ZSkge1xuICAgIGlzUHNldWRvID0gdmFsdWU7XG59XG4vKipcbiAqIEludm9rZWQgaW4gYSBidWlsdCBwcm9kdWN0IGF0IHJ1bi10aW1lXG4gKiBAc2tpcE1hbmdsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlKGtleSwgZGF0YSkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbGl6ZTogY3JlYXRlU2NvcGVkTG9jYWxpemUoZGF0YVtrZXldKSxcbiAgICAgICAgbG9jYWxpemUyOiBjcmVhdGVTY29wZWRMb2NhbGl6ZTIoZGF0YVtrZXldKSxcbiAgICAgICAgZ2V0Q29uZmlndXJlZERlZmF1bHRMb2NhbGU6IChfYSA9IGRhdGEuZ2V0Q29uZmlndXJlZERlZmF1bHRMb2NhbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgoXykgPT4gdW5kZWZpbmVkKVxuICAgIH07XG59XG4vKipcbiAqIEludm9rZWQgYnkgdGhlIGxvYWRlciBhdCBydW4tdGltZVxuICogQHNraXBNYW5nbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxvYWQobmFtZSwgcmVxLCBsb2FkLCBjb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcGx1Z2luQ29uZmlnID0gKF9hID0gY29uZmlnWyd2cy9ubHMnXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgaWYgKCFuYW1lIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gZ2l2ZSBiYWNrIHRoZSBtYW5nbGVkIG5hbWVzIGhlcmVcbiAgICAgICAgcmV0dXJuIGxvYWQoe1xuICAgICAgICAgICAgbG9jYWxpemU6IGxvY2FsaXplLFxuICAgICAgICAgICAgbG9jYWxpemUyOiBsb2NhbGl6ZTIsXG4gICAgICAgICAgICBnZXRDb25maWd1cmVkRGVmYXVsdExvY2FsZTogKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBwbHVnaW5Db25maWcuYXZhaWxhYmxlTGFuZ3VhZ2VzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJyonXTsgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSBwbHVnaW5Db25maWcuYXZhaWxhYmxlTGFuZ3VhZ2VzID8gZmluZExhbmd1YWdlRm9yTW9kdWxlKHBsdWdpbkNvbmZpZy5hdmFpbGFibGVMYW5ndWFnZXMsIG5hbWUpIDogbnVsbDtcbiAgICBjb25zdCB1c2VEZWZhdWx0TGFuZ3VhZ2UgPSBsYW5ndWFnZSA9PT0gbnVsbCB8fCBsYW5ndWFnZSA9PT0gREVGQVVMVF9UQUc7XG4gICAgbGV0IHN1ZmZpeCA9ICcubmxzJztcbiAgICBpZiAoIXVzZURlZmF1bHRMYW5ndWFnZSkge1xuICAgICAgICBzdWZmaXggPSBzdWZmaXggKyAnLicgKyBsYW5ndWFnZTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXNMb2FkZWQgPSAobWVzc2FnZXMpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZXMpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5sb2NhbGl6ZSA9IGNyZWF0ZVNjb3BlZExvY2FsaXplKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmxvY2FsaXplMiA9IGNyZWF0ZVNjb3BlZExvY2FsaXplMihtZXNzYWdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5sb2NhbGl6ZSA9IGNyZWF0ZVNjb3BlZExvY2FsaXplKG1lc3NhZ2VzW25hbWVdKTtcbiAgICAgICAgICAgIG1lc3NhZ2VzLmxvY2FsaXplMiA9IGNyZWF0ZVNjb3BlZExvY2FsaXplMihtZXNzYWdlc1tuYW1lXSk7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZXMuZ2V0Q29uZmlndXJlZERlZmF1bHRMb2NhbGUgPSAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHBsdWdpbkNvbmZpZy5hdmFpbGFibGVMYW5ndWFnZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVsnKiddOyB9O1xuICAgICAgICBsb2FkKG1lc3NhZ2VzKTtcbiAgICB9O1xuICAgIGlmICh0eXBlb2YgcGx1Z2luQ29uZmlnLmxvYWRCdW5kbGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcGx1Z2luQ29uZmlnLmxvYWRCdW5kbGUobmFtZSwgbGFuZ3VhZ2UsIChlcnIsIG1lc3NhZ2VzKSA9PiB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIGFuIGVycm9yLiBMb2FkIHRoZSBFbmdsaXNoIGRlZmF1bHQgc3RyaW5ncyB0byBub3QgZmFpbFxuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlcShbbmFtZSArICcubmxzJ10sIG1lc3NhZ2VzTG9hZGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzTG9hZGVkKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHBsdWdpbkNvbmZpZy50cmFuc2xhdGlvblNlcnZpY2VVcmwgJiYgIXVzZURlZmF1bHRMYW5ndWFnZSkge1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGF3YWl0IGdldE1lc3NhZ2VzRnJvbVRyYW5zbGF0aW9uc1NlcnZpY2UocGx1Z2luQ29uZmlnLnRyYW5zbGF0aW9uU2VydmljZVVybCwgbGFuZ3VhZ2UsIG5hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlc0xvYWRlZChtZXNzYWdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gTGFuZ3VhZ2UgaXMgYWxyZWFkeSBhcyBnZW5lcmljIGFzIGl0IGdldHMsIHNvIHJlcXVpcmUgZGVmYXVsdCBtZXNzYWdlc1xuICAgICAgICAgICAgICAgIGlmICghbGFuZ3VhZ2UuaW5jbHVkZXMoJy0nKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXEoW25hbWUgKyAnLm5scyddLCBtZXNzYWdlc0xvYWRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoZXJlIGlzIGEgZGFzaCwgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyZWQgaXMgYSBzcGVjaWZpYyBzdWItbGFuZ3VhZ2Ugb2YgdGhlIHNhbWUgZ2VuZXJpYyBsYW5ndWFnZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2Ugd2VyZSB1bmFibGUgdG8gbG9hZCB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UsIHRyeSB0byBsb2FkIHRoZSBnZW5lcmljIGxhbmd1YWdlLiBFeC4gd2UgZmFpbGVkIHRvIGZpbmQgYVxuICAgICAgICAgICAgICAgICAgICAvLyBTd2lzcyBHZXJtYW4gKGRlLUNIKSwgc28gdHJ5IHRvIGxvYWQgdGhlIGdlbmVyaWMgR2VybWFuIChkZSkgbWVzc2FnZXMgaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJpY0xhbmd1YWdlID0gbGFuZ3VhZ2Uuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZXMgPSBhd2FpdCBnZXRNZXNzYWdlc0Zyb21UcmFuc2xhdGlvbnNTZXJ2aWNlKHBsdWdpbkNvbmZpZy50cmFuc2xhdGlvblNlcnZpY2VVcmwsIGdlbmVyaWNMYW5ndWFnZSwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdvdCBzb21lIG1lc3NhZ2VzLCBzbyB3ZSBjb25maWd1cmUgdGhlIGNvbmZpZ3VyYXRpb24gdG8gdXNlIHRoZSBnZW5lcmljIGxhbmd1YWdlIGZvciB0aGlzIHNlc3Npb24uXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHBsdWdpbkNvbmZpZy5hdmFpbGFibGVMYW5ndWFnZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChwbHVnaW5Db25maWcuYXZhaWxhYmxlTGFuZ3VhZ2VzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW5Db25maWcuYXZhaWxhYmxlTGFuZ3VhZ2VzWycqJ10gPSBnZW5lcmljTGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlc0xvYWRlZChtZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxKFtuYW1lICsgJy5ubHMnXSwgbWVzc2FnZXNMb2FkZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlcShbbmFtZSArIHN1ZmZpeF0sIG1lc3NhZ2VzTG9hZGVkLCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3VmZml4ID09PSAnLm5scycpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdHJ5aW5nIHRvIGxvYWQgZGVmYXVsdCBsYW5ndWFnZSBzdHJpbmdzJywgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBtZXNzYWdlIGJ1bmRsZSBmb3IgbGFuZ3VhZ2UgJHtsYW5ndWFnZX0uIEZhbGxpbmcgYmFjayB0byB0aGUgZGVmYXVsdCBsYW5ndWFnZTpgLCBlcnIpO1xuICAgICAgICAgICAgcmVxKFtuYW1lICsgJy5ubHMnXSwgbWVzc2FnZXNMb2FkZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJ2YXIgX2EsIF9iO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBubHMgZnJvbSAnLi4vLi4vbmxzLmpzJztcbmV4cG9ydCBjb25zdCBMQU5HVUFHRV9ERUZBVUxUID0gJ2VuJztcbmxldCBfaXNXaW5kb3dzID0gZmFsc2U7XG5sZXQgX2lzTWFjaW50b3NoID0gZmFsc2U7XG5sZXQgX2lzTGludXggPSBmYWxzZTtcbmxldCBfaXNMaW51eFNuYXAgPSBmYWxzZTtcbmxldCBfaXNOYXRpdmUgPSBmYWxzZTtcbmxldCBfaXNXZWIgPSBmYWxzZTtcbmxldCBfaXNFbGVjdHJvbiA9IGZhbHNlO1xubGV0IF9pc0lPUyA9IGZhbHNlO1xubGV0IF9pc0NJID0gZmFsc2U7XG5sZXQgX2lzTW9iaWxlID0gZmFsc2U7XG5sZXQgX2xvY2FsZSA9IHVuZGVmaW5lZDtcbmxldCBfbGFuZ3VhZ2UgPSBMQU5HVUFHRV9ERUZBVUxUO1xubGV0IF9wbGF0Zm9ybUxvY2FsZSA9IExBTkdVQUdFX0RFRkFVTFQ7XG5sZXQgX3RyYW5zbGF0aW9uc0NvbmZpZ0ZpbGUgPSB1bmRlZmluZWQ7XG5sZXQgX3VzZXJBZ2VudCA9IHVuZGVmaW5lZDtcbmNvbnN0ICRnbG9iYWxUaGlzID0gZ2xvYmFsVGhpcztcbmxldCBub2RlUHJvY2VzcyA9IHVuZGVmaW5lZDtcbmlmICh0eXBlb2YgJGdsb2JhbFRoaXMudnNjb2RlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgJGdsb2JhbFRoaXMudnNjb2RlLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTmF0aXZlIGVudmlyb25tZW50IChzYW5kYm94ZWQpXG4gICAgbm9kZVByb2Nlc3MgPSAkZ2xvYmFsVGhpcy52c2NvZGUucHJvY2Vzcztcbn1cbmVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgKChfYSA9IHByb2Nlc3MgPT09IG51bGwgfHwgcHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzcy52ZXJzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpID09PSAnc3RyaW5nJykge1xuICAgIC8vIE5hdGl2ZSBlbnZpcm9ubWVudCAobm9uLXNhbmRib3hlZClcbiAgICBub2RlUHJvY2VzcyA9IHByb2Nlc3M7XG59XG5jb25zdCBpc0VsZWN0cm9uUHJvY2VzcyA9IHR5cGVvZiAoKF9iID0gbm9kZVByb2Nlc3MgPT09IG51bGwgfHwgbm9kZVByb2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVQcm9jZXNzLnZlcnNpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZWxlY3Ryb24pID09PSAnc3RyaW5nJztcbmNvbnN0IGlzRWxlY3Ryb25SZW5kZXJlciA9IGlzRWxlY3Ryb25Qcm9jZXNzICYmIChub2RlUHJvY2VzcyA9PT0gbnVsbCB8fCBub2RlUHJvY2VzcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZVByb2Nlc3MudHlwZSkgPT09ICdyZW5kZXJlcic7XG4vLyBOYXRpdmUgZW52aXJvbm1lbnRcbmlmICh0eXBlb2Ygbm9kZVByb2Nlc3MgPT09ICdvYmplY3QnKSB7XG4gICAgX2lzV2luZG93cyA9IChub2RlUHJvY2Vzcy5wbGF0Zm9ybSA9PT0gJ3dpbjMyJyk7XG4gICAgX2lzTWFjaW50b3NoID0gKG5vZGVQcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJyk7XG4gICAgX2lzTGludXggPSAobm9kZVByb2Nlc3MucGxhdGZvcm0gPT09ICdsaW51eCcpO1xuICAgIF9pc0xpbnV4U25hcCA9IF9pc0xpbnV4ICYmICEhbm9kZVByb2Nlc3MuZW52WydTTkFQJ10gJiYgISFub2RlUHJvY2Vzcy5lbnZbJ1NOQVBfUkVWSVNJT04nXTtcbiAgICBfaXNFbGVjdHJvbiA9IGlzRWxlY3Ryb25Qcm9jZXNzO1xuICAgIF9pc0NJID0gISFub2RlUHJvY2Vzcy5lbnZbJ0NJJ10gfHwgISFub2RlUHJvY2Vzcy5lbnZbJ0JVSUxEX0FSVElGQUNUU1RBR0lOR0RJUkVDVE9SWSddO1xuICAgIF9sb2NhbGUgPSBMQU5HVUFHRV9ERUZBVUxUO1xuICAgIF9sYW5ndWFnZSA9IExBTkdVQUdFX0RFRkFVTFQ7XG4gICAgY29uc3QgcmF3TmxzQ29uZmlnID0gbm9kZVByb2Nlc3MuZW52WydWU0NPREVfTkxTX0NPTkZJRyddO1xuICAgIGlmIChyYXdObHNDb25maWcpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG5sc0NvbmZpZyA9IEpTT04ucGFyc2UocmF3TmxzQ29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gbmxzQ29uZmlnLmF2YWlsYWJsZUxhbmd1YWdlc1snKiddO1xuICAgICAgICAgICAgX2xvY2FsZSA9IG5sc0NvbmZpZy5sb2NhbGU7XG4gICAgICAgICAgICBfcGxhdGZvcm1Mb2NhbGUgPSBubHNDb25maWcub3NMb2NhbGU7XG4gICAgICAgICAgICAvLyBWU0NvZGUncyBkZWZhdWx0IGxhbmd1YWdlIGlzICdlbidcbiAgICAgICAgICAgIF9sYW5ndWFnZSA9IHJlc29sdmVkID8gcmVzb2x2ZWQgOiBMQU5HVUFHRV9ERUZBVUxUO1xuICAgICAgICAgICAgX3RyYW5zbGF0aW9uc0NvbmZpZ0ZpbGUgPSBubHNDb25maWcuX3RyYW5zbGF0aW9uc0NvbmZpZ0ZpbGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaXNOYXRpdmUgPSB0cnVlO1xufVxuLy8gV2ViIGVudmlyb25tZW50XG5lbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiAhaXNFbGVjdHJvblJlbmRlcmVyKSB7XG4gICAgX3VzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgX2lzV2luZG93cyA9IF91c2VyQWdlbnQuaW5kZXhPZignV2luZG93cycpID49IDA7XG4gICAgX2lzTWFjaW50b3NoID0gX3VzZXJBZ2VudC5pbmRleE9mKCdNYWNpbnRvc2gnKSA+PSAwO1xuICAgIF9pc0lPUyA9IChfdXNlckFnZW50LmluZGV4T2YoJ01hY2ludG9zaCcpID49IDAgfHwgX3VzZXJBZ2VudC5pbmRleE9mKCdpUGFkJykgPj0gMCB8fCBfdXNlckFnZW50LmluZGV4T2YoJ2lQaG9uZScpID49IDApICYmICEhbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XG4gICAgX2lzTGludXggPSBfdXNlckFnZW50LmluZGV4T2YoJ0xpbnV4JykgPj0gMDtcbiAgICBfaXNNb2JpbGUgPSAoX3VzZXJBZ2VudCA9PT0gbnVsbCB8fCBfdXNlckFnZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdXNlckFnZW50LmluZGV4T2YoJ01vYmknKSkgPj0gMDtcbiAgICBfaXNXZWIgPSB0cnVlO1xuICAgIGNvbnN0IGNvbmZpZ3VyZWRMb2NhbGUgPSBubHMuZ2V0Q29uZmlndXJlZERlZmF1bHRMb2NhbGUoXG4gICAgLy8gVGhpcyBjYWxsIF9tdXN0XyBiZSBkb25lIGluIHRoZSBmaWxlIHRoYXQgY2FsbHMgYG5scy5nZXRDb25maWd1cmVkRGVmYXVsdExvY2FsZWBcbiAgICAvLyB0byBlbnN1cmUgdGhhdCB0aGUgTkxTIEFNRCBMb2FkZXIgcGx1Z2luIGhhcyBiZWVuIGxvYWRlZCBhbmQgY29uZmlndXJlZC5cbiAgICAvLyBUaGlzIGlzIGJlY2F1c2UgdGhlIGxvYWRlciBwbHVnaW4gZGVjaWRlcyB3aGF0IHRoZSBkZWZhdWx0IGxvY2FsZSBpcyBiYXNlZCBvblxuICAgIC8vIGhvdyBpdCdzIGFibGUgdG8gcmVzb2x2ZSB0aGUgc3RyaW5ncy5cbiAgICBubHMubG9jYWxpemUoeyBrZXk6ICdlbnN1cmVMb2FkZXJQbHVnaW5Jc0xvYWRlZCcsIGNvbW1lbnQ6IFsne0xvY2tlZH0nXSB9LCAnXycpKTtcbiAgICBfbG9jYWxlID0gY29uZmlndXJlZExvY2FsZSB8fCBMQU5HVUFHRV9ERUZBVUxUO1xuICAgIF9sYW5ndWFnZSA9IF9sb2NhbGU7XG4gICAgX3BsYXRmb3JtTG9jYWxlID0gbmF2aWdhdG9yLmxhbmd1YWdlO1xufVxuLy8gVW5rbm93biBlbnZpcm9ubWVudFxuZWxzZSB7XG4gICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIHJlc29sdmUgcGxhdGZvcm0uJyk7XG59XG5sZXQgX3BsYXRmb3JtID0gMCAvKiBQbGF0Zm9ybS5XZWIgKi87XG5pZiAoX2lzTWFjaW50b3NoKSB7XG4gICAgX3BsYXRmb3JtID0gMSAvKiBQbGF0Zm9ybS5NYWMgKi87XG59XG5lbHNlIGlmIChfaXNXaW5kb3dzKSB7XG4gICAgX3BsYXRmb3JtID0gMyAvKiBQbGF0Zm9ybS5XaW5kb3dzICovO1xufVxuZWxzZSBpZiAoX2lzTGludXgpIHtcbiAgICBfcGxhdGZvcm0gPSAyIC8qIFBsYXRmb3JtLkxpbnV4ICovO1xufVxuZXhwb3J0IGNvbnN0IGlzV2luZG93cyA9IF9pc1dpbmRvd3M7XG5leHBvcnQgY29uc3QgaXNNYWNpbnRvc2ggPSBfaXNNYWNpbnRvc2g7XG5leHBvcnQgY29uc3QgaXNMaW51eCA9IF9pc0xpbnV4O1xuZXhwb3J0IGNvbnN0IGlzTmF0aXZlID0gX2lzTmF0aXZlO1xuZXhwb3J0IGNvbnN0IGlzV2ViID0gX2lzV2ViO1xuZXhwb3J0IGNvbnN0IGlzV2ViV29ya2VyID0gKF9pc1dlYiAmJiB0eXBlb2YgJGdsb2JhbFRoaXMuaW1wb3J0U2NyaXB0cyA9PT0gJ2Z1bmN0aW9uJyk7XG5leHBvcnQgY29uc3Qgd2ViV29ya2VyT3JpZ2luID0gaXNXZWJXb3JrZXIgPyAkZ2xvYmFsVGhpcy5vcmlnaW4gOiB1bmRlZmluZWQ7XG5leHBvcnQgY29uc3QgaXNJT1MgPSBfaXNJT1M7XG5leHBvcnQgY29uc3QgaXNNb2JpbGUgPSBfaXNNb2JpbGU7XG5leHBvcnQgY29uc3QgdXNlckFnZW50ID0gX3VzZXJBZ2VudDtcbi8qKlxuICogVGhlIGxhbmd1YWdlIHVzZWQgZm9yIHRoZSB1c2VyIGludGVyZmFjZS4gVGhlIGZvcm1hdCBvZlxuICogdGhlIHN0cmluZyBpcyBhbGwgbG93ZXIgY2FzZSAoZS5nLiB6aC10dyBmb3IgVHJhZGl0aW9uYWxcbiAqIENoaW5lc2UpXG4gKi9cbmV4cG9ydCBjb25zdCBsYW5ndWFnZSA9IF9sYW5ndWFnZTtcbmV4cG9ydCBjb25zdCBzZXRUaW1lb3V0MElzRmFzdGVyID0gKHR5cGVvZiAkZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhJGdsb2JhbFRoaXMuaW1wb3J0U2NyaXB0cyk7XG4vKipcbiAqIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sIzp+OnRleHQ9dGhhbiUyMDQlMkMlMjB0aGVuLSxzZXQlMjB0aW1lb3V0JTIwdG8lMjA0LC0uXG4gKlxuICogV29ya3Mgc2ltaWxhcmx5IHRvIGBzZXRUaW1lb3V0KDApYCBidXQgZG9lc24ndCBzdWZmZXIgZnJvbSB0aGUgNG1zIGFydGlmaWNpYWwgZGVsYXlcbiAqIHRoYXQgYnJvd3NlcnMgc2V0IHdoZW4gdGhlIG5lc3RpbmcgbGV2ZWwgaXMgPiA1LlxuICovXG5leHBvcnQgY29uc3Qgc2V0VGltZW91dDAgPSAoKCkgPT4ge1xuICAgIGlmIChzZXRUaW1lb3V0MElzRmFzdGVyKSB7XG4gICAgICAgIGNvbnN0IHBlbmRpbmcgPSBbXTtcbiAgICAgICAgJGdsb2JhbFRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZS5kYXRhICYmIGUuZGF0YS52c2NvZGVTY2hlZHVsZUFzeW5jV29yaykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwZW5kaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHBlbmRpbmdbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuaWQgPT09IGUuZGF0YS52c2NvZGVTY2hlZHVsZUFzeW5jV29yaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUuY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBsYXN0SWQgPSAwO1xuICAgICAgICByZXR1cm4gKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBteUlkID0gKytsYXN0SWQ7XG4gICAgICAgICAgICBwZW5kaW5nLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBteUlkLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAkZ2xvYmFsVGhpcy5wb3N0TWVzc2FnZSh7IHZzY29kZVNjaGVkdWxlQXN5bmNXb3JrOiBteUlkIH0sICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiAoY2FsbGJhY2spID0+IHNldFRpbWVvdXQoY2FsbGJhY2spO1xufSkoKTtcbmV4cG9ydCBjb25zdCBPUyA9IChfaXNNYWNpbnRvc2ggfHwgX2lzSU9TID8gMiAvKiBPcGVyYXRpbmdTeXN0ZW0uTWFjaW50b3NoICovIDogKF9pc1dpbmRvd3MgPyAxIC8qIE9wZXJhdGluZ1N5c3RlbS5XaW5kb3dzICovIDogMyAvKiBPcGVyYXRpbmdTeXN0ZW0uTGludXggKi8pKTtcbmxldCBfaXNMaXR0bGVFbmRpYW4gPSB0cnVlO1xubGV0IF9pc0xpdHRsZUVuZGlhbkNvbXB1dGVkID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XG4gICAgaWYgKCFfaXNMaXR0bGVFbmRpYW5Db21wdXRlZCkge1xuICAgICAgICBfaXNMaXR0bGVFbmRpYW5Db21wdXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRlc3QgPSBuZXcgVWludDhBcnJheSgyKTtcbiAgICAgICAgdGVzdFswXSA9IDE7XG4gICAgICAgIHRlc3RbMV0gPSAyO1xuICAgICAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQxNkFycmF5KHRlc3QuYnVmZmVyKTtcbiAgICAgICAgX2lzTGl0dGxlRW5kaWFuID0gKHZpZXdbMF0gPT09ICgyIDw8IDgpICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBfaXNMaXR0bGVFbmRpYW47XG59XG5leHBvcnQgY29uc3QgaXNDaHJvbWUgPSAhISh1c2VyQWdlbnQgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID49IDApO1xuZXhwb3J0IGNvbnN0IGlzRmlyZWZveCA9ICEhKHVzZXJBZ2VudCAmJiB1c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID49IDApO1xuZXhwb3J0IGNvbnN0IGlzU2FmYXJpID0gISEoIWlzQ2hyb21lICYmICh1c2VyQWdlbnQgJiYgdXNlckFnZW50LmluZGV4T2YoJ1NhZmFyaScpID49IDApKTtcbmV4cG9ydCBjb25zdCBpc0VkZ2UgPSAhISh1c2VyQWdlbnQgJiYgdXNlckFnZW50LmluZGV4T2YoJ0VkZy8nKSA+PSAwKTtcbmV4cG9ydCBjb25zdCBpc0FuZHJvaWQgPSAhISh1c2VyQWdlbnQgJiYgdXNlckFnZW50LmluZGV4T2YoJ0FuZHJvaWQnKSA+PSAwKTtcbiIsImV4cG9ydCBmdW5jdGlvbiBpZGVudGl0eSh0KSB7XG4gICAgcmV0dXJuIHQ7XG59XG4vKipcbiAqIFVzZXMgYSBMUlUgY2FjaGUgdG8gbWFrZSBhIGdpdmVuIHBhcmFtZXRyaXplZCBmdW5jdGlvbiBjYWNoZWQuXG4gKiBDYWNoZXMganVzdCB0aGUgbGFzdCBrZXkvdmFsdWUuXG4qL1xuZXhwb3J0IGNsYXNzIExSVUNhY2hlZEZ1bmN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihhcmcxLCBhcmcyKSB7XG4gICAgICAgIHRoaXMubGFzdENhY2hlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxhc3RBcmdLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fZm4gPSBhcmcxO1xuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUtleSA9IGlkZW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZm4gPSBhcmcyO1xuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUtleSA9IGFyZzEuZ2V0Q2FjaGVLZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGFyZykge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl9jb21wdXRlS2V5KGFyZyk7XG4gICAgICAgIGlmICh0aGlzLmxhc3RBcmdLZXkgIT09IGtleSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0QXJnS2V5ID0ga2V5O1xuICAgICAgICAgICAgdGhpcy5sYXN0Q2FjaGUgPSB0aGlzLl9mbihhcmcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDYWNoZTtcbiAgICB9XG59XG4vKipcbiAqIFVzZXMgYW4gdW5ib3VuZGVkIGNhY2hlIHRvIG1lbW9pemUgdGhlIHJlc3VsdHMgb2YgdGhlIGdpdmVuIGZ1bmN0aW9uLlxuKi9cbmV4cG9ydCBjbGFzcyBDYWNoZWRGdW5jdGlvbiB7XG4gICAgZ2V0IGNhY2hlZFZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYXJnMSwgYXJnMikge1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX21hcDIgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5fZm4gPSBhcmcxO1xuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUtleSA9IGlkZW50aXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fZm4gPSBhcmcyO1xuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUtleSA9IGFyZzEuZ2V0Q2FjaGVLZXk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGFyZykge1xuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl9jb21wdXRlS2V5KGFyZyk7XG4gICAgICAgIGlmICh0aGlzLl9tYXAyLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwMi5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2ZuKGFyZyk7XG4gICAgICAgIHRoaXMuX21hcC5zZXQoYXJnLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuX21hcDIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgY2xhc3MgTGF6eSB7XG4gICAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICAgICAgdGhpcy5leGVjdXRvciA9IGV4ZWN1dG9yO1xuICAgICAgICB0aGlzLl9kaWRSdW4gPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGZvcmNlIGV2YWx1YXRpb24gb2YgdGhlIGxhenkgdmFsdWUgaWYgaXQgaGFzIG5vdCBiZWVuIHJlc29sdmVkIHlldC4gTGF6eSB2YWx1ZXMgYXJlIG9ubHlcbiAgICAgKiByZXNvbHZlZCBvbmNlLiBgZ2V0VmFsdWVgIHdpbGwgcmUtdGhyb3cgZXhjZXB0aW9ucyB0aGF0IGFyZSBoaXQgd2hpbGUgcmVzb2x2aW5nIHRoZSB2YWx1ZVxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kaWRSdW4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB0aGlzLmV4ZWN1dG9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kaWRSdW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9lcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5fZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHdyYXBwZWQgdmFsdWUgd2l0aG91dCBmb3JjaW5nIGV2YWx1YXRpb24uXG4gICAgICovXG4gICAgZ2V0IHJhd1ZhbHVlKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9hO1xuaW1wb3J0IHsgTFJVQ2FjaGVkRnVuY3Rpb24gfSBmcm9tICcuL2NhY2hlLmpzJztcbmltcG9ydCB7IExhenkgfSBmcm9tICcuL2xhenkuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmFsc3lPcldoaXRlc3BhY2Uoc3RyKSB7XG4gICAgaWYgKCFzdHIgfHwgdHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzdHIudHJpbSgpLmxlbmd0aCA9PT0gMDtcbn1cbmNvbnN0IF9mb3JtYXRSZWdleHAgPSAveyhcXGQrKX0vZztcbi8qKlxuICogSGVscGVyIHRvIHByb2R1Y2UgYSBzdHJpbmcgd2l0aCBhIHZhcmlhYmxlIG51bWJlciBvZiBhcmd1bWVudHMuIEluc2VydCB2YXJpYWJsZSBzZWdtZW50c1xuICogaW50byB0aGUgc3RyaW5nIHVzaW5nIHRoZSB7bn0gbm90YXRpb24gd2hlcmUgTiBpcyB0aGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IGZvbGxvd2luZyB0aGUgc3RyaW5nLlxuICogQHBhcmFtIHZhbHVlIHN0cmluZyB0byB3aGljaCBmb3JtYXR0aW5nIGlzIGFwcGxpZWRcbiAqIEBwYXJhbSBhcmdzIHJlcGxhY2VtZW50cyBmb3Ige259LWVudHJpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgLi4uYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKF9mb3JtYXRSZWdleHAsIGZ1bmN0aW9uIChtYXRjaCwgZ3JvdXApIHtcbiAgICAgICAgY29uc3QgaWR4ID0gcGFyc2VJbnQoZ3JvdXAsIDEwKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKGlkeCkgfHwgaWR4IDwgMCB8fCBpZHggPj0gYXJncy5sZW5ndGggP1xuICAgICAgICAgICAgbWF0Y2ggOlxuICAgICAgICAgICAgYXJnc1tpZHhdO1xuICAgIH0pO1xufVxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiB2YWx1ZSBzbyB0aGF0IGl0IGNhbiBiZSB1c2VkIGFzIGxpdGVyYWwgdmFsdWUgaW4gaHRtbCBhdHRyaWJ1dGVzLlxuICpcbiAqIEluIG90aGVyIHdvcmRzLCBjb21wdXRlcyBgJHZhbGAsIHN1Y2ggdGhhdCBgYXR0cmAgaW4gYDxkaXYgYXR0cj1cIiR2YWxcIiAvPmAgaGFzIHRoZSBydW50aW1lIHZhbHVlIGB2YWx1ZWAuXG4gKiBUaGlzIHByZXZlbnRzIFhTUyBpbmplY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBodG1sQXR0cmlidXRlRW5jb2RlVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvWzw+XCInJl0vZywgY2ggPT4ge1xuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgICAgICBjYXNlICc8JzogcmV0dXJuICcmbHQ7JztcbiAgICAgICAgICAgIGNhc2UgJz4nOiByZXR1cm4gJyZndDsnO1xuICAgICAgICAgICAgY2FzZSAnXCInOiByZXR1cm4gJyZxdW90Oyc7XG4gICAgICAgICAgICBjYXNlICdcXCcnOiByZXR1cm4gJyZhcG9zOyc7XG4gICAgICAgICAgICBjYXNlICcmJzogcmV0dXJuICcmYW1wOyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0pO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBIVE1MIGNoYXJhY3RlcnMgaW5zaWRlIHRoZSBzdHJpbmcgdG8gdXNlIGVudGl0aWVzIGluc3RlYWQuIE1ha2VzIHRoZSBzdHJpbmcgc2FmZSBmcm9tXG4gKiBiZWluZyB1c2VkIGUuZy4gaW4gSFRNTEVsZW1lbnQuaW5uZXJIVE1MLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlKGh0bWwpIHtcbiAgICByZXR1cm4gaHRtbC5yZXBsYWNlKC9bPD4mXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgc3dpdGNoIChtYXRjaCkge1xuICAgICAgICAgICAgY2FzZSAnPCc6IHJldHVybiAnJmx0Oyc7XG4gICAgICAgICAgICBjYXNlICc+JzogcmV0dXJuICcmZ3Q7JztcbiAgICAgICAgICAgIGNhc2UgJyYnOiByZXR1cm4gJyZhbXA7JztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLyoqXG4gKiBFc2NhcGVzIHJlZ3VsYXIgZXhwcmVzc2lvbiBjaGFyYWN0ZXJzIGluIGEgZ2l2ZW4gc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1tcXFxcXFx7XFx9XFwqXFwrXFw/XFx8XFxeXFwkXFwuXFxbXFxdXFwoXFwpXS9nLCAnXFxcXCQmJyk7XG59XG4vKipcbiAqIFJlbW92ZXMgYWxsIG9jY3VycmVuY2VzIG9mIG5lZWRsZSBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBoYXlzdGFjay5cbiAqIEBwYXJhbSBoYXlzdGFjayBzdHJpbmcgdG8gdHJpbVxuICogQHBhcmFtIG5lZWRsZSB0aGUgdGhpbmcgdG8gdHJpbSAoZGVmYXVsdCBpcyBhIGJsYW5rKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJpbShoYXlzdGFjaywgbmVlZGxlID0gJyAnKSB7XG4gICAgY29uc3QgdHJpbW1lZCA9IGx0cmltKGhheXN0YWNrLCBuZWVkbGUpO1xuICAgIHJldHVybiBydHJpbSh0cmltbWVkLCBuZWVkbGUpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBuZWVkbGUgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGhheXN0YWNrLlxuICogQHBhcmFtIGhheXN0YWNrIHN0cmluZyB0byB0cmltXG4gKiBAcGFyYW0gbmVlZGxlIHRoZSB0aGluZyB0byB0cmltXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsdHJpbShoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgaWYgKCFoYXlzdGFjayB8fCAhbmVlZGxlKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcbiAgICB9XG4gICAgY29uc3QgbmVlZGxlTGVuID0gbmVlZGxlLmxlbmd0aDtcbiAgICBpZiAobmVlZGxlTGVuID09PSAwIHx8IGhheXN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaGF5c3RhY2s7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIHdoaWxlIChoYXlzdGFjay5pbmRleE9mKG5lZWRsZSwgb2Zmc2V0KSA9PT0gb2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCArIG5lZWRsZUxlbjtcbiAgICB9XG4gICAgcmV0dXJuIGhheXN0YWNrLnN1YnN0cmluZyhvZmZzZXQpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGFsbCBvY2N1cnJlbmNlcyBvZiBuZWVkbGUgZnJvbSB0aGUgZW5kIG9mIGhheXN0YWNrLlxuICogQHBhcmFtIGhheXN0YWNrIHN0cmluZyB0byB0cmltXG4gKiBAcGFyYW0gbmVlZGxlIHRoZSB0aGluZyB0byB0cmltXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydHJpbShoYXlzdGFjaywgbmVlZGxlKSB7XG4gICAgaWYgKCFoYXlzdGFjayB8fCAhbmVlZGxlKSB7XG4gICAgICAgIHJldHVybiBoYXlzdGFjaztcbiAgICB9XG4gICAgY29uc3QgbmVlZGxlTGVuID0gbmVlZGxlLmxlbmd0aCwgaGF5c3RhY2tMZW4gPSBoYXlzdGFjay5sZW5ndGg7XG4gICAgaWYgKG5lZWRsZUxlbiA9PT0gMCB8fCBoYXlzdGFja0xlbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaGF5c3RhY2s7XG4gICAgfVxuICAgIGxldCBvZmZzZXQgPSBoYXlzdGFja0xlbiwgaWR4ID0gLTE7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWR4ID0gaGF5c3RhY2subGFzdEluZGV4T2YobmVlZGxlLCBvZmZzZXQgLSAxKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEgfHwgaWR4ICsgbmVlZGxlTGVuICE9PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpZHggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBvZmZzZXQgPSBpZHg7XG4gICAgfVxuICAgIHJldHVybiBoYXlzdGFjay5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0U2ltcGxlMlJlZ0V4cFBhdHRlcm4ocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoL1tcXC1cXFxcXFx7XFx9XFwrXFw/XFx8XFxeXFwkXFwuXFwsXFxbXFxdXFwoXFwpXFwjXFxzXS9nLCAnXFxcXCQmJykucmVwbGFjZSgvW1xcKl0vZywgJy4qJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaXBXaWxkY2FyZHMocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLnJlcGxhY2UoL1xcKi9nLCAnJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVnRXhwKHNlYXJjaFN0cmluZywgaXNSZWdleCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKCFzZWFyY2hTdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY3JlYXRlIHJlZ2V4IGZyb20gZW1wdHkgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmICghaXNSZWdleCkge1xuICAgICAgICBzZWFyY2hTdHJpbmcgPSBlc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKHNlYXJjaFN0cmluZyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndob2xlV29yZCkge1xuICAgICAgICBpZiAoIS9cXEIvLnRlc3Qoc2VhcmNoU3RyaW5nLmNoYXJBdCgwKSkpIHtcbiAgICAgICAgICAgIHNlYXJjaFN0cmluZyA9ICdcXFxcYicgKyBzZWFyY2hTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEvXFxCLy50ZXN0KHNlYXJjaFN0cmluZy5jaGFyQXQoc2VhcmNoU3RyaW5nLmxlbmd0aCAtIDEpKSkge1xuICAgICAgICAgICAgc2VhcmNoU3RyaW5nID0gc2VhcmNoU3RyaW5nICsgJ1xcXFxiJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbW9kaWZpZXJzID0gJyc7XG4gICAgaWYgKG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgICAgIG1vZGlmaWVycyArPSAnZyc7XG4gICAgfVxuICAgIGlmICghb3B0aW9ucy5tYXRjaENhc2UpIHtcbiAgICAgICAgbW9kaWZpZXJzICs9ICdpJztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMubXVsdGlsaW5lKSB7XG4gICAgICAgIG1vZGlmaWVycyArPSAnbSc7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnVuaWNvZGUpIHtcbiAgICAgICAgbW9kaWZpZXJzICs9ICd1JztcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc2VhcmNoU3RyaW5nLCBtb2RpZmllcnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlZ0V4cExlYWRzVG9FbmRsZXNzTG9vcChyZWdleHApIHtcbiAgICAvLyBFeGl0IGVhcmx5IGlmIGl0J3Mgb25lIG9mIHRoZXNlIHNwZWNpYWwgY2FzZXMgd2hpY2ggYXJlIG1lYW50IHRvIG1hdGNoXG4gICAgLy8gYWdhaW5zdCBhbiBlbXB0eSBzdHJpbmdcbiAgICBpZiAocmVnZXhwLnNvdXJjZSA9PT0gJ14nIHx8IHJlZ2V4cC5zb3VyY2UgPT09ICdeJCcgfHwgcmVnZXhwLnNvdXJjZSA9PT0gJyQnIHx8IHJlZ2V4cC5zb3VyY2UgPT09ICdeXFxcXHMqJCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBXZSBjaGVjayBhZ2FpbnN0IGFuIGVtcHR5IHN0cmluZy4gSWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBkb2Vzbid0IGFkdmFuY2VcbiAgICAvLyAoZS5nLiBlbmRzIGluIGFuIGVuZGxlc3MgbG9vcCkgaXQgd2lsbCBtYXRjaCBhbiBlbXB0eSBzdHJpbmcuXG4gICAgY29uc3QgbWF0Y2ggPSByZWdleHAuZXhlYygnJyk7XG4gICAgcmV0dXJuICEhKG1hdGNoICYmIHJlZ2V4cC5sYXN0SW5kZXggPT09IDApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0TGluZXMoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgvXFxyXFxufFxccnxcXG4vKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzcGxpdExpbmVzSW5jbHVkZVNlcGFyYXRvcnMoc3RyKSB7XG4gICAgdmFyIF9iO1xuICAgIGNvbnN0IGxpbmVzV2l0aFNlcGFyYXRvcnMgPSBbXTtcbiAgICBjb25zdCBzcGxpdExpbmVzQW5kU2VwYXJhdG9ycyA9IHN0ci5zcGxpdCgvKFxcclxcbnxcXHJ8XFxuKS8pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5jZWlsKHNwbGl0TGluZXNBbmRTZXBhcmF0b3JzLmxlbmd0aCAvIDIpOyBpKyspIHtcbiAgICAgICAgbGluZXNXaXRoU2VwYXJhdG9ycy5wdXNoKHNwbGl0TGluZXNBbmRTZXBhcmF0b3JzWzIgKiBpXSArICgoX2IgPSBzcGxpdExpbmVzQW5kU2VwYXJhdG9yc1syICogaSArIDFdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJykpO1xuICAgIH1cbiAgICByZXR1cm4gbGluZXNXaXRoU2VwYXJhdG9ycztcbn1cbi8qKlxuICogUmV0dXJucyBmaXJzdCBpbmRleCBvZiB0aGUgc3RyaW5nIHRoYXQgaXMgbm90IHdoaXRlc3BhY2UuXG4gKiBJZiBzdHJpbmcgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyAtMVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmlyc3ROb25XaGl0ZXNwYWNlSW5kZXgoc3RyKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoQ29kZSAhPT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8gJiYgY2hDb2RlICE9PSA5IC8qIENoYXJDb2RlLlRhYiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2Ugb2YgdGhlIHN0cmluZy5cbiAqIElmIHRoZSBzdHJpbmcgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyBlbnRpcmUgc3RyaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWFkaW5nV2hpdGVzcGFjZShzdHIsIHN0YXJ0ID0gMCwgZW5kID0gc3RyLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGNoQ29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoY2hDb2RlICE9PSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLyAmJiBjaENvZGUgIT09IDkgLyogQ2hhckNvZGUuVGFiICovKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyLnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG59XG4vKipcbiAqIFJldHVybnMgbGFzdCBpbmRleCBvZiB0aGUgc3RyaW5nIHRoYXQgaXMgbm90IHdoaXRlc3BhY2UuXG4gKiBJZiBzdHJpbmcgaXMgZW1wdHkgb3IgY29udGFpbnMgb25seSB3aGl0ZXNwYWNlcywgcmV0dXJucyAtMVxuICovXG5leHBvcnQgZnVuY3Rpb24gbGFzdE5vbldoaXRlc3BhY2VJbmRleChzdHIsIHN0YXJ0SW5kZXggPSBzdHIubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBjaENvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoQ29kZSAhPT0gMzIgLyogQ2hhckNvZGUuU3BhY2UgKi8gJiYgY2hDb2RlICE9PSA5IC8qIENoYXJDb2RlLlRhYiAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgIGlmIChhIDwgYikge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTdWJzdHJpbmcoYSwgYiwgYVN0YXJ0ID0gMCwgYUVuZCA9IGEubGVuZ3RoLCBiU3RhcnQgPSAwLCBiRW5kID0gYi5sZW5ndGgpIHtcbiAgICBmb3IgKDsgYVN0YXJ0IDwgYUVuZCAmJiBiU3RhcnQgPCBiRW5kOyBhU3RhcnQrKywgYlN0YXJ0KyspIHtcbiAgICAgICAgY29uc3QgY29kZUEgPSBhLmNoYXJDb2RlQXQoYVN0YXJ0KTtcbiAgICAgICAgY29uc3QgY29kZUIgPSBiLmNoYXJDb2RlQXQoYlN0YXJ0KTtcbiAgICAgICAgaWYgKGNvZGVBIDwgY29kZUIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlQSA+IGNvZGVCKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhTGVuID0gYUVuZCAtIGFTdGFydDtcbiAgICBjb25zdCBiTGVuID0gYkVuZCAtIGJTdGFydDtcbiAgICBpZiAoYUxlbiA8IGJMZW4pIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChhTGVuID4gYkxlbikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUlnbm9yZUNhc2UoYSwgYikge1xuICAgIHJldHVybiBjb21wYXJlU3Vic3RyaW5nSWdub3JlQ2FzZShhLCBiLCAwLCBhLmxlbmd0aCwgMCwgYi5sZW5ndGgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBhcmVTdWJzdHJpbmdJZ25vcmVDYXNlKGEsIGIsIGFTdGFydCA9IDAsIGFFbmQgPSBhLmxlbmd0aCwgYlN0YXJ0ID0gMCwgYkVuZCA9IGIubGVuZ3RoKSB7XG4gICAgZm9yICg7IGFTdGFydCA8IGFFbmQgJiYgYlN0YXJ0IDwgYkVuZDsgYVN0YXJ0KyssIGJTdGFydCsrKSB7XG4gICAgICAgIGxldCBjb2RlQSA9IGEuY2hhckNvZGVBdChhU3RhcnQpO1xuICAgICAgICBsZXQgY29kZUIgPSBiLmNoYXJDb2RlQXQoYlN0YXJ0KTtcbiAgICAgICAgaWYgKGNvZGVBID09PSBjb2RlQikge1xuICAgICAgICAgICAgLy8gZXF1YWxcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlQSA+PSAxMjggfHwgY29kZUIgPj0gMTI4KSB7XG4gICAgICAgICAgICAvLyBub3QgQVNDSUkgbGV0dGVycyAtPiBmYWxsYmFjayB0byBsb3dlci1jYXNpbmcgc3RyaW5nc1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmVTdWJzdHJpbmcoYS50b0xvd2VyQ2FzZSgpLCBiLnRvTG93ZXJDYXNlKCksIGFTdGFydCwgYUVuZCwgYlN0YXJ0LCBiRW5kKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtYXBwZXIgbG93ZXItY2FzZSBhc2NpaSBsZXR0ZXIgb250byB1cHBlci1jYXNlIHZhcmluYXRzXG4gICAgICAgIC8vIFs5Ny0xMjJdIChsb3dlciBhc2NpaSkgLS0+IFs2NS05MF0gKHVwcGVyIGFzY2lpKVxuICAgICAgICBpZiAoaXNMb3dlckFzY2lpTGV0dGVyKGNvZGVBKSkge1xuICAgICAgICAgICAgY29kZUEgLT0gMzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTG93ZXJBc2NpaUxldHRlcihjb2RlQikpIHtcbiAgICAgICAgICAgIGNvZGVCIC09IDMyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXBhcmUgYm90aCBjb2RlIHBvaW50c1xuICAgICAgICBjb25zdCBkaWZmID0gY29kZUEgLSBjb2RlQjtcbiAgICAgICAgaWYgKGRpZmYgPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkaWZmO1xuICAgIH1cbiAgICBjb25zdCBhTGVuID0gYUVuZCAtIGFTdGFydDtcbiAgICBjb25zdCBiTGVuID0gYkVuZCAtIGJTdGFydDtcbiAgICBpZiAoYUxlbiA8IGJMZW4pIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBlbHNlIGlmIChhTGVuID4gYkxlbikge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBc2NpaURpZ2l0KGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA0OCAvKiBDaGFyQ29kZS5EaWdpdDAgKi8gJiYgY29kZSA8PSA1NyAvKiBDaGFyQ29kZS5EaWdpdDkgKi87XG59XG5leHBvcnQgZnVuY3Rpb24gaXNMb3dlckFzY2lpTGV0dGVyKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA5NyAvKiBDaGFyQ29kZS5hICovICYmIGNvZGUgPD0gMTIyIC8qIENoYXJDb2RlLnogKi87XG59XG5leHBvcnQgZnVuY3Rpb24gaXNVcHBlckFzY2lpTGV0dGVyKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA+PSA2NSAvKiBDaGFyQ29kZS5BICovICYmIGNvZGUgPD0gOTAgLyogQ2hhckNvZGUuWiAqLztcbn1cbmV4cG9ydCBmdW5jdGlvbiBlcXVhbHNJZ25vcmVDYXNlKGEsIGIpIHtcbiAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGNvbXBhcmVTdWJzdHJpbmdJZ25vcmVDYXNlKGEsIGIpID09PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0c1dpdGhJZ25vcmVDYXNlKHN0ciwgY2FuZGlkYXRlKSB7XG4gICAgY29uc3QgY2FuZGlkYXRlTGVuZ3RoID0gY2FuZGlkYXRlLmxlbmd0aDtcbiAgICBpZiAoY2FuZGlkYXRlLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gY29tcGFyZVN1YnN0cmluZ0lnbm9yZUNhc2Uoc3RyLCBjYW5kaWRhdGUsIDAsIGNhbmRpZGF0ZUxlbmd0aCkgPT09IDA7XG59XG4vKipcbiAqIEByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGNvbW1vbiBwcmVmaXggb2YgdGhlIHR3byBzdHJpbmdzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uUHJlZml4TGVuZ3RoKGEsIGIpIHtcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoYS5jaGFyQ29kZUF0KGkpICE9PSBiLmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIGNvbW1vbiBzdWZmaXggb2YgdGhlIHR3byBzdHJpbmdzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uU3VmZml4TGVuZ3RoKGEsIGIpIHtcbiAgICBjb25zdCBsZW4gPSBNYXRoLm1pbihhLmxlbmd0aCwgYi5sZW5ndGgpO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IGFMYXN0SW5kZXggPSBhLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgYkxhc3RJbmRleCA9IGIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGEuY2hhckNvZGVBdChhTGFzdEluZGV4IC0gaSkgIT09IGIuY2hhckNvZGVBdChiTGFzdEluZGV4IC0gaSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIFNlZSBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1cnJvZ2F0ZV9wYWlyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gKDB4RDgwMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAweERCRkYpO1xufVxuLyoqXG4gKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXJyb2dhdGVfcGFpclxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb3dTdXJyb2dhdGUoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gKDB4REMwMCA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSAweERGRkYpO1xufVxuLyoqXG4gKiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TdXJyb2dhdGVfcGFpclxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUNvZGVQb2ludChoaWdoU3Vycm9nYXRlLCBsb3dTdXJyb2dhdGUpIHtcbiAgICByZXR1cm4gKChoaWdoU3Vycm9nYXRlIC0gMHhEODAwKSA8PCAxMCkgKyAobG93U3Vycm9nYXRlIC0gMHhEQzAwKSArIDB4MTAwMDA7XG59XG4vKipcbiAqIGdldCB0aGUgY29kZSBwb2ludCB0aGF0IGJlZ2lucyBhdCBvZmZzZXQgYG9mZnNldGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHRDb2RlUG9pbnQoc3RyLCBsZW4sIG9mZnNldCkge1xuICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlKSAmJiBvZmZzZXQgKyAxIDwgbGVuKSB7XG4gICAgICAgIGNvbnN0IG5leHRDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCArIDEpO1xuICAgICAgICBpZiAoaXNMb3dTdXJyb2dhdGUobmV4dENoYXJDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVDb2RlUG9pbnQoY2hhckNvZGUsIG5leHRDaGFyQ29kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xufVxuLyoqXG4gKiBnZXQgdGhlIGNvZGUgcG9pbnQgdGhhdCBlbmRzIHJpZ2h0IGJlZm9yZSBvZmZzZXQgYG9mZnNldGBcbiAqL1xuZnVuY3Rpb24gZ2V0UHJldkNvZGVQb2ludChzdHIsIG9mZnNldCkge1xuICAgIGNvbnN0IGNoYXJDb2RlID0gc3RyLmNoYXJDb2RlQXQob2Zmc2V0IC0gMSk7XG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXJDb2RlKSAmJiBvZmZzZXQgPiAxKSB7XG4gICAgICAgIGNvbnN0IHByZXZDaGFyQ29kZSA9IHN0ci5jaGFyQ29kZUF0KG9mZnNldCAtIDIpO1xuICAgICAgICBpZiAoaXNIaWdoU3Vycm9nYXRlKHByZXZDaGFyQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQ29kZVBvaW50KHByZXZDaGFyQ29kZSwgY2hhckNvZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFyQ29kZTtcbn1cbmV4cG9ydCBjbGFzcyBDb2RlUG9pbnRJdGVyYXRvciB7XG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3RyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHRoaXMuX3N0ciA9IHN0cjtcbiAgICAgICAgdGhpcy5fbGVuID0gc3RyLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgIH1cbiAgICBzZXRPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgcHJldkNvZGVQb2ludCgpIHtcbiAgICAgICAgY29uc3QgY29kZVBvaW50ID0gZ2V0UHJldkNvZGVQb2ludCh0aGlzLl9zdHIsIHRoaXMuX29mZnNldCk7XG4gICAgICAgIHRoaXMuX29mZnNldCAtPSAoY29kZVBvaW50ID49IDY1NTM2IC8qIENvbnN0YW50cy5VTklDT0RFX1NVUFBMRU1FTlRBUllfUExBTkVfQkVHSU4gKi8gPyAyIDogMSk7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgfVxuICAgIG5leHRDb2RlUG9pbnQoKSB7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludCA9IGdldE5leHRDb2RlUG9pbnQodGhpcy5fc3RyLCB0aGlzLl9sZW4sIHRoaXMuX29mZnNldCk7XG4gICAgICAgIHRoaXMuX29mZnNldCArPSAoY29kZVBvaW50ID49IDY1NTM2IC8qIENvbnN0YW50cy5VTklDT0RFX1NVUFBMRU1FTlRBUllfUExBTkVfQkVHSU4gKi8gPyAyIDogMSk7XG4gICAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgfVxuICAgIGVvbCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9vZmZzZXQgPj0gdGhpcy5fbGVuKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgR3JhcGhlbWVJdGVyYXRvciB7XG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZXJhdG9yLm9mZnNldDtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc3RyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHRoaXMuX2l0ZXJhdG9yID0gbmV3IENvZGVQb2ludEl0ZXJhdG9yKHN0ciwgb2Zmc2V0KTtcbiAgICB9XG4gICAgbmV4dEdyYXBoZW1lTGVuZ3RoKCkge1xuICAgICAgICBjb25zdCBncmFwaGVtZUJyZWFrVHJlZSA9IEdyYXBoZW1lQnJlYWtUcmVlLmdldEluc3RhbmNlKCk7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5faXRlcmF0b3I7XG4gICAgICAgIGNvbnN0IGluaXRpYWxPZmZzZXQgPSBpdGVyYXRvci5vZmZzZXQ7XG4gICAgICAgIGxldCBncmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKGl0ZXJhdG9yLm5leHRDb2RlUG9pbnQoKSk7XG4gICAgICAgIHdoaWxlICghaXRlcmF0b3IuZW9sKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGl0ZXJhdG9yLm9mZnNldDtcbiAgICAgICAgICAgIGNvbnN0IG5leHRHcmFwaGVtZUJyZWFrVHlwZSA9IGdyYXBoZW1lQnJlYWtUcmVlLmdldEdyYXBoZW1lQnJlYWtUeXBlKGl0ZXJhdG9yLm5leHRDb2RlUG9pbnQoKSk7XG4gICAgICAgICAgICBpZiAoYnJlYWtCZXR3ZWVuR3JhcGhlbWVCcmVha1R5cGUoZ3JhcGhlbWVCcmVha1R5cGUsIG5leHRHcmFwaGVtZUJyZWFrVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtb3ZlIGl0ZXJhdG9yIGJhY2tcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5zZXRPZmZzZXQob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYXBoZW1lQnJlYWtUeXBlID0gbmV4dEdyYXBoZW1lQnJlYWtUeXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaXRlcmF0b3Iub2Zmc2V0IC0gaW5pdGlhbE9mZnNldCk7XG4gICAgfVxuICAgIHByZXZHcmFwaGVtZUxlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgZ3JhcGhlbWVCcmVha1RyZWUgPSBHcmFwaGVtZUJyZWFrVHJlZS5nZXRJbnN0YW5jZSgpO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX2l0ZXJhdG9yO1xuICAgICAgICBjb25zdCBpbml0aWFsT2Zmc2V0ID0gaXRlcmF0b3Iub2Zmc2V0O1xuICAgICAgICBsZXQgZ3JhcGhlbWVCcmVha1R5cGUgPSBncmFwaGVtZUJyZWFrVHJlZS5nZXRHcmFwaGVtZUJyZWFrVHlwZShpdGVyYXRvci5wcmV2Q29kZVBvaW50KCkpO1xuICAgICAgICB3aGlsZSAoaXRlcmF0b3Iub2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gaXRlcmF0b3Iub2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgcHJldkdyYXBoZW1lQnJlYWtUeXBlID0gZ3JhcGhlbWVCcmVha1RyZWUuZ2V0R3JhcGhlbWVCcmVha1R5cGUoaXRlcmF0b3IucHJldkNvZGVQb2ludCgpKTtcbiAgICAgICAgICAgIGlmIChicmVha0JldHdlZW5HcmFwaGVtZUJyZWFrVHlwZShwcmV2R3JhcGhlbWVCcmVha1R5cGUsIGdyYXBoZW1lQnJlYWtUeXBlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1vdmUgaXRlcmF0b3IgYmFja1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yLnNldE9mZnNldChvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JhcGhlbWVCcmVha1R5cGUgPSBwcmV2R3JhcGhlbWVCcmVha1R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpbml0aWFsT2Zmc2V0IC0gaXRlcmF0b3Iub2Zmc2V0KTtcbiAgICB9XG4gICAgZW9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlcmF0b3IuZW9sKCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIG5leHRDaGFyTGVuZ3RoKHN0ciwgaW5pdGlhbE9mZnNldCkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gbmV3IEdyYXBoZW1lSXRlcmF0b3Ioc3RyLCBpbml0aWFsT2Zmc2V0KTtcbiAgICByZXR1cm4gaXRlcmF0b3IubmV4dEdyYXBoZW1lTGVuZ3RoKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJldkNoYXJMZW5ndGgoc3RyLCBpbml0aWFsT2Zmc2V0KSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSBuZXcgR3JhcGhlbWVJdGVyYXRvcihzdHIsIGluaXRpYWxPZmZzZXQpO1xuICAgIHJldHVybiBpdGVyYXRvci5wcmV2R3JhcGhlbWVMZW5ndGgoKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRDaGFyQ29udGFpbmluZ09mZnNldChzdHIsIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPiAwICYmIGlzTG93U3Vycm9nYXRlKHN0ci5jaGFyQ29kZUF0KG9mZnNldCkpKSB7XG4gICAgICAgIG9mZnNldC0tO1xuICAgIH1cbiAgICBjb25zdCBlbmRPZmZzZXQgPSBvZmZzZXQgKyBuZXh0Q2hhckxlbmd0aChzdHIsIG9mZnNldCk7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQgPSBlbmRPZmZzZXQgLSBwcmV2Q2hhckxlbmd0aChzdHIsIGVuZE9mZnNldCk7XG4gICAgcmV0dXJuIFtzdGFydE9mZnNldCwgZW5kT2Zmc2V0XTtcbn1cbmxldCBDT05UQUlOU19SVEwgPSB1bmRlZmluZWQ7XG5mdW5jdGlvbiBtYWtlQ29udGFpbnNSdGwoKSB7XG4gICAgLy8gR2VuZXJhdGVkIHVzaW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hbGV4ZGltYS91bmljb2RlLXV0aWxzL2Jsb2IvbWFpbi9ydGwtdGVzdC5qc1xuICAgIHJldHVybiAvKD86W1xcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUQwLVxcdTA1RjRcXHUwNjA4XFx1MDYwQlxcdTA2MERcXHUwNjFCLVxcdTA2NEFcXHUwNjZELVxcdTA2NkZcXHUwNjcxLVxcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNzEwXFx1MDcxMi1cXHUwNzJGXFx1MDc0RC1cXHUwN0E1XFx1MDdCMS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDdGRS1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDgzMC1cXHUwODU4XFx1MDg1RS1cXHUwODhFXFx1MDhBMC1cXHUwOEM5XFx1MjAwRlxcdUZCMURcXHVGQjFGLVxcdUZCMjhcXHVGQjJBLVxcdUZEM0RcXHVGRDUwLVxcdUZEQzdcXHVGREYwLVxcdUZERkNcXHVGRTcwLVxcdUZFRkNdfFxcdUQ4MDJbXFx1REMwMC1cXHVERDFCXFx1REQyMC1cXHVERTAwXFx1REUxMC1cXHVERTM1XFx1REU0MC1cXHVERUU0XFx1REVFQi1cXHVERjM1XFx1REY0MC1cXHVERkZGXXxcXHVEODAzW1xcdURDMDAtXFx1REQyM1xcdURFODAtXFx1REVBOVxcdURFQUQtXFx1REY0NVxcdURGNTEtXFx1REY4MVxcdURGODYtXFx1REZGNl18XFx1RDgzQVtcXHVEQzAwLVxcdURDQ0ZcXHVERDAwLVxcdURENDNcXHVERDRCLVxcdURGRkZdfFxcdUQ4M0JbXFx1REMwMC1cXHVERUJCXSkvO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHN0cmAgY29udGFpbnMgYW55IFVuaWNvZGUgY2hhcmFjdGVyIHRoYXQgaXMgY2xhc3NpZmllZCBhcyBcIlJcIiBvciBcIkFMXCIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb250YWluc1JUTChzdHIpIHtcbiAgICBpZiAoIUNPTlRBSU5TX1JUTCkge1xuICAgICAgICBDT05UQUlOU19SVEwgPSBtYWtlQ29udGFpbnNSdGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIENPTlRBSU5TX1JUTC50ZXN0KHN0cik7XG59XG5jb25zdCBJU19CQVNJQ19BU0NJSSA9IC9eW1xcdFxcblxcclxceDIwLVxceDdFXSokLztcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGBzdHJgIGNvbnRhaW5zIG9ubHkgYmFzaWMgQVNDSUkgY2hhcmFjdGVycyBpbiB0aGUgcmFuZ2UgMzIgLSAxMjYgKGluY2x1ZGluZyAzMiBhbmQgMTI2KSBvciBcXG4sIFxcciwgXFx0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jhc2ljQVNDSUkoc3RyKSB7XG4gICAgcmV0dXJuIElTX0JBU0lDX0FTQ0lJLnRlc3Qoc3RyKTtcbn1cbmV4cG9ydCBjb25zdCBVTlVTVUFMX0xJTkVfVEVSTUlOQVRPUlMgPSAvW1xcdTIwMjhcXHUyMDI5XS87IC8vIExJTkUgU0VQQVJBVE9SIChMUykgb3IgUEFSQUdSQVBIIFNFUEFSQVRPUiAoUFMpXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgc3RyYCBjb250YWlucyB1bnVzdWFsIGxpbmUgdGVybWluYXRvcnMsIGxpa2UgTFMgb3IgUFNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zVW51c3VhbExpbmVUZXJtaW5hdG9ycyhzdHIpIHtcbiAgICByZXR1cm4gVU5VU1VBTF9MSU5FX1RFUk1JTkFUT1JTLnRlc3Qoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bGxXaWR0aENoYXJhY3RlcihjaGFyQ29kZSkge1xuICAgIC8vIERvIGEgY2hlYXAgdHJpY2sgdG8gYmV0dGVyIHN1cHBvcnQgd3JhcHBpbmcgb2Ygd2lkZSBjaGFyYWN0ZXJzLCB0cmVhdCB0aGVtIGFzIDIgY29sdW1uc1xuICAgIC8vIGh0dHA6Ly9qcmdyYXBoaXgubmV0L3Jlc2VhcmNoL3VuaWNvZGVfYmxvY2tzLnBocFxuICAgIC8vICAgICAgICAgIDJFODAgLSAyRUZGICAgQ0pLIFJhZGljYWxzIFN1cHBsZW1lbnRcbiAgICAvLyAgICAgICAgICAyRjAwIC0gMkZERiAgIEthbmd4aSBSYWRpY2Fsc1xuICAgIC8vICAgICAgICAgIDJGRjAgLSAyRkZGICAgSWRlb2dyYXBoaWMgRGVzY3JpcHRpb24gQ2hhcmFjdGVyc1xuICAgIC8vICAgICAgICAgIDMwMDAgLSAzMDNGICAgQ0pLIFN5bWJvbHMgYW5kIFB1bmN0dWF0aW9uXG4gICAgLy8gICAgICAgICAgMzA0MCAtIDMwOUYgICBIaXJhZ2FuYVxuICAgIC8vICAgICAgICAgIDMwQTAgLSAzMEZGICAgS2F0YWthbmFcbiAgICAvLyAgICAgICAgICAzMTAwIC0gMzEyRiAgIEJvcG9tb2ZvXG4gICAgLy8gICAgICAgICAgMzEzMCAtIDMxOEYgICBIYW5ndWwgQ29tcGF0aWJpbGl0eSBKYW1vXG4gICAgLy8gICAgICAgICAgMzE5MCAtIDMxOUYgICBLYW5idW5cbiAgICAvLyAgICAgICAgICAzMUEwIC0gMzFCRiAgIEJvcG9tb2ZvIEV4dGVuZGVkXG4gICAgLy8gICAgICAgICAgMzFGMCAtIDMxRkYgICBLYXRha2FuYSBQaG9uZXRpYyBFeHRlbnNpb25zXG4gICAgLy8gICAgICAgICAgMzIwMCAtIDMyRkYgICBFbmNsb3NlZCBDSksgTGV0dGVycyBhbmQgTW9udGhzXG4gICAgLy8gICAgICAgICAgMzMwMCAtIDMzRkYgICBDSksgQ29tcGF0aWJpbGl0eVxuICAgIC8vICAgICAgICAgIDM0MDAgLSA0REJGICAgQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQVxuICAgIC8vICAgICAgICAgIDREQzAgLSA0REZGICAgWWlqaW5nIEhleGFncmFtIFN5bWJvbHNcbiAgICAvLyAgICAgICAgICA0RTAwIC0gOUZGRiAgIENKSyBVbmlmaWVkIElkZW9ncmFwaHNcbiAgICAvLyAgICAgICAgICBBMDAwIC0gQTQ4RiAgIFlpIFN5bGxhYmxlc1xuICAgIC8vICAgICAgICAgIEE0OTAgLSBBNENGICAgWWkgUmFkaWNhbHNcbiAgICAvLyAgICAgICAgICBBQzAwIC0gRDdBRiAgIEhhbmd1bCBTeWxsYWJsZXNcbiAgICAvLyBbSUdOT1JFXSBEODAwIC0gREI3RiAgIEhpZ2ggU3Vycm9nYXRlc1xuICAgIC8vIFtJR05PUkVdIERCODAgLSBEQkZGICAgSGlnaCBQcml2YXRlIFVzZSBTdXJyb2dhdGVzXG4gICAgLy8gW0lHTk9SRV0gREMwMCAtIERGRkYgICBMb3cgU3Vycm9nYXRlc1xuICAgIC8vIFtJR05PUkVdIEUwMDAgLSBGOEZGICAgUHJpdmF0ZSBVc2UgQXJlYVxuICAgIC8vICAgICAgICAgIEY5MDAgLSBGQUZGICAgQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBoc1xuICAgIC8vIFtJR05PUkVdIEZCMDAgLSBGQjRGICAgQWxwaGFiZXRpYyBQcmVzZW50YXRpb24gRm9ybXNcbiAgICAvLyBbSUdOT1JFXSBGQjUwIC0gRkRGRiAgIEFyYWJpYyBQcmVzZW50YXRpb24gRm9ybXMtQVxuICAgIC8vIFtJR05PUkVdIEZFMDAgLSBGRTBGICAgVmFyaWF0aW9uIFNlbGVjdG9yc1xuICAgIC8vIFtJR05PUkVdIEZFMjAgLSBGRTJGICAgQ29tYmluaW5nIEhhbGYgTWFya3NcbiAgICAvLyBbSUdOT1JFXSBGRTMwIC0gRkU0RiAgIENKSyBDb21wYXRpYmlsaXR5IEZvcm1zXG4gICAgLy8gW0lHTk9SRV0gRkU1MCAtIEZFNkYgICBTbWFsbCBGb3JtIFZhcmlhbnRzXG4gICAgLy8gW0lHTk9SRV0gRkU3MCAtIEZFRkYgICBBcmFiaWMgUHJlc2VudGF0aW9uIEZvcm1zLUJcbiAgICAvLyAgICAgICAgICBGRjAwIC0gRkZFRiAgIEhhbGZ3aWR0aCBhbmQgRnVsbHdpZHRoIEZvcm1zXG4gICAgLy8gICAgICAgICAgICAgICBbaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGFsZndpZHRoX2FuZF9mdWxsd2lkdGhfZm9ybXNdXG4gICAgLy8gICAgICAgICAgICAgICBvZiB3aGljaCBGRjAxIC0gRkY1RSBmdWxsd2lkdGggQVNDSUkgb2YgMjEgdG8gN0VcbiAgICAvLyBbSUdOT1JFXSAgICBhbmQgRkY2NSAtIEZGREMgaGFsZndpZHRoIG9mIEthdGFrYW5hIGFuZCBIYW5ndWxcbiAgICAvLyBbSUdOT1JFXSBGRkYwIC0gRkZGRiAgIFNwZWNpYWxzXG4gICAgcmV0dXJuICgoY2hhckNvZGUgPj0gMHgyRTgwICYmIGNoYXJDb2RlIDw9IDB4RDdBRilcbiAgICAgICAgfHwgKGNoYXJDb2RlID49IDB4RjkwMCAmJiBjaGFyQ29kZSA8PSAweEZBRkYpXG4gICAgICAgIHx8IChjaGFyQ29kZSA+PSAweEZGMDEgJiYgY2hhckNvZGUgPD0gMHhGRjVFKSk7XG59XG4vKipcbiAqIEEgZmFzdCBmdW5jdGlvbiAodGhlcmVmb3JlIGltcHJlY2lzZSkgdG8gY2hlY2sgaWYgY29kZSBwb2ludHMgYXJlIGVtb2ppcy5cbiAqIEdlbmVyYXRlZCB1c2luZyBodHRwczovL2dpdGh1Yi5jb20vYWxleGRpbWEvdW5pY29kZS11dGlscy9ibG9iL21haW4vZW1vamktdGVzdC5qc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFbW9qaUltcHJlY2lzZSh4KSB7XG4gICAgcmV0dXJuICgoeCA+PSAweDFGMUU2ICYmIHggPD0gMHgxRjFGRikgfHwgKHggPT09IDg5ODYpIHx8ICh4ID09PSA4OTg3KSB8fCAoeCA9PT0gOTIwMClcbiAgICAgICAgfHwgKHggPT09IDkyMDMpIHx8ICh4ID49IDk3MjggJiYgeCA8PSAxMDE3NSkgfHwgKHggPT09IDExMDg4KSB8fCAoeCA9PT0gMTEwOTMpXG4gICAgICAgIHx8ICh4ID49IDEyNzc0NCAmJiB4IDw9IDEyODU5MSkgfHwgKHggPj0gMTI4NjQwICYmIHggPD0gMTI4NzY0KVxuICAgICAgICB8fCAoeCA+PSAxMjg5OTIgJiYgeCA8PSAxMjkwMDgpIHx8ICh4ID49IDEyOTI4MCAmJiB4IDw9IDEyOTUzNSlcbiAgICAgICAgfHwgKHggPj0gMTI5NjQ4ICYmIHggPD0gMTI5NzgyKSk7XG59XG4vLyAtLSBVVEYtOCBCT01cbmV4cG9ydCBjb25zdCBVVEY4X0JPTV9DSEFSQUNURVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1Mjc5IC8qIENoYXJDb2RlLlVURjhfQk9NICovKTtcbmV4cG9ydCBmdW5jdGlvbiBzdGFydHNXaXRoVVRGOEJPTShzdHIpIHtcbiAgICByZXR1cm4gISEoc3RyICYmIHN0ci5sZW5ndGggPiAwICYmIHN0ci5jaGFyQ29kZUF0KDApID09PSA2NTI3OSAvKiBDaGFyQ29kZS5VVEY4X0JPTSAqLyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29udGFpbnNVcHBlcmNhc2VDaGFyYWN0ZXIodGFyZ2V0LCBpZ25vcmVFc2NhcGVkQ2hhcnMgPSBmYWxzZSkge1xuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGlnbm9yZUVzY2FwZWRDaGFycykge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQucmVwbGFjZSgvXFxcXC4vZywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LnRvTG93ZXJDYXNlKCkgIT09IHRhcmdldDtcbn1cbi8qKlxuICogUHJvZHVjZXMgJ2EnLSd6JywgZm9sbG93ZWQgYnkgJ0EnLSdaJy4uLiBmb2xsb3dlZCBieSAnYSctJ3onLCBldGMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaW5nbGVMZXR0ZXJIYXNoKG4pIHtcbiAgICBjb25zdCBMRVRURVJTX0NOVCA9ICg5MCAvKiBDaGFyQ29kZS5aICovIC0gNjUgLyogQ2hhckNvZGUuQSAqLyArIDEpO1xuICAgIG4gPSBuICUgKDIgKiBMRVRURVJTX0NOVCk7XG4gICAgaWYgKG4gPCBMRVRURVJTX0NOVCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyAvKiBDaGFyQ29kZS5hICovICsgbik7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1IC8qIENoYXJDb2RlLkEgKi8gKyBuIC0gTEVUVEVSU19DTlQpO1xufVxuZnVuY3Rpb24gYnJlYWtCZXR3ZWVuR3JhcGhlbWVCcmVha1R5cGUoYnJlYWtUeXBlQSwgYnJlYWtUeXBlQikge1xuICAgIC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjI5LyNHcmFwaGVtZV9DbHVzdGVyX0JvdW5kYXJ5X1J1bGVzXG4gICAgLy8gISEhIExldCdzIG1ha2UgdGhlIGNvbW1vbiBjYXNlIGEgYml0IGZhc3RlclxuICAgIGlmIChicmVha1R5cGVBID09PSAwIC8qIEdyYXBoZW1lQnJlYWtUeXBlLk90aGVyICovKSB7XG4gICAgICAgIC8vIHNlZSBodHRwczovL3d3dy51bmljb2RlLm9yZy9QdWJsaWMvMTMuMC4wL3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QtMTMuMC4wZDEwLmh0bWwjdGFibGVcbiAgICAgICAgcmV0dXJuIChicmVha1R5cGVCICE9PSA1IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkV4dGVuZCAqLyAmJiBicmVha1R5cGVCICE9PSA3IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlNwYWNpbmdNYXJrICovKTtcbiAgICB9XG4gICAgLy8gRG8gbm90IGJyZWFrIGJldHdlZW4gYSBDUiBhbmQgTEYuIE90aGVyd2lzZSwgYnJlYWsgYmVmb3JlIGFuZCBhZnRlciBjb250cm9scy5cbiAgICAvLyBHQjMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ1Igw5cgTEZcbiAgICAvLyBHQjQgICAgICAgICAgICAgICAgICAgICAgIChDb250cm9sIHwgQ1IgfCBMRikgw7dcbiAgICAvLyBHQjUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgw7cgKENvbnRyb2wgfCBDUiB8IExGKVxuICAgIGlmIChicmVha1R5cGVBID09PSAyIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkNSICovKSB7XG4gICAgICAgIGlmIChicmVha1R5cGVCID09PSAzIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkxGICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCM1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChicmVha1R5cGVBID09PSA0IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkNvbnRyb2wgKi8gfHwgYnJlYWtUeXBlQSA9PT0gMiAvKiBHcmFwaGVtZUJyZWFrVHlwZS5DUiAqLyB8fCBicmVha1R5cGVBID09PSAzIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkxGICovKSB7XG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBHQjRcbiAgICB9XG4gICAgaWYgKGJyZWFrVHlwZUIgPT09IDQgLyogR3JhcGhlbWVCcmVha1R5cGUuQ29udHJvbCAqLyB8fCBicmVha1R5cGVCID09PSAyIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkNSICovIHx8IGJyZWFrVHlwZUIgPT09IDMgLyogR3JhcGhlbWVCcmVha1R5cGUuTEYgKi8pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7IC8vIEdCNVxuICAgIH1cbiAgICAvLyBEbyBub3QgYnJlYWsgSGFuZ3VsIHN5bGxhYmxlIHNlcXVlbmNlcy5cbiAgICAvLyBHQjYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEwgw5cgKEwgfCBWIHwgTFYgfCBMVlQpXG4gICAgLy8gR0I3ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChMViB8IFYpIMOXIChWIHwgVClcbiAgICAvLyBHQjggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoTFZUIHwgVCkgw5cgVFxuICAgIGlmIChicmVha1R5cGVBID09PSA4IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkwgKi8pIHtcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDggLyogR3JhcGhlbWVCcmVha1R5cGUuTCAqLyB8fCBicmVha1R5cGVCID09PSA5IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlYgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMTEgLyogR3JhcGhlbWVCcmVha1R5cGUuTFYgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMTIgLyogR3JhcGhlbWVCcmVha1R5cGUuTFZUICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCNlxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChicmVha1R5cGVBID09PSAxMSAvKiBHcmFwaGVtZUJyZWFrVHlwZS5MViAqLyB8fCBicmVha1R5cGVBID09PSA5IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlYgKi8pIHtcbiAgICAgICAgaWYgKGJyZWFrVHlwZUIgPT09IDkgLyogR3JhcGhlbWVCcmVha1R5cGUuViAqLyB8fCBicmVha1R5cGVCID09PSAxMCAvKiBHcmFwaGVtZUJyZWFrVHlwZS5UICovKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCN1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChicmVha1R5cGVBID09PSAxMiAvKiBHcmFwaGVtZUJyZWFrVHlwZS5MVlQgKi8gfHwgYnJlYWtUeXBlQSA9PT0gMTAgLyogR3JhcGhlbWVCcmVha1R5cGUuVCAqLykge1xuICAgICAgICBpZiAoYnJlYWtUeXBlQiA9PT0gMTAgLyogR3JhcGhlbWVCcmVha1R5cGUuVCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjhcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEbyBub3QgYnJlYWsgYmVmb3JlIGV4dGVuZGluZyBjaGFyYWN0ZXJzIG9yIFpXSi5cbiAgICAvLyBHQjkgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgw5cgKEV4dGVuZCB8IFpXSilcbiAgICBpZiAoYnJlYWtUeXBlQiA9PT0gNSAvKiBHcmFwaGVtZUJyZWFrVHlwZS5FeHRlbmQgKi8gfHwgYnJlYWtUeXBlQiA9PT0gMTMgLyogR3JhcGhlbWVCcmVha1R5cGUuWldKICovKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gR0I5XG4gICAgfVxuICAgIC8vIFRoZSBHQjlhIGFuZCBHQjliIHJ1bGVzIG9ubHkgYXBwbHkgdG8gZXh0ZW5kZWQgZ3JhcGhlbWUgY2x1c3RlcnM6XG4gICAgLy8gRG8gbm90IGJyZWFrIGJlZm9yZSBTcGFjaW5nTWFya3MsIG9yIGFmdGVyIFByZXBlbmQgY2hhcmFjdGVycy5cbiAgICAvLyBHQjlhICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgw5cgU3BhY2luZ01hcmtcbiAgICAvLyBHQjliICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFByZXBlbmQgw5dcbiAgICBpZiAoYnJlYWtUeXBlQiA9PT0gNyAvKiBHcmFwaGVtZUJyZWFrVHlwZS5TcGFjaW5nTWFyayAqLykge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCOWFcbiAgICB9XG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDEgLyogR3JhcGhlbWVCcmVha1R5cGUuUHJlcGVuZCAqLykge1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCOWJcbiAgICB9XG4gICAgLy8gRG8gbm90IGJyZWFrIHdpdGhpbiBlbW9qaSBtb2RpZmllciBzZXF1ZW5jZXMgb3IgZW1vamkgendqIHNlcXVlbmNlcy5cbiAgICAvLyBHQjExICAgIFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9IEV4dGVuZCogWldKIMOXIFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9XG4gICAgaWYgKGJyZWFrVHlwZUEgPT09IDEzIC8qIEdyYXBoZW1lQnJlYWtUeXBlLlpXSiAqLyAmJiBicmVha1R5cGVCID09PSAxNCAvKiBHcmFwaGVtZUJyZWFrVHlwZS5FeHRlbmRlZF9QaWN0b2dyYXBoaWMgKi8pIHtcbiAgICAgICAgLy8gTm90ZTogd2UgYXJlIG5vdCBpbXBsZW1lbnRpbmcgdGhlIHJ1bGUgZW50aXJlbHkgaGVyZSB0byBhdm9pZCBpbnRyb2R1Y2luZyBzdGF0ZXNcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBHQjExXG4gICAgfVxuICAgIC8vIEdCMTIgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdCAoUkkgUkkpKiBSSSDDlyBSSVxuICAgIC8vIEdCMTMgICAgICAgICAgICAgICAgICAgICAgICBbXlJJXSAoUkkgUkkpKiBSSSDDlyBSSVxuICAgIGlmIChicmVha1R5cGVBID09PSA2IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlJlZ2lvbmFsX0luZGljYXRvciAqLyAmJiBicmVha1R5cGVCID09PSA2IC8qIEdyYXBoZW1lQnJlYWtUeXBlLlJlZ2lvbmFsX0luZGljYXRvciAqLykge1xuICAgICAgICAvLyBOb3RlOiB3ZSBhcmUgbm90IGltcGxlbWVudGluZyB0aGUgcnVsZSBlbnRpcmVseSBoZXJlIHRvIGF2b2lkIGludHJvZHVjaW5nIHN0YXRlc1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIEdCMTIgJiBHQjEzXG4gICAgfVxuICAgIC8vIEdCOTk5ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFueSDDtyBBbnlcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIEdyYXBoZW1lQnJlYWtUcmVlIHtcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIGlmICghR3JhcGhlbWVCcmVha1RyZWUuX0lOU1RBTkNFKSB7XG4gICAgICAgICAgICBHcmFwaGVtZUJyZWFrVHJlZS5fSU5TVEFOQ0UgPSBuZXcgR3JhcGhlbWVCcmVha1RyZWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gR3JhcGhlbWVCcmVha1RyZWUuX0lOU1RBTkNFO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IGdldEdyYXBoZW1lQnJlYWtSYXdEYXRhKCk7XG4gICAgfVxuICAgIGdldEdyYXBoZW1lQnJlYWtUeXBlKGNvZGVQb2ludCkge1xuICAgICAgICAvLyAhISEgTGV0J3MgbWFrZSA3Yml0IEFTQ0lJIGEgYml0IGZhc3RlcjogMC4uMzFcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50ID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIEdyYXBoZW1lQnJlYWtUeXBlLkxGICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMiAvKiBHcmFwaGVtZUJyZWFrVHlwZS5DUiAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiA0IC8qIEdyYXBoZW1lQnJlYWtUeXBlLkNvbnRyb2wgKi87XG4gICAgICAgIH1cbiAgICAgICAgLy8gISEhIExldCdzIG1ha2UgN2JpdCBBU0NJSSBhIGJpdCBmYXN0ZXI6IDMyLi4xMjZcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDEyNykge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogR3JhcGhlbWVCcmVha1R5cGUuT3RoZXIgKi87XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgICAgIGNvbnN0IG5vZGVDb3VudCA9IGRhdGEubGVuZ3RoIC8gMztcbiAgICAgICAgbGV0IG5vZGVJbmRleCA9IDE7XG4gICAgICAgIHdoaWxlIChub2RlSW5kZXggPD0gbm9kZUNvdW50KSB7XG4gICAgICAgICAgICBpZiAoY29kZVBvaW50IDwgZGF0YVszICogbm9kZUluZGV4XSkge1xuICAgICAgICAgICAgICAgIC8vIGdvIGxlZnRcbiAgICAgICAgICAgICAgICBub2RlSW5kZXggPSAyICogbm9kZUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29kZVBvaW50ID4gZGF0YVszICogbm9kZUluZGV4ICsgMV0pIHtcbiAgICAgICAgICAgICAgICAvLyBnbyByaWdodFxuICAgICAgICAgICAgICAgIG5vZGVJbmRleCA9IDIgKiBub2RlSW5kZXggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaGl0XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFbMyAqIG5vZGVJbmRleCArIDJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwIC8qIEdyYXBoZW1lQnJlYWtUeXBlLk90aGVyICovO1xuICAgIH1cbn1cbkdyYXBoZW1lQnJlYWtUcmVlLl9JTlNUQU5DRSA9IG51bGw7XG5mdW5jdGlvbiBnZXRHcmFwaGVtZUJyZWFrUmF3RGF0YSgpIHtcbiAgICAvLyBnZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FsZXhkaW1hL3VuaWNvZGUtdXRpbHMvYmxvYi9tYWluL2dyYXBoZW1lLWJyZWFrLmpzXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoJ1swLDAsMCw1MTIyOSw1MTI1NSwxMiw0NDA2MSw0NDA4NywxMiwxMjc0NjIsMTI3NDg3LDYsNzA4Myw3MDg1LDUsNDc2NDUsNDc2NzEsMTIsNTQ4MTMsNTQ4MzksMTIsMTI4Njc4LDEyODY3OCwxNCwzMjcwLDMyNzAsNSw5OTE5LDk5MjMsMTQsNDU4NTMsNDU4NzksMTIsNDk0MzcsNDk0NjMsMTIsNTMwMjEsNTMwNDcsMTIsNzEyMTYsNzEyMTgsNywxMjgzOTgsMTI4Mzk5LDE0LDEyOTM2MCwxMjkzNzQsMTQsMjUxOSwyNTE5LDUsNDQ0OCw0NTE5LDksOTc0Miw5NzQyLDE0LDEyMzM2LDEyMzM2LDE0LDQ0OTU3LDQ0OTgzLDEyLDQ2NzQ5LDQ2Nzc1LDEyLDQ4NTQxLDQ4NTY3LDEyLDUwMzMzLDUwMzU5LDEyLDUyMTI1LDUyMTUxLDEyLDUzOTE3LDUzOTQzLDEyLDY5ODg4LDY5ODkwLDUsNzMwMTgsNzMwMTgsNSwxMjc5OTAsMTI3OTkwLDE0LDEyODU1OCwxMjg1NTksMTQsMTI4NzU5LDEyODc2MCwxNCwxMjk2NTMsMTI5NjU1LDE0LDIwMjcsMjAzNSw1LDI4OTEsMjg5Miw3LDM3NjEsMzc2MSw1LDY2ODMsNjY4Myw1LDgyOTMsODI5Myw0LDk4MjUsOTgyNiwxNCw5OTk5LDk5OTksMTQsNDM0NTIsNDM0NTMsNSw0NDUwOSw0NDUzNSwxMiw0NTQwNSw0NTQzMSwxMiw0NjMwMSw0NjMyNywxMiw0NzE5Nyw0NzIyMywxMiw0ODA5Myw0ODExOSwxMiw0ODk4OSw0OTAxNSwxMiw0OTg4NSw0OTkxMSwxMiw1MDc4MSw1MDgwNywxMiw1MTY3Nyw1MTcwMywxMiw1MjU3Myw1MjU5OSwxMiw1MzQ2OSw1MzQ5NSwxMiw1NDM2NSw1NDM5MSwxMiw2NTI3OSw2NTI3OSw0LDcwNDcxLDcwNDcyLDcsNzIxNDUsNzIxNDcsNywxMTkxNzMsMTE5MTc5LDUsMTI3Nzk5LDEyNzgxOCwxNCwxMjgyNDAsMTI4MjQ0LDE0LDEyODUxMiwxMjg1MTIsMTQsMTI4NjUyLDEyODY1MiwxNCwxMjg3MjEsMTI4NzIyLDE0LDEyOTI5MiwxMjkyOTIsMTQsMTI5NDQ1LDEyOTQ1MCwxNCwxMjk3MzQsMTI5NzQzLDE0LDE0NzYsMTQ3Nyw1LDIzNjYsMjM2OCw3LDI3NTAsMjc1Miw3LDMwNzYsMzA3Niw1LDM0MTUsMzQxNSw1LDQxNDEsNDE0NCw1LDYxMDksNjEwOSw1LDY5NjQsNjk2NCw1LDczOTQsNzQwMCw1LDkxOTcsOTE5OCwxNCw5NzcwLDk3NzAsMTQsOTg3Nyw5ODc3LDE0LDk5NjgsOTk2OSwxNCwxMDA4NCwxMDA4NCwxNCw0MzA1Miw0MzA1Miw1LDQzNzEzLDQzNzEzLDUsNDQyODUsNDQzMTEsMTIsNDQ3MzMsNDQ3NTksMTIsNDUxODEsNDUyMDcsMTIsNDU2MjksNDU2NTUsMTIsNDYwNzcsNDYxMDMsMTIsNDY1MjUsNDY1NTEsMTIsNDY5NzMsNDY5OTksMTIsNDc0MjEsNDc0NDcsMTIsNDc4NjksNDc4OTUsMTIsNDgzMTcsNDgzNDMsMTIsNDg3NjUsNDg3OTEsMTIsNDkyMTMsNDkyMzksMTIsNDk2NjEsNDk2ODcsMTIsNTAxMDksNTAxMzUsMTIsNTA1NTcsNTA1ODMsMTIsNTEwMDUsNTEwMzEsMTIsNTE0NTMsNTE0NzksMTIsNTE5MDEsNTE5MjcsMTIsNTIzNDksNTIzNzUsMTIsNTI3OTcsNTI4MjMsMTIsNTMyNDUsNTMyNzEsMTIsNTM2OTMsNTM3MTksMTIsNTQxNDEsNTQxNjcsMTIsNTQ1ODksNTQ2MTUsMTIsNTUwMzcsNTUwNjMsMTIsNjk1MDYsNjk1MDksNSw3MDE5MSw3MDE5Myw1LDcwODQxLDcwODQxLDcsNzE0NjMsNzE0NjcsNSw3MjMzMCw3MjM0Miw1LDk0MDMxLDk0MDMxLDUsMTIzNjI4LDEyMzYzMSw1LDEyNzc2MywxMjc3NjUsMTQsMTI3OTQxLDEyNzk0MSwxNCwxMjgwNDMsMTI4MDYyLDE0LDEyODMwMiwxMjgzMTcsMTQsMTI4NDY1LDEyODQ2NywxNCwxMjg1MzksMTI4NTM5LDE0LDEyODY0MCwxMjg2NDAsMTQsMTI4NjYyLDEyODY2MiwxNCwxMjg3MDMsMTI4NzAzLDE0LDEyODc0NSwxMjg3NDUsMTQsMTI5MDA0LDEyOTAwNywxNCwxMjkzMjksMTI5MzMwLDE0LDEyOTQwMiwxMjk0MDIsMTQsMTI5NDgzLDEyOTQ4MywxNCwxMjk2ODYsMTI5NzA0LDE0LDEzMDA0OCwxMzEwNjksMTQsMTczLDE3Myw0LDE3NTcsMTc1NywxLDIyMDAsMjIwNyw1LDI0MzQsMjQzNSw3LDI2MzEsMjYzMiw1LDI4MTcsMjgxNyw1LDMwMDgsMzAwOCw1LDMyMDEsMzIwMSw1LDMzODcsMzM4OCw1LDM1NDIsMzU0Miw1LDM5MDIsMzkwMyw3LDQxOTAsNDE5Miw1LDYwMDIsNjAwMyw1LDY0MzksNjQ0MCw1LDY3NjUsNjc3MCw3LDcwMTksNzAyNyw1LDcxNTQsNzE1NSw3LDgyMDUsODIwNSwxMyw4NTA1LDg1MDUsMTQsOTY1NCw5NjU0LDE0LDk3NTcsOTc1NywxNCw5NzkyLDk3OTIsMTQsOTg1Miw5ODUzLDE0LDk4OTAsOTg5NCwxNCw5OTM3LDk5MzcsMTQsOTk4MSw5OTgxLDE0LDEwMDM1LDEwMDM2LDE0LDExMDM1LDExMDM2LDE0LDQyNjU0LDQyNjU1LDUsNDMzNDYsNDMzNDcsNyw0MzU4Nyw0MzU4Nyw1LDQ0MDA2LDQ0MDA3LDcsNDQxNzMsNDQxOTksMTIsNDQzOTcsNDQ0MjMsMTIsNDQ2MjEsNDQ2NDcsMTIsNDQ4NDUsNDQ4NzEsMTIsNDUwNjksNDUwOTUsMTIsNDUyOTMsNDUzMTksMTIsNDU1MTcsNDU1NDMsMTIsNDU3NDEsNDU3NjcsMTIsNDU5NjUsNDU5OTEsMTIsNDYxODksNDYyMTUsMTIsNDY0MTMsNDY0MzksMTIsNDY2MzcsNDY2NjMsMTIsNDY4NjEsNDY4ODcsMTIsNDcwODUsNDcxMTEsMTIsNDczMDksNDczMzUsMTIsNDc1MzMsNDc1NTksMTIsNDc3NTcsNDc3ODMsMTIsNDc5ODEsNDgwMDcsMTIsNDgyMDUsNDgyMzEsMTIsNDg0MjksNDg0NTUsMTIsNDg2NTMsNDg2NzksMTIsNDg4NzcsNDg5MDMsMTIsNDkxMDEsNDkxMjcsMTIsNDkzMjUsNDkzNTEsMTIsNDk1NDksNDk1NzUsMTIsNDk3NzMsNDk3OTksMTIsNDk5OTcsNTAwMjMsMTIsNTAyMjEsNTAyNDcsMTIsNTA0NDUsNTA0NzEsMTIsNTA2NjksNTA2OTUsMTIsNTA4OTMsNTA5MTksMTIsNTExMTcsNTExNDMsMTIsNTEzNDEsNTEzNjcsMTIsNTE1NjUsNTE1OTEsMTIsNTE3ODksNTE4MTUsMTIsNTIwMTMsNTIwMzksMTIsNTIyMzcsNTIyNjMsMTIsNTI0NjEsNTI0ODcsMTIsNTI2ODUsNTI3MTEsMTIsNTI5MDksNTI5MzUsMTIsNTMxMzMsNTMxNTksMTIsNTMzNTcsNTMzODMsMTIsNTM1ODEsNTM2MDcsMTIsNTM4MDUsNTM4MzEsMTIsNTQwMjksNTQwNTUsMTIsNTQyNTMsNTQyNzksMTIsNTQ0NzcsNTQ1MDMsMTIsNTQ3MDEsNTQ3MjcsMTIsNTQ5MjUsNTQ5NTEsMTIsNTUxNDksNTUxNzUsMTIsNjgxMDEsNjgxMDIsNSw2OTc2Miw2OTc2Miw3LDcwMDY3LDcwMDY5LDcsNzAzNzEsNzAzNzgsNSw3MDcyMCw3MDcyMSw3LDcxMDg3LDcxMDg3LDUsNzEzNDEsNzEzNDEsNSw3MTk5NSw3MTk5Niw1LDcyMjQ5LDcyMjQ5LDcsNzI4NTAsNzI4NzEsNSw3MzEwOSw3MzEwOSw1LDExODU3NiwxMTg1OTgsNSwxMjE1MDUsMTIxNTE5LDUsMTI3MjQ1LDEyNzI0NywxNCwxMjc1NjgsMTI3NTY5LDE0LDEyNzc3NywxMjc3NzcsMTQsMTI3ODcyLDEyNzg5MSwxNCwxMjc5NTYsMTI3OTY3LDE0LDEyODAxNSwxMjgwMTYsMTQsMTI4MTEwLDEyODE3MiwxNCwxMjgyNTksMTI4MjU5LDE0LDEyODM2NywxMjgzNjgsMTQsMTI4NDI0LDEyODQyNCwxNCwxMjg0ODgsMTI4NDg4LDE0LDEyODUzMCwxMjg1MzIsMTQsMTI4NTUwLDEyODU1MSwxNCwxMjg1NjYsMTI4NTY2LDE0LDEyODY0NywxMjg2NDcsMTQsMTI4NjU2LDEyODY1NiwxNCwxMjg2NjcsMTI4NjczLDE0LDEyODY5MSwxMjg2OTMsMTQsMTI4NzE1LDEyODcxNSwxNCwxMjg3MjgsMTI4NzMyLDE0LDEyODc1MiwxMjg3NTIsMTQsMTI4NzY1LDEyODc2NywxNCwxMjkwOTYsMTI5MTAzLDE0LDEyOTMxMSwxMjkzMTEsMTQsMTI5MzQ0LDEyOTM0OSwxNCwxMjkzOTQsMTI5Mzk0LDE0LDEyOTQxMywxMjk0MjUsMTQsMTI5NDY2LDEyOTQ3MSwxNCwxMjk1MTEsMTI5NTM1LDE0LDEyOTY2NCwxMjk2NjYsMTQsMTI5NzE5LDEyOTcyMiwxNCwxMjk3NjAsMTI5NzY3LDE0LDkxNzUzNiw5MTc2MzEsNSwxMywxMywyLDExNjAsMTE2MSw1LDE1NjQsMTU2NCw0LDE4MDcsMTgwNywxLDIwODUsMjA4Nyw1LDIzMDcsMjMwNyw3LDIzODIsMjM4Myw3LDI0OTcsMjUwMCw1LDI1NjMsMjU2Myw3LDI2NzcsMjY3Nyw1LDI3NjMsMjc2NCw3LDI4NzksMjg3OSw1LDI5MTQsMjkxNSw1LDMwMjEsMzAyMSw1LDMxNDIsMzE0NCw1LDMyNjMsMzI2Myw1LDMyODUsMzI4Niw1LDMzOTgsMzQwMCw3LDM1MzAsMzUzMCw1LDM2MzMsMzYzMyw1LDM4NjQsMzg2NSw1LDM5NzQsMzk3NSw1LDQxNTUsNDE1Niw3LDQyMjksNDIzMCw1LDU5MDksNTkwOSw3LDYwNzgsNjA4NSw3LDYyNzcsNjI3OCw1LDY0NTEsNjQ1Niw3LDY3NDQsNjc1MCw1LDY4NDYsNjg0Niw1LDY5NzIsNjk3Miw1LDcwNzQsNzA3Nyw1LDcxNDYsNzE0OCw3LDcyMjIsNzIyMyw1LDc0MTYsNzQxNyw1LDgyMzQsODIzOCw0LDg0MTcsODQxNyw1LDkwMDAsOTAwMCwxNCw5MjAzLDkyMDMsMTQsOTczMCw5NzMxLDE0LDk3NDgsOTc0OSwxNCw5NzYyLDk3NjMsMTQsOTc3Niw5NzgzLDE0LDk4MDAsOTgxMSwxNCw5ODMxLDk4MzEsMTQsOTg3Miw5ODczLDE0LDk4ODIsOTg4MiwxNCw5OTAwLDk5MDMsMTQsOTkyOSw5OTMzLDE0LDk5NDEsOTk2MCwxNCw5OTc0LDk5NzQsMTQsOTk4OSw5OTg5LDE0LDEwMDA2LDEwMDA2LDE0LDEwMDYyLDEwMDYyLDE0LDEwMTYwLDEwMTYwLDE0LDExNjQ3LDExNjQ3LDUsMTI5NTMsMTI5NTMsMTQsNDMwMTksNDMwMTksNSw0MzIzMiw0MzI0OSw1LDQzNDQzLDQzNDQzLDUsNDM1NjcsNDM1NjgsNyw0MzY5Niw0MzY5Niw1LDQzNzY1LDQzNzY1LDcsNDQwMTMsNDQwMTMsNSw0NDExNyw0NDE0MywxMiw0NDIyOSw0NDI1NSwxMiw0NDM0MSw0NDM2NywxMiw0NDQ1Myw0NDQ3OSwxMiw0NDU2NSw0NDU5MSwxMiw0NDY3Nyw0NDcwMywxMiw0NDc4OSw0NDgxNSwxMiw0NDkwMSw0NDkyNywxMiw0NTAxMyw0NTAzOSwxMiw0NTEyNSw0NTE1MSwxMiw0NTIzNyw0NTI2MywxMiw0NTM0OSw0NTM3NSwxMiw0NTQ2MSw0NTQ4NywxMiw0NTU3Myw0NTU5OSwxMiw0NTY4NSw0NTcxMSwxMiw0NTc5Nyw0NTgyMywxMiw0NTkwOSw0NTkzNSwxMiw0NjAyMSw0NjA0NywxMiw0NjEzMyw0NjE1OSwxMiw0NjI0NSw0NjI3MSwxMiw0NjM1Nyw0NjM4MywxMiw0NjQ2OSw0NjQ5NSwxMiw0NjU4MSw0NjYwNywxMiw0NjY5Myw0NjcxOSwxMiw0NjgwNSw0NjgzMSwxMiw0NjkxNyw0Njk0MywxMiw0NzAyOSw0NzA1NSwxMiw0NzE0MSw0NzE2NywxMiw0NzI1Myw0NzI3OSwxMiw0NzM2NSw0NzM5MSwxMiw0NzQ3Nyw0NzUwMywxMiw0NzU4OSw0NzYxNSwxMiw0NzcwMSw0NzcyNywxMiw0NzgxMyw0NzgzOSwxMiw0NzkyNSw0Nzk1MSwxMiw0ODAzNyw0ODA2MywxMiw0ODE0OSw0ODE3NSwxMiw0ODI2MSw0ODI4NywxMiw0ODM3Myw0ODM5OSwxMiw0ODQ4NSw0ODUxMSwxMiw0ODU5Nyw0ODYyMywxMiw0ODcwOSw0ODczNSwxMiw0ODgyMSw0ODg0NywxMiw0ODkzMyw0ODk1OSwxMiw0OTA0NSw0OTA3MSwxMiw0OTE1Nyw0OTE4MywxMiw0OTI2OSw0OTI5NSwxMiw0OTM4MSw0OTQwNywxMiw0OTQ5Myw0OTUxOSwxMiw0OTYwNSw0OTYzMSwxMiw0OTcxNyw0OTc0MywxMiw0OTgyOSw0OTg1NSwxMiw0OTk0MSw0OTk2NywxMiw1MDA1Myw1MDA3OSwxMiw1MDE2NSw1MDE5MSwxMiw1MDI3Nyw1MDMwMywxMiw1MDM4OSw1MDQxNSwxMiw1MDUwMSw1MDUyNywxMiw1MDYxMyw1MDYzOSwxMiw1MDcyNSw1MDc1MSwxMiw1MDgzNyw1MDg2MywxMiw1MDk0OSw1MDk3NSwxMiw1MTA2MSw1MTA4NywxMiw1MTE3Myw1MTE5OSwxMiw1MTI4NSw1MTMxMSwxMiw1MTM5Nyw1MTQyMywxMiw1MTUwOSw1MTUzNSwxMiw1MTYyMSw1MTY0NywxMiw1MTczMyw1MTc1OSwxMiw1MTg0NSw1MTg3MSwxMiw1MTk1Nyw1MTk4MywxMiw1MjA2OSw1MjA5NSwxMiw1MjE4MSw1MjIwNywxMiw1MjI5Myw1MjMxOSwxMiw1MjQwNSw1MjQzMSwxMiw1MjUxNyw1MjU0MywxMiw1MjYyOSw1MjY1NSwxMiw1Mjc0MSw1Mjc2NywxMiw1Mjg1Myw1Mjg3OSwxMiw1Mjk2NSw1Mjk5MSwxMiw1MzA3Nyw1MzEwMywxMiw1MzE4OSw1MzIxNSwxMiw1MzMwMSw1MzMyNywxMiw1MzQxMyw1MzQzOSwxMiw1MzUyNSw1MzU1MSwxMiw1MzYzNyw1MzY2MywxMiw1Mzc0OSw1Mzc3NSwxMiw1Mzg2MSw1Mzg4NywxMiw1Mzk3Myw1Mzk5OSwxMiw1NDA4NSw1NDExMSwxMiw1NDE5Nyw1NDIyMywxMiw1NDMwOSw1NDMzNSwxMiw1NDQyMSw1NDQ0NywxMiw1NDUzMyw1NDU1OSwxMiw1NDY0NSw1NDY3MSwxMiw1NDc1Nyw1NDc4MywxMiw1NDg2OSw1NDg5NSwxMiw1NDk4MSw1NTAwNywxMiw1NTA5Myw1NTExOSwxMiw1NTI0Myw1NTI5MSwxMCw2NjA0NSw2NjA0NSw1LDY4MzI1LDY4MzI2LDUsNjk2ODgsNjk3MDIsNSw2OTgxNyw2OTgxOCw1LDY5OTU3LDY5OTU4LDcsNzAwODksNzAwOTIsNSw3MDE5OCw3MDE5OSw1LDcwNDYyLDcwNDYyLDUsNzA1MDIsNzA1MDgsNSw3MDc1MCw3MDc1MCw1LDcwODQ2LDcwODQ2LDcsNzExMDAsNzExMDEsNSw3MTIzMCw3MTIzMCw3LDcxMzUxLDcxMzUxLDUsNzE3MzcsNzE3MzgsNSw3MjAwMCw3MjAwMCw3LDcyMTYwLDcyMTYwLDUsNzIyNzMsNzIyNzgsNSw3Mjc1Miw3Mjc1OCw1LDcyODgyLDcyODgzLDUsNzMwMzEsNzMwMzEsNSw3MzQ2MSw3MzQ2Miw3LDk0MTkyLDk0MTkzLDcsMTE5MTQ5LDExOTE0OSw3LDEyMTQwMywxMjE0NTIsNSwxMjI5MTUsMTIyOTE2LDUsMTI2OTgwLDEyNjk4MCwxNCwxMjczNTgsMTI3MzU5LDE0LDEyNzUzNSwxMjc1MzUsMTQsMTI3NzU5LDEyNzc1OSwxNCwxMjc3NzEsMTI3NzcxLDE0LDEyNzc5MiwxMjc3OTMsMTQsMTI3ODI1LDEyNzg2NywxNCwxMjc4OTcsMTI3ODk5LDE0LDEyNzk0NSwxMjc5NDUsMTQsMTI3OTg1LDEyNzk4NiwxNCwxMjgwMDAsMTI4MDA3LDE0LDEyODAyMSwxMjgwMjEsMTQsMTI4MDY2LDEyODEwMCwxNCwxMjgxODQsMTI4MjM1LDE0LDEyODI0OSwxMjgyNTIsMTQsMTI4MjY2LDEyODI3NiwxNCwxMjgzMzUsMTI4MzM1LDE0LDEyODM3OSwxMjgzOTAsMTQsMTI4NDA3LDEyODQxOSwxNCwxMjg0NDQsMTI4NDQ0LDE0LDEyODQ4MSwxMjg0ODEsMTQsMTI4NDk5LDEyODQ5OSwxNCwxMjg1MjYsMTI4NTI2LDE0LDEyODUzNiwxMjg1MzYsMTQsMTI4NTQzLDEyODU0MywxNCwxMjg1NTYsMTI4NTU2LDE0LDEyODU2NCwxMjg1NjQsMTQsMTI4NTc3LDEyODU4MCwxNCwxMjg2NDMsMTI4NjQ1LDE0LDEyODY0OSwxMjg2NDksMTQsMTI4NjU0LDEyODY1NCwxNCwxMjg2NjAsMTI4NjYwLDE0LDEyODY2NCwxMjg2NjQsMTQsMTI4Njc1LDEyODY3NSwxNCwxMjg2ODYsMTI4Njg5LDE0LDEyODY5NSwxMjg2OTYsMTQsMTI4NzA1LDEyODcwOSwxNCwxMjg3MTcsMTI4NzE5LDE0LDEyODcyNSwxMjg3MjUsMTQsMTI4NzM2LDEyODc0MSwxNCwxMjg3NDcsMTI4NzQ4LDE0LDEyODc1NSwxMjg3NTUsMTQsMTI4NzYyLDEyODc2MiwxNCwxMjg5ODEsMTI4OTkxLDE0LDEyOTAwOSwxMjkwMjMsMTQsMTI5MTYwLDEyOTE2NywxNCwxMjkyOTYsMTI5MzA0LDE0LDEyOTMyMCwxMjkzMjcsMTQsMTI5MzQwLDEyOTM0MiwxNCwxMjkzNTYsMTI5MzU2LDE0LDEyOTM4OCwxMjkzOTIsMTQsMTI5Mzk5LDEyOTQwMCwxNCwxMjk0MDQsMTI5NDA3LDE0LDEyOTQzMiwxMjk0NDIsMTQsMTI5NDU0LDEyOTQ1NSwxNCwxMjk0NzMsMTI5NDc0LDE0LDEyOTQ4NSwxMjk0ODcsMTQsMTI5NjQ4LDEyOTY1MSwxNCwxMjk2NTksMTI5NjYwLDE0LDEyOTY3MSwxMjk2NzksMTQsMTI5NzA5LDEyOTcxMSwxNCwxMjk3MjgsMTI5NzMwLDE0LDEyOTc1MSwxMjk3NTMsMTQsMTI5Nzc2LDEyOTc4MiwxNCw5MTc1MDUsOTE3NTA1LDQsOTE3NzYwLDkxNzk5OSw1LDEwLDEwLDMsMTI3LDE1OSw0LDc2OCw4NzksNSwxNDcxLDE0NzEsNSwxNTM2LDE1NDEsMSwxNjQ4LDE2NDgsNSwxNzY3LDE3NjgsNSwxODQwLDE4NjYsNSwyMDcwLDIwNzMsNSwyMTM3LDIxMzksNSwyMjc0LDIyNzQsMSwyMzYzLDIzNjMsNywyMzc3LDIzODAsNywyNDAyLDI0MDMsNSwyNDk0LDI0OTQsNSwyNTA3LDI1MDgsNywyNTU4LDI1NTgsNSwyNjIyLDI2MjQsNywyNjQxLDI2NDEsNSwyNjkxLDI2OTEsNywyNzU5LDI3NjAsNSwyNzg2LDI3ODcsNSwyODc2LDI4NzYsNSwyODgxLDI4ODQsNSwyOTAxLDI5MDIsNSwzMDA2LDMwMDYsNSwzMDE0LDMwMTYsNywzMDcyLDMwNzIsNSwzMTM0LDMxMzYsNSwzMTU3LDMxNTgsNSwzMjYwLDMyNjAsNSwzMjY2LDMyNjYsNSwzMjc0LDMyNzUsNywzMzI4LDMzMjksNSwzMzkxLDMzOTIsNywzNDA1LDM0MDUsNSwzNDU3LDM0NTcsNSwzNTM2LDM1MzcsNywzNTUxLDM1NTEsNSwzNjM2LDM2NDIsNSwzNzY0LDM3NzIsNSwzODk1LDM4OTUsNSwzOTY3LDM5NjcsNywzOTkzLDQwMjgsNSw0MTQ2LDQxNTEsNSw0MTgyLDQxODMsNyw0MjI2LDQyMjYsNSw0MjUzLDQyNTMsNSw0OTU3LDQ5NTksNSw1OTQwLDU5NDAsNyw2MDcwLDYwNzAsNyw2MDg3LDYwODgsNyw2MTU4LDYxNTgsNCw2NDMyLDY0MzQsNSw2NDQ4LDY0NDksNyw2Njc5LDY2ODAsNSw2NzQyLDY3NDIsNSw2NzU0LDY3NTQsNSw2NzgzLDY3ODMsNSw2OTEyLDY5MTUsNSw2OTY2LDY5NzAsNSw2OTc4LDY5NzgsNSw3MDQyLDcwNDIsNyw3MDgwLDcwODEsNSw3MTQzLDcxNDMsNyw3MTUwLDcxNTAsNyw3MjEyLDcyMTksNSw3MzgwLDczOTIsNSw3NDEyLDc0MTIsNSw4MjAzLDgyMDMsNCw4MjMyLDgyMzIsNCw4MjY1LDgyNjUsMTQsODQwMCw4NDEyLDUsODQyMSw4NDMyLDUsODYxNyw4NjE4LDE0LDkxNjcsOTE2NywxNCw5MjAwLDkyMDAsMTQsOTQxMCw5NDEwLDE0LDk3MjMsOTcyNiwxNCw5NzMzLDk3MzMsMTQsOTc0NSw5NzQ1LDE0LDk3NTIsOTc1MiwxNCw5NzYwLDk3NjAsMTQsOTc2Niw5NzY2LDE0LDk3NzQsOTc3NCwxNCw5Nzg2LDk3ODYsMTQsOTc5NCw5Nzk0LDE0LDk4MjMsOTgyMywxNCw5ODI4LDk4MjgsMTQsOTgzMyw5ODUwLDE0LDk4NTUsOTg1NSwxNCw5ODc1LDk4NzUsMTQsOTg4MCw5ODgwLDE0LDk4ODUsOTg4NywxNCw5ODk2LDk4OTcsMTQsOTkwNiw5OTE2LDE0LDk5MjYsOTkyNywxNCw5OTM1LDk5MzUsMTQsOTkzOSw5OTM5LDE0LDk5NjIsOTk2MiwxNCw5OTcyLDk5NzIsMTQsOTk3OCw5OTc4LDE0LDk5ODYsOTk4NiwxNCw5OTk3LDk5OTcsMTQsMTAwMDIsMTAwMDIsMTQsMTAwMTcsMTAwMTcsMTQsMTAwNTUsMTAwNTUsMTQsMTAwNzEsMTAwNzEsMTQsMTAxMzMsMTAxMzUsMTQsMTA1NDgsMTA1NDksMTQsMTEwOTMsMTEwOTMsMTQsMTIzMzAsMTIzMzMsNSwxMjQ0MSwxMjQ0Miw1LDQyNjA4LDQyNjEwLDUsNDMwMTAsNDMwMTAsNSw0MzA0NSw0MzA0Niw1LDQzMTg4LDQzMjAzLDcsNDMzMDIsNDMzMDksNSw0MzM5Miw0MzM5NCw1LDQzNDQ2LDQzNDQ5LDUsNDM0OTMsNDM0OTMsNSw0MzU3MSw0MzU3Miw3LDQzNTk3LDQzNTk3LDcsNDM3MDMsNDM3MDQsNSw0Mzc1Niw0Mzc1Nyw1LDQ0MDAzLDQ0MDA0LDcsNDQwMDksNDQwMTAsNyw0NDAzMyw0NDA1OSwxMiw0NDA4OSw0NDExNSwxMiw0NDE0NSw0NDE3MSwxMiw0NDIwMSw0NDIyNywxMiw0NDI1Nyw0NDI4MywxMiw0NDMxMyw0NDMzOSwxMiw0NDM2OSw0NDM5NSwxMiw0NDQyNSw0NDQ1MSwxMiw0NDQ4MSw0NDUwNywxMiw0NDUzNyw0NDU2MywxMiw0NDU5Myw0NDYxOSwxMiw0NDY0OSw0NDY3NSwxMiw0NDcwNSw0NDczMSwxMiw0NDc2MSw0NDc4NywxMiw0NDgxNyw0NDg0MywxMiw0NDg3Myw0NDg5OSwxMiw0NDkyOSw0NDk1NSwxMiw0NDk4NSw0NTAxMSwxMiw0NTA0MSw0NTA2NywxMiw0NTA5Nyw0NTEyMywxMiw0NTE1Myw0NTE3OSwxMiw0NTIwOSw0NTIzNSwxMiw0NTI2NSw0NTI5MSwxMiw0NTMyMSw0NTM0NywxMiw0NTM3Nyw0NTQwMywxMiw0NTQzMyw0NTQ1OSwxMiw0NTQ4OSw0NTUxNSwxMiw0NTU0NSw0NTU3MSwxMiw0NTYwMSw0NTYyNywxMiw0NTY1Nyw0NTY4MywxMiw0NTcxMyw0NTczOSwxMiw0NTc2OSw0NTc5NSwxMiw0NTgyNSw0NTg1MSwxMiw0NTg4MSw0NTkwNywxMiw0NTkzNyw0NTk2MywxMiw0NTk5Myw0NjAxOSwxMiw0NjA0OSw0NjA3NSwxMiw0NjEwNSw0NjEzMSwxMiw0NjE2MSw0NjE4NywxMiw0NjIxNyw0NjI0MywxMiw0NjI3Myw0NjI5OSwxMiw0NjMyOSw0NjM1NSwxMiw0NjM4NSw0NjQxMSwxMiw0NjQ0MSw0NjQ2NywxMiw0NjQ5Nyw0NjUyMywxMiw0NjU1Myw0NjU3OSwxMiw0NjYwOSw0NjYzNSwxMiw0NjY2NSw0NjY5MSwxMiw0NjcyMSw0Njc0NywxMiw0Njc3Nyw0NjgwMywxMiw0NjgzMyw0Njg1OSwxMiw0Njg4OSw0NjkxNSwxMiw0Njk0NSw0Njk3MSwxMiw0NzAwMSw0NzAyNywxMiw0NzA1Nyw0NzA4MywxMiw0NzExMyw0NzEzOSwxMiw0NzE2OSw0NzE5NSwxMiw0NzIyNSw0NzI1MSwxMiw0NzI4MSw0NzMwNywxMiw0NzMzNyw0NzM2MywxMiw0NzM5Myw0NzQxOSwxMiw0NzQ0OSw0NzQ3NSwxMiw0NzUwNSw0NzUzMSwxMiw0NzU2MSw0NzU4NywxMiw0NzYxNyw0NzY0MywxMiw0NzY3Myw0NzY5OSwxMiw0NzcyOSw0Nzc1NSwxMiw0Nzc4NSw0NzgxMSwxMiw0Nzg0MSw0Nzg2NywxMiw0Nzg5Nyw0NzkyMywxMiw0Nzk1Myw0Nzk3OSwxMiw0ODAwOSw0ODAzNSwxMiw0ODA2NSw0ODA5MSwxMiw0ODEyMSw0ODE0NywxMiw0ODE3Nyw0ODIwMywxMiw0ODIzMyw0ODI1OSwxMiw0ODI4OSw0ODMxNSwxMiw0ODM0NSw0ODM3MSwxMiw0ODQwMSw0ODQyNywxMiw0ODQ1Nyw0ODQ4MywxMiw0ODUxMyw0ODUzOSwxMiw0ODU2OSw0ODU5NSwxMiw0ODYyNSw0ODY1MSwxMiw0ODY4MSw0ODcwNywxMiw0ODczNyw0ODc2MywxMiw0ODc5Myw0ODgxOSwxMiw0ODg0OSw0ODg3NSwxMiw0ODkwNSw0ODkzMSwxMiw0ODk2MSw0ODk4NywxMiw0OTAxNyw0OTA0MywxMiw0OTA3Myw0OTA5OSwxMiw0OTEyOSw0OTE1NSwxMiw0OTE4NSw0OTIxMSwxMiw0OTI0MSw0OTI2NywxMiw0OTI5Nyw0OTMyMywxMiw0OTM1Myw0OTM3OSwxMiw0OTQwOSw0OTQzNSwxMiw0OTQ2NSw0OTQ5MSwxMiw0OTUyMSw0OTU0NywxMiw0OTU3Nyw0OTYwMywxMiw0OTYzMyw0OTY1OSwxMiw0OTY4OSw0OTcxNSwxMiw0OTc0NSw0OTc3MSwxMiw0OTgwMSw0OTgyNywxMiw0OTg1Nyw0OTg4MywxMiw0OTkxMyw0OTkzOSwxMiw0OTk2OSw0OTk5NSwxMiw1MDAyNSw1MDA1MSwxMiw1MDA4MSw1MDEwNywxMiw1MDEzNyw1MDE2MywxMiw1MDE5Myw1MDIxOSwxMiw1MDI0OSw1MDI3NSwxMiw1MDMwNSw1MDMzMSwxMiw1MDM2MSw1MDM4NywxMiw1MDQxNyw1MDQ0MywxMiw1MDQ3Myw1MDQ5OSwxMiw1MDUyOSw1MDU1NSwxMiw1MDU4NSw1MDYxMSwxMiw1MDY0MSw1MDY2NywxMiw1MDY5Nyw1MDcyMywxMiw1MDc1Myw1MDc3OSwxMiw1MDgwOSw1MDgzNSwxMiw1MDg2NSw1MDg5MSwxMiw1MDkyMSw1MDk0NywxMiw1MDk3Nyw1MTAwMywxMiw1MTAzMyw1MTA1OSwxMiw1MTA4OSw1MTExNSwxMiw1MTE0NSw1MTE3MSwxMiw1MTIwMSw1MTIyNywxMiw1MTI1Nyw1MTI4MywxMiw1MTMxMyw1MTMzOSwxMiw1MTM2OSw1MTM5NSwxMiw1MTQyNSw1MTQ1MSwxMiw1MTQ4MSw1MTUwNywxMiw1MTUzNyw1MTU2MywxMiw1MTU5Myw1MTYxOSwxMiw1MTY0OSw1MTY3NSwxMiw1MTcwNSw1MTczMSwxMiw1MTc2MSw1MTc4NywxMiw1MTgxNyw1MTg0MywxMiw1MTg3Myw1MTg5OSwxMiw1MTkyOSw1MTk1NSwxMiw1MTk4NSw1MjAxMSwxMiw1MjA0MSw1MjA2NywxMiw1MjA5Nyw1MjEyMywxMiw1MjE1Myw1MjE3OSwxMiw1MjIwOSw1MjIzNSwxMiw1MjI2NSw1MjI5MSwxMiw1MjMyMSw1MjM0NywxMiw1MjM3Nyw1MjQwMywxMiw1MjQzMyw1MjQ1OSwxMiw1MjQ4OSw1MjUxNSwxMiw1MjU0NSw1MjU3MSwxMiw1MjYwMSw1MjYyNywxMiw1MjY1Nyw1MjY4MywxMiw1MjcxMyw1MjczOSwxMiw1Mjc2OSw1Mjc5NSwxMiw1MjgyNSw1Mjg1MSwxMiw1Mjg4MSw1MjkwNywxMiw1MjkzNyw1Mjk2MywxMiw1Mjk5Myw1MzAxOSwxMiw1MzA0OSw1MzA3NSwxMiw1MzEwNSw1MzEzMSwxMiw1MzE2MSw1MzE4NywxMiw1MzIxNyw1MzI0MywxMiw1MzI3Myw1MzI5OSwxMiw1MzMyOSw1MzM1NSwxMiw1MzM4NSw1MzQxMSwxMiw1MzQ0MSw1MzQ2NywxMiw1MzQ5Nyw1MzUyMywxMiw1MzU1Myw1MzU3OSwxMiw1MzYwOSw1MzYzNSwxMiw1MzY2NSw1MzY5MSwxMiw1MzcyMSw1Mzc0NywxMiw1Mzc3Nyw1MzgwMywxMiw1MzgzMyw1Mzg1OSwxMiw1Mzg4OSw1MzkxNSwxMiw1Mzk0NSw1Mzk3MSwxMiw1NDAwMSw1NDAyNywxMiw1NDA1Nyw1NDA4MywxMiw1NDExMyw1NDEzOSwxMiw1NDE2OSw1NDE5NSwxMiw1NDIyNSw1NDI1MSwxMiw1NDI4MSw1NDMwNywxMiw1NDMzNyw1NDM2MywxMiw1NDM5Myw1NDQxOSwxMiw1NDQ0OSw1NDQ3NSwxMiw1NDUwNSw1NDUzMSwxMiw1NDU2MSw1NDU4NywxMiw1NDYxNyw1NDY0MywxMiw1NDY3Myw1NDY5OSwxMiw1NDcyOSw1NDc1NSwxMiw1NDc4NSw1NDgxMSwxMiw1NDg0MSw1NDg2NywxMiw1NDg5Nyw1NDkyMywxMiw1NDk1Myw1NDk3OSwxMiw1NTAwOSw1NTAzNSwxMiw1NTA2NSw1NTA5MSwxMiw1NTEyMSw1NTE0NywxMiw1NTE3Nyw1NTIwMywxMiw2NTAyNCw2NTAzOSw1LDY1NTIwLDY1NTI4LDQsNjY0MjIsNjY0MjYsNSw2ODE1Miw2ODE1NCw1LDY5MjkxLDY5MjkyLDUsNjk2MzMsNjk2MzMsNSw2OTc0Nyw2OTc0OCw1LDY5ODExLDY5ODE0LDUsNjk4MjYsNjk4MjYsNSw2OTkzMiw2OTkzMiw3LDcwMDE2LDcwMDE3LDUsNzAwNzksNzAwODAsNyw3MDA5NSw3MDA5NSw1LDcwMTk2LDcwMTk2LDUsNzAzNjcsNzAzNjcsNSw3MDQwMiw3MDQwMyw3LDcwNDY0LDcwNDY0LDUsNzA0ODcsNzA0ODcsNSw3MDcwOSw3MDcxMSw3LDcwNzI1LDcwNzI1LDcsNzA4MzMsNzA4MzQsNyw3MDg0Myw3MDg0NCw3LDcwODQ5LDcwODQ5LDcsNzEwOTAsNzEwOTMsNSw3MTEwMyw3MTEwNCw1LDcxMjI3LDcxMjI4LDcsNzEzMzksNzEzMzksNSw3MTM0NCw3MTM0OSw1LDcxNDU4LDcxNDYxLDUsNzE3MjcsNzE3MzUsNSw3MTk4NSw3MTk4OSw3LDcxOTk4LDcxOTk4LDUsNzIwMDIsNzIwMDIsNyw3MjE1NCw3MjE1NSw1LDcyMTkzLDcyMjAyLDUsNzIyNTEsNzIyNTQsNSw3MjI4MSw3MjI4Myw1LDcyMzQ0LDcyMzQ1LDUsNzI3NjYsNzI3NjYsNyw3Mjg3NCw3Mjg4MCw1LDcyODg1LDcyODg2LDUsNzMwMjMsNzMwMjksNSw3MzEwNCw3MzEwNSw1LDczMTExLDczMTExLDUsOTI5MTIsOTI5MTYsNSw5NDA5NSw5NDA5OCw1LDExMzgyNCwxMTM4MjcsNCwxMTkxNDIsMTE5MTQyLDcsMTE5MTU1LDExOTE2Miw0LDExOTM2MiwxMTkzNjQsNSwxMjE0NzYsMTIxNDc2LDUsMTIyODg4LDEyMjkwNCw1LDEyMzE4NCwxMjMxOTAsNSwxMjUyNTIsMTI1MjU4LDUsMTI3MTgzLDEyNzE4MywxNCwxMjczNDAsMTI3MzQzLDE0LDEyNzM3NywxMjczODYsMTQsMTI3NDkxLDEyNzUwMywxNCwxMjc1NDgsMTI3NTUxLDE0LDEyNzc0NCwxMjc3NTYsMTQsMTI3NzYxLDEyNzc2MSwxNCwxMjc3NjksMTI3NzY5LDE0LDEyNzc3MywxMjc3NzQsMTQsMTI3NzgwLDEyNzc4OCwxNCwxMjc3OTYsMTI3Nzk3LDE0LDEyNzgyMCwxMjc4MjMsMTQsMTI3ODY5LDEyNzg2OSwxNCwxMjc4OTQsMTI3ODk1LDE0LDEyNzkwMiwxMjc5MDMsMTQsMTI3OTQzLDEyNzk0MywxNCwxMjc5NDcsMTI3OTUwLDE0LDEyNzk3MiwxMjc5NzIsMTQsMTI3OTg4LDEyNzk4OCwxNCwxMjc5OTIsMTI3OTk0LDE0LDEyODAwOSwxMjgwMTEsMTQsMTI4MDE5LDEyODAxOSwxNCwxMjgwMjMsMTI4MDQxLDE0LDEyODA2NCwxMjgwNjQsMTQsMTI4MTAyLDEyODEwNywxNCwxMjgxNzQsMTI4MTgxLDE0LDEyODIzOCwxMjgyMzgsMTQsMTI4MjQ2LDEyODI0NywxNCwxMjgyNTQsMTI4MjU0LDE0LDEyODI2NCwxMjgyNjQsMTQsMTI4Mjc4LDEyODI5OSwxNCwxMjgzMjksMTI4MzMwLDE0LDEyODM0OCwxMjgzNTksMTQsMTI4MzcxLDEyODM3NywxNCwxMjgzOTIsMTI4MzkzLDE0LDEyODQwMSwxMjg0MDQsMTQsMTI4NDIxLDEyODQyMSwxNCwxMjg0MzMsMTI4NDM0LDE0LDEyODQ1MCwxMjg0NTIsMTQsMTI4NDc2LDEyODQ3OCwxNCwxMjg0ODMsMTI4NDgzLDE0LDEyODQ5NSwxMjg0OTUsMTQsMTI4NTA2LDEyODUwNiwxNCwxMjg1MTksMTI4NTIwLDE0LDEyODUyOCwxMjg1MjgsMTQsMTI4NTM0LDEyODUzNCwxNCwxMjg1MzgsMTI4NTM4LDE0LDEyODU0MCwxMjg1NDIsMTQsMTI4NTQ0LDEyODU0OSwxNCwxMjg1NTIsMTI4NTU1LDE0LDEyODU1NywxMjg1NTcsMTQsMTI4NTYwLDEyODU2MywxNCwxMjg1NjUsMTI4NTY1LDE0LDEyODU2NywxMjg1NzYsMTQsMTI4NTgxLDEyODU5MSwxNCwxMjg2NDEsMTI4NjQyLDE0LDEyODY0NiwxMjg2NDYsMTQsMTI4NjQ4LDEyODY0OCwxNCwxMjg2NTAsMTI4NjUxLDE0LDEyODY1MywxMjg2NTMsMTQsMTI4NjU1LDEyODY1NSwxNCwxMjg2NTcsMTI4NjU5LDE0LDEyODY2MSwxMjg2NjEsMTQsMTI4NjYzLDEyODY2MywxNCwxMjg2NjUsMTI4NjY2LDE0LDEyODY3NCwxMjg2NzQsMTQsMTI4Njc2LDEyODY3NywxNCwxMjg2NzksMTI4Njg1LDE0LDEyODY5MCwxMjg2OTAsMTQsMTI4Njk0LDEyODY5NCwxNCwxMjg2OTcsMTI4NzAyLDE0LDEyODcwNCwxMjg3MDQsMTQsMTI4NzEwLDEyODcxNCwxNCwxMjg3MTYsMTI4NzE2LDE0LDEyODcyMCwxMjg3MjAsMTQsMTI4NzIzLDEyODcyNCwxNCwxMjg3MjYsMTI4NzI3LDE0LDEyODczMywxMjg3MzUsMTQsMTI4NzQyLDEyODc0NCwxNCwxMjg3NDYsMTI4NzQ2LDE0LDEyODc0OSwxMjg3NTEsMTQsMTI4NzUzLDEyODc1NCwxNCwxMjg3NTYsMTI4NzU4LDE0LDEyODc2MSwxMjg3NjEsMTQsMTI4NzYzLDEyODc2NCwxNCwxMjg4ODQsMTI4ODk1LDE0LDEyODk5MiwxMjkwMDMsMTQsMTI5MDA4LDEyOTAwOCwxNCwxMjkwMzYsMTI5MDM5LDE0LDEyOTExNCwxMjkxMTksMTQsMTI5MTk4LDEyOTI3OSwxNCwxMjkyOTMsMTI5Mjk1LDE0LDEyOTMwNSwxMjkzMTAsMTQsMTI5MzEyLDEyOTMxOSwxNCwxMjkzMjgsMTI5MzI4LDE0LDEyOTMzMSwxMjkzMzgsMTQsMTI5MzQzLDEyOTM0MywxNCwxMjkzNTEsMTI5MzU1LDE0LDEyOTM1NywxMjkzNTksMTQsMTI5Mzc1LDEyOTM4NywxNCwxMjkzOTMsMTI5MzkzLDE0LDEyOTM5NSwxMjkzOTgsMTQsMTI5NDAxLDEyOTQwMSwxNCwxMjk0MDMsMTI5NDAzLDE0LDEyOTQwOCwxMjk0MTIsMTQsMTI5NDI2LDEyOTQzMSwxNCwxMjk0NDMsMTI5NDQ0LDE0LDEyOTQ1MSwxMjk0NTMsMTQsMTI5NDU2LDEyOTQ2NSwxNCwxMjk0NzIsMTI5NDcyLDE0LDEyOTQ3NSwxMjk0ODIsMTQsMTI5NDg0LDEyOTQ4NCwxNCwxMjk0ODgsMTI5NTEwLDE0LDEyOTUzNiwxMjk2NDcsMTQsMTI5NjUyLDEyOTY1MiwxNCwxMjk2NTYsMTI5NjU4LDE0LDEyOTY2MSwxMjk2NjMsMTQsMTI5NjY3LDEyOTY3MCwxNCwxMjk2ODAsMTI5Njg1LDE0LDEyOTcwNSwxMjk3MDgsMTQsMTI5NzEyLDEyOTcxOCwxNCwxMjk3MjMsMTI5NzI3LDE0LDEyOTczMSwxMjk3MzMsMTQsMTI5NzQ0LDEyOTc1MCwxNCwxMjk3NTQsMTI5NzU5LDE0LDEyOTc2OCwxMjk3NzUsMTQsMTI5NzgzLDEyOTc5MSwxNCw5MTc1MDQsOTE3NTA0LDQsOTE3NTA2LDkxNzUzNSw0LDkxNzYzMiw5MTc3NTksNCw5MTgwMDAsOTIxNTk5LDQsMCw5LDQsMTEsMTIsNCwxNCwzMSw0LDE2OSwxNjksMTQsMTc0LDE3NCwxNCwxMTU1LDExNTksNSwxNDI1LDE0NjksNSwxNDczLDE0NzQsNSwxNDc5LDE0NzksNSwxNTUyLDE1NjIsNSwxNjExLDE2MzEsNSwxNzUwLDE3NTYsNSwxNzU5LDE3NjQsNSwxNzcwLDE3NzMsNSwxODA5LDE4MDksNSwxOTU4LDE5NjgsNSwyMDQ1LDIwNDUsNSwyMDc1LDIwODMsNSwyMDg5LDIwOTMsNSwyMTkyLDIxOTMsMSwyMjUwLDIyNzMsNSwyMjc1LDIzMDYsNSwyMzYyLDIzNjIsNSwyMzY0LDIzNjQsNSwyMzY5LDIzNzYsNSwyMzgxLDIzODEsNSwyMzg1LDIzOTEsNSwyNDMzLDI0MzMsNSwyNDkyLDI0OTIsNSwyNDk1LDI0OTYsNywyNTAzLDI1MDQsNywyNTA5LDI1MDksNSwyNTMwLDI1MzEsNSwyNTYxLDI1NjIsNSwyNjIwLDI2MjAsNSwyNjI1LDI2MjYsNSwyNjM1LDI2MzcsNSwyNjcyLDI2NzMsNSwyNjg5LDI2OTAsNSwyNzQ4LDI3NDgsNSwyNzUzLDI3NTcsNSwyNzYxLDI3NjEsNywyNzY1LDI3NjUsNSwyODEwLDI4MTUsNSwyODE4LDI4MTksNywyODc4LDI4NzgsNSwyODgwLDI4ODAsNywyODg3LDI4ODgsNywyODkzLDI4OTMsNSwyOTAzLDI5MDMsNSwyOTQ2LDI5NDYsNSwzMDA3LDMwMDcsNywzMDA5LDMwMTAsNywzMDE4LDMwMjAsNywzMDMxLDMwMzEsNSwzMDczLDMwNzUsNywzMTMyLDMxMzIsNSwzMTM3LDMxNDAsNywzMTQ2LDMxNDksNSwzMTcwLDMxNzEsNSwzMjAyLDMyMDMsNywzMjYyLDMyNjIsNywzMjY0LDMyNjUsNywzMjY3LDMyNjgsNywzMjcxLDMyNzIsNywzMjc2LDMyNzcsNSwzMjk4LDMyOTksNSwzMzMwLDMzMzEsNywzMzkwLDMzOTAsNSwzMzkzLDMzOTYsNSwzNDAyLDM0MDQsNywzNDA2LDM0MDYsMSwzNDI2LDM0MjcsNSwzNDU4LDM0NTksNywzNTM1LDM1MzUsNSwzNTM4LDM1NDAsNSwzNTQ0LDM1NTAsNywzNTcwLDM1NzEsNywzNjM1LDM2MzUsNywzNjU1LDM2NjIsNSwzNzYzLDM3NjMsNywzNzg0LDM3ODksNSwzODkzLDM4OTMsNSwzODk3LDM4OTcsNSwzOTUzLDM5NjYsNSwzOTY4LDM5NzIsNSwzOTgxLDM5OTEsNSw0MDM4LDQwMzgsNSw0MTQ1LDQxNDUsNyw0MTUzLDQxNTQsNSw0MTU3LDQxNTgsNSw0MTg0LDQxODUsNSw0MjA5LDQyMTIsNSw0MjI4LDQyMjgsNyw0MjM3LDQyMzcsNSw0MzUyLDQ0NDcsOCw0NTIwLDQ2MDcsMTAsNTkwNiw1OTA4LDUsNTkzOCw1OTM5LDUsNTk3MCw1OTcxLDUsNjA2OCw2MDY5LDUsNjA3MSw2MDc3LDUsNjA4Niw2MDg2LDUsNjA4OSw2MDk5LDUsNjE1NSw2MTU3LDUsNjE1OSw2MTU5LDUsNjMxMyw2MzEzLDUsNjQzNSw2NDM4LDcsNjQ0MSw2NDQzLDcsNjQ1MCw2NDUwLDUsNjQ1Nyw2NDU5LDUsNjY4MSw2NjgyLDcsNjc0MSw2NzQxLDcsNjc0Myw2NzQzLDcsNjc1Miw2NzUyLDUsNjc1Nyw2NzY0LDUsNjc3MSw2NzgwLDUsNjgzMiw2ODQ1LDUsNjg0Nyw2ODYyLDUsNjkxNiw2OTE2LDcsNjk2NSw2OTY1LDUsNjk3MSw2OTcxLDcsNjk3Myw2OTc3LDcsNjk3OSw2OTgwLDcsNzA0MCw3MDQxLDUsNzA3Myw3MDczLDcsNzA3OCw3MDc5LDcsNzA4Miw3MDgyLDcsNzE0Miw3MTQyLDUsNzE0NCw3MTQ1LDUsNzE0OSw3MTQ5LDUsNzE1MSw3MTUzLDUsNzIwNCw3MjExLDcsNzIyMCw3MjIxLDcsNzM3Niw3Mzc4LDUsNzM5Myw3MzkzLDcsNzQwNSw3NDA1LDUsNzQxNSw3NDE1LDcsNzYxNiw3Njc5LDUsODIwNCw4MjA0LDUsODIwNiw4MjA3LDQsODIzMyw4MjMzLDQsODI1Miw4MjUyLDE0LDgyODgsODI5Miw0LDgyOTQsODMwMyw0LDg0MTMsODQxNiw1LDg0MTgsODQyMCw1LDg0ODIsODQ4MiwxNCw4NTk2LDg2MDEsMTQsODk4Niw4OTg3LDE0LDkwOTYsOTA5NiwxNCw5MTkzLDkxOTYsMTQsOTE5OSw5MTk5LDE0LDkyMDEsOTIwMiwxNCw5MjA4LDkyMTAsMTQsOTY0Miw5NjQzLDE0LDk2NjQsOTY2NCwxNCw5NzI4LDk3MjksMTQsOTczMiw5NzMyLDE0LDk3MzUsOTc0MSwxNCw5NzQzLDk3NDQsMTQsOTc0Niw5NzQ2LDE0LDk3NTAsOTc1MSwxNCw5NzUzLDk3NTYsMTQsOTc1OCw5NzU5LDE0LDk3NjEsOTc2MSwxNCw5NzY0LDk3NjUsMTQsOTc2Nyw5NzY5LDE0LDk3NzEsOTc3MywxNCw5Nzc1LDk3NzUsMTQsOTc4NCw5Nzg1LDE0LDk3ODcsOTc5MSwxNCw5NzkzLDk3OTMsMTQsOTc5NSw5Nzk5LDE0LDk4MTIsOTgyMiwxNCw5ODI0LDk4MjQsMTQsOTgyNyw5ODI3LDE0LDk4MjksOTgzMCwxNCw5ODMyLDk4MzIsMTQsOTg1MSw5ODUxLDE0LDk4NTQsOTg1NCwxNCw5ODU2LDk4NjEsMTQsOTg3NCw5ODc0LDE0LDk4NzYsOTg3NiwxNCw5ODc4LDk4NzksMTQsOTg4MSw5ODgxLDE0LDk4ODMsOTg4NCwxNCw5ODg4LDk4ODksMTQsOTg5NSw5ODk1LDE0LDk4OTgsOTg5OSwxNCw5OTA0LDk5MDUsMTQsOTkxNyw5OTE4LDE0LDk5MjQsOTkyNSwxNCw5OTI4LDk5MjgsMTQsOTkzNCw5OTM0LDE0LDk5MzYsOTkzNiwxNCw5OTM4LDk5MzgsMTQsOTk0MCw5OTQwLDE0LDk5NjEsOTk2MSwxNCw5OTYzLDk5NjcsMTQsOTk3MCw5OTcxLDE0LDk5NzMsOTk3MywxNCw5OTc1LDk5NzcsMTQsOTk3OSw5OTgwLDE0LDk5ODIsOTk4NSwxNCw5OTg3LDk5ODgsMTQsOTk5Miw5OTk2LDE0LDk5OTgsOTk5OCwxNCwxMDAwMCwxMDAwMSwxNCwxMDAwNCwxMDAwNCwxNCwxMDAxMywxMDAxMywxNCwxMDAyNCwxMDAyNCwxNCwxMDA1MiwxMDA1MiwxNCwxMDA2MCwxMDA2MCwxNCwxMDA2NywxMDA2OSwxNCwxMDA4MywxMDA4MywxNCwxMDA4NSwxMDA4NywxNCwxMDE0NSwxMDE0NSwxNCwxMDE3NSwxMDE3NSwxNCwxMTAxMywxMTAxNSwxNCwxMTA4OCwxMTA4OCwxNCwxMTUwMywxMTUwNSw1LDExNzQ0LDExNzc1LDUsMTIzMzQsMTIzMzUsNSwxMjM0OSwxMjM0OSwxNCwxMjk1MSwxMjk1MSwxNCw0MjYwNyw0MjYwNyw1LDQyNjEyLDQyNjIxLDUsNDI3MzYsNDI3MzcsNSw0MzAxNCw0MzAxNCw1LDQzMDQzLDQzMDQ0LDcsNDMwNDcsNDMwNDcsNyw0MzEzNiw0MzEzNyw3LDQzMjA0LDQzMjA1LDUsNDMyNjMsNDMyNjMsNSw0MzMzNSw0MzM0NSw1LDQzMzYwLDQzMzg4LDgsNDMzOTUsNDMzOTUsNyw0MzQ0NCw0MzQ0NSw3LDQzNDUwLDQzNDUxLDcsNDM0NTQsNDM0NTYsNyw0MzU2MSw0MzU2Niw1LDQzNTY5LDQzNTcwLDUsNDM1NzMsNDM1NzQsNSw0MzU5Niw0MzU5Niw1LDQzNjQ0LDQzNjQ0LDUsNDM2OTgsNDM3MDAsNSw0MzcxMCw0MzcxMSw1LDQzNzU1LDQzNzU1LDcsNDM3NTgsNDM3NTksNyw0Mzc2Niw0Mzc2Niw1LDQ0MDA1LDQ0MDA1LDUsNDQwMDgsNDQwMDgsNSw0NDAxMiw0NDAxMiw3LDQ0MDMyLDQ0MDMyLDExLDQ0MDYwLDQ0MDYwLDExLDQ0MDg4LDQ0MDg4LDExLDQ0MTE2LDQ0MTE2LDExLDQ0MTQ0LDQ0MTQ0LDExLDQ0MTcyLDQ0MTcyLDExLDQ0MjAwLDQ0MjAwLDExLDQ0MjI4LDQ0MjI4LDExLDQ0MjU2LDQ0MjU2LDExLDQ0Mjg0LDQ0Mjg0LDExLDQ0MzEyLDQ0MzEyLDExLDQ0MzQwLDQ0MzQwLDExLDQ0MzY4LDQ0MzY4LDExLDQ0Mzk2LDQ0Mzk2LDExLDQ0NDI0LDQ0NDI0LDExLDQ0NDUyLDQ0NDUyLDExLDQ0NDgwLDQ0NDgwLDExLDQ0NTA4LDQ0NTA4LDExLDQ0NTM2LDQ0NTM2LDExLDQ0NTY0LDQ0NTY0LDExLDQ0NTkyLDQ0NTkyLDExLDQ0NjIwLDQ0NjIwLDExLDQ0NjQ4LDQ0NjQ4LDExLDQ0Njc2LDQ0Njc2LDExLDQ0NzA0LDQ0NzA0LDExLDQ0NzMyLDQ0NzMyLDExLDQ0NzYwLDQ0NzYwLDExLDQ0Nzg4LDQ0Nzg4LDExLDQ0ODE2LDQ0ODE2LDExLDQ0ODQ0LDQ0ODQ0LDExLDQ0ODcyLDQ0ODcyLDExLDQ0OTAwLDQ0OTAwLDExLDQ0OTI4LDQ0OTI4LDExLDQ0OTU2LDQ0OTU2LDExLDQ0OTg0LDQ0OTg0LDExLDQ1MDEyLDQ1MDEyLDExLDQ1MDQwLDQ1MDQwLDExLDQ1MDY4LDQ1MDY4LDExLDQ1MDk2LDQ1MDk2LDExLDQ1MTI0LDQ1MTI0LDExLDQ1MTUyLDQ1MTUyLDExLDQ1MTgwLDQ1MTgwLDExLDQ1MjA4LDQ1MjA4LDExLDQ1MjM2LDQ1MjM2LDExLDQ1MjY0LDQ1MjY0LDExLDQ1MjkyLDQ1MjkyLDExLDQ1MzIwLDQ1MzIwLDExLDQ1MzQ4LDQ1MzQ4LDExLDQ1Mzc2LDQ1Mzc2LDExLDQ1NDA0LDQ1NDA0LDExLDQ1NDMyLDQ1NDMyLDExLDQ1NDYwLDQ1NDYwLDExLDQ1NDg4LDQ1NDg4LDExLDQ1NTE2LDQ1NTE2LDExLDQ1NTQ0LDQ1NTQ0LDExLDQ1NTcyLDQ1NTcyLDExLDQ1NjAwLDQ1NjAwLDExLDQ1NjI4LDQ1NjI4LDExLDQ1NjU2LDQ1NjU2LDExLDQ1Njg0LDQ1Njg0LDExLDQ1NzEyLDQ1NzEyLDExLDQ1NzQwLDQ1NzQwLDExLDQ1NzY4LDQ1NzY4LDExLDQ1Nzk2LDQ1Nzk2LDExLDQ1ODI0LDQ1ODI0LDExLDQ1ODUyLDQ1ODUyLDExLDQ1ODgwLDQ1ODgwLDExLDQ1OTA4LDQ1OTA4LDExLDQ1OTM2LDQ1OTM2LDExLDQ1OTY0LDQ1OTY0LDExLDQ1OTkyLDQ1OTkyLDExLDQ2MDIwLDQ2MDIwLDExLDQ2MDQ4LDQ2MDQ4LDExLDQ2MDc2LDQ2MDc2LDExLDQ2MTA0LDQ2MTA0LDExLDQ2MTMyLDQ2MTMyLDExLDQ2MTYwLDQ2MTYwLDExLDQ2MTg4LDQ2MTg4LDExLDQ2MjE2LDQ2MjE2LDExLDQ2MjQ0LDQ2MjQ0LDExLDQ2MjcyLDQ2MjcyLDExLDQ2MzAwLDQ2MzAwLDExLDQ2MzI4LDQ2MzI4LDExLDQ2MzU2LDQ2MzU2LDExLDQ2Mzg0LDQ2Mzg0LDExLDQ2NDEyLDQ2NDEyLDExLDQ2NDQwLDQ2NDQwLDExLDQ2NDY4LDQ2NDY4LDExLDQ2NDk2LDQ2NDk2LDExLDQ2NTI0LDQ2NTI0LDExLDQ2NTUyLDQ2NTUyLDExLDQ2NTgwLDQ2NTgwLDExLDQ2NjA4LDQ2NjA4LDExLDQ2NjM2LDQ2NjM2LDExLDQ2NjY0LDQ2NjY0LDExLDQ2NjkyLDQ2NjkyLDExLDQ2NzIwLDQ2NzIwLDExLDQ2NzQ4LDQ2NzQ4LDExLDQ2Nzc2LDQ2Nzc2LDExLDQ2ODA0LDQ2ODA0LDExLDQ2ODMyLDQ2ODMyLDExLDQ2ODYwLDQ2ODYwLDExLDQ2ODg4LDQ2ODg4LDExLDQ2OTE2LDQ2OTE2LDExLDQ2OTQ0LDQ2OTQ0LDExLDQ2OTcyLDQ2OTcyLDExLDQ3MDAwLDQ3MDAwLDExLDQ3MDI4LDQ3MDI4LDExLDQ3MDU2LDQ3MDU2LDExLDQ3MDg0LDQ3MDg0LDExLDQ3MTEyLDQ3MTEyLDExLDQ3MTQwLDQ3MTQwLDExLDQ3MTY4LDQ3MTY4LDExLDQ3MTk2LDQ3MTk2LDExLDQ3MjI0LDQ3MjI0LDExLDQ3MjUyLDQ3MjUyLDExLDQ3MjgwLDQ3MjgwLDExLDQ3MzA4LDQ3MzA4LDExLDQ3MzM2LDQ3MzM2LDExLDQ3MzY0LDQ3MzY0LDExLDQ3MzkyLDQ3MzkyLDExLDQ3NDIwLDQ3NDIwLDExLDQ3NDQ4LDQ3NDQ4LDExLDQ3NDc2LDQ3NDc2LDExLDQ3NTA0LDQ3NTA0LDExLDQ3NTMyLDQ3NTMyLDExLDQ3NTYwLDQ3NTYwLDExLDQ3NTg4LDQ3NTg4LDExLDQ3NjE2LDQ3NjE2LDExLDQ3NjQ0LDQ3NjQ0LDExLDQ3NjcyLDQ3NjcyLDExLDQ3NzAwLDQ3NzAwLDExLDQ3NzI4LDQ3NzI4LDExLDQ3NzU2LDQ3NzU2LDExLDQ3Nzg0LDQ3Nzg0LDExLDQ3ODEyLDQ3ODEyLDExLDQ3ODQwLDQ3ODQwLDExLDQ3ODY4LDQ3ODY4LDExLDQ3ODk2LDQ3ODk2LDExLDQ3OTI0LDQ3OTI0LDExLDQ3OTUyLDQ3OTUyLDExLDQ3OTgwLDQ3OTgwLDExLDQ4MDA4LDQ4MDA4LDExLDQ4MDM2LDQ4MDM2LDExLDQ4MDY0LDQ4MDY0LDExLDQ4MDkyLDQ4MDkyLDExLDQ4MTIwLDQ4MTIwLDExLDQ4MTQ4LDQ4MTQ4LDExLDQ4MTc2LDQ4MTc2LDExLDQ4MjA0LDQ4MjA0LDExLDQ4MjMyLDQ4MjMyLDExLDQ4MjYwLDQ4MjYwLDExLDQ4Mjg4LDQ4Mjg4LDExLDQ4MzE2LDQ4MzE2LDExLDQ4MzQ0LDQ4MzQ0LDExLDQ4MzcyLDQ4MzcyLDExLDQ4NDAwLDQ4NDAwLDExLDQ4NDI4LDQ4NDI4LDExLDQ4NDU2LDQ4NDU2LDExLDQ4NDg0LDQ4NDg0LDExLDQ4NTEyLDQ4NTEyLDExLDQ4NTQwLDQ4NTQwLDExLDQ4NTY4LDQ4NTY4LDExLDQ4NTk2LDQ4NTk2LDExLDQ4NjI0LDQ4NjI0LDExLDQ4NjUyLDQ4NjUyLDExLDQ4NjgwLDQ4NjgwLDExLDQ4NzA4LDQ4NzA4LDExLDQ4NzM2LDQ4NzM2LDExLDQ4NzY0LDQ4NzY0LDExLDQ4NzkyLDQ4NzkyLDExLDQ4ODIwLDQ4ODIwLDExLDQ4ODQ4LDQ4ODQ4LDExLDQ4ODc2LDQ4ODc2LDExLDQ4OTA0LDQ4OTA0LDExLDQ4OTMyLDQ4OTMyLDExLDQ4OTYwLDQ4OTYwLDExLDQ4OTg4LDQ4OTg4LDExLDQ5MDE2LDQ5MDE2LDExLDQ5MDQ0LDQ5MDQ0LDExLDQ5MDcyLDQ5MDcyLDExLDQ5MTAwLDQ5MTAwLDExLDQ5MTI4LDQ5MTI4LDExLDQ5MTU2LDQ5MTU2LDExLDQ5MTg0LDQ5MTg0LDExLDQ5MjEyLDQ5MjEyLDExLDQ5MjQwLDQ5MjQwLDExLDQ5MjY4LDQ5MjY4LDExLDQ5Mjk2LDQ5Mjk2LDExLDQ5MzI0LDQ5MzI0LDExLDQ5MzUyLDQ5MzUyLDExLDQ5MzgwLDQ5MzgwLDExLDQ5NDA4LDQ5NDA4LDExLDQ5NDM2LDQ5NDM2LDExLDQ5NDY0LDQ5NDY0LDExLDQ5NDkyLDQ5NDkyLDExLDQ5NTIwLDQ5NTIwLDExLDQ5NTQ4LDQ5NTQ4LDExLDQ5NTc2LDQ5NTc2LDExLDQ5NjA0LDQ5NjA0LDExLDQ5NjMyLDQ5NjMyLDExLDQ5NjYwLDQ5NjYwLDExLDQ5Njg4LDQ5Njg4LDExLDQ5NzE2LDQ5NzE2LDExLDQ5NzQ0LDQ5NzQ0LDExLDQ5NzcyLDQ5NzcyLDExLDQ5ODAwLDQ5ODAwLDExLDQ5ODI4LDQ5ODI4LDExLDQ5ODU2LDQ5ODU2LDExLDQ5ODg0LDQ5ODg0LDExLDQ5OTEyLDQ5OTEyLDExLDQ5OTQwLDQ5OTQwLDExLDQ5OTY4LDQ5OTY4LDExLDQ5OTk2LDQ5OTk2LDExLDUwMDI0LDUwMDI0LDExLDUwMDUyLDUwMDUyLDExLDUwMDgwLDUwMDgwLDExLDUwMTA4LDUwMTA4LDExLDUwMTM2LDUwMTM2LDExLDUwMTY0LDUwMTY0LDExLDUwMTkyLDUwMTkyLDExLDUwMjIwLDUwMjIwLDExLDUwMjQ4LDUwMjQ4LDExLDUwMjc2LDUwMjc2LDExLDUwMzA0LDUwMzA0LDExLDUwMzMyLDUwMzMyLDExLDUwMzYwLDUwMzYwLDExLDUwMzg4LDUwMzg4LDExLDUwNDE2LDUwNDE2LDExLDUwNDQ0LDUwNDQ0LDExLDUwNDcyLDUwNDcyLDExLDUwNTAwLDUwNTAwLDExLDUwNTI4LDUwNTI4LDExLDUwNTU2LDUwNTU2LDExLDUwNTg0LDUwNTg0LDExLDUwNjEyLDUwNjEyLDExLDUwNjQwLDUwNjQwLDExLDUwNjY4LDUwNjY4LDExLDUwNjk2LDUwNjk2LDExLDUwNzI0LDUwNzI0LDExLDUwNzUyLDUwNzUyLDExLDUwNzgwLDUwNzgwLDExLDUwODA4LDUwODA4LDExLDUwODM2LDUwODM2LDExLDUwODY0LDUwODY0LDExLDUwODkyLDUwODkyLDExLDUwOTIwLDUwOTIwLDExLDUwOTQ4LDUwOTQ4LDExLDUwOTc2LDUwOTc2LDExLDUxMDA0LDUxMDA0LDExLDUxMDMyLDUxMDMyLDExLDUxMDYwLDUxMDYwLDExLDUxMDg4LDUxMDg4LDExLDUxMTE2LDUxMTE2LDExLDUxMTQ0LDUxMTQ0LDExLDUxMTcyLDUxMTcyLDExLDUxMjAwLDUxMjAwLDExLDUxMjI4LDUxMjI4LDExLDUxMjU2LDUxMjU2LDExLDUxMjg0LDUxMjg0LDExLDUxMzEyLDUxMzEyLDExLDUxMzQwLDUxMzQwLDExLDUxMzY4LDUxMzY4LDExLDUxMzk2LDUxMzk2LDExLDUxNDI0LDUxNDI0LDExLDUxNDUyLDUxNDUyLDExLDUxNDgwLDUxNDgwLDExLDUxNTA4LDUxNTA4LDExLDUxNTM2LDUxNTM2LDExLDUxNTY0LDUxNTY0LDExLDUxNTkyLDUxNTkyLDExLDUxNjIwLDUxNjIwLDExLDUxNjQ4LDUxNjQ4LDExLDUxNjc2LDUxNjc2LDExLDUxNzA0LDUxNzA0LDExLDUxNzMyLDUxNzMyLDExLDUxNzYwLDUxNzYwLDExLDUxNzg4LDUxNzg4LDExLDUxODE2LDUxODE2LDExLDUxODQ0LDUxODQ0LDExLDUxODcyLDUxODcyLDExLDUxOTAwLDUxOTAwLDExLDUxOTI4LDUxOTI4LDExLDUxOTU2LDUxOTU2LDExLDUxOTg0LDUxOTg0LDExLDUyMDEyLDUyMDEyLDExLDUyMDQwLDUyMDQwLDExLDUyMDY4LDUyMDY4LDExLDUyMDk2LDUyMDk2LDExLDUyMTI0LDUyMTI0LDExLDUyMTUyLDUyMTUyLDExLDUyMTgwLDUyMTgwLDExLDUyMjA4LDUyMjA4LDExLDUyMjM2LDUyMjM2LDExLDUyMjY0LDUyMjY0LDExLDUyMjkyLDUyMjkyLDExLDUyMzIwLDUyMzIwLDExLDUyMzQ4LDUyMzQ4LDExLDUyMzc2LDUyMzc2LDExLDUyNDA0LDUyNDA0LDExLDUyNDMyLDUyNDMyLDExLDUyNDYwLDUyNDYwLDExLDUyNDg4LDUyNDg4LDExLDUyNTE2LDUyNTE2LDExLDUyNTQ0LDUyNTQ0LDExLDUyNTcyLDUyNTcyLDExLDUyNjAwLDUyNjAwLDExLDUyNjI4LDUyNjI4LDExLDUyNjU2LDUyNjU2LDExLDUyNjg0LDUyNjg0LDExLDUyNzEyLDUyNzEyLDExLDUyNzQwLDUyNzQwLDExLDUyNzY4LDUyNzY4LDExLDUyNzk2LDUyNzk2LDExLDUyODI0LDUyODI0LDExLDUyODUyLDUyODUyLDExLDUyODgwLDUyODgwLDExLDUyOTA4LDUyOTA4LDExLDUyOTM2LDUyOTM2LDExLDUyOTY0LDUyOTY0LDExLDUyOTkyLDUyOTkyLDExLDUzMDIwLDUzMDIwLDExLDUzMDQ4LDUzMDQ4LDExLDUzMDc2LDUzMDc2LDExLDUzMTA0LDUzMTA0LDExLDUzMTMyLDUzMTMyLDExLDUzMTYwLDUzMTYwLDExLDUzMTg4LDUzMTg4LDExLDUzMjE2LDUzMjE2LDExLDUzMjQ0LDUzMjQ0LDExLDUzMjcyLDUzMjcyLDExLDUzMzAwLDUzMzAwLDExLDUzMzI4LDUzMzI4LDExLDUzMzU2LDUzMzU2LDExLDUzMzg0LDUzMzg0LDExLDUzNDEyLDUzNDEyLDExLDUzNDQwLDUzNDQwLDExLDUzNDY4LDUzNDY4LDExLDUzNDk2LDUzNDk2LDExLDUzNTI0LDUzNTI0LDExLDUzNTUyLDUzNTUyLDExLDUzNTgwLDUzNTgwLDExLDUzNjA4LDUzNjA4LDExLDUzNjM2LDUzNjM2LDExLDUzNjY0LDUzNjY0LDExLDUzNjkyLDUzNjkyLDExLDUzNzIwLDUzNzIwLDExLDUzNzQ4LDUzNzQ4LDExLDUzNzc2LDUzNzc2LDExLDUzODA0LDUzODA0LDExLDUzODMyLDUzODMyLDExLDUzODYwLDUzODYwLDExLDUzODg4LDUzODg4LDExLDUzOTE2LDUzOTE2LDExLDUzOTQ0LDUzOTQ0LDExLDUzOTcyLDUzOTcyLDExLDU0MDAwLDU0MDAwLDExLDU0MDI4LDU0MDI4LDExLDU0MDU2LDU0MDU2LDExLDU0MDg0LDU0MDg0LDExLDU0MTEyLDU0MTEyLDExLDU0MTQwLDU0MTQwLDExLDU0MTY4LDU0MTY4LDExLDU0MTk2LDU0MTk2LDExLDU0MjI0LDU0MjI0LDExLDU0MjUyLDU0MjUyLDExLDU0MjgwLDU0MjgwLDExLDU0MzA4LDU0MzA4LDExLDU0MzM2LDU0MzM2LDExLDU0MzY0LDU0MzY0LDExLDU0MzkyLDU0MzkyLDExLDU0NDIwLDU0NDIwLDExLDU0NDQ4LDU0NDQ4LDExLDU0NDc2LDU0NDc2LDExLDU0NTA0LDU0NTA0LDExLDU0NTMyLDU0NTMyLDExLDU0NTYwLDU0NTYwLDExLDU0NTg4LDU0NTg4LDExLDU0NjE2LDU0NjE2LDExLDU0NjQ0LDU0NjQ0LDExLDU0NjcyLDU0NjcyLDExLDU0NzAwLDU0NzAwLDExLDU0NzI4LDU0NzI4LDExLDU0NzU2LDU0NzU2LDExLDU0Nzg0LDU0Nzg0LDExLDU0ODEyLDU0ODEyLDExLDU0ODQwLDU0ODQwLDExLDU0ODY4LDU0ODY4LDExLDU0ODk2LDU0ODk2LDExLDU0OTI0LDU0OTI0LDExLDU0OTUyLDU0OTUyLDExLDU0OTgwLDU0OTgwLDExLDU1MDA4LDU1MDA4LDExLDU1MDM2LDU1MDM2LDExLDU1MDY0LDU1MDY0LDExLDU1MDkyLDU1MDkyLDExLDU1MTIwLDU1MTIwLDExLDU1MTQ4LDU1MTQ4LDExLDU1MTc2LDU1MTc2LDExLDU1MjE2LDU1MjM4LDksNjQyODYsNjQyODYsNSw2NTA1Niw2NTA3MSw1LDY1NDM4LDY1NDM5LDUsNjU1MjksNjU1MzEsNCw2NjI3Miw2NjI3Miw1LDY4MDk3LDY4MDk5LDUsNjgxMDgsNjgxMTEsNSw2ODE1OSw2ODE1OSw1LDY4OTAwLDY4OTAzLDUsNjk0NDYsNjk0NTYsNSw2OTYzMiw2OTYzMiw3LDY5NjM0LDY5NjM0LDcsNjk3NDQsNjk3NDQsNSw2OTc1OSw2OTc2MSw1LDY5ODA4LDY5ODEwLDcsNjk4MTUsNjk4MTYsNyw2OTgyMSw2OTgyMSwxLDY5ODM3LDY5ODM3LDEsNjk5MjcsNjk5MzEsNSw2OTkzMyw2OTk0MCw1LDcwMDAzLDcwMDAzLDUsNzAwMTgsNzAwMTgsNyw3MDA3MCw3MDA3OCw1LDcwMDgyLDcwMDgzLDEsNzAwOTQsNzAwOTQsNyw3MDE4OCw3MDE5MCw3LDcwMTk0LDcwMTk1LDcsNzAxOTcsNzAxOTcsNyw3MDIwNiw3MDIwNiw1LDcwMzY4LDcwMzcwLDcsNzA0MDAsNzA0MDEsNSw3MDQ1OSw3MDQ2MCw1LDcwNDYzLDcwNDYzLDcsNzA0NjUsNzA0NjgsNyw3MDQ3NSw3MDQ3Nyw3LDcwNDk4LDcwNDk5LDcsNzA1MTIsNzA1MTYsNSw3MDcxMiw3MDcxOSw1LDcwNzIyLDcwNzI0LDUsNzA3MjYsNzA3MjYsNSw3MDgzMiw3MDgzMiw1LDcwODM1LDcwODQwLDUsNzA4NDIsNzA4NDIsNSw3MDg0NSw3MDg0NSw1LDcwODQ3LDcwODQ4LDUsNzA4NTAsNzA4NTEsNSw3MTA4OCw3MTA4OSw3LDcxMDk2LDcxMDk5LDcsNzExMDIsNzExMDIsNyw3MTEzMiw3MTEzMyw1LDcxMjE5LDcxMjI2LDUsNzEyMjksNzEyMjksNSw3MTIzMSw3MTIzMiw1LDcxMzQwLDcxMzQwLDcsNzEzNDIsNzEzNDMsNyw3MTM1MCw3MTM1MCw3LDcxNDUzLDcxNDU1LDUsNzE0NjIsNzE0NjIsNyw3MTcyNCw3MTcyNiw3LDcxNzM2LDcxNzM2LDcsNzE5ODQsNzE5ODQsNSw3MTk5MSw3MTk5Miw3LDcxOTk3LDcxOTk3LDcsNzE5OTksNzE5OTksMSw3MjAwMSw3MjAwMSwxLDcyMDAzLDcyMDAzLDUsNzIxNDgsNzIxNTEsNSw3MjE1Niw3MjE1OSw3LDcyMTY0LDcyMTY0LDcsNzIyNDMsNzIyNDgsNSw3MjI1MCw3MjI1MCwxLDcyMjYzLDcyMjYzLDUsNzIyNzksNzIyODAsNyw3MjMyNCw3MjMyOSwxLDcyMzQzLDcyMzQzLDcsNzI3NTEsNzI3NTEsNyw3Mjc2MCw3Mjc2NSw1LDcyNzY3LDcyNzY3LDUsNzI4NzMsNzI4NzMsNyw3Mjg4MSw3Mjg4MSw3LDcyODg0LDcyODg0LDcsNzMwMDksNzMwMTQsNSw3MzAyMCw3MzAyMSw1LDczMDMwLDczMDMwLDEsNzMwOTgsNzMxMDIsNyw3MzEwNyw3MzEwOCw3LDczMTEwLDczMTEwLDcsNzM0NTksNzM0NjAsNSw3ODg5Niw3ODkwNCw0LDkyOTc2LDkyOTgyLDUsOTQwMzMsOTQwODcsNyw5NDE4MCw5NDE4MCw1LDExMzgyMSwxMTM4MjIsNSwxMTg1MjgsMTE4NTczLDUsMTE5MTQxLDExOTE0MSw1LDExOTE0MywxMTkxNDUsNSwxMTkxNTAsMTE5MTU0LDUsMTE5MTYzLDExOTE3MCw1LDExOTIxMCwxMTkyMTMsNSwxMjEzNDQsMTIxMzk4LDUsMTIxNDYxLDEyMTQ2MSw1LDEyMTQ5OSwxMjE1MDMsNSwxMjI4ODAsMTIyODg2LDUsMTIyOTA3LDEyMjkxMyw1LDEyMjkxOCwxMjI5MjIsNSwxMjM1NjYsMTIzNTY2LDUsMTI1MTM2LDEyNTE0Miw1LDEyNjk3NiwxMjY5NzksMTQsMTI2OTgxLDEyNzE4MiwxNCwxMjcxODQsMTI3MjMxLDE0LDEyNzI3OSwxMjcyNzksMTQsMTI3MzQ0LDEyNzM0NSwxNCwxMjczNzQsMTI3Mzc0LDE0LDEyNzQwNSwxMjc0NjEsMTQsMTI3NDg5LDEyNzQ5MCwxNCwxMjc1MTQsMTI3NTE0LDE0LDEyNzUzOCwxMjc1NDYsMTQsMTI3NTYxLDEyNzU2NywxNCwxMjc1NzAsMTI3NzQzLDE0LDEyNzc1NywxMjc3NTgsMTQsMTI3NzYwLDEyNzc2MCwxNCwxMjc3NjIsMTI3NzYyLDE0LDEyNzc2NiwxMjc3NjgsMTQsMTI3NzcwLDEyNzc3MCwxNCwxMjc3NzIsMTI3NzcyLDE0LDEyNzc3NSwxMjc3NzYsMTQsMTI3Nzc4LDEyNzc3OSwxNCwxMjc3ODksMTI3NzkxLDE0LDEyNzc5NCwxMjc3OTUsMTQsMTI3Nzk4LDEyNzc5OCwxNCwxMjc4MTksMTI3ODE5LDE0LDEyNzgyNCwxMjc4MjQsMTQsMTI3ODY4LDEyNzg2OCwxNCwxMjc4NzAsMTI3ODcxLDE0LDEyNzg5MiwxMjc4OTMsMTQsMTI3ODk2LDEyNzg5NiwxNCwxMjc5MDAsMTI3OTAxLDE0LDEyNzkwNCwxMjc5NDAsMTQsMTI3OTQyLDEyNzk0MiwxNCwxMjc5NDQsMTI3OTQ0LDE0LDEyNzk0NiwxMjc5NDYsMTQsMTI3OTUxLDEyNzk1NSwxNCwxMjc5NjgsMTI3OTcxLDE0LDEyNzk3MywxMjc5ODQsMTQsMTI3OTg3LDEyNzk4NywxNCwxMjc5ODksMTI3OTg5LDE0LDEyNzk5MSwxMjc5OTEsMTQsMTI3OTk1LDEyNzk5OSw1LDEyODAwOCwxMjgwMDgsMTQsMTI4MDEyLDEyODAxNCwxNCwxMjgwMTcsMTI4MDE4LDE0LDEyODAyMCwxMjgwMjAsMTQsMTI4MDIyLDEyODAyMiwxNCwxMjgwNDIsMTI4MDQyLDE0LDEyODA2MywxMjgwNjMsMTQsMTI4MDY1LDEyODA2NSwxNCwxMjgxMDEsMTI4MTAxLDE0LDEyODEwOCwxMjgxMDksMTQsMTI4MTczLDEyODE3MywxNCwxMjgxODIsMTI4MTgzLDE0LDEyODIzNiwxMjgyMzcsMTQsMTI4MjM5LDEyODIzOSwxNCwxMjgyNDUsMTI4MjQ1LDE0LDEyODI0OCwxMjgyNDgsMTQsMTI4MjUzLDEyODI1MywxNCwxMjgyNTUsMTI4MjU4LDE0LDEyODI2MCwxMjgyNjMsMTQsMTI4MjY1LDEyODI2NSwxNCwxMjgyNzcsMTI4Mjc3LDE0LDEyODMwMCwxMjgzMDEsMTQsMTI4MzI2LDEyODMyOCwxNCwxMjgzMzEsMTI4MzM0LDE0LDEyODMzNiwxMjgzNDcsMTQsMTI4MzYwLDEyODM2NiwxNCwxMjgzNjksMTI4MzcwLDE0LDEyODM3OCwxMjgzNzgsMTQsMTI4MzkxLDEyODM5MSwxNCwxMjgzOTQsMTI4Mzk3LDE0LDEyODQwMCwxMjg0MDAsMTQsMTI4NDA1LDEyODQwNiwxNCwxMjg0MjAsMTI4NDIwLDE0LDEyODQyMiwxMjg0MjMsMTQsMTI4NDI1LDEyODQzMiwxNCwxMjg0MzUsMTI4NDQzLDE0LDEyODQ0NSwxMjg0NDksMTQsMTI4NDUzLDEyODQ2NCwxNCwxMjg0NjgsMTI4NDc1LDE0LDEyODQ3OSwxMjg0ODAsMTQsMTI4NDgyLDEyODQ4MiwxNCwxMjg0ODQsMTI4NDg3LDE0LDEyODQ4OSwxMjg0OTQsMTQsMTI4NDk2LDEyODQ5OCwxNCwxMjg1MDAsMTI4NTA1LDE0LDEyODUwNywxMjg1MTEsMTQsMTI4NTEzLDEyODUxOCwxNCwxMjg1MjEsMTI4NTI1LDE0LDEyODUyNywxMjg1MjcsMTQsMTI4NTI5LDEyODUyOSwxNCwxMjg1MzMsMTI4NTMzLDE0LDEyODUzNSwxMjg1MzUsMTQsMTI4NTM3LDEyODUzNywxNF0nKTtcbn1cbi8vI2VuZHJlZ2lvblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgb2Zmc2V0IGFmdGVyIHBlcmZvcm1pbmcgYSBsZWZ0IGRlbGV0ZSBvbiB0aGUgZ2l2ZW4gc3RyaW5nLFxuICogd2hpbGUgY29uc2lkZXJpbmcgdW5pY29kZSBncmFwaGVtZS9lbW9qaSBydWxlcy5cbiovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVmdERlbGV0ZU9mZnNldChvZmZzZXQsIHN0cikge1xuICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFRyeSB0byBkZWxldGUgZW1vamkgcGFydC5cbiAgICBjb25zdCBlbW9qaU9mZnNldCA9IGdldE9mZnNldEJlZm9yZUxhc3RFbW9qaUNvbXBvbmVudChvZmZzZXQsIHN0cik7XG4gICAgaWYgKGVtb2ppT2Zmc2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVtb2ppT2Zmc2V0O1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGp1c3Qgc2tpcCBhIHNpbmdsZSBjb2RlIHBvaW50LlxuICAgIGNvbnN0IGl0ZXJhdG9yID0gbmV3IENvZGVQb2ludEl0ZXJhdG9yKHN0ciwgb2Zmc2V0KTtcbiAgICBpdGVyYXRvci5wcmV2Q29kZVBvaW50KCk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yLm9mZnNldDtcbn1cbmZ1bmN0aW9uIGdldE9mZnNldEJlZm9yZUxhc3RFbW9qaUNvbXBvbmVudChpbml0aWFsT2Zmc2V0LCBzdHIpIHtcbiAgICAvLyBTZWUgaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjUxL3RyNTEtMTQuaHRtbCNFQk5GX2FuZF9SZWdleCBmb3IgdGhlXG4gICAgLy8gc3RydWN0dXJlIG9mIGVtb2ppcy5cbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBDb2RlUG9pbnRJdGVyYXRvcihzdHIsIGluaXRpYWxPZmZzZXQpO1xuICAgIGxldCBjb2RlUG9pbnQgPSBpdGVyYXRvci5wcmV2Q29kZVBvaW50KCk7XG4gICAgLy8gU2tpcCBtb2RpZmllcnNcbiAgICB3aGlsZSAoKGlzRW1vamlNb2RpZmllcihjb2RlUG9pbnQpIHx8IGNvZGVQb2ludCA9PT0gNjUwMzkgLyogQ29kZVBvaW50LmVtb2ppVmFyaWFudFNlbGVjdG9yICovIHx8IGNvZGVQb2ludCA9PT0gODQxOSAvKiBDb2RlUG9pbnQuZW5jbG9zaW5nS2V5Q2FwICovKSkge1xuICAgICAgICBpZiAoaXRlcmF0b3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAvLyBDYW5ub3Qgc2tpcCBtb2RpZmllciwgbm8gcHJlY2VkaW5nIGVtb2ppIGJhc2UuXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCA9IGl0ZXJhdG9yLnByZXZDb2RlUG9pbnQoKTtcbiAgICB9XG4gICAgLy8gRXhwZWN0IGJhc2UgZW1vamlcbiAgICBpZiAoIWlzRW1vamlJbXByZWNpc2UoY29kZVBvaW50KSkge1xuICAgICAgICAvLyBVbmV4cGVjdGVkIGNvZGUgcG9pbnQsIG5vdCBhIHZhbGlkIGVtb2ppLlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0T2Zmc2V0ID0gaXRlcmF0b3Iub2Zmc2V0O1xuICAgIGlmIChyZXN1bHRPZmZzZXQgPiAwKSB7XG4gICAgICAgIC8vIFNraXAgb3B0aW9uYWwgWldKIGNvZGUgcG9pbnRzIHRoYXQgY29tYmluZSBtdWx0aXBsZSBlbW9qaXMuXG4gICAgICAgIC8vIEluIHRoZW9yeSwgd2Ugc2hvdWxkIGNoZWNrIGlmIHRoYXQgWldKIGFjdHVhbGx5IGNvbWJpbmVzIG11bHRpcGxlIGVtb2ppc1xuICAgICAgICAvLyB0byBwcmV2ZW50IGRlbGV0aW5nIFpXSnMgaW4gc2l0dWF0aW9ucyB3ZSBkaWRuJ3QgYWNjb3VudCBmb3IuXG4gICAgICAgIGNvbnN0IG9wdGlvbmFsWndqQ29kZVBvaW50ID0gaXRlcmF0b3IucHJldkNvZGVQb2ludCgpO1xuICAgICAgICBpZiAob3B0aW9uYWxad2pDb2RlUG9pbnQgPT09IDgyMDUgLyogQ29kZVBvaW50Lnp3aiAqLykge1xuICAgICAgICAgICAgcmVzdWx0T2Zmc2V0ID0gaXRlcmF0b3Iub2Zmc2V0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRPZmZzZXQ7XG59XG5mdW5jdGlvbiBpc0Vtb2ppTW9kaWZpZXIoY29kZVBvaW50KSB7XG4gICAgcmV0dXJuIDB4MUYzRkIgPD0gY29kZVBvaW50ICYmIGNvZGVQb2ludCA8PSAweDFGM0ZGO1xufVxuZXhwb3J0IGNvbnN0IG5vQnJlYWtXaGl0ZXNwYWNlID0gJ1xceGEwJztcbmV4cG9ydCBjbGFzcyBBbWJpZ3VvdXNDaGFyYWN0ZXJzIHtcbiAgICBzdGF0aWMgZ2V0SW5zdGFuY2UobG9jYWxlcykge1xuICAgICAgICByZXR1cm4gX2EuY2FjaGUuZ2V0KEFycmF5LmZyb20obG9jYWxlcykpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TG9jYWxlcygpIHtcbiAgICAgICAgcmV0dXJuIF9hLl9sb2NhbGVzLnZhbHVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb25mdXNhYmxlRGljdGlvbmFyeSkge1xuICAgICAgICB0aGlzLmNvbmZ1c2FibGVEaWN0aW9uYXJ5ID0gY29uZnVzYWJsZURpY3Rpb25hcnk7XG4gICAgfVxuICAgIGlzQW1iaWd1b3VzKGNvZGVQb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25mdXNhYmxlRGljdGlvbmFyeS5oYXMoY29kZVBvaW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbm9uIGJhc2ljIEFTQ0lJIGNvZGUgcG9pbnQgdGhhdCB0aGUgZ2l2ZW4gY29kZSBwb2ludCBjYW4gYmUgY29uZnVzZWQsXG4gICAgICogb3IgdW5kZWZpbmVkIGlmIHN1Y2ggY29kZSBwb2ludCBkb2VzIG5vdGUgZXhpc3QuXG4gICAgICovXG4gICAgZ2V0UHJpbWFyeUNvbmZ1c2FibGUoY29kZVBvaW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZ1c2FibGVEaWN0aW9uYXJ5LmdldChjb2RlUG9pbnQpO1xuICAgIH1cbiAgICBnZXRDb25mdXNhYmxlQ29kZVBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5jb25mdXNhYmxlRGljdGlvbmFyeS5rZXlzKCkpO1xuICAgIH1cbn1cbl9hID0gQW1iaWd1b3VzQ2hhcmFjdGVycztcbkFtYmlndW91c0NoYXJhY3RlcnMuYW1iaWd1b3VzQ2hhcmFjdGVyRGF0YSA9IG5ldyBMYXp5KCgpID0+IHtcbiAgICAvLyBHZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2hlZGlldC92c2NvZGUtdW5pY29kZS1kYXRhXG4gICAgLy8gU3RvcmVkIGFzIGtleTEsIHZhbHVlMSwga2V5MiwgdmFsdWUyLCAuLi5cbiAgICByZXR1cm4gSlNPTi5wYXJzZSgne1xcXCJfY29tbW9uXFxcIjpbODIzMiwzMiw4MjMzLDMyLDU3NjAsMzIsODE5MiwzMiw4MTkzLDMyLDgxOTQsMzIsODE5NSwzMiw4MTk2LDMyLDgxOTcsMzIsODE5OCwzMiw4MjAwLDMyLDgyMDEsMzIsODIwMiwzMiw4Mjg3LDMyLDgxOTksMzIsODIzOSwzMiwyMDQyLDk1LDY1MTAxLDk1LDY1MTAyLDk1LDY1MTAzLDk1LDgyMDgsNDUsODIwOSw0NSw4MjEwLDQ1LDY1MTEyLDQ1LDE3NDgsNDUsODI1OSw0NSw3MjcsNDUsODcyMiw0NSwxMDEzNCw0NSwxMTQ1MCw0NSwxNTQ5LDQ0LDE2NDMsNDQsODIxOCw0NCwxODQsNDQsNDIyMzMsNDQsODk0LDU5LDIzMDcsNTgsMjY5MSw1OCwxNDE3LDU4LDE3OTUsNTgsMTc5Niw1OCw1ODY4LDU4LDY1MDcyLDU4LDYxNDcsNTgsNjE1Myw1OCw4MjgyLDU4LDE0NzUsNTgsNzYwLDU4LDQyODg5LDU4LDg3NTgsNTgsNzIwLDU4LDQyMjM3LDU4LDQ1MSwzMywxMTYwMSwzMyw2NjAsNjMsNTc3LDYzLDI0MjksNjMsNTAzOCw2Myw0MjczMSw2MywxMTkxNDksNDYsODIyOCw0NiwxNzkzLDQ2LDE3OTQsNDYsNDI1MTAsNDYsNjgxNzYsNDYsMTYzMiw0NiwxNzc2LDQ2LDQyMjMyLDQ2LDEzNzMsOTYsNjUyODcsOTYsODIxOSw5Niw4MjQyLDk2LDEzNzAsOTYsMTUyMyw5Niw4MTc1LDk2LDY1MzQ0LDk2LDkwMCw5Niw4MTg5LDk2LDgxMjUsOTYsODEyNyw5Niw4MTkwLDk2LDY5Nyw5Niw4ODQsOTYsNzEyLDk2LDcxNCw5Niw3MTUsOTYsNzU2LDk2LDY5OSw5Niw3MDEsOTYsNzAwLDk2LDcwMiw5Niw0Mjg5Miw5NiwxNDk3LDk2LDIwMzYsOTYsMjAzNyw5Niw1MTk0LDk2LDU4MzYsOTYsOTQwMzMsOTYsOTQwMzQsOTYsNjUzMzksOTEsMTAwODgsNDAsMTAwOTgsNDAsMTIzMDgsNDAsNjQ4MzAsNDAsNjUzNDEsOTMsMTAwODksNDEsMTAwOTksNDEsMTIzMDksNDEsNjQ4MzEsNDEsMTAxMDAsMTIzLDExOTA2MCwxMjMsMTAxMDEsMTI1LDY1MzQyLDk0LDgyNzAsNDIsMTY0NSw0Miw4NzI3LDQyLDY2MzM1LDQyLDU5NDEsNDcsODI1Nyw0Nyw4NzI1LDQ3LDgyNjAsNDcsOTU4NSw0NywxMDE4Nyw0NywxMDc0NCw0NywxMTkzNTQsNDcsMTI3NTUsNDcsMTIzMzksNDcsMTE0NjIsNDcsMjAwMzEsNDcsMTIwMzUsNDcsNjUzNDAsOTIsNjUxMjgsOTIsODcyNiw5MiwxMDE4OSw5MiwxMDc0MSw5MiwxMDc0NSw5MiwxMTkzMTEsOTIsMTE5MzU1LDkyLDEyNzU2LDkyLDIwMDIyLDkyLDEyMDM0LDkyLDQyODcyLDM4LDcwOCw5NCw3MTAsOTQsNTg2OSw0MywxMDEzMyw0Myw2NjIwMyw0Myw4MjQ5LDYwLDEwMDk0LDYwLDcwNiw2MCwxMTkzNTAsNjAsNTE3Niw2MCw1ODEwLDYwLDUxMjAsNjEsMTE4NDAsNjEsMTI0NDgsNjEsNDIyMzksNjEsODI1MCw2MiwxMDA5NSw2Miw3MDcsNjIsMTE5MzUxLDYyLDUxNzEsNjIsOTQwMTUsNjIsODI3NSwxMjYsNzMyLDEyNiw4MTI4LDEyNiw4NzY0LDEyNiw2NTM3MiwxMjQsNjUyOTMsNDUsMTIwNzg0LDUwLDEyMDc5NCw1MCwxMjA4MDQsNTAsMTIwODE0LDUwLDEyMDgyNCw1MCwxMzAwMzQsNTAsNDI4NDIsNTAsNDIzLDUwLDEwMDAsNTAsNDI1NjQsNTAsNTMxMSw1MCw0MjczNSw1MCwxMTkzMDIsNTEsMTIwNzg1LDUxLDEyMDc5NSw1MSwxMjA4MDUsNTEsMTIwODE1LDUxLDEyMDgyNSw1MSwxMzAwMzUsNTEsNDI5MjMsNTEsNTQwLDUxLDQzOSw1MSw0Mjg1OCw1MSwxMTQ2OCw1MSwxMjQ4LDUxLDk0MDExLDUxLDcxODgyLDUxLDEyMDc4Niw1MiwxMjA3OTYsNTIsMTIwODA2LDUyLDEyMDgxNiw1MiwxMjA4MjYsNTIsMTMwMDM2LDUyLDUwNzAsNTIsNzE4NTUsNTIsMTIwNzg3LDUzLDEyMDc5Nyw1MywxMjA4MDcsNTMsMTIwODE3LDUzLDEyMDgyNyw1MywxMzAwMzcsNTMsNDQ0LDUzLDcxODY3LDUzLDEyMDc4OCw1NCwxMjA3OTgsNTQsMTIwODA4LDU0LDEyMDgxOCw1NCwxMjA4MjgsNTQsMTMwMDM4LDU0LDExNDc0LDU0LDUxMDIsNTQsNzE4OTMsNTQsMTE5MzE0LDU1LDEyMDc4OSw1NSwxMjA3OTksNTUsMTIwODA5LDU1LDEyMDgxOSw1NSwxMjA4MjksNTUsMTMwMDM5LDU1LDY2NzcwLDU1LDcxODc4LDU1LDI4MTksNTYsMjUzOCw1NiwyNjY2LDU2LDEyNTEzMSw1NiwxMjA3OTAsNTYsMTIwODAwLDU2LDEyMDgxMCw1NiwxMjA4MjAsNTYsMTIwODMwLDU2LDEzMDA0MCw1Niw1NDcsNTYsNTQ2LDU2LDY2MzMwLDU2LDI2NjMsNTcsMjkyMCw1NywyNTQxLDU3LDM0MzcsNTcsMTIwNzkxLDU3LDEyMDgwMSw1NywxMjA4MTEsNTcsMTIwODIxLDU3LDEyMDgzMSw1NywxMzAwNDEsNTcsNDI4NjIsNTcsMTE0NjYsNTcsNzE4ODQsNTcsNzE4NTIsNTcsNzE4OTQsNTcsOTA4Miw5Nyw2NTM0NSw5NywxMTk4MzQsOTcsMTE5ODg2LDk3LDExOTkzOCw5NywxMTk5OTAsOTcsMTIwMDQyLDk3LDEyMDA5NCw5NywxMjAxNDYsOTcsMTIwMTk4LDk3LDEyMDI1MCw5NywxMjAzMDIsOTcsMTIwMzU0LDk3LDEyMDQwNiw5NywxMjA0NTgsOTcsNTkzLDk3LDk0NSw5NywxMjA1MTQsOTcsMTIwNTcyLDk3LDEyMDYzMCw5NywxMjA2ODgsOTcsMTIwNzQ2LDk3LDY1MzEzLDY1LDExOTgwOCw2NSwxMTk4NjAsNjUsMTE5OTEyLDY1LDExOTk2NCw2NSwxMjAwMTYsNjUsMTIwMDY4LDY1LDEyMDEyMCw2NSwxMjAxNzIsNjUsMTIwMjI0LDY1LDEyMDI3Niw2NSwxMjAzMjgsNjUsMTIwMzgwLDY1LDEyMDQzMiw2NSw5MTMsNjUsMTIwNDg4LDY1LDEyMDU0Niw2NSwxMjA2MDQsNjUsMTIwNjYyLDY1LDEyMDcyMCw2NSw1MDM0LDY1LDU1NzMsNjUsNDIyMjIsNjUsOTQwMTYsNjUsNjYyMDgsNjUsMTE5ODM1LDk4LDExOTg4Nyw5OCwxMTk5MzksOTgsMTE5OTkxLDk4LDEyMDA0Myw5OCwxMjAwOTUsOTgsMTIwMTQ3LDk4LDEyMDE5OSw5OCwxMjAyNTEsOTgsMTIwMzAzLDk4LDEyMDM1NSw5OCwxMjA0MDcsOTgsMTIwNDU5LDk4LDM4OCw5OCw1MDcxLDk4LDUyMzQsOTgsNTU1MSw5OCw2NTMxNCw2Niw4NDkyLDY2LDExOTgwOSw2NiwxMTk4NjEsNjYsMTE5OTEzLDY2LDEyMDAxNyw2NiwxMjAwNjksNjYsMTIwMTIxLDY2LDEyMDE3Myw2NiwxMjAyMjUsNjYsMTIwMjc3LDY2LDEyMDMyOSw2NiwxMjAzODEsNjYsMTIwNDMzLDY2LDQyOTMyLDY2LDkxNCw2NiwxMjA0ODksNjYsMTIwNTQ3LDY2LDEyMDYwNSw2NiwxMjA2NjMsNjYsMTIwNzIxLDY2LDUxMDgsNjYsNTYyMyw2Niw0MjE5Miw2Niw2NjE3OCw2Niw2NjIwOSw2Niw2NjMwNSw2Niw2NTM0Nyw5OSw4NTczLDk5LDExOTgzNiw5OSwxMTk4ODgsOTksMTE5OTQwLDk5LDExOTk5Miw5OSwxMjAwNDQsOTksMTIwMDk2LDk5LDEyMDE0OCw5OSwxMjAyMDAsOTksMTIwMjUyLDk5LDEyMDMwNCw5OSwxMjAzNTYsOTksMTIwNDA4LDk5LDEyMDQ2MCw5OSw3NDI4LDk5LDEwMTAsOTksMTE0MjksOTksNDM5NTEsOTksNjY2MjEsOTksMTI4ODQ0LDY3LDcxOTIyLDY3LDcxOTEzLDY3LDY1MzE1LDY3LDg1NTcsNjcsODQ1MCw2Nyw4NDkzLDY3LDExOTgxMCw2NywxMTk4NjIsNjcsMTE5OTE0LDY3LDExOTk2Niw2NywxMjAwMTgsNjcsMTIwMTc0LDY3LDEyMDIyNiw2NywxMjAyNzgsNjcsMTIwMzMwLDY3LDEyMDM4Miw2NywxMjA0MzQsNjcsMTAxNyw2NywxMTQyOCw2Nyw1MDg3LDY3LDQyMjAyLDY3LDY2MjEwLDY3LDY2MzA2LDY3LDY2NTgxLDY3LDY2ODQ0LDY3LDg1NzQsMTAwLDg1MTgsMTAwLDExOTgzNywxMDAsMTE5ODg5LDEwMCwxMTk5NDEsMTAwLDExOTk5MywxMDAsMTIwMDQ1LDEwMCwxMjAwOTcsMTAwLDEyMDE0OSwxMDAsMTIwMjAxLDEwMCwxMjAyNTMsMTAwLDEyMDMwNSwxMDAsMTIwMzU3LDEwMCwxMjA0MDksMTAwLDEyMDQ2MSwxMDAsMTI4MSwxMDAsNTA5NSwxMDAsNTIzMSwxMDAsNDIxOTQsMTAwLDg1NTgsNjgsODUxNyw2OCwxMTk4MTEsNjgsMTE5ODYzLDY4LDExOTkxNSw2OCwxMTk5NjcsNjgsMTIwMDE5LDY4LDEyMDA3MSw2OCwxMjAxMjMsNjgsMTIwMTc1LDY4LDEyMDIyNyw2OCwxMjAyNzksNjgsMTIwMzMxLDY4LDEyMDM4Myw2OCwxMjA0MzUsNjgsNTAyNCw2OCw1NTk4LDY4LDU2MTAsNjgsNDIxOTUsNjgsODQ5NCwxMDEsNjUzNDksMTAxLDg0OTUsMTAxLDg1MTksMTAxLDExOTgzOCwxMDEsMTE5ODkwLDEwMSwxMTk5NDIsMTAxLDEyMDA0NiwxMDEsMTIwMDk4LDEwMSwxMjAxNTAsMTAxLDEyMDIwMiwxMDEsMTIwMjU0LDEwMSwxMjAzMDYsMTAxLDEyMDM1OCwxMDEsMTIwNDEwLDEwMSwxMjA0NjIsMTAxLDQzODI2LDEwMSwxMjEzLDEwMSw4OTU5LDY5LDY1MzE3LDY5LDg0OTYsNjksMTE5ODEyLDY5LDExOTg2NCw2OSwxMTk5MTYsNjksMTIwMDIwLDY5LDEyMDA3Miw2OSwxMjAxMjQsNjksMTIwMTc2LDY5LDEyMDIyOCw2OSwxMjAyODAsNjksMTIwMzMyLDY5LDEyMDM4NCw2OSwxMjA0MzYsNjksOTE3LDY5LDEyMDQ5Miw2OSwxMjA1NTAsNjksMTIwNjA4LDY5LDEyMDY2Niw2OSwxMjA3MjQsNjksMTE1NzcsNjksNTAzNiw2OSw0MjIyNCw2OSw3MTg0Niw2OSw3MTg1NCw2OSw2NjE4Miw2OSwxMTk4MzksMTAyLDExOTg5MSwxMDIsMTE5OTQzLDEwMiwxMTk5OTUsMTAyLDEyMDA0NywxMDIsMTIwMDk5LDEwMiwxMjAxNTEsMTAyLDEyMDIwMywxMDIsMTIwMjU1LDEwMiwxMjAzMDcsMTAyLDEyMDM1OSwxMDIsMTIwNDExLDEwMiwxMjA0NjMsMTAyLDQzODI5LDEwMiw0MjkwNSwxMDIsMzgzLDEwMiw3ODM3LDEwMiwxNDEyLDEwMiwxMTkzMTUsNzAsODQ5Nyw3MCwxMTk4MTMsNzAsMTE5ODY1LDcwLDExOTkxNyw3MCwxMjAwMjEsNzAsMTIwMDczLDcwLDEyMDEyNSw3MCwxMjAxNzcsNzAsMTIwMjI5LDcwLDEyMDI4MSw3MCwxMjAzMzMsNzAsMTIwMzg1LDcwLDEyMDQzNyw3MCw0MjkwNCw3MCw5ODgsNzAsMTIwNzc4LDcwLDU1NTYsNzAsNDIyMDUsNzAsNzE4NzQsNzAsNzE4NDIsNzAsNjYxODMsNzAsNjYyMTMsNzAsNjY4NTMsNzAsNjUzNTEsMTAzLDg0NTgsMTAzLDExOTg0MCwxMDMsMTE5ODkyLDEwMywxMTk5NDQsMTAzLDEyMDA0OCwxMDMsMTIwMTAwLDEwMywxMjAxNTIsMTAzLDEyMDIwNCwxMDMsMTIwMjU2LDEwMywxMjAzMDgsMTAzLDEyMDM2MCwxMDMsMTIwNDEyLDEwMywxMjA0NjQsMTAzLDYwOSwxMDMsNzU1NSwxMDMsMzk3LDEwMywxNDA5LDEwMywxMTk4MTQsNzEsMTE5ODY2LDcxLDExOTkxOCw3MSwxMTk5NzAsNzEsMTIwMDIyLDcxLDEyMDA3NCw3MSwxMjAxMjYsNzEsMTIwMTc4LDcxLDEyMDIzMCw3MSwxMjAyODIsNzEsMTIwMzM0LDcxLDEyMDM4Niw3MSwxMjA0MzgsNzEsMTI5Miw3MSw1MDU2LDcxLDUxMDcsNzEsNDIxOTgsNzEsNjUzNTIsMTA0LDg0NjIsMTA0LDExOTg0MSwxMDQsMTE5OTQ1LDEwNCwxMTk5OTcsMTA0LDEyMDA0OSwxMDQsMTIwMTAxLDEwNCwxMjAxNTMsMTA0LDEyMDIwNSwxMDQsMTIwMjU3LDEwNCwxMjAzMDksMTA0LDEyMDM2MSwxMDQsMTIwNDEzLDEwNCwxMjA0NjUsMTA0LDEyMTEsMTA0LDEzOTIsMTA0LDUwNTgsMTA0LDY1MzIwLDcyLDg0NTksNzIsODQ2MCw3Miw4NDYxLDcyLDExOTgxNSw3MiwxMTk4NjcsNzIsMTE5OTE5LDcyLDEyMDAyMyw3MiwxMjAxNzksNzIsMTIwMjMxLDcyLDEyMDI4Myw3MiwxMjAzMzUsNzIsMTIwMzg3LDcyLDEyMDQzOSw3Miw5MTksNzIsMTIwNDk0LDcyLDEyMDU1Miw3MiwxMjA2MTAsNzIsMTIwNjY4LDcyLDEyMDcyNiw3MiwxMTQwNiw3Miw1MDUxLDcyLDU1MDAsNzIsNDIyMTUsNzIsNjYyNTUsNzIsNzMxLDEwNSw5MDc1LDEwNSw2NTM1MywxMDUsODU2MCwxMDUsODUwNSwxMDUsODUyMCwxMDUsMTE5ODQyLDEwNSwxMTk4OTQsMTA1LDExOTk0NiwxMDUsMTE5OTk4LDEwNSwxMjAwNTAsMTA1LDEyMDEwMiwxMDUsMTIwMTU0LDEwNSwxMjAyMDYsMTA1LDEyMDI1OCwxMDUsMTIwMzEwLDEwNSwxMjAzNjIsMTA1LDEyMDQxNCwxMDUsMTIwNDY2LDEwNSwxMjA0ODQsMTA1LDYxOCwxMDUsNjE3LDEwNSw5NTMsMTA1LDgxMjYsMTA1LDg5MCwxMDUsMTIwNTIyLDEwNSwxMjA1ODAsMTA1LDEyMDYzOCwxMDUsMTIwNjk2LDEwNSwxMjA3NTQsMTA1LDExMTAsMTA1LDQyNTY3LDEwNSwxMjMxLDEwNSw0Mzg5MywxMDUsNTAyOSwxMDUsNzE4NzUsMTA1LDY1MzU0LDEwNiw4NTIxLDEwNiwxMTk4NDMsMTA2LDExOTg5NSwxMDYsMTE5OTQ3LDEwNiwxMTk5OTksMTA2LDEyMDA1MSwxMDYsMTIwMTAzLDEwNiwxMjAxNTUsMTA2LDEyMDIwNywxMDYsMTIwMjU5LDEwNiwxMjAzMTEsMTA2LDEyMDM2MywxMDYsMTIwNDE1LDEwNiwxMjA0NjcsMTA2LDEwMTEsMTA2LDExMTIsMTA2LDY1MzIyLDc0LDExOTgxNyw3NCwxMTk4NjksNzQsMTE5OTIxLDc0LDExOTk3Myw3NCwxMjAwMjUsNzQsMTIwMDc3LDc0LDEyMDEyOSw3NCwxMjAxODEsNzQsMTIwMjMzLDc0LDEyMDI4NSw3NCwxMjAzMzcsNzQsMTIwMzg5LDc0LDEyMDQ0MSw3NCw0MjkzMCw3NCw4OTUsNzQsMTAzMiw3NCw1MDM1LDc0LDUyNjEsNzQsNDIyMDEsNzQsMTE5ODQ0LDEwNywxMTk4OTYsMTA3LDExOTk0OCwxMDcsMTIwMDAwLDEwNywxMjAwNTIsMTA3LDEyMDEwNCwxMDcsMTIwMTU2LDEwNywxMjAyMDgsMTA3LDEyMDI2MCwxMDcsMTIwMzEyLDEwNywxMjAzNjQsMTA3LDEyMDQxNiwxMDcsMTIwNDY4LDEwNyw4NDkwLDc1LDY1MzIzLDc1LDExOTgxOCw3NSwxMTk4NzAsNzUsMTE5OTIyLDc1LDExOTk3NCw3NSwxMjAwMjYsNzUsMTIwMDc4LDc1LDEyMDEzMCw3NSwxMjAxODIsNzUsMTIwMjM0LDc1LDEyMDI4Niw3NSwxMjAzMzgsNzUsMTIwMzkwLDc1LDEyMDQ0Miw3NSw5MjIsNzUsMTIwNDk3LDc1LDEyMDU1NSw3NSwxMjA2MTMsNzUsMTIwNjcxLDc1LDEyMDcyOSw3NSwxMTQxMiw3NSw1MDk0LDc1LDU4NDUsNzUsNDIxOTksNzUsNjY4NDAsNzUsMTQ3MiwxMDgsODczOSw3Myw5MjEzLDczLDY1NTEyLDczLDE2MzMsMTA4LDE3NzcsNzMsNjYzMzYsMTA4LDEyNTEyNywxMDgsMTIwNzgzLDczLDEyMDc5Myw3MywxMjA4MDMsNzMsMTIwODEzLDczLDEyMDgyMyw3MywxMzAwMzMsNzMsNjUzMjEsNzMsODU0NCw3Myw4NDY0LDczLDg0NjUsNzMsMTE5ODE2LDczLDExOTg2OCw3MywxMTk5MjAsNzMsMTIwMDI0LDczLDEyMDEyOCw3MywxMjAxODAsNzMsMTIwMjMyLDczLDEyMDI4NCw3MywxMjAzMzYsNzMsMTIwMzg4LDczLDEyMDQ0MCw3Myw2NTM1NiwxMDgsODU3Miw3Myw4NDY3LDEwOCwxMTk4NDUsMTA4LDExOTg5NywxMDgsMTE5OTQ5LDEwOCwxMjAwMDEsMTA4LDEyMDA1MywxMDgsMTIwMTA1LDczLDEyMDE1Nyw3MywxMjAyMDksNzMsMTIwMjYxLDczLDEyMDMxMyw3MywxMjAzNjUsNzMsMTIwNDE3LDczLDEyMDQ2OSw3Myw0NDgsNzMsMTIwNDk2LDczLDEyMDU1NCw3MywxMjA2MTIsNzMsMTIwNjcwLDczLDEyMDcyOCw3MywxMTQxMCw3MywxMDMwLDczLDEyMTYsNzMsMTQ5MywxMDgsMTUwMywxMDgsMTU3NSwxMDgsMTI2NDY0LDEwOCwxMjY1OTIsMTA4LDY1MTY2LDEwOCw2NTE2NSwxMDgsMTk5NCwxMDgsMTE1OTksNzMsNTgyNSw3Myw0MjIyNiw3Myw5Mzk5Miw3Myw2NjE4NiwxMjQsNjYzMTMsMTI0LDExOTMzOCw3Niw4NTU2LDc2LDg0NjYsNzYsMTE5ODE5LDc2LDExOTg3MSw3NiwxMTk5MjMsNzYsMTIwMDI3LDc2LDEyMDA3OSw3NiwxMjAxMzEsNzYsMTIwMTgzLDc2LDEyMDIzNSw3NiwxMjAyODcsNzYsMTIwMzM5LDc2LDEyMDM5MSw3NiwxMjA0NDMsNzYsMTE0NzIsNzYsNTA4Niw3Niw1MjkwLDc2LDQyMjA5LDc2LDkzOTc0LDc2LDcxODQzLDc2LDcxODU4LDc2LDY2NTg3LDc2LDY2ODU0LDc2LDY1MzI1LDc3LDg1NTksNzcsODQ5OSw3NywxMTk4MjAsNzcsMTE5ODcyLDc3LDExOTkyNCw3NywxMjAwMjgsNzcsMTIwMDgwLDc3LDEyMDEzMiw3NywxMjAxODQsNzcsMTIwMjM2LDc3LDEyMDI4OCw3NywxMjAzNDAsNzcsMTIwMzkyLDc3LDEyMDQ0NCw3Nyw5MjQsNzcsMTIwNDk5LDc3LDEyMDU1Nyw3NywxMjA2MTUsNzcsMTIwNjczLDc3LDEyMDczMSw3NywxMDE4LDc3LDExNDE2LDc3LDUwNDcsNzcsNTYxNiw3Nyw1ODQ2LDc3LDQyMjA3LDc3LDY2MjI0LDc3LDY2MzIxLDc3LDExOTg0NywxMTAsMTE5ODk5LDExMCwxMTk5NTEsMTEwLDEyMDAwMywxMTAsMTIwMDU1LDExMCwxMjAxMDcsMTEwLDEyMDE1OSwxMTAsMTIwMjExLDExMCwxMjAyNjMsMTEwLDEyMDMxNSwxMTAsMTIwMzY3LDExMCwxMjA0MTksMTEwLDEyMDQ3MSwxMTAsMTQwMCwxMTAsMTQwNCwxMTAsNjUzMjYsNzgsODQ2OSw3OCwxMTk4MjEsNzgsMTE5ODczLDc4LDExOTkyNSw3OCwxMTk5NzcsNzgsMTIwMDI5LDc4LDEyMDA4MSw3OCwxMjAxODUsNzgsMTIwMjM3LDc4LDEyMDI4OSw3OCwxMjAzNDEsNzgsMTIwMzkzLDc4LDEyMDQ0NSw3OCw5MjUsNzgsMTIwNTAwLDc4LDEyMDU1OCw3OCwxMjA2MTYsNzgsMTIwNjc0LDc4LDEyMDczMiw3OCwxMTQxOCw3OCw0MjIwOCw3OCw2NjgzNSw3OCwzMDc0LDExMSwzMjAyLDExMSwzMzMwLDExMSwzNDU4LDExMSwyNDA2LDExMSwyNjYyLDExMSwyNzkwLDExMSwzMDQ2LDExMSwzMTc0LDExMSwzMzAyLDExMSwzNDMwLDExMSwzNjY0LDExMSwzNzkyLDExMSw0MTYwLDExMSwxNjM3LDExMSwxNzgxLDExMSw2NTM1OSwxMTEsODUwMCwxMTEsMTE5ODQ4LDExMSwxMTk5MDAsMTExLDExOTk1MiwxMTEsMTIwMDU2LDExMSwxMjAxMDgsMTExLDEyMDE2MCwxMTEsMTIwMjEyLDExMSwxMjAyNjQsMTExLDEyMDMxNiwxMTEsMTIwMzY4LDExMSwxMjA0MjAsMTExLDEyMDQ3MiwxMTEsNzQzOSwxMTEsNzQ0MSwxMTEsNDM4MzcsMTExLDk1OSwxMTEsMTIwNTI4LDExMSwxMjA1ODYsMTExLDEyMDY0NCwxMTEsMTIwNzAyLDExMSwxMjA3NjAsMTExLDk2MywxMTEsMTIwNTMyLDExMSwxMjA1OTAsMTExLDEyMDY0OCwxMTEsMTIwNzA2LDExMSwxMjA3NjQsMTExLDExNDIzLDExMSw0MzUxLDExMSwxNDEzLDExMSwxNTA1LDExMSwxNjA3LDExMSwxMjY1MDAsMTExLDEyNjU2NCwxMTEsMTI2NTk2LDExMSw2NTI1OSwxMTEsNjUyNjAsMTExLDY1MjU4LDExMSw2NTI1NywxMTEsMTcyNiwxMTEsNjQ0MjgsMTExLDY0NDI5LDExMSw2NDQyNywxMTEsNjQ0MjYsMTExLDE3MjksMTExLDY0NDI0LDExMSw2NDQyNSwxMTEsNjQ0MjMsMTExLDY0NDIyLDExMSwxNzQ5LDExMSwzMzYwLDExMSw0MTI1LDExMSw2Njc5NCwxMTEsNzE4ODAsMTExLDcxODk1LDExMSw2NjYwNCwxMTEsMTk4NCw3OSwyNTM0LDc5LDI5MTgsNzksMTIyOTUsNzksNzA4NjQsNzksNzE5MDQsNzksMTIwNzgyLDc5LDEyMDc5Miw3OSwxMjA4MDIsNzksMTIwODEyLDc5LDEyMDgyMiw3OSwxMzAwMzIsNzksNjUzMjcsNzksMTE5ODIyLDc5LDExOTg3NCw3OSwxMTk5MjYsNzksMTE5OTc4LDc5LDEyMDAzMCw3OSwxMjAwODIsNzksMTIwMTM0LDc5LDEyMDE4Niw3OSwxMjAyMzgsNzksMTIwMjkwLDc5LDEyMDM0Miw3OSwxMjAzOTQsNzksMTIwNDQ2LDc5LDkyNyw3OSwxMjA1MDIsNzksMTIwNTYwLDc5LDEyMDYxOCw3OSwxMjA2NzYsNzksMTIwNzM0LDc5LDExNDIyLDc5LDEzNjUsNzksMTE2MDQsNzksNDgxNiw3OSwyODQ4LDc5LDY2NzU0LDc5LDQyMjI3LDc5LDcxODYxLDc5LDY2MTk0LDc5LDY2MjE5LDc5LDY2NTY0LDc5LDY2ODM4LDc5LDkwNzYsMTEyLDY1MzYwLDExMiwxMTk4NDksMTEyLDExOTkwMSwxMTIsMTE5OTUzLDExMiwxMjAwMDUsMTEyLDEyMDA1NywxMTIsMTIwMTA5LDExMiwxMjAxNjEsMTEyLDEyMDIxMywxMTIsMTIwMjY1LDExMiwxMjAzMTcsMTEyLDEyMDM2OSwxMTIsMTIwNDIxLDExMiwxMjA0NzMsMTEyLDk2MSwxMTIsMTIwNTMwLDExMiwxMjA1NDQsMTEyLDEyMDU4OCwxMTIsMTIwNjAyLDExMiwxMjA2NDYsMTEyLDEyMDY2MCwxMTIsMTIwNzA0LDExMiwxMjA3MTgsMTEyLDEyMDc2MiwxMTIsMTIwNzc2LDExMiwxMTQyNywxMTIsNjUzMjgsODAsODQ3Myw4MCwxMTk4MjMsODAsMTE5ODc1LDgwLDExOTkyNyw4MCwxMTk5NzksODAsMTIwMDMxLDgwLDEyMDA4Myw4MCwxMjAxODcsODAsMTIwMjM5LDgwLDEyMDI5MSw4MCwxMjAzNDMsODAsMTIwMzk1LDgwLDEyMDQ0Nyw4MCw5MjksODAsMTIwNTA0LDgwLDEyMDU2Miw4MCwxMjA2MjAsODAsMTIwNjc4LDgwLDEyMDczNiw4MCwxMTQyNiw4MCw1MDkwLDgwLDUyMjksODAsNDIxOTMsODAsNjYxOTcsODAsMTE5ODUwLDExMywxMTk5MDIsMTEzLDExOTk1NCwxMTMsMTIwMDA2LDExMywxMjAwNTgsMTEzLDEyMDExMCwxMTMsMTIwMTYyLDExMywxMjAyMTQsMTEzLDEyMDI2NiwxMTMsMTIwMzE4LDExMywxMjAzNzAsMTEzLDEyMDQyMiwxMTMsMTIwNDc0LDExMywxMzA3LDExMywxMzc5LDExMywxMzgyLDExMyw4NDc0LDgxLDExOTgyNCw4MSwxMTk4NzYsODEsMTE5OTI4LDgxLDExOTk4MCw4MSwxMjAwMzIsODEsMTIwMDg0LDgxLDEyMDE4OCw4MSwxMjAyNDAsODEsMTIwMjkyLDgxLDEyMDM0NCw4MSwxMjAzOTYsODEsMTIwNDQ4LDgxLDExNjA1LDgxLDExOTg1MSwxMTQsMTE5OTAzLDExNCwxMTk5NTUsMTE0LDEyMDAwNywxMTQsMTIwMDU5LDExNCwxMjAxMTEsMTE0LDEyMDE2MywxMTQsMTIwMjE1LDExNCwxMjAyNjcsMTE0LDEyMDMxOSwxMTQsMTIwMzcxLDExNCwxMjA0MjMsMTE0LDEyMDQ3NSwxMTQsNDM4NDcsMTE0LDQzODQ4LDExNCw3NDYyLDExNCwxMTM5NywxMTQsNDM5MDUsMTE0LDExOTMxOCw4Miw4NDc1LDgyLDg0NzYsODIsODQ3Nyw4MiwxMTk4MjUsODIsMTE5ODc3LDgyLDExOTkyOSw4MiwxMjAwMzMsODIsMTIwMTg5LDgyLDEyMDI0MSw4MiwxMjAyOTMsODIsMTIwMzQ1LDgyLDEyMDM5Nyw4MiwxMjA0NDksODIsNDIyLDgyLDUwMjUsODIsNTA3NCw4Miw2Njc0MCw4Miw1NTExLDgyLDQyMjExLDgyLDk0MDA1LDgyLDY1MzYzLDExNSwxMTk4NTIsMTE1LDExOTkwNCwxMTUsMTE5OTU2LDExNSwxMjAwMDgsMTE1LDEyMDA2MCwxMTUsMTIwMTEyLDExNSwxMjAxNjQsMTE1LDEyMDIxNiwxMTUsMTIwMjY4LDExNSwxMjAzMjAsMTE1LDEyMDM3MiwxMTUsMTIwNDI0LDExNSwxMjA0NzYsMTE1LDQyODAxLDExNSw0NDUsMTE1LDExMDksMTE1LDQzOTQ2LDExNSw3MTg3MywxMTUsNjY2MzIsMTE1LDY1MzMxLDgzLDExOTgyNiw4MywxMTk4NzgsODMsMTE5OTMwLDgzLDExOTk4Miw4MywxMjAwMzQsODMsMTIwMDg2LDgzLDEyMDEzOCw4MywxMjAxOTAsODMsMTIwMjQyLDgzLDEyMDI5NCw4MywxMjAzNDYsODMsMTIwMzk4LDgzLDEyMDQ1MCw4MywxMDI5LDgzLDEzNTksODMsNTA3Nyw4Myw1MDgyLDgzLDQyMjEwLDgzLDk0MDEwLDgzLDY2MTk4LDgzLDY2NTkyLDgzLDExOTg1MywxMTYsMTE5OTA1LDExNiwxMTk5NTcsMTE2LDEyMDAwOSwxMTYsMTIwMDYxLDExNiwxMjAxMTMsMTE2LDEyMDE2NSwxMTYsMTIwMjE3LDExNiwxMjAyNjksMTE2LDEyMDMyMSwxMTYsMTIwMzczLDExNiwxMjA0MjUsMTE2LDEyMDQ3NywxMTYsODg2OCw4NCwxMDIwMSw4NCwxMjg4NzIsODQsNjUzMzIsODQsMTE5ODI3LDg0LDExOTg3OSw4NCwxMTk5MzEsODQsMTE5OTgzLDg0LDEyMDAzNSw4NCwxMjAwODcsODQsMTIwMTM5LDg0LDEyMDE5MSw4NCwxMjAyNDMsODQsMTIwMjk1LDg0LDEyMDM0Nyw4NCwxMjAzOTksODQsMTIwNDUxLDg0LDkzMiw4NCwxMjA1MDcsODQsMTIwNTY1LDg0LDEyMDYyMyw4NCwxMjA2ODEsODQsMTIwNzM5LDg0LDExNDMwLDg0LDUwMjYsODQsNDIxOTYsODQsOTM5NjIsODQsNzE4NjgsODQsNjYxOTksODQsNjYyMjUsODQsNjYzMjUsODQsMTE5ODU0LDExNywxMTk5MDYsMTE3LDExOTk1OCwxMTcsMTIwMDEwLDExNywxMjAwNjIsMTE3LDEyMDExNCwxMTcsMTIwMTY2LDExNywxMjAyMTgsMTE3LDEyMDI3MCwxMTcsMTIwMzIyLDExNywxMjAzNzQsMTE3LDEyMDQyNiwxMTcsMTIwNDc4LDExNyw0MjkxMSwxMTcsNzQ1MiwxMTcsNDM4NTQsMTE3LDQzODU4LDExNyw2NTEsMTE3LDk2NSwxMTcsMTIwNTM0LDExNywxMjA1OTIsMTE3LDEyMDY1MCwxMTcsMTIwNzA4LDExNywxMjA3NjYsMTE3LDE0MDUsMTE3LDY2ODA2LDExNyw3MTg5NiwxMTcsODc0Niw4NSw4ODk5LDg1LDExOTgyOCw4NSwxMTk4ODAsODUsMTE5OTMyLDg1LDExOTk4NCw4NSwxMjAwMzYsODUsMTIwMDg4LDg1LDEyMDE0MCw4NSwxMjAxOTIsODUsMTIwMjQ0LDg1LDEyMDI5Niw4NSwxMjAzNDgsODUsMTIwNDAwLDg1LDEyMDQ1Miw4NSwxMzU3LDg1LDQ2MDgsODUsNjY3NjYsODUsNTE5Niw4NSw0MjIyOCw4NSw5NDAxOCw4NSw3MTg2NCw4NSw4NzQ0LDExOCw4ODk3LDExOCw2NTM2NiwxMTgsODU2NCwxMTgsMTE5ODU1LDExOCwxMTk5MDcsMTE4LDExOTk1OSwxMTgsMTIwMDExLDExOCwxMjAwNjMsMTE4LDEyMDExNSwxMTgsMTIwMTY3LDExOCwxMjAyMTksMTE4LDEyMDI3MSwxMTgsMTIwMzIzLDExOCwxMjAzNzUsMTE4LDEyMDQyNywxMTgsMTIwNDc5LDExOCw3NDU2LDExOCw5NTcsMTE4LDEyMDUyNiwxMTgsMTIwNTg0LDExOCwxMjA2NDIsMTE4LDEyMDcwMCwxMTgsMTIwNzU4LDExOCwxMTQxLDExOCwxNDk2LDExOCw3MTQzMCwxMTgsNDM5NDUsMTE4LDcxODcyLDExOCwxMTkzMDksODYsMTYzOSw4NiwxNzgzLDg2LDg1NDgsODYsMTE5ODI5LDg2LDExOTg4MSw4NiwxMTk5MzMsODYsMTE5OTg1LDg2LDEyMDAzNyw4NiwxMjAwODksODYsMTIwMTQxLDg2LDEyMDE5Myw4NiwxMjAyNDUsODYsMTIwMjk3LDg2LDEyMDM0OSw4NiwxMjA0MDEsODYsMTIwNDUzLDg2LDExNDAsODYsMTE1NzYsODYsNTA4MSw4Niw1MTY3LDg2LDQyNzE5LDg2LDQyMjE0LDg2LDkzOTYwLDg2LDcxODQwLDg2LDY2ODQ1LDg2LDYyMywxMTksMTE5ODU2LDExOSwxMTk5MDgsMTE5LDExOTk2MCwxMTksMTIwMDEyLDExOSwxMjAwNjQsMTE5LDEyMDExNiwxMTksMTIwMTY4LDExOSwxMjAyMjAsMTE5LDEyMDI3MiwxMTksMTIwMzI0LDExOSwxMjAzNzYsMTE5LDEyMDQyOCwxMTksMTIwNDgwLDExOSw3NDU3LDExOSwxMTIxLDExOSwxMzA5LDExOSwxMzc3LDExOSw3MTQzNCwxMTksNzE0MzgsMTE5LDcxNDM5LDExOSw0MzkwNywxMTksNzE5MTksODcsNzE5MTAsODcsMTE5ODMwLDg3LDExOTg4Miw4NywxMTk5MzQsODcsMTE5OTg2LDg3LDEyMDAzOCw4NywxMjAwOTAsODcsMTIwMTQyLDg3LDEyMDE5NCw4NywxMjAyNDYsODcsMTIwMjk4LDg3LDEyMDM1MCw4NywxMjA0MDIsODcsMTIwNDU0LDg3LDEzMDgsODcsNTA0Myw4Nyw1MDc2LDg3LDQyMjE4LDg3LDU3NDIsMTIwLDEwNTM5LDEyMCwxMDU0MCwxMjAsMTA3OTksMTIwLDY1MzY4LDEyMCw4NTY5LDEyMCwxMTk4NTcsMTIwLDExOTkwOSwxMjAsMTE5OTYxLDEyMCwxMjAwMTMsMTIwLDEyMDA2NSwxMjAsMTIwMTE3LDEyMCwxMjAxNjksMTIwLDEyMDIyMSwxMjAsMTIwMjczLDEyMCwxMjAzMjUsMTIwLDEyMDM3NywxMjAsMTIwNDI5LDEyMCwxMjA0ODEsMTIwLDU0NDEsMTIwLDU1MDEsMTIwLDU3NDEsODgsOTU4Nyw4OCw2NjMzOCw4OCw3MTkxNiw4OCw2NTMzNiw4OCw4NTUzLDg4LDExOTgzMSw4OCwxMTk4ODMsODgsMTE5OTM1LDg4LDExOTk4Nyw4OCwxMjAwMzksODgsMTIwMDkxLDg4LDEyMDE0Myw4OCwxMjAxOTUsODgsMTIwMjQ3LDg4LDEyMDI5OSw4OCwxMjAzNTEsODgsMTIwNDAzLDg4LDEyMDQ1NSw4OCw0MjkzMSw4OCw5MzUsODgsMTIwNTEwLDg4LDEyMDU2OCw4OCwxMjA2MjYsODgsMTIwNjg0LDg4LDEyMDc0Miw4OCwxMTQzNiw4OCwxMTYxMyw4OCw1ODE1LDg4LDQyMjE5LDg4LDY2MTkyLDg4LDY2MjI4LDg4LDY2MzI3LDg4LDY2ODU1LDg4LDYxMSwxMjEsNzU2NCwxMjEsNjUzNjksMTIxLDExOTg1OCwxMjEsMTE5OTEwLDEyMSwxMTk5NjIsMTIxLDEyMDAxNCwxMjEsMTIwMDY2LDEyMSwxMjAxMTgsMTIxLDEyMDE3MCwxMjEsMTIwMjIyLDEyMSwxMjAyNzQsMTIxLDEyMDMyNiwxMjEsMTIwMzc4LDEyMSwxMjA0MzAsMTIxLDEyMDQ4MiwxMjEsNjU1LDEyMSw3OTM1LDEyMSw0Mzg2NiwxMjEsOTQ3LDEyMSw4NTA5LDEyMSwxMjA1MTYsMTIxLDEyMDU3NCwxMjEsMTIwNjMyLDEyMSwxMjA2OTAsMTIxLDEyMDc0OCwxMjEsMTE5OSwxMjEsNDMyNywxMjEsNzE5MDAsMTIxLDY1MzM3LDg5LDExOTgzMiw4OSwxMTk4ODQsODksMTE5OTM2LDg5LDExOTk4OCw4OSwxMjAwNDAsODksMTIwMDkyLDg5LDEyMDE0NCw4OSwxMjAxOTYsODksMTIwMjQ4LDg5LDEyMDMwMCw4OSwxMjAzNTIsODksMTIwNDA0LDg5LDEyMDQ1Niw4OSw5MzMsODksOTc4LDg5LDEyMDUwOCw4OSwxMjA1NjYsODksMTIwNjI0LDg5LDEyMDY4Miw4OSwxMjA3NDAsODksMTE0MzIsODksMTE5OCw4OSw1MDMzLDg5LDUwNTMsODksNDIyMjAsODksOTQwMTksODksNzE4NDQsODksNjYyMjYsODksMTE5ODU5LDEyMiwxMTk5MTEsMTIyLDExOTk2MywxMjIsMTIwMDE1LDEyMiwxMjAwNjcsMTIyLDEyMDExOSwxMjIsMTIwMTcxLDEyMiwxMjAyMjMsMTIyLDEyMDI3NSwxMjIsMTIwMzI3LDEyMiwxMjAzNzksMTIyLDEyMDQzMSwxMjIsMTIwNDgzLDEyMiw3NDU4LDEyMiw0MzkyMywxMjIsNzE4NzYsMTIyLDY2MjkzLDkwLDcxOTA5LDkwLDY1MzM4LDkwLDg0ODQsOTAsODQ4OCw5MCwxMTk4MzMsOTAsMTE5ODg1LDkwLDExOTkzNyw5MCwxMTk5ODksOTAsMTIwMDQxLDkwLDEyMDE5Nyw5MCwxMjAyNDksOTAsMTIwMzAxLDkwLDEyMDM1Myw5MCwxMjA0MDUsOTAsMTIwNDU3LDkwLDkxOCw5MCwxMjA0OTMsOTAsMTIwNTUxLDkwLDEyMDYwOSw5MCwxMjA2NjcsOTAsMTIwNzI1LDkwLDUwNTksOTAsNDIyMDQsOTAsNzE4NDksOTAsNjUyODIsMzQsNjUyODQsMzYsNjUyODUsMzcsNjUyODYsMzgsNjUyOTAsNDIsNjUyOTEsNDMsNjUyOTQsNDYsNjUyOTUsNDcsNjUyOTYsNDgsNjUyOTcsNDksNjUyOTgsNTAsNjUyOTksNTEsNjUzMDAsNTIsNjUzMDEsNTMsNjUzMDIsNTQsNjUzMDMsNTUsNjUzMDQsNTYsNjUzMDUsNTcsNjUzMDgsNjAsNjUzMDksNjEsNjUzMTAsNjIsNjUzMTIsNjQsNjUzMTYsNjgsNjUzMTgsNzAsNjUzMTksNzEsNjUzMjQsNzYsNjUzMjksODEsNjUzMzAsODIsNjUzMzMsODUsNjUzMzQsODYsNjUzMzUsODcsNjUzNDMsOTUsNjUzNDYsOTgsNjUzNDgsMTAwLDY1MzUwLDEwMiw2NTM1NSwxMDcsNjUzNTcsMTA5LDY1MzU4LDExMCw2NTM2MSwxMTMsNjUzNjIsMTE0LDY1MzY0LDExNiw2NTM2NSwxMTcsNjUzNjcsMTE5LDY1MzcwLDEyMiw2NTM3MSwxMjMsNjUzNzMsMTI1LDExOTg0NiwxMDldLFxcXCJfZGVmYXVsdFxcXCI6WzE2MCwzMiw4MjExLDQ1LDY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyMTcsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJjc1xcXCI6WzY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjE2LDk2LDgyMTcsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwiZGVcXFwiOls2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjE3LDk2LDgyNDUsOTYsMTgwLDk2LDEyNDk0LDQ3LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcImVzXFxcIjpbODIxMSw0NSw2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcImZyXFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODI0NSw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcIml0XFxcIjpbMTYwLDMyLDgyMTEsNDUsNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUyODgsNDAsNjUyODksNDEsNjUyOTIsNDQsNjUzMDcsNTksNjUzMTEsNjNdLFxcXCJqYVxcXCI6WzgyMTEsNDUsNjUzMDYsNTgsNjUyODEsMzMsODIxNiw5Niw4MjE3LDk2LDgyNDUsOTYsMTgwLDk2LDEwNDcsNTEsMTA3Myw1NCwxMDcyLDk3LDEwNDAsNjUsMTA2OCw5OCwxMDQyLDY2LDEwODksOTksMTA1Nyw2NywxMDc3LDEwMSwxMDQ1LDY5LDEwNTMsNzIsMzA1LDEwNSwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1MjkyLDQ0LDY1MzA3LDU5XSxcXFwia29cXFwiOls4MjExLDQ1LDY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcInBsXFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcInB0LUJSXFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcInFwcy1wbG9jXFxcIjpbMTYwLDMyLDgyMTEsNDUsNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4MywzNSw2NTI4OCw0MCw2NTI4OSw0MSw2NTI5Miw0NCw2NTMwNyw1OSw2NTMxMSw2M10sXFxcInJ1XFxcIjpbNjUzNzQsMTI2LDY1MzA2LDU4LDY1MjgxLDMzLDgyMTYsOTYsODIxNyw5Niw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywzMDUsMTA1LDkyMSw3MywxMDA5LDExMiwyMTUsMTIwLDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwidHJcXFwiOlsxNjAsMzIsODIxMSw0NSw2NTM3NCwxMjYsNjUzMDYsNTgsNjUyODEsMzMsODI0NSw5NiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwxMDUwLDc1LDkyMSw3MywxMDUyLDc3LDEwODYsMTExLDEwNTQsNzksMTAwOSwxMTIsMTA4OCwxMTIsMTA1Niw4MCwxMDc1LDExNCwxMDU4LDg0LDIxNSwxMjAsMTA5MywxMjAsMTA2MSw4OCwxMDkxLDEyMSwxMDU5LDg5LDY1MjgzLDM1LDY1Mjg4LDQwLDY1Mjg5LDQxLDY1MjkyLDQ0LDY1MzA3LDU5LDY1MzExLDYzXSxcXFwiemgtaGFuc1xcXCI6WzY1Mzc0LDEyNiw2NTMwNiw1OCw2NTI4MSwzMyw4MjQ1LDk2LDE4MCw5NiwxMjQ5NCw0NywxMDQ3LDUxLDEwNzMsNTQsMTA3Miw5NywxMDQwLDY1LDEwNjgsOTgsMTA0Miw2NiwxMDg5LDk5LDEwNTcsNjcsMTA3NywxMDEsMTA0NSw2OSwxMDUzLDcyLDMwNSwxMDUsMTA1MCw3NSw5MjEsNzMsMTA1Miw3NywxMDg2LDExMSwxMDU0LDc5LDEwMDksMTEyLDEwODgsMTEyLDEwNTYsODAsMTA3NSwxMTQsMTA1OCw4NCwyMTUsMTIwLDEwOTMsMTIwLDEwNjEsODgsMTA5MSwxMjEsMTA1OSw4OSw2NTI4OCw0MCw2NTI4OSw0MV0sXFxcInpoLWhhbnRcXFwiOls4MjExLDQ1LDY1Mzc0LDEyNiwxODAsOTYsMTI0OTQsNDcsMTA0Nyw1MSwxMDczLDU0LDEwNzIsOTcsMTA0MCw2NSwxMDY4LDk4LDEwNDIsNjYsMTA4OSw5OSwxMDU3LDY3LDEwNzcsMTAxLDEwNDUsNjksMTA1Myw3MiwzMDUsMTA1LDEwNTAsNzUsOTIxLDczLDEwNTIsNzcsMTA4NiwxMTEsMTA1NCw3OSwxMDA5LDExMiwxMDg4LDExMiwxMDU2LDgwLDEwNzUsMTE0LDEwNTgsODQsMjE1LDEyMCwxMDkzLDEyMCwxMDYxLDg4LDEwOTEsMTIxLDEwNTksODksNjUyODMsMzUsNjUzMDcsNTldfScpO1xufSk7XG5BbWJpZ3VvdXNDaGFyYWN0ZXJzLmNhY2hlID0gbmV3IExSVUNhY2hlZEZ1bmN0aW9uKHsgZ2V0Q2FjaGVLZXk6IEpTT04uc3RyaW5naWZ5IH0sIChsb2NhbGVzKSA9PiB7XG4gICAgZnVuY3Rpb24gYXJyYXlUb01hcChhcnIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgcmVzdWx0LnNldChhcnJbaV0sIGFycltpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1lcmdlTWFwcyhtYXAxLCBtYXAyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXAobWFwMSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG1hcDIpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW50ZXJzZWN0TWFwcyhtYXAxLCBtYXAyKSB7XG4gICAgICAgIGlmICghbWFwMSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hcDI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAxKSB7XG4gICAgICAgICAgICBpZiAobWFwMi5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IF9hLmFtYmlndW91c0NoYXJhY3RlckRhdGEudmFsdWU7XG4gICAgbGV0IGZpbHRlcmVkTG9jYWxlcyA9IGxvY2FsZXMuZmlsdGVyKChsKSA9PiAhbC5zdGFydHNXaXRoKCdfJykgJiYgbCBpbiBkYXRhKTtcbiAgICBpZiAoZmlsdGVyZWRMb2NhbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBmaWx0ZXJlZExvY2FsZXMgPSBbJ19kZWZhdWx0J107XG4gICAgfVxuICAgIGxldCBsYW5ndWFnZVNwZWNpZmljTWFwID0gdW5kZWZpbmVkO1xuICAgIGZvciAoY29uc3QgbG9jYWxlIG9mIGZpbHRlcmVkTG9jYWxlcykge1xuICAgICAgICBjb25zdCBtYXAgPSBhcnJheVRvTWFwKGRhdGFbbG9jYWxlXSk7XG4gICAgICAgIGxhbmd1YWdlU3BlY2lmaWNNYXAgPSBpbnRlcnNlY3RNYXBzKGxhbmd1YWdlU3BlY2lmaWNNYXAsIG1hcCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbk1hcCA9IGFycmF5VG9NYXAoZGF0YVsnX2NvbW1vbiddKTtcbiAgICBjb25zdCBtYXAgPSBtZXJnZU1hcHMoY29tbW9uTWFwLCBsYW5ndWFnZVNwZWNpZmljTWFwKTtcbiAgICByZXR1cm4gbmV3IF9hKG1hcCk7XG59KTtcbkFtYmlndW91c0NoYXJhY3RlcnMuX2xvY2FsZXMgPSBuZXcgTGF6eSgoKSA9PiBPYmplY3Qua2V5cyhfYS5hbWJpZ3VvdXNDaGFyYWN0ZXJEYXRhLnZhbHVlKS5maWx0ZXIoKGspID0+ICFrLnN0YXJ0c1dpdGgoJ18nKSkpO1xuZXhwb3J0IGNsYXNzIEludmlzaWJsZUNoYXJhY3RlcnMge1xuICAgIHN0YXRpYyBnZXRSYXdEYXRhKCkge1xuICAgICAgICAvLyBHZW5lcmF0ZWQgdXNpbmcgaHR0cHM6Ly9naXRodWIuY29tL2hlZGlldC92c2NvZGUtdW5pY29kZS1kYXRhXG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKCdbOSwxMCwxMSwxMiwxMywzMiwxMjcsMTYwLDE3Myw4NDcsMTU2NCw0NDQ3LDQ0NDgsNjA2OCw2MDY5LDYxNTUsNjE1Niw2MTU3LDYxNTgsNzM1NSw3MzU2LDgxOTIsODE5Myw4MTk0LDgxOTUsODE5Niw4MTk3LDgxOTgsODE5OSw4MjAwLDgyMDEsODIwMiw4MjAzLDgyMDQsODIwNSw4MjA2LDgyMDcsODIzNCw4MjM1LDgyMzYsODIzNyw4MjM4LDgyMzksODI4Nyw4Mjg4LDgyODksODI5MCw4MjkxLDgyOTIsODI5Myw4Mjk0LDgyOTUsODI5Niw4Mjk3LDgyOTgsODI5OSw4MzAwLDgzMDEsODMwMiw4MzAzLDEwMjQwLDEyMjg4LDEyNjQ0LDY1MDI0LDY1MDI1LDY1MDI2LDY1MDI3LDY1MDI4LDY1MDI5LDY1MDMwLDY1MDMxLDY1MDMyLDY1MDMzLDY1MDM0LDY1MDM1LDY1MDM2LDY1MDM3LDY1MDM4LDY1MDM5LDY1Mjc5LDY1NDQwLDY1NTIwLDY1NTIxLDY1NTIyLDY1NTIzLDY1NTI0LDY1NTI1LDY1NTI2LDY1NTI3LDY1NTI4LDY1NTMyLDc4ODQ0LDExOTE1NSwxMTkxNTYsMTE5MTU3LDExOTE1OCwxMTkxNTksMTE5MTYwLDExOTE2MSwxMTkxNjIsOTE3NTA0LDkxNzUwNSw5MTc1MDYsOTE3NTA3LDkxNzUwOCw5MTc1MDksOTE3NTEwLDkxNzUxMSw5MTc1MTIsOTE3NTEzLDkxNzUxNCw5MTc1MTUsOTE3NTE2LDkxNzUxNyw5MTc1MTgsOTE3NTE5LDkxNzUyMCw5MTc1MjEsOTE3NTIyLDkxNzUyMyw5MTc1MjQsOTE3NTI1LDkxNzUyNiw5MTc1MjcsOTE3NTI4LDkxNzUyOSw5MTc1MzAsOTE3NTMxLDkxNzUzMiw5MTc1MzMsOTE3NTM0LDkxNzUzNSw5MTc1MzYsOTE3NTM3LDkxNzUzOCw5MTc1MzksOTE3NTQwLDkxNzU0MSw5MTc1NDIsOTE3NTQzLDkxNzU0NCw5MTc1NDUsOTE3NTQ2LDkxNzU0Nyw5MTc1NDgsOTE3NTQ5LDkxNzU1MCw5MTc1NTEsOTE3NTUyLDkxNzU1Myw5MTc1NTQsOTE3NTU1LDkxNzU1Niw5MTc1NTcsOTE3NTU4LDkxNzU1OSw5MTc1NjAsOTE3NTYxLDkxNzU2Miw5MTc1NjMsOTE3NTY0LDkxNzU2NSw5MTc1NjYsOTE3NTY3LDkxNzU2OCw5MTc1NjksOTE3NTcwLDkxNzU3MSw5MTc1NzIsOTE3NTczLDkxNzU3NCw5MTc1NzUsOTE3NTc2LDkxNzU3Nyw5MTc1NzgsOTE3NTc5LDkxNzU4MCw5MTc1ODEsOTE3NTgyLDkxNzU4Myw5MTc1ODQsOTE3NTg1LDkxNzU4Niw5MTc1ODcsOTE3NTg4LDkxNzU4OSw5MTc1OTAsOTE3NTkxLDkxNzU5Miw5MTc1OTMsOTE3NTk0LDkxNzU5NSw5MTc1OTYsOTE3NTk3LDkxNzU5OCw5MTc1OTksOTE3NjAwLDkxNzYwMSw5MTc2MDIsOTE3NjAzLDkxNzYwNCw5MTc2MDUsOTE3NjA2LDkxNzYwNyw5MTc2MDgsOTE3NjA5LDkxNzYxMCw5MTc2MTEsOTE3NjEyLDkxNzYxMyw5MTc2MTQsOTE3NjE1LDkxNzYxNiw5MTc2MTcsOTE3NjE4LDkxNzYxOSw5MTc2MjAsOTE3NjIxLDkxNzYyMiw5MTc2MjMsOTE3NjI0LDkxNzYyNSw5MTc2MjYsOTE3NjI3LDkxNzYyOCw5MTc2MjksOTE3NjMwLDkxNzYzMSw5MTc3NjAsOTE3NzYxLDkxNzc2Miw5MTc3NjMsOTE3NzY0LDkxNzc2NSw5MTc3NjYsOTE3NzY3LDkxNzc2OCw5MTc3NjksOTE3NzcwLDkxNzc3MSw5MTc3NzIsOTE3NzczLDkxNzc3NCw5MTc3NzUsOTE3Nzc2LDkxNzc3Nyw5MTc3NzgsOTE3Nzc5LDkxNzc4MCw5MTc3ODEsOTE3NzgyLDkxNzc4Myw5MTc3ODQsOTE3Nzg1LDkxNzc4Niw5MTc3ODcsOTE3Nzg4LDkxNzc4OSw5MTc3OTAsOTE3NzkxLDkxNzc5Miw5MTc3OTMsOTE3Nzk0LDkxNzc5NSw5MTc3OTYsOTE3Nzk3LDkxNzc5OCw5MTc3OTksOTE3ODAwLDkxNzgwMSw5MTc4MDIsOTE3ODAzLDkxNzgwNCw5MTc4MDUsOTE3ODA2LDkxNzgwNyw5MTc4MDgsOTE3ODA5LDkxNzgxMCw5MTc4MTEsOTE3ODEyLDkxNzgxMyw5MTc4MTQsOTE3ODE1LDkxNzgxNiw5MTc4MTcsOTE3ODE4LDkxNzgxOSw5MTc4MjAsOTE3ODIxLDkxNzgyMiw5MTc4MjMsOTE3ODI0LDkxNzgyNSw5MTc4MjYsOTE3ODI3LDkxNzgyOCw5MTc4MjksOTE3ODMwLDkxNzgzMSw5MTc4MzIsOTE3ODMzLDkxNzgzNCw5MTc4MzUsOTE3ODM2LDkxNzgzNyw5MTc4MzgsOTE3ODM5LDkxNzg0MCw5MTc4NDEsOTE3ODQyLDkxNzg0Myw5MTc4NDQsOTE3ODQ1LDkxNzg0Niw5MTc4NDcsOTE3ODQ4LDkxNzg0OSw5MTc4NTAsOTE3ODUxLDkxNzg1Miw5MTc4NTMsOTE3ODU0LDkxNzg1NSw5MTc4NTYsOTE3ODU3LDkxNzg1OCw5MTc4NTksOTE3ODYwLDkxNzg2MSw5MTc4NjIsOTE3ODYzLDkxNzg2NCw5MTc4NjUsOTE3ODY2LDkxNzg2Nyw5MTc4NjgsOTE3ODY5LDkxNzg3MCw5MTc4NzEsOTE3ODcyLDkxNzg3Myw5MTc4NzQsOTE3ODc1LDkxNzg3Niw5MTc4NzcsOTE3ODc4LDkxNzg3OSw5MTc4ODAsOTE3ODgxLDkxNzg4Miw5MTc4ODMsOTE3ODg0LDkxNzg4NSw5MTc4ODYsOTE3ODg3LDkxNzg4OCw5MTc4ODksOTE3ODkwLDkxNzg5MSw5MTc4OTIsOTE3ODkzLDkxNzg5NCw5MTc4OTUsOTE3ODk2LDkxNzg5Nyw5MTc4OTgsOTE3ODk5LDkxNzkwMCw5MTc5MDEsOTE3OTAyLDkxNzkwMyw5MTc5MDQsOTE3OTA1LDkxNzkwNiw5MTc5MDcsOTE3OTA4LDkxNzkwOSw5MTc5MTAsOTE3OTExLDkxNzkxMiw5MTc5MTMsOTE3OTE0LDkxNzkxNSw5MTc5MTYsOTE3OTE3LDkxNzkxOCw5MTc5MTksOTE3OTIwLDkxNzkyMSw5MTc5MjIsOTE3OTIzLDkxNzkyNCw5MTc5MjUsOTE3OTI2LDkxNzkyNyw5MTc5MjgsOTE3OTI5LDkxNzkzMCw5MTc5MzEsOTE3OTMyLDkxNzkzMyw5MTc5MzQsOTE3OTM1LDkxNzkzNiw5MTc5MzcsOTE3OTM4LDkxNzkzOSw5MTc5NDAsOTE3OTQxLDkxNzk0Miw5MTc5NDMsOTE3OTQ0LDkxNzk0NSw5MTc5NDYsOTE3OTQ3LDkxNzk0OCw5MTc5NDksOTE3OTUwLDkxNzk1MSw5MTc5NTIsOTE3OTUzLDkxNzk1NCw5MTc5NTUsOTE3OTU2LDkxNzk1Nyw5MTc5NTgsOTE3OTU5LDkxNzk2MCw5MTc5NjEsOTE3OTYyLDkxNzk2Myw5MTc5NjQsOTE3OTY1LDkxNzk2Niw5MTc5NjcsOTE3OTY4LDkxNzk2OSw5MTc5NzAsOTE3OTcxLDkxNzk3Miw5MTc5NzMsOTE3OTc0LDkxNzk3NSw5MTc5NzYsOTE3OTc3LDkxNzk3OCw5MTc5NzksOTE3OTgwLDkxNzk4MSw5MTc5ODIsOTE3OTgzLDkxNzk4NCw5MTc5ODUsOTE3OTg2LDkxNzk4Nyw5MTc5ODgsOTE3OTg5LDkxNzk5MCw5MTc5OTEsOTE3OTkyLDkxNzk5Myw5MTc5OTQsOTE3OTk1LDkxNzk5Niw5MTc5OTcsOTE3OTk4LDkxNzk5OV0nKTtcbiAgICB9XG4gICAgc3RhdGljIGdldERhdGEoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBTZXQoSW52aXNpYmxlQ2hhcmFjdGVycy5nZXRSYXdEYXRhKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cbiAgICBzdGF0aWMgaXNJbnZpc2libGVDaGFyYWN0ZXIoY29kZVBvaW50KSB7XG4gICAgICAgIHJldHVybiBJbnZpc2libGVDaGFyYWN0ZXJzLmdldERhdGEoKS5oYXMoY29kZVBvaW50KTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBjb2RlUG9pbnRzKCkge1xuICAgICAgICByZXR1cm4gSW52aXNpYmxlQ2hhcmFjdGVycy5nZXREYXRhKCk7XG4gICAgfVxufVxuSW52aXNpYmxlQ2hhcmFjdGVycy5fZGF0YSA9IHVuZGVmaW5lZDtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgdHJhbnNmb3JtRXJyb3JGb3JTZXJpYWxpemF0aW9uIH0gZnJvbSAnLi4vZXJyb3JzLmpzJztcbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi9ldmVudC5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlIH0gZnJvbSAnLi4vbGlmZWN5Y2xlLmpzJztcbmltcG9ydCB7IGdldEFsbE1ldGhvZE5hbWVzIH0gZnJvbSAnLi4vb2JqZWN0cy5qcyc7XG5pbXBvcnQgeyBpc1dlYiB9IGZyb20gJy4uL3BsYXRmb3JtLmpzJztcbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi4vc3RyaW5ncy5qcyc7XG5jb25zdCBJTklUSUFMSVpFID0gJyRpbml0aWFsaXplJztcbmxldCB3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gbG9nT25jZVdlYldvcmtlcldhcm5pbmcoZXJyKSB7XG4gICAgaWYgKCFpc1dlYikge1xuICAgICAgICAvLyBydW5uaW5nIHRlc3RzXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF3ZWJXb3JrZXJXYXJuaW5nTG9nZ2VkKSB7XG4gICAgICAgIHdlYldvcmtlcldhcm5pbmdMb2dnZWQgPSB0cnVlO1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBjcmVhdGUgd2ViIHdvcmtlcihzKS4gRmFsbGluZyBiYWNrIHRvIGxvYWRpbmcgd2ViIHdvcmtlciBjb2RlIGluIG1haW4gdGhyZWFkLCB3aGljaCBtaWdodCBjYXVzZSBVSSBmcmVlemVzLiBQbGVhc2Ugc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvbW9uYWNvLWVkaXRvciNmYXEnKTtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKGVyci5tZXNzYWdlKTtcbn1cbmNsYXNzIFJlcXVlc3RNZXNzYWdlIHtcbiAgICBjb25zdHJ1Y3Rvcih2c1dvcmtlciwgcmVxLCBtZXRob2QsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy52c1dvcmtlciA9IHZzV29ya2VyO1xuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMudHlwZSA9IDAgLyogTWVzc2FnZVR5cGUuUmVxdWVzdCAqLztcbiAgICB9XG59XG5jbGFzcyBSZXBseU1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZzV29ya2VyLCBzZXEsIHJlcywgZXJyKSB7XG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcbiAgICAgICAgdGhpcy5zZXEgPSBzZXE7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICB0aGlzLmVyciA9IGVycjtcbiAgICAgICAgdGhpcy50eXBlID0gMSAvKiBNZXNzYWdlVHlwZS5SZXBseSAqLztcbiAgICB9XG59XG5jbGFzcyBTdWJzY3JpYmVFdmVudE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZzV29ya2VyLCByZXEsIGV2ZW50TmFtZSwgYXJnKSB7XG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLmFyZyA9IGFyZztcbiAgICAgICAgdGhpcy50eXBlID0gMiAvKiBNZXNzYWdlVHlwZS5TdWJzY3JpYmVFdmVudCAqLztcbiAgICB9XG59XG5jbGFzcyBFdmVudE1lc3NhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHZzV29ya2VyLCByZXEsIGV2ZW50KSB7XG4gICAgICAgIHRoaXMudnNXb3JrZXIgPSB2c1dvcmtlcjtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICAgICAgdGhpcy50eXBlID0gMyAvKiBNZXNzYWdlVHlwZS5FdmVudCAqLztcbiAgICB9XG59XG5jbGFzcyBVbnN1YnNjcmliZUV2ZW50TWVzc2FnZSB7XG4gICAgY29uc3RydWN0b3IodnNXb3JrZXIsIHJlcSkge1xuICAgICAgICB0aGlzLnZzV29ya2VyID0gdnNXb3JrZXI7XG4gICAgICAgIHRoaXMucmVxID0gcmVxO1xuICAgICAgICB0aGlzLnR5cGUgPSA0IC8qIE1lc3NhZ2VUeXBlLlVuc3Vic2NyaWJlRXZlbnQgKi87XG4gICAgfVxufVxuY2xhc3MgU2ltcGxlV29ya2VyUHJvdG9jb2wge1xuICAgIGNvbnN0cnVjdG9yKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fd29ya2VySWQgPSAtMTtcbiAgICAgICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZXI7XG4gICAgICAgIHRoaXMuX2xhc3RTZW50UmVxID0gMDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1JlcGxpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRW1pdHRlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdFdmVudHMgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHNldFdvcmtlcklkKHdvcmtlcklkKSB7XG4gICAgICAgIHRoaXMuX3dvcmtlcklkID0gd29ya2VySWQ7XG4gICAgfVxuICAgIHNlbmRNZXNzYWdlKG1ldGhvZCwgYXJncykge1xuICAgICAgICBjb25zdCByZXEgPSBTdHJpbmcoKyt0aGlzLl9sYXN0U2VudFJlcSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nUmVwbGllc1tyZXFdID0ge1xuICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgICAgICAgICAgICAgcmVqZWN0OiByZWplY3RcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9zZW5kKG5ldyBSZXF1ZXN0TWVzc2FnZSh0aGlzLl93b3JrZXJJZCwgcmVxLCBtZXRob2QsIGFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxpc3RlbihldmVudE5hbWUsIGFyZykge1xuICAgICAgICBsZXQgcmVxID0gbnVsbDtcbiAgICAgICAgY29uc3QgZW1pdHRlciA9IG5ldyBFbWl0dGVyKHtcbiAgICAgICAgICAgIG9uV2lsbEFkZEZpcnN0TGlzdGVuZXI6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXEgPSBTdHJpbmcoKyt0aGlzLl9sYXN0U2VudFJlcSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0VtaXR0ZXJzLnNldChyZXEsIGVtaXR0ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmQobmV3IFN1YnNjcmliZUV2ZW50TWVzc2FnZSh0aGlzLl93b3JrZXJJZCwgcmVxLCBldmVudE5hbWUsIGFyZykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRGlkUmVtb3ZlTGFzdExpc3RlbmVyOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0VtaXR0ZXJzLmRlbGV0ZShyZXEpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbmQobmV3IFVuc3Vic2NyaWJlRXZlbnRNZXNzYWdlKHRoaXMuX3dvcmtlcklkLCByZXEpKTtcbiAgICAgICAgICAgICAgICByZXEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVtaXR0ZXIuZXZlbnQ7XG4gICAgfVxuICAgIGhhbmRsZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UgfHwgIW1lc3NhZ2UudnNXb3JrZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fd29ya2VySWQgIT09IC0xICYmIG1lc3NhZ2UudnNXb3JrZXIgIT09IHRoaXMuX3dvcmtlcklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG4gICAgX2hhbmRsZU1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHN3aXRjaCAobXNnLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMSAvKiBNZXNzYWdlVHlwZS5SZXBseSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlUmVwbHlNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICBjYXNlIDAgLyogTWVzc2FnZVR5cGUuUmVxdWVzdCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlUmVxdWVzdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBNZXNzYWdlVHlwZS5TdWJzY3JpYmVFdmVudCAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlU3Vic2NyaWJlRXZlbnRNZXNzYWdlKG1zZyk7XG4gICAgICAgICAgICBjYXNlIDMgLyogTWVzc2FnZVR5cGUuRXZlbnQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUV2ZW50TWVzc2FnZShtc2cpO1xuICAgICAgICAgICAgY2FzZSA0IC8qIE1lc3NhZ2VUeXBlLlVuc3Vic2NyaWJlRXZlbnQgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZVVuc3Vic2NyaWJlRXZlbnRNZXNzYWdlKG1zZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2hhbmRsZVJlcGx5TWVzc2FnZShyZXBseU1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9wZW5kaW5nUmVwbGllc1tyZXBseU1lc3NhZ2Uuc2VxXSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdHb3QgcmVwbHkgdG8gdW5rbm93biBzZXEnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBseSA9IHRoaXMuX3BlbmRpbmdSZXBsaWVzW3JlcGx5TWVzc2FnZS5zZXFdO1xuICAgICAgICBkZWxldGUgdGhpcy5fcGVuZGluZ1JlcGxpZXNbcmVwbHlNZXNzYWdlLnNlcV07XG4gICAgICAgIGlmIChyZXBseU1lc3NhZ2UuZXJyKSB7XG4gICAgICAgICAgICBsZXQgZXJyID0gcmVwbHlNZXNzYWdlLmVycjtcbiAgICAgICAgICAgIGlmIChyZXBseU1lc3NhZ2UuZXJyLiRpc0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAgICAgZXJyLm5hbWUgPSByZXBseU1lc3NhZ2UuZXJyLm5hbWU7XG4gICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSByZXBseU1lc3NhZ2UuZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgZXJyLnN0YWNrID0gcmVwbHlNZXNzYWdlLmVyci5zdGFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcGx5LnJlamVjdChlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlcGx5LnJlc29sdmUocmVwbHlNZXNzYWdlLnJlcyk7XG4gICAgfVxuICAgIF9oYW5kbGVSZXF1ZXN0TWVzc2FnZShyZXF1ZXN0TWVzc2FnZSkge1xuICAgICAgICBjb25zdCByZXEgPSByZXF1ZXN0TWVzc2FnZS5yZXE7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2hhbmRsZXIuaGFuZGxlTWVzc2FnZShyZXF1ZXN0TWVzc2FnZS5tZXRob2QsIHJlcXVlc3RNZXNzYWdlLmFyZ3MpO1xuICAgICAgICByZXN1bHQudGhlbigocikgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2VuZChuZXcgUmVwbHlNZXNzYWdlKHRoaXMuX3dvcmtlcklkLCByZXEsIHIsIHVuZGVmaW5lZCkpO1xuICAgICAgICB9LCAoZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGUuZGV0YWlsIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2FkaW5nIGVycm9ycyBoYXZlIGEgZGV0YWlsIHByb3BlcnR5IHRoYXQgcG9pbnRzIHRvIHRoZSBhY3R1YWwgZXJyb3JcbiAgICAgICAgICAgICAgICBlLmRldGFpbCA9IHRyYW5zZm9ybUVycm9yRm9yU2VyaWFsaXphdGlvbihlLmRldGFpbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZW5kKG5ldyBSZXBseU1lc3NhZ2UodGhpcy5fd29ya2VySWQsIHJlcSwgdW5kZWZpbmVkLCB0cmFuc2Zvcm1FcnJvckZvclNlcmlhbGl6YXRpb24oZSkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9oYW5kbGVTdWJzY3JpYmVFdmVudE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIGNvbnN0IHJlcSA9IG1zZy5yZXE7XG4gICAgICAgIGNvbnN0IGRpc3Bvc2FibGUgPSB0aGlzLl9oYW5kbGVyLmhhbmRsZUV2ZW50KG1zZy5ldmVudE5hbWUsIG1zZy5hcmcpKChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fc2VuZChuZXcgRXZlbnRNZXNzYWdlKHRoaXMuX3dvcmtlcklkLCByZXEsIGV2ZW50KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRXZlbnRzLnNldChyZXEsIGRpc3Bvc2FibGUpO1xuICAgIH1cbiAgICBfaGFuZGxlRXZlbnRNZXNzYWdlKG1zZykge1xuICAgICAgICBpZiAoIXRoaXMuX3BlbmRpbmdFbWl0dGVycy5oYXMobXNnLnJlcSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignR290IGV2ZW50IGZvciB1bmtub3duIHJlcScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BlbmRpbmdFbWl0dGVycy5nZXQobXNnLnJlcSkuZmlyZShtc2cuZXZlbnQpO1xuICAgIH1cbiAgICBfaGFuZGxlVW5zdWJzY3JpYmVFdmVudE1lc3NhZ2UobXNnKSB7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZ0V2ZW50cy5oYXMobXNnLnJlcSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignR290IHVuc3Vic2NyaWJlIGZvciB1bmtub3duIHJlcScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BlbmRpbmdFdmVudHMuZ2V0KG1zZy5yZXEpLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ0V2ZW50cy5kZWxldGUobXNnLnJlcSk7XG4gICAgfVxuICAgIF9zZW5kKG1zZykge1xuICAgICAgICBjb25zdCB0cmFuc2ZlciA9IFtdO1xuICAgICAgICBpZiAobXNnLnR5cGUgPT09IDAgLyogTWVzc2FnZVR5cGUuUmVxdWVzdCAqLykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cuYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChtc2cuYXJnc1tpXSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyLnB1c2gobXNnLmFyZ3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtc2cudHlwZSA9PT0gMSAvKiBNZXNzYWdlVHlwZS5SZXBseSAqLykge1xuICAgICAgICAgICAgaWYgKG1zZy5yZXMgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIHRyYW5zZmVyLnB1c2gobXNnLnJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFuZGxlci5zZW5kTWVzc2FnZShtc2csIHRyYW5zZmVyKTtcbiAgICB9XG59XG4vKipcbiAqIE1haW4gdGhyZWFkIHNpZGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXBsZVdvcmtlckNsaWVudCBleHRlbmRzIERpc3Bvc2FibGUge1xuICAgIGNvbnN0cnVjdG9yKHdvcmtlckZhY3RvcnksIG1vZHVsZUlkLCBob3N0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGxldCBsYXp5UHJveHlSZWplY3QgPSBudWxsO1xuICAgICAgICB0aGlzLl93b3JrZXIgPSB0aGlzLl9yZWdpc3Rlcih3b3JrZXJGYWN0b3J5LmNyZWF0ZSgndnMvYmFzZS9jb21tb24vd29ya2VyL3NpbXBsZVdvcmtlcicsIChtc2cpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Byb3RvY29sLmhhbmRsZU1lc3NhZ2UobXNnKTtcbiAgICAgICAgfSwgKGVycikgPT4ge1xuICAgICAgICAgICAgLy8gaW4gRmlyZWZveCwgd2ViIHdvcmtlcnMgZmFpbCBsYXppbHkgOihcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgcmVqZWN0IHRoZSBwcm94eVxuICAgICAgICAgICAgbGF6eVByb3h5UmVqZWN0ID09PSBudWxsIHx8IGxhenlQcm94eVJlamVjdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF6eVByb3h5UmVqZWN0KGVycik7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wgPSBuZXcgU2ltcGxlV29ya2VyUHJvdG9jb2woe1xuICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IChtc2csIHRyYW5zZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya2VyLnBvc3RNZXNzYWdlKG1zZywgdHJhbnNmZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZU1lc3NhZ2U6IChtZXRob2QsIGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhvc3RbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNaXNzaW5nIG1ldGhvZCAnICsgbWV0aG9kICsgJyBvbiBtYWluIHRocmVhZCBob3N0LicpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShob3N0W21ldGhvZF0uYXBwbHkoaG9zdCwgYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50OiAoZXZlbnROYW1lLCBhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlJc0R5bmFtaWNFdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gaG9zdFtldmVudE5hbWVdLmNhbGwoaG9zdCwgYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGR5bmFtaWMgZXZlbnQgJHtldmVudE5hbWV9IG9uIG1haW4gdGhyZWFkIGhvc3QuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlJc0V2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBob3N0W2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBldmVudCAke2V2ZW50TmFtZX0gb24gbWFpbiB0aHJlYWQgaG9zdC5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGV2ZW50IG5hbWUgJHtldmVudE5hbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcm90b2NvbC5zZXRXb3JrZXJJZCh0aGlzLl93b3JrZXIuZ2V0SWQoKSk7XG4gICAgICAgIC8vIEdhdGhlciBsb2FkZXIgY29uZmlndXJhdGlvblxuICAgICAgICBsZXQgbG9hZGVyQ29uZmlndXJhdGlvbiA9IG51bGw7XG4gICAgICAgIGNvbnN0IGdsb2JhbFJlcXVpcmUgPSBnbG9iYWxUaGlzLnJlcXVpcmU7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsUmVxdWlyZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGdsb2JhbFJlcXVpcmUuZ2V0Q29uZmlnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgTW9uYWNvIEFNRCBMb2FkZXJcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZ3VyYXRpb24gPSBnbG9iYWxSZXF1aXJlLmdldENvbmZpZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBnbG9iYWxUaGlzLnJlcXVpcmVqcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgY29uZmlndXJhdGlvbiBmcm9tIHJlcXVpcmVqc1xuICAgICAgICAgICAgbG9hZGVyQ29uZmlndXJhdGlvbiA9IGdsb2JhbFRoaXMucmVxdWlyZWpzLnMuY29udGV4dHMuXy5jb25maWc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9zdE1ldGhvZHMgPSBnZXRBbGxNZXRob2ROYW1lcyhob3N0KTtcbiAgICAgICAgLy8gU2VuZCBpbml0aWFsaXplIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5fb25Nb2R1bGVMb2FkZWQgPSB0aGlzLl9wcm90b2NvbC5zZW5kTWVzc2FnZShJTklUSUFMSVpFLCBbXG4gICAgICAgICAgICB0aGlzLl93b3JrZXIuZ2V0SWQoKSxcbiAgICAgICAgICAgIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobG9hZGVyQ29uZmlndXJhdGlvbikpLFxuICAgICAgICAgICAgbW9kdWxlSWQsXG4gICAgICAgICAgICBob3N0TWV0aG9kcyxcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIENyZWF0ZSBwcm94eSB0byBsb2FkZWQgY29kZVxuICAgICAgICBjb25zdCBwcm94eU1ldGhvZFJlcXVlc3QgPSAobWV0aG9kLCBhcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVxdWVzdChtZXRob2QsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm94eUxpc3RlbiA9IChldmVudE5hbWUsIGFyZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sLmxpc3RlbihldmVudE5hbWUsIGFyZyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xhenlQcm94eSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxhenlQcm94eVJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIHRoaXMuX29uTW9kdWxlTG9hZGVkLnRoZW4oKGF2YWlsYWJsZU1ldGhvZHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKGNyZWF0ZVByb3h5T2JqZWN0KGF2YWlsYWJsZU1ldGhvZHMsIHByb3h5TWV0aG9kUmVxdWVzdCwgcHJveHlMaXN0ZW4pKTtcbiAgICAgICAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29uRXJyb3IoJ1dvcmtlciBmYWlsZWQgdG8gbG9hZCAnICsgbW9kdWxlSWQsIGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQcm94eU9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhenlQcm94eTtcbiAgICB9XG4gICAgX3JlcXVlc3QobWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9vbk1vZHVsZUxvYWRlZC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm90b2NvbC5zZW5kTWVzc2FnZShtZXRob2QsIGFyZ3MpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfb25FcnJvcihtZXNzYWdlLCBlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmluZm8oZXJyb3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb3BlcnR5SXNFdmVudChuYW1lKSB7XG4gICAgLy8gQXNzdW1lIGEgcHJvcGVydHkgaXMgYW4gZXZlbnQgaWYgaXQgaGFzIGEgZm9ybSBvZiBcIm9uU29tZXRoaW5nXCJcbiAgICByZXR1cm4gbmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJyAmJiBzdHJpbmdzLmlzVXBwZXJBc2NpaUxldHRlcihuYW1lLmNoYXJDb2RlQXQoMikpO1xufVxuZnVuY3Rpb24gcHJvcGVydHlJc0R5bmFtaWNFdmVudChuYW1lKSB7XG4gICAgLy8gQXNzdW1lIGEgcHJvcGVydHkgaXMgYSBkeW5hbWljIGV2ZW50IChhIG1ldGhvZCB0aGF0IHJldHVybnMgYW4gZXZlbnQpIGlmIGl0IGhhcyBhIGZvcm0gb2YgXCJvbkR5bmFtaWNTb21ldGhpbmdcIlxuICAgIHJldHVybiAvXm9uRHluYW1pYy8udGVzdChuYW1lKSAmJiBzdHJpbmdzLmlzVXBwZXJBc2NpaUxldHRlcihuYW1lLmNoYXJDb2RlQXQoOSkpO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJveHlPYmplY3QobWV0aG9kTmFtZXMsIGludm9rZSwgcHJveHlMaXN0ZW4pIHtcbiAgICBjb25zdCBjcmVhdGVQcm94eU1ldGhvZCA9IChtZXRob2QpID0+IHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAgICAgICAgICAgcmV0dXJuIGludm9rZShtZXRob2QsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgY3JlYXRlUHJveHlEeW5hbWljRXZlbnQgPSAoZXZlbnROYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJveHlMaXN0ZW4oZXZlbnROYW1lLCBhcmcpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBtZXRob2ROYW1lIG9mIG1ldGhvZE5hbWVzKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRHluYW1pY0V2ZW50KG1ldGhvZE5hbWUpKSB7XG4gICAgICAgICAgICByZXN1bHRbbWV0aG9kTmFtZV0gPSBjcmVhdGVQcm94eUR5bmFtaWNFdmVudChtZXRob2ROYW1lKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wZXJ0eUlzRXZlbnQobWV0aG9kTmFtZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFttZXRob2ROYW1lXSA9IHByb3h5TGlzdGVuKG1ldGhvZE5hbWUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbbWV0aG9kTmFtZV0gPSBjcmVhdGVQcm94eU1ldGhvZChtZXRob2ROYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogV29ya2VyIHNpZGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNpbXBsZVdvcmtlclNlcnZlciB7XG4gICAgY29uc3RydWN0b3IocG9zdE1lc3NhZ2UsIHJlcXVlc3RIYW5kbGVyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLl9yZXF1ZXN0SGFuZGxlckZhY3RvcnkgPSByZXF1ZXN0SGFuZGxlckZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvdG9jb2wgPSBuZXcgU2ltcGxlV29ya2VyUHJvdG9jb2woe1xuICAgICAgICAgICAgc2VuZE1lc3NhZ2U6IChtc2csIHRyYW5zZmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2UobXNnLCB0cmFuc2Zlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlTWVzc2FnZTogKG1ldGhvZCwgYXJncykgPT4gdGhpcy5faGFuZGxlTWVzc2FnZShtZXRob2QsIGFyZ3MpLFxuICAgICAgICAgICAgaGFuZGxlRXZlbnQ6IChldmVudE5hbWUsIGFyZykgPT4gdGhpcy5faGFuZGxlRXZlbnQoZXZlbnROYW1lLCBhcmcpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbm1lc3NhZ2UobXNnKSB7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sLmhhbmRsZU1lc3NhZ2UobXNnKTtcbiAgICB9XG4gICAgX2hhbmRsZU1lc3NhZ2UobWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IElOSVRJQUxJWkUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxpemUoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0SGFuZGxlciB8fCB0eXBlb2YgdGhpcy5fcmVxdWVzdEhhbmRsZXJbbWV0aG9kXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignTWlzc2luZyByZXF1ZXN0SGFuZGxlciBvciBtZXRob2Q6ICcgKyBtZXRob2QpKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9yZXF1ZXN0SGFuZGxlclttZXRob2RdLmFwcGx5KHRoaXMuX3JlcXVlc3RIYW5kbGVyLCBhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaGFuZGxlRXZlbnQoZXZlbnROYW1lLCBhcmcpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0SGFuZGxlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHJlcXVlc3RIYW5kbGVyYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnR5SXNEeW5hbWljRXZlbnQoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSB0aGlzLl9yZXF1ZXN0SGFuZGxlcltldmVudE5hbWVdLmNhbGwodGhpcy5fcmVxdWVzdEhhbmRsZXIsIGFyZyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIGR5bmFtaWMgZXZlbnQgJHtldmVudE5hbWV9IG9uIHJlcXVlc3QgaGFuZGxlci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcGVydHlJc0V2ZW50KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fcmVxdWVzdEhhbmRsZXJbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZXZlbnQgJHtldmVudE5hbWV9IG9uIHJlcXVlc3QgaGFuZGxlci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCBldmVudCBuYW1lICR7ZXZlbnROYW1lfWApO1xuICAgIH1cbiAgICBpbml0aWFsaXplKHdvcmtlcklkLCBsb2FkZXJDb25maWcsIG1vZHVsZUlkLCBob3N0TWV0aG9kcykge1xuICAgICAgICB0aGlzLl9wcm90b2NvbC5zZXRXb3JrZXJJZCh3b3JrZXJJZCk7XG4gICAgICAgIGNvbnN0IHByb3h5TWV0aG9kUmVxdWVzdCA9IChtZXRob2QsIGFyZ3MpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm90b2NvbC5zZW5kTWVzc2FnZShtZXRob2QsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwcm94eUxpc3RlbiA9IChldmVudE5hbWUsIGFyZykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sLmxpc3RlbihldmVudE5hbWUsIGFyZyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhvc3RQcm94eSA9IGNyZWF0ZVByb3h5T2JqZWN0KGhvc3RNZXRob2RzLCBwcm94eU1ldGhvZFJlcXVlc3QsIHByb3h5TGlzdGVuKTtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RIYW5kbGVyRmFjdG9yeSkge1xuICAgICAgICAgICAgLy8gc3RhdGljIHJlcXVlc3QgaGFuZGxlclxuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdEhhbmRsZXIgPSB0aGlzLl9yZXF1ZXN0SGFuZGxlckZhY3RvcnkoaG9zdFByb3h5KTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ2V0QWxsTWV0aG9kTmFtZXModGhpcy5fcmVxdWVzdEhhbmRsZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9hZGVyQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgJ2Jhc2VVcmwnLCBoYW5kbGluZyBpdCBpcyBiZXlvbmQgc2NvcGUgZm9yIG5vd1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2FkZXJDb25maWcuYmFzZVVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbG9hZGVyQ29uZmlnWydiYXNlVXJsJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy5wYXRocyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy5wYXRocy52cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGxvYWRlckNvbmZpZy5wYXRoc1sndnMnXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvYWRlckNvbmZpZy50cnVzdGVkVHlwZXNQb2xpY3kgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9uJ3QgdXNlLCBpdCBoYXMgYmVlbiBkZXN0cm95ZWQgZHVyaW5nIHNlcmlhbGl6ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBsb2FkZXJDb25maWdbJ3RydXN0ZWRUeXBlc1BvbGljeSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBpbiBhIHdlYiB3b3JrZXIsIGVuYWJsZSBjYXRjaGluZyBlcnJvcnNcbiAgICAgICAgICAgIGxvYWRlckNvbmZpZy5jYXRjaEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIGdsb2JhbFRoaXMucmVxdWlyZS5jb25maWcobG9hZGVyQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBnbG9iYWwgcmVxdWlyZSB0byBiZSBzdXJlIHRvIGdldCB0aGUgZ2xvYmFsIGNvbmZpZ1xuICAgICAgICAgICAgLy8gRVNNLWNvbW1lbnQtYmVnaW5cbiAgICAgICAgICAgIC8vIFx0XHRcdGNvbnN0IHJlcSA9IChnbG9iYWxUaGlzLnJlcXVpcmUgfHwgcmVxdWlyZSk7XG4gICAgICAgICAgICAvLyBFU00tY29tbWVudC1lbmRcbiAgICAgICAgICAgIC8vIEVTTS11bmNvbW1lbnQtYmVnaW5cbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGdsb2JhbFRoaXMucmVxdWlyZTtcbiAgICAgICAgICAgIC8vIEVTTS11bmNvbW1lbnQtZW5kXG4gICAgICAgICAgICByZXEoW21vZHVsZUlkXSwgKG1vZHVsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RIYW5kbGVyID0gbW9kdWxlLmNyZWF0ZShob3N0UHJveHkpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcmVxdWVzdEhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgTm8gUmVxdWVzdEhhbmRsZXIhYCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUoZ2V0QWxsTWV0aG9kTmFtZXModGhpcy5fcmVxdWVzdEhhbmRsZXIpKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogQ2FsbGVkIG9uIHRoZSB3b3JrZXIgc2lkZVxuICogQHNraXBNYW5nbGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZShwb3N0TWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgU2ltcGxlV29ya2VyU2VydmVyKHBvc3RNZXNzYWdlLCBudWxsKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuLyoqXG4gKiBSZXByZXNlbnRzIGluZm9ybWF0aW9uIGFib3V0IGEgc3BlY2lmaWMgZGlmZmVyZW5jZSBiZXR3ZWVuIHR3byBzZXF1ZW5jZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBEaWZmQ2hhbmdlIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IERpZmZDaGFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gc2VxdWVuY2UgaW5mb3JtYXRpb25cbiAgICAgKiBhbmQgY29udGVudC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHtcbiAgICAgICAgLy9EZWJ1Zy5Bc3NlcnQob3JpZ2luYWxMZW5ndGggPiAwIHx8IG1vZGlmaWVkTGVuZ3RoID4gMCwgXCJvcmlnaW5hbExlbmd0aCBhbmQgbW9kaWZpZWRMZW5ndGggY2Fubm90IGJvdGggYmUgPD0gMFwiKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFN0YXJ0ID0gb3JpZ2luYWxTdGFydDtcbiAgICAgICAgdGhpcy5vcmlnaW5hbExlbmd0aCA9IG9yaWdpbmFsTGVuZ3RoO1xuICAgICAgICB0aGlzLm1vZGlmaWVkU3RhcnQgPSBtb2RpZmllZFN0YXJ0O1xuICAgICAgICB0aGlzLm1vZGlmaWVkTGVuZ3RoID0gbW9kaWZpZWRMZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBlbmQgcG9pbnQgKGV4Y2x1c2l2ZSkgb2YgdGhlIGNoYW5nZSBpbiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UuXG4gICAgICovXG4gICAgZ2V0T3JpZ2luYWxFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsU3RhcnQgKyB0aGlzLm9yaWdpbmFsTGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZW5kIHBvaW50IChleGNsdXNpdmUpIG9mIHRoZSBjaGFuZ2UgaW4gdGhlIG1vZGlmaWVkIHNlcXVlbmNlLlxuICAgICAqL1xuICAgIGdldE1vZGlmaWVkRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RpZmllZFN0YXJ0ICsgdGhpcy5tb2RpZmllZExlbmd0aDtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi9zdHJpbmdzLmpzJztcbi8qKlxuICogUmV0dXJuIGEgaGFzaCB2YWx1ZSBmb3IgYW4gb2JqZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChvYmopIHtcbiAgICByZXR1cm4gZG9IYXNoKG9iaiwgMCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZG9IYXNoKG9iaiwgaGFzaFZhbCkge1xuICAgIHN3aXRjaCAodHlwZW9mIG9iaikge1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudW1iZXJIYXNoKDM0OSwgaGFzaFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlIYXNoKG9iaiwgaGFzaFZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0SGFzaChvYmosIGhhc2hWYWwpO1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0hhc2gob2JqLCBoYXNoVmFsKTtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gYm9vbGVhbkhhc2gob2JqLCBoYXNoVmFsKTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJIYXNoKG9iaiwgaGFzaFZhbCk7XG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVySGFzaCg5MzcsIGhhc2hWYWwpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bWJlckhhc2goNjE3LCBoYXNoVmFsKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVySGFzaCh2YWwsIGluaXRpYWxIYXNoVmFsKSB7XG4gICAgcmV0dXJuICgoKGluaXRpYWxIYXNoVmFsIDw8IDUpIC0gaW5pdGlhbEhhc2hWYWwpICsgdmFsKSB8IDA7IC8vIGhhc2hWYWwgKiAzMSArIGNoLCBrZWVwIGFzIGludDMyXG59XG5mdW5jdGlvbiBib29sZWFuSGFzaChiLCBpbml0aWFsSGFzaFZhbCkge1xuICAgIHJldHVybiBudW1iZXJIYXNoKGIgPyA0MzMgOiA4NjMsIGluaXRpYWxIYXNoVmFsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdIYXNoKHMsIGhhc2hWYWwpIHtcbiAgICBoYXNoVmFsID0gbnVtYmVySGFzaCgxNDk0MTcsIGhhc2hWYWwpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSBzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhhc2hWYWwgPSBudW1iZXJIYXNoKHMuY2hhckNvZGVBdChpKSwgaGFzaFZhbCk7XG4gICAgfVxuICAgIHJldHVybiBoYXNoVmFsO1xufVxuZnVuY3Rpb24gYXJyYXlIYXNoKGFyciwgaW5pdGlhbEhhc2hWYWwpIHtcbiAgICBpbml0aWFsSGFzaFZhbCA9IG51bWJlckhhc2goMTA0NTc5LCBpbml0aWFsSGFzaFZhbCk7XG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoKGhhc2hWYWwsIGl0ZW0pID0+IGRvSGFzaChpdGVtLCBoYXNoVmFsKSwgaW5pdGlhbEhhc2hWYWwpO1xufVxuZnVuY3Rpb24gb2JqZWN0SGFzaChvYmosIGluaXRpYWxIYXNoVmFsKSB7XG4gICAgaW5pdGlhbEhhc2hWYWwgPSBudW1iZXJIYXNoKDE4MTM4NywgaW5pdGlhbEhhc2hWYWwpO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5yZWR1Y2UoKGhhc2hWYWwsIGtleSkgPT4ge1xuICAgICAgICBoYXNoVmFsID0gc3RyaW5nSGFzaChrZXksIGhhc2hWYWwpO1xuICAgICAgICByZXR1cm4gZG9IYXNoKG9ialtrZXldLCBoYXNoVmFsKTtcbiAgICB9LCBpbml0aWFsSGFzaFZhbCk7XG59XG5mdW5jdGlvbiBsZWZ0Um90YXRlKHZhbHVlLCBiaXRzLCB0b3RhbEJpdHMgPSAzMikge1xuICAgIC8vIGRlbHRhICsgYml0cyA9IHRvdGFsQml0c1xuICAgIGNvbnN0IGRlbHRhID0gdG90YWxCaXRzIC0gYml0cztcbiAgICAvLyBBbGwgb25lcywgZXhwZWN0IGBkZWx0YWAgemVyb3MgYWxpZ25lZCB0byB0aGUgcmlnaHRcbiAgICBjb25zdCBtYXNrID0gfigoMSA8PCBkZWx0YSkgLSAxKTtcbiAgICAvLyBKb2luICh2YWx1ZSBsZWZ0LXNoaWZ0ZWQgYGJpdHNgIGJpdHMpIHdpdGggKG1hc2tlZCB2YWx1ZSByaWdodC1zaGlmdGVkIGBkZWx0YWAgYml0cylcbiAgICByZXR1cm4gKCh2YWx1ZSA8PCBiaXRzKSB8ICgobWFzayAmIHZhbHVlKSA+Pj4gZGVsdGEpKSA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGZpbGwoZGVzdCwgaW5kZXggPSAwLCBjb3VudCA9IGRlc3QuYnl0ZUxlbmd0aCwgdmFsdWUgPSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGRlc3RbaW5kZXggKyBpXSA9IHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGxlZnRQYWQodmFsdWUsIGxlbmd0aCwgY2hhciA9ICcwJykge1xuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBjaGFyICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0hleFN0cmluZyhidWZmZXJPclZhbHVlLCBiaXRzaXplID0gMzIpIHtcbiAgICBpZiAoYnVmZmVyT3JWYWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBVaW50OEFycmF5KGJ1ZmZlck9yVmFsdWUpKS5tYXAoYiA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgcmV0dXJuIGxlZnRQYWQoKGJ1ZmZlck9yVmFsdWUgPj4+IDApLnRvU3RyaW5nKDE2KSwgYml0c2l6ZSAvIDQpO1xufVxuLyoqXG4gKiBBIFNIQTEgaW1wbGVtZW50YXRpb24gdGhhdCB3b3JrcyB3aXRoIHN0cmluZ3MgYW5kIGRvZXMgbm90IGFsbG9jYXRlLlxuICovXG5leHBvcnQgY2xhc3MgU3RyaW5nU0hBMSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2gwID0gMHg2NzQ1MjMwMTtcbiAgICAgICAgdGhpcy5faDEgPSAweEVGQ0RBQjg5O1xuICAgICAgICB0aGlzLl9oMiA9IDB4OThCQURDRkU7XG4gICAgICAgIHRoaXMuX2gzID0gMHgxMDMyNTQ3NjtcbiAgICAgICAgdGhpcy5faDQgPSAweEMzRDJFMUYwO1xuICAgICAgICB0aGlzLl9idWZmID0gbmV3IFVpbnQ4QXJyYXkoNjQgLyogU0hBMUNvbnN0YW50LkJMT0NLX1NJWkUgKi8gKyAzIC8qIHRvIGZpdCBhbnkgdXRmLTggKi8pO1xuICAgICAgICB0aGlzLl9idWZmRFYgPSBuZXcgRGF0YVZpZXcodGhpcy5fYnVmZi5idWZmZXIpO1xuICAgICAgICB0aGlzLl9idWZmTGVuID0gMDtcbiAgICAgICAgdGhpcy5fdG90YWxMZW4gPSAwO1xuICAgICAgICB0aGlzLl9sZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgPSAwO1xuICAgICAgICB0aGlzLl9maW5pc2hlZCA9IGZhbHNlO1xuICAgIH1cbiAgICB1cGRhdGUoc3RyKSB7XG4gICAgICAgIGNvbnN0IHN0ckxlbiA9IHN0ci5sZW5ndGg7XG4gICAgICAgIGlmIChzdHJMZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmID0gdGhpcy5fYnVmZjtcbiAgICAgICAgbGV0IGJ1ZmZMZW4gPSB0aGlzLl9idWZmTGVuO1xuICAgICAgICBsZXQgbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gdGhpcy5fbGVmdG92ZXJIaWdoU3Vycm9nYXRlO1xuICAgICAgICBsZXQgY2hhckNvZGU7XG4gICAgICAgIGxldCBvZmZzZXQ7XG4gICAgICAgIGlmIChsZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgIT09IDApIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gbGVmdG92ZXJIaWdoU3Vycm9nYXRlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICBsZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGxldCBjb2RlUG9pbnQgPSBjaGFyQ29kZTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdzLmlzSGlnaFN1cnJvZ2F0ZShjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAob2Zmc2V0ICsgMSA8IHN0ckxlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNMb3dTdXJyb2dhdGUobmV4dENoYXJDb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSBzdHJpbmdzLmNvbXB1dGVDb2RlUG9pbnQoY2hhckNvZGUsIG5leHRDaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsID0+IHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlUG9pbnQgPSA2NTUzMyAvKiBTSEExQ29uc3RhbnQuVU5JQ09ERV9SRVBMQUNFTUVOVCAqLztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGFzdCBjaGFyYWN0ZXIgaXMgYSBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgICAgICAgICAgICBsZWZ0b3ZlckhpZ2hTdXJyb2dhdGUgPSBjaGFyQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RyaW5ncy5pc0xvd1N1cnJvZ2F0ZShjaGFyQ29kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsID0+IHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgY29kZVBvaW50ID0gNjU1MzMgLyogU0hBMUNvbnN0YW50LlVOSUNPREVfUkVQTEFDRU1FTlQgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmTGVuID0gdGhpcy5fcHVzaChidWZmLCBidWZmTGVuLCBjb2RlUG9pbnQpO1xuICAgICAgICAgICAgb2Zmc2V0Kys7XG4gICAgICAgICAgICBpZiAob2Zmc2V0IDwgc3RyTGVuKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYnVmZkxlbiA9IGJ1ZmZMZW47XG4gICAgICAgIHRoaXMuX2xlZnRvdmVySGlnaFN1cnJvZ2F0ZSA9IGxlZnRvdmVySGlnaFN1cnJvZ2F0ZTtcbiAgICB9XG4gICAgX3B1c2goYnVmZiwgYnVmZkxlbiwgY29kZVBvaW50KSB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDAwODApIHtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IGNvZGVQb2ludDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDA4MDApIHtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTEwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTEwMDAwMDApID4+PiA2KTtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxMTExMTEpID4+PiAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjExMTAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAxMTExMDAwMDAwMDAwMDAwKSA+Pj4gMTIpO1xuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMTAwMDAwMCkgPj4+IDYpO1xuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMDAwMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDExMTExMSkgPj4+IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnVmZltidWZmTGVuKytdID0gMGIxMTExMDAwMCB8ICgoY29kZVBvaW50ICYgMGIwMDAwMDAwMDAwMDExMTAwMDAwMDAwMDAwMDAwMDAwMCkgPj4+IDE4KTtcbiAgICAgICAgICAgIGJ1ZmZbYnVmZkxlbisrXSA9IDBiMTAwMDAwMDAgfCAoKGNvZGVQb2ludCAmIDBiMDAwMDAwMDAwMDAwMDAxMTExMTEwMDAwMDAwMDAwMDApID4+PiAxMik7XG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjEwMDAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTExMDAwMDAwKSA+Pj4gNik7XG4gICAgICAgICAgICBidWZmW2J1ZmZMZW4rK10gPSAwYjEwMDAwMDAwIHwgKChjb2RlUG9pbnQgJiAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTExMTExKSA+Pj4gMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1ZmZMZW4gPj0gNjQgLyogU0hBMUNvbnN0YW50LkJMT0NLX1NJWkUgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuX3N0ZXAoKTtcbiAgICAgICAgICAgIGJ1ZmZMZW4gLT0gNjQgLyogU0hBMUNvbnN0YW50LkJMT0NLX1NJWkUgKi87XG4gICAgICAgICAgICB0aGlzLl90b3RhbExlbiArPSA2NCAvKiBTSEExQ29uc3RhbnQuQkxPQ0tfU0laRSAqLztcbiAgICAgICAgICAgIC8vIHRha2UgbGFzdCAzIGluIGNhc2Ugb2YgVVRGOCBvdmVyZmxvd1xuICAgICAgICAgICAgYnVmZlswXSA9IGJ1ZmZbNjQgLyogU0hBMUNvbnN0YW50LkJMT0NLX1NJWkUgKi8gKyAwXTtcbiAgICAgICAgICAgIGJ1ZmZbMV0gPSBidWZmWzY0IC8qIFNIQTFDb25zdGFudC5CTE9DS19TSVpFICovICsgMV07XG4gICAgICAgICAgICBidWZmWzJdID0gYnVmZls2NCAvKiBTSEExQ29uc3RhbnQuQkxPQ0tfU0laRSAqLyArIDJdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmTGVuO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZWZ0b3ZlckhpZ2hTdXJyb2dhdGUpIHtcbiAgICAgICAgICAgICAgICAvLyBpbGxlZ2FsID0+IHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVmdG92ZXJIaWdoU3Vycm9nYXRlID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9idWZmTGVuID0gdGhpcy5fcHVzaCh0aGlzLl9idWZmLCB0aGlzLl9idWZmTGVuLCA2NTUzMyAvKiBTSEExQ29uc3RhbnQuVU5JQ09ERV9SRVBMQUNFTUVOVCAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl90b3RhbExlbiArPSB0aGlzLl9idWZmTGVuO1xuICAgICAgICAgICAgdGhpcy5fd3JhcFVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvSGV4U3RyaW5nKHRoaXMuX2gwKSArIHRvSGV4U3RyaW5nKHRoaXMuX2gxKSArIHRvSGV4U3RyaW5nKHRoaXMuX2gyKSArIHRvSGV4U3RyaW5nKHRoaXMuX2gzKSArIHRvSGV4U3RyaW5nKHRoaXMuX2g0KTtcbiAgICB9XG4gICAgX3dyYXBVcCgpIHtcbiAgICAgICAgdGhpcy5fYnVmZlt0aGlzLl9idWZmTGVuKytdID0gMHg4MDtcbiAgICAgICAgZmlsbCh0aGlzLl9idWZmLCB0aGlzLl9idWZmTGVuKTtcbiAgICAgICAgaWYgKHRoaXMuX2J1ZmZMZW4gPiA1Nikge1xuICAgICAgICAgICAgdGhpcy5fc3RlcCgpO1xuICAgICAgICAgICAgZmlsbCh0aGlzLl9idWZmKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzIHdpbGwgZml0IGJlY2F1c2UgdGhlIG1hbnRpc3NhIGNhbiBjb3ZlciB1cCB0byA1MiBiaXRzXG4gICAgICAgIGNvbnN0IG1sID0gOCAqIHRoaXMuX3RvdGFsTGVuO1xuICAgICAgICB0aGlzLl9idWZmRFYuc2V0VWludDMyKDU2LCBNYXRoLmZsb29yKG1sIC8gNDI5NDk2NzI5NiksIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fYnVmZkRWLnNldFVpbnQzMig2MCwgbWwgJSA0Mjk0OTY3Mjk2LCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX3N0ZXAoKTtcbiAgICB9XG4gICAgX3N0ZXAoKSB7XG4gICAgICAgIGNvbnN0IGJpZ0Jsb2NrMzIgPSBTdHJpbmdTSEExLl9iaWdCbG9jazMyO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fYnVmZkRWO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDY0IC8qIDE2KjQgKi87IGogKz0gNCkge1xuICAgICAgICAgICAgYmlnQmxvY2szMi5zZXRVaW50MzIoaiwgZGF0YS5nZXRVaW50MzIoaiwgZmFsc2UpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDY0OyBqIDwgMzIwIC8qIDgwKjQgKi87IGogKz0gNCkge1xuICAgICAgICAgICAgYmlnQmxvY2szMi5zZXRVaW50MzIoaiwgbGVmdFJvdGF0ZSgoYmlnQmxvY2szMi5nZXRVaW50MzIoaiAtIDEyLCBmYWxzZSkgXiBiaWdCbG9jazMyLmdldFVpbnQzMihqIC0gMzIsIGZhbHNlKSBeIGJpZ0Jsb2NrMzIuZ2V0VWludDMyKGogLSA1NiwgZmFsc2UpIF4gYmlnQmxvY2szMi5nZXRVaW50MzIoaiAtIDY0LCBmYWxzZSkpLCAxKSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhID0gdGhpcy5faDA7XG4gICAgICAgIGxldCBiID0gdGhpcy5faDE7XG4gICAgICAgIGxldCBjID0gdGhpcy5faDI7XG4gICAgICAgIGxldCBkID0gdGhpcy5faDM7XG4gICAgICAgIGxldCBlID0gdGhpcy5faDQ7XG4gICAgICAgIGxldCBmLCBrO1xuICAgICAgICBsZXQgdGVtcDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoaiA8IDIwKSB7XG4gICAgICAgICAgICAgICAgZiA9IChiICYgYykgfCAoKH5iKSAmIGQpO1xuICAgICAgICAgICAgICAgIGsgPSAweDVBODI3OTk5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaiA8IDQwKSB7XG4gICAgICAgICAgICAgICAgZiA9IGIgXiBjIF4gZDtcbiAgICAgICAgICAgICAgICBrID0gMHg2RUQ5RUJBMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGogPCA2MCkge1xuICAgICAgICAgICAgICAgIGYgPSAoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCk7XG4gICAgICAgICAgICAgICAgayA9IDB4OEYxQkJDREM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmID0gYiBeIGMgXiBkO1xuICAgICAgICAgICAgICAgIGsgPSAweENBNjJDMUQ2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGVtcCA9IChsZWZ0Um90YXRlKGEsIDUpICsgZiArIGUgKyBrICsgYmlnQmxvY2szMi5nZXRVaW50MzIoaiAqIDQsIGZhbHNlKSkgJiAweGZmZmZmZmZmO1xuICAgICAgICAgICAgZSA9IGQ7XG4gICAgICAgICAgICBkID0gYztcbiAgICAgICAgICAgIGMgPSBsZWZ0Um90YXRlKGIsIDMwKTtcbiAgICAgICAgICAgIGIgPSBhO1xuICAgICAgICAgICAgYSA9IHRlbXA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faDAgPSAodGhpcy5faDAgKyBhKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuX2gxID0gKHRoaXMuX2gxICsgYikgJiAweGZmZmZmZmZmO1xuICAgICAgICB0aGlzLl9oMiA9ICh0aGlzLl9oMiArIGMpICYgMHhmZmZmZmZmZjtcbiAgICAgICAgdGhpcy5faDMgPSAodGhpcy5faDMgKyBkKSAmIDB4ZmZmZmZmZmY7XG4gICAgICAgIHRoaXMuX2g0ID0gKHRoaXMuX2g0ICsgZSkgJiAweGZmZmZmZmZmO1xuICAgIH1cbn1cblN0cmluZ1NIQTEuX2JpZ0Jsb2NrMzIgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDMyMCkpOyAvLyA4MCAqIDQgPSAzMjBcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgRGlmZkNoYW5nZSB9IGZyb20gJy4vZGlmZkNoYW5nZS5qcyc7XG5pbXBvcnQgeyBzdHJpbmdIYXNoIH0gZnJvbSAnLi4vaGFzaC5qcyc7XG5leHBvcnQgY2xhc3MgU3RyaW5nRGlmZlNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGdldEVsZW1lbnRzKCkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVycyA9IG5ldyBJbnQzMkFycmF5KHNvdXJjZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXJzW2ldID0gc291cmNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYXJhY3RlcnM7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0RpZmYob3JpZ2luYWwsIG1vZGlmaWVkLCBwcmV0dHkpIHtcbiAgICByZXR1cm4gbmV3IExjc0RpZmYobmV3IFN0cmluZ0RpZmZTZXF1ZW5jZShvcmlnaW5hbCksIG5ldyBTdHJpbmdEaWZmU2VxdWVuY2UobW9kaWZpZWQpKS5Db21wdXRlRGlmZihwcmV0dHkpLmNoYW5nZXM7XG59XG4vL1xuLy8gVGhlIGNvZGUgYmVsb3cgaGFzIGJlZW4gcG9ydGVkIGZyb20gYSBDIyBpbXBsZW1lbnRhdGlvbiBpbiBWU1xuLy9cbmNsYXNzIERlYnVnIHtcbiAgICBzdGF0aWMgQXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxufVxuY2xhc3MgTXlBcnJheSB7XG4gICAgLyoqXG4gICAgICogQ29waWVzIGEgcmFuZ2Ugb2YgZWxlbWVudHMgZnJvbSBhbiBBcnJheSBzdGFydGluZyBhdCB0aGUgc3BlY2lmaWVkIHNvdXJjZSBpbmRleCBhbmQgcGFzdGVzXG4gICAgICogdGhlbSB0byBhbm90aGVyIEFycmF5IHN0YXJ0aW5nIGF0IHRoZSBzcGVjaWZpZWQgZGVzdGluYXRpb24gaW5kZXguIFRoZSBsZW5ndGggYW5kIHRoZSBpbmRleGVzXG4gICAgICogYXJlIHNwZWNpZmllZCBhcyA2NC1iaXQgaW50ZWdlcnMuXG4gICAgICogc291cmNlQXJyYXk6XG4gICAgICpcdFx0VGhlIEFycmF5IHRoYXQgY29udGFpbnMgdGhlIGRhdGEgdG8gY29weS5cbiAgICAgKiBzb3VyY2VJbmRleDpcbiAgICAgKlx0XHRBIDY0LWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5kZXggaW4gdGhlIHNvdXJjZUFycmF5IGF0IHdoaWNoIGNvcHlpbmcgYmVnaW5zLlxuICAgICAqIGRlc3RpbmF0aW9uQXJyYXk6XG4gICAgICpcdFx0VGhlIEFycmF5IHRoYXQgcmVjZWl2ZXMgdGhlIGRhdGEuXG4gICAgICogZGVzdGluYXRpb25JbmRleDpcbiAgICAgKlx0XHRBIDY0LWJpdCBpbnRlZ2VyIHRoYXQgcmVwcmVzZW50cyB0aGUgaW5kZXggaW4gdGhlIGRlc3RpbmF0aW9uQXJyYXkgYXQgd2hpY2ggc3RvcmluZyBiZWdpbnMuXG4gICAgICogbGVuZ3RoOlxuICAgICAqXHRcdEEgNjQtYml0IGludGVnZXIgdGhhdCByZXByZXNlbnRzIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gY29weS5cbiAgICAgKi9cbiAgICBzdGF0aWMgQ29weShzb3VyY2VBcnJheSwgc291cmNlSW5kZXgsIGRlc3RpbmF0aW9uQXJyYXksIGRlc3RpbmF0aW9uSW5kZXgsIGxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbkFycmF5W2Rlc3RpbmF0aW9uSW5kZXggKyBpXSA9IHNvdXJjZUFycmF5W3NvdXJjZUluZGV4ICsgaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIENvcHkyKHNvdXJjZUFycmF5LCBzb3VyY2VJbmRleCwgZGVzdGluYXRpb25BcnJheSwgZGVzdGluYXRpb25JbmRleCwgbGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uQXJyYXlbZGVzdGluYXRpb25JbmRleCArIGldID0gc291cmNlQXJyYXlbc291cmNlSW5kZXggKyBpXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHdoaWNoIGhlbHBzIHRvIGNyZWF0ZSB0aGUgc2V0IG9mIERpZmZDaGFuZ2VzIGZyb21cbiAqIGEgZGlmZmVyZW5jZSBvcGVyYXRpb24uIFRoaXMgY2xhc3MgYWNjZXB0cyBvcmlnaW5hbCBEaWZmRWxlbWVudHMgYW5kXG4gKiBtb2RpZmllZCBEaWZmRWxlbWVudHMgdGhhdCBhcmUgaW52b2x2ZWQgaW4gYSBwYXJ0aWN1bGFyIGNoYW5nZS4gVGhlXG4gKiBNYXJrTmV4dENoYW5nZSgpIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIG1hcmsgdGhlIHNlcGFyYXRpb24gYmV0d2VlblxuICogZGlzdGluY3QgY2hhbmdlcy4gQXQgdGhlIGVuZCwgdGhlIENoYW5nZXMgcHJvcGVydHkgY2FuIGJlIGNhbGxlZCB0byByZXRyaWV2ZVxuICogdGhlIGNvbnN0cnVjdGVkIGNoYW5nZXMuXG4gKi9cbmNsYXNzIERpZmZDaGFuZ2VIZWxwZXIge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBuZXcgRGlmZkNoYW5nZUhlbHBlciBmb3IgdGhlIGdpdmVuIERpZmZTZXF1ZW5jZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubV9jaGFuZ2VzID0gW107XG4gICAgICAgIHRoaXMubV9vcmlnaW5hbFN0YXJ0ID0gMTA3Mzc0MTgyNCAvKiBDb25zdGFudHMuTUFYX1NBRkVfU01BTExfSU5URUdFUiAqLztcbiAgICAgICAgdGhpcy5tX21vZGlmaWVkU3RhcnQgPSAxMDczNzQxODI0IC8qIENvbnN0YW50cy5NQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubV9tb2RpZmllZENvdW50ID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFya3MgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBjaGFuZ2UgaW4gdGhlIHNldCBvZiBkaWZmZXJlbmNlcy5cbiAgICAgKi9cbiAgICBNYXJrTmV4dENoYW5nZSgpIHtcbiAgICAgICAgLy8gT25seSBhZGQgdG8gdGhlIGxpc3QgaWYgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGFkZFxuICAgICAgICBpZiAodGhpcy5tX29yaWdpbmFsQ291bnQgPiAwIHx8IHRoaXMubV9tb2RpZmllZENvdW50ID4gMCkge1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBuZXcgY2hhbmdlIHRvIG91ciBsaXN0XG4gICAgICAgICAgICB0aGlzLm1fY2hhbmdlcy5wdXNoKG5ldyBEaWZmQ2hhbmdlKHRoaXMubV9vcmlnaW5hbFN0YXJ0LCB0aGlzLm1fb3JpZ2luYWxDb3VudCwgdGhpcy5tX21vZGlmaWVkU3RhcnQsIHRoaXMubV9tb2RpZmllZENvdW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgZm9yIHRoZSBuZXh0IGNoYW5nZVxuICAgICAgICB0aGlzLm1fb3JpZ2luYWxDb3VudCA9IDA7XG4gICAgICAgIHRoaXMubV9tb2RpZmllZENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSAxMDczNzQxODI0IC8qIENvbnN0YW50cy5NQVhfU0FGRV9TTUFMTF9JTlRFR0VSICovO1xuICAgICAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IDEwNzM3NDE4MjQgLyogQ29uc3RhbnRzLk1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIG9yaWdpbmFsIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHRvIHRoZSBlbGVtZW50c1xuICAgICAqIGFmZmVjdGVkIGJ5IHRoZSBjdXJyZW50IGNoYW5nZS4gVGhlIG1vZGlmaWVkIGluZGV4IGdpdmVzIGNvbnRleHRcbiAgICAgKiB0byB0aGUgY2hhbmdlIHBvc2l0aW9uIHdpdGggcmVzcGVjdCB0byB0aGUgb3JpZ2luYWwgc2VxdWVuY2UuXG4gICAgICogQHBhcmFtIG9yaWdpbmFsSW5kZXggVGhlIGluZGV4IG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50IHRvIGFkZC5cbiAgICAgKiBAcGFyYW0gbW9kaWZpZWRJbmRleCBUaGUgaW5kZXggb2YgdGhlIG1vZGlmaWVkIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBjb3JyZXNwb25kaW5nIHBvc2l0aW9uIGluIHRoZSBtb2RpZmllZCBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBBZGRPcmlnaW5hbEVsZW1lbnQob3JpZ2luYWxJbmRleCwgbW9kaWZpZWRJbmRleCkge1xuICAgICAgICAvLyBUaGUgJ3RydWUnIHN0YXJ0IGluZGV4IGlzIHRoZSBzbWFsbGVzdCBvZiB0aGUgb25lcyB3ZSd2ZSBzZWVuXG4gICAgICAgIHRoaXMubV9vcmlnaW5hbFN0YXJ0ID0gTWF0aC5taW4odGhpcy5tX29yaWdpbmFsU3RhcnQsIG9yaWdpbmFsSW5kZXgpO1xuICAgICAgICB0aGlzLm1fbW9kaWZpZWRTdGFydCA9IE1hdGgubWluKHRoaXMubV9tb2RpZmllZFN0YXJ0LCBtb2RpZmllZEluZGV4KTtcbiAgICAgICAgdGhpcy5tX29yaWdpbmFsQ291bnQrKztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgbW9kaWZpZWQgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gdG8gdGhlIGVsZW1lbnRzXG4gICAgICogYWZmZWN0ZWQgYnkgdGhlIGN1cnJlbnQgY2hhbmdlLiBUaGUgb3JpZ2luYWwgaW5kZXggZ2l2ZXMgY29udGV4dFxuICAgICAqIHRvIHRoZSBjaGFuZ2UgcG9zaXRpb24gd2l0aCByZXNwZWN0IHRvIHRoZSBtb2RpZmllZCBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxJbmRleCBUaGUgaW5kZXggb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBjb3JyZXNwb25kaW5nIHBvc2l0aW9uIGluIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS5cbiAgICAgKiBAcGFyYW0gbW9kaWZpZWRJbmRleCBUaGUgaW5kZXggb2YgdGhlIG1vZGlmaWVkIGVsZW1lbnQgdG8gYWRkLlxuICAgICAqL1xuICAgIEFkZE1vZGlmaWVkRWxlbWVudChvcmlnaW5hbEluZGV4LCBtb2RpZmllZEluZGV4KSB7XG4gICAgICAgIC8vIFRoZSAndHJ1ZScgc3RhcnQgaW5kZXggaXMgdGhlIHNtYWxsZXN0IG9mIHRoZSBvbmVzIHdlJ3ZlIHNlZW5cbiAgICAgICAgdGhpcy5tX29yaWdpbmFsU3RhcnQgPSBNYXRoLm1pbih0aGlzLm1fb3JpZ2luYWxTdGFydCwgb3JpZ2luYWxJbmRleCk7XG4gICAgICAgIHRoaXMubV9tb2RpZmllZFN0YXJ0ID0gTWF0aC5taW4odGhpcy5tX21vZGlmaWVkU3RhcnQsIG1vZGlmaWVkSW5kZXgpO1xuICAgICAgICB0aGlzLm1fbW9kaWZpZWRDb3VudCsrO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIG9mIHRoZSBjaGFuZ2VzIG1hcmtlZCBieSB0aGUgY2xhc3MuXG4gICAgICovXG4gICAgZ2V0Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMubV9vcmlnaW5hbENvdW50ID4gMCB8fCB0aGlzLm1fbW9kaWZpZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIEZpbmlzaCB1cCBvbiB3aGF0ZXZlciBpcyBsZWZ0XG4gICAgICAgICAgICB0aGlzLk1hcmtOZXh0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubV9jaGFuZ2VzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYWxsIG9mIHRoZSBjaGFuZ2VzIG1hcmtlZCBieSB0aGUgY2xhc3MgaW4gdGhlIHJldmVyc2Ugb3JkZXJcbiAgICAgKi9cbiAgICBnZXRSZXZlcnNlQ2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMubV9vcmlnaW5hbENvdW50ID4gMCB8fCB0aGlzLm1fbW9kaWZpZWRDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIEZpbmlzaCB1cCBvbiB3aGF0ZXZlciBpcyBsZWZ0XG4gICAgICAgICAgICB0aGlzLk1hcmtOZXh0Q2hhbmdlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tX2NoYW5nZXMucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5tX2NoYW5nZXM7XG4gICAgfVxufVxuLyoqXG4gKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGlmZmVyZW5jZSBhbGdvcml0aG0gZGVzY3JpYmVkIGluXG4gKiBcIkFuIE8oTkQpIERpZmZlcmVuY2UgQWxnb3JpdGhtIGFuZCBpdHMgdmFyaWF0aW9uc1wiIGJ5IEV1Z2VuZSBXLiBNeWVyc1xuICovXG5leHBvcnQgY2xhc3MgTGNzRGlmZiB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyB0aGUgRGlmZkZpbmRlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsU2VxdWVuY2UsIG1vZGlmaWVkU2VxdWVuY2UsIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5Db250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgPSBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGU7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsU2VxdWVuY2UgPSBvcmlnaW5hbFNlcXVlbmNlO1xuICAgICAgICB0aGlzLl9tb2RpZmllZFNlcXVlbmNlID0gbW9kaWZpZWRTZXF1ZW5jZTtcbiAgICAgICAgY29uc3QgW29yaWdpbmFsU3RyaW5nRWxlbWVudHMsIG9yaWdpbmFsRWxlbWVudHNPckhhc2gsIG9yaWdpbmFsSGFzU3RyaW5nc10gPSBMY3NEaWZmLl9nZXRFbGVtZW50cyhvcmlnaW5hbFNlcXVlbmNlKTtcbiAgICAgICAgY29uc3QgW21vZGlmaWVkU3RyaW5nRWxlbWVudHMsIG1vZGlmaWVkRWxlbWVudHNPckhhc2gsIG1vZGlmaWVkSGFzU3RyaW5nc10gPSBMY3NEaWZmLl9nZXRFbGVtZW50cyhtb2RpZmllZFNlcXVlbmNlKTtcbiAgICAgICAgdGhpcy5faGFzU3RyaW5ncyA9IChvcmlnaW5hbEhhc1N0cmluZ3MgJiYgbW9kaWZpZWRIYXNTdHJpbmdzKTtcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50cyA9IG9yaWdpbmFsU3RyaW5nRWxlbWVudHM7XG4gICAgICAgIHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2ggPSBvcmlnaW5hbEVsZW1lbnRzT3JIYXNoO1xuICAgICAgICB0aGlzLl9tb2RpZmllZFN0cmluZ0VsZW1lbnRzID0gbW9kaWZpZWRTdHJpbmdFbGVtZW50cztcbiAgICAgICAgdGhpcy5fbW9kaWZpZWRFbGVtZW50c09ySGFzaCA9IG1vZGlmaWVkRWxlbWVudHNPckhhc2g7XG4gICAgICAgIHRoaXMubV9mb3J3YXJkSGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkgPSBbXTtcbiAgICB9XG4gICAgc3RhdGljIF9pc1N0cmluZ0FycmF5KGFycikge1xuICAgICAgICByZXR1cm4gKGFyci5sZW5ndGggPiAwICYmIHR5cGVvZiBhcnJbMF0gPT09ICdzdHJpbmcnKTtcbiAgICB9XG4gICAgc3RhdGljIF9nZXRFbGVtZW50cyhzZXF1ZW5jZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHNlcXVlbmNlLmdldEVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChMY3NEaWZmLl9pc1N0cmluZ0FycmF5KGVsZW1lbnRzKSkge1xuICAgICAgICAgICAgY29uc3QgaGFzaGVzID0gbmV3IEludDMyQXJyYXkoZWxlbWVudHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGhhc2hlc1tpXSA9IHN0cmluZ0hhc2goZWxlbWVudHNbaV0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtlbGVtZW50cywgaGFzaGVzLCB0cnVlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxlbWVudHMgaW5zdGFuY2VvZiBJbnQzMkFycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gW1tdLCBlbGVtZW50cywgZmFsc2VdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbW10sIG5ldyBJbnQzMkFycmF5KGVsZW1lbnRzKSwgZmFsc2VdO1xuICAgIH1cbiAgICBFbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoW29yaWdpbmFsSW5kZXhdICE9PSB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoW25ld0luZGV4XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyA/IHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbb3JpZ2luYWxJbmRleF0gPT09IHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbbmV3SW5kZXhdIDogdHJ1ZSk7XG4gICAgfVxuICAgIEVsZW1lbnRzQXJlU3RyaWN0RXF1YWwob3JpZ2luYWxJbmRleCwgbmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKCF0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxJbmRleCwgbmV3SW5kZXgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFbGVtZW50ID0gTGNzRGlmZi5fZ2V0U3RyaWN0RWxlbWVudCh0aGlzLl9vcmlnaW5hbFNlcXVlbmNlLCBvcmlnaW5hbEluZGV4KTtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRFbGVtZW50ID0gTGNzRGlmZi5fZ2V0U3RyaWN0RWxlbWVudCh0aGlzLl9tb2RpZmllZFNlcXVlbmNlLCBuZXdJbmRleCk7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWxFbGVtZW50ID09PSBtb2RpZmllZEVsZW1lbnQpO1xuICAgIH1cbiAgICBzdGF0aWMgX2dldFN0cmljdEVsZW1lbnQoc2VxdWVuY2UsIGluZGV4KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VxdWVuY2UuZ2V0U3RyaWN0RWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHNlcXVlbmNlLmdldFN0cmljdEVsZW1lbnQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBPcmlnaW5hbEVsZW1lbnRzQXJlRXF1YWwoaW5kZXgxLCBpbmRleDIpIHtcbiAgICAgICAgaWYgKHRoaXMuX29yaWdpbmFsRWxlbWVudHNPckhhc2hbaW5kZXgxXSAhPT0gdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaFtpbmRleDJdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh0aGlzLl9oYXNTdHJpbmdzID8gdGhpcy5fb3JpZ2luYWxTdHJpbmdFbGVtZW50c1tpbmRleDFdID09PSB0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzW2luZGV4Ml0gOiB0cnVlKTtcbiAgICB9XG4gICAgTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKGluZGV4MSwgaW5kZXgyKSB7XG4gICAgICAgIGlmICh0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoW2luZGV4MV0gIT09IHRoaXMuX21vZGlmaWVkRWxlbWVudHNPckhhc2hbaW5kZXgyXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyA/IHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbaW5kZXgxXSA9PT0gdGhpcy5fbW9kaWZpZWRTdHJpbmdFbGVtZW50c1tpbmRleDJdIDogdHJ1ZSk7XG4gICAgfVxuICAgIENvbXB1dGVEaWZmKHByZXR0eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fQ29tcHV0ZURpZmYoMCwgdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaC5sZW5ndGggLSAxLCAwLCB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoLmxlbmd0aCAtIDEsIHByZXR0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSBvcmlnaW5hbCBhbmQgbW9kaWZpZWQgaW5wdXRcbiAgICAgKiBzZXF1ZW5jZXMgb24gdGhlIGJvdW5kZWQgcmFuZ2UuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhlIHR3byBpbnB1dCBzZXF1ZW5jZXMuXG4gICAgICovXG4gICAgX0NvbXB1dGVEaWZmKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgcHJldHR5KSB7XG4gICAgICAgIGNvbnN0IHF1aXRFYXJseUFyciA9IFtmYWxzZV07XG4gICAgICAgIGxldCBjaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQsIHF1aXRFYXJseUFycik7XG4gICAgICAgIGlmIChwcmV0dHkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gY2xlYW4gdXAgdGhlIGNvbXB1dGVkIGRpZmYgdG8gYmUgbW9yZSBpbnR1aXRpdmVcbiAgICAgICAgICAgIC8vIGJ1dCBpdCB0dXJucyBvdXQgdGhpcyBjYW5ub3QgYmUgZG9uZSBjb3JyZWN0bHkgdW50aWwgdGhlIGVudGlyZSBzZXRcbiAgICAgICAgICAgIC8vIG9mIGRpZmZzIGhhdmUgYmVlbiBjb21wdXRlZFxuICAgICAgICAgICAgY2hhbmdlcyA9IHRoaXMuUHJldHRpZnlDaGFuZ2VzKGNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWl0RWFybHk6IHF1aXRFYXJseUFyclswXSxcbiAgICAgICAgICAgIGNoYW5nZXM6IGNoYW5nZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBoZWxwZXIgbWV0aG9kIHdoaWNoIGNvbXB1dGVzIHRoZSBkaWZmZXJlbmNlcyBvbiB0aGUgYm91bmRlZCByYW5nZVxuICAgICAqIHJlY3Vyc2l2ZWx5LlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gaW5wdXQgc2VxdWVuY2VzLlxuICAgICAqL1xuICAgIENvbXB1dGVEaWZmUmVjdXJzaXZlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgcXVpdEVhcmx5QXJyKSB7XG4gICAgICAgIHF1aXRFYXJseUFyclswXSA9IGZhbHNlO1xuICAgICAgICAvLyBGaW5kIHRoZSBzdGFydCBvZiB0aGUgZGlmZmVyZW5jZXNcbiAgICAgICAgd2hpbGUgKG9yaWdpbmFsU3RhcnQgPD0gb3JpZ2luYWxFbmQgJiYgbW9kaWZpZWRTdGFydCA8PSBtb2RpZmllZEVuZCAmJiB0aGlzLkVsZW1lbnRzQXJlRXF1YWwob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydCkpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsU3RhcnQrKztcbiAgICAgICAgICAgIG1vZGlmaWVkU3RhcnQrKztcbiAgICAgICAgfVxuICAgICAgICAvLyBGaW5kIHRoZSBlbmQgb2YgdGhlIGRpZmZlcmVuY2VzXG4gICAgICAgIHdoaWxlIChvcmlnaW5hbEVuZCA+PSBvcmlnaW5hbFN0YXJ0ICYmIG1vZGlmaWVkRW5kID49IG1vZGlmaWVkU3RhcnQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsRW5kLCBtb2RpZmllZEVuZCkpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kLS07XG4gICAgICAgICAgICBtb2RpZmllZEVuZC0tO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluIHRoZSBzcGVjaWFsIGNhc2Ugd2hlcmUgd2UgZWl0aGVyIGhhdmUgYWxsIGluc2VydGlvbnMgb3IgYWxsIGRlbGV0aW9ucyBvciB0aGUgc2VxdWVuY2VzIGFyZSBpZGVudGljYWxcbiAgICAgICAgaWYgKG9yaWdpbmFsU3RhcnQgPiBvcmlnaW5hbEVuZCB8fCBtb2RpZmllZFN0YXJ0ID4gbW9kaWZpZWRFbmQpIHtcbiAgICAgICAgICAgIGxldCBjaGFuZ2VzO1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVkU3RhcnQgPD0gbW9kaWZpZWRFbmQpIHtcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQob3JpZ2luYWxTdGFydCA9PT0gb3JpZ2luYWxFbmQgKyAxLCAnb3JpZ2luYWxTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG9yaWdpbmFsRW5kJyk7XG4gICAgICAgICAgICAgICAgLy8gQWxsIGluc2VydGlvbnNcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCAwLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQgKyAxKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcmlnaW5hbFN0YXJ0IDw9IG9yaWdpbmFsRW5kKSB7XG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG1vZGlmaWVkU3RhcnQgPT09IG1vZGlmaWVkRW5kICsgMSwgJ21vZGlmaWVkU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBtb2RpZmllZEVuZCcpO1xuICAgICAgICAgICAgICAgIC8vIEFsbCBkZWxldGlvbnNcbiAgICAgICAgICAgICAgICBjaGFuZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbEVuZCAtIG9yaWdpbmFsU3RhcnQgKyAxLCBtb2RpZmllZFN0YXJ0LCAwKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBEZWJ1Zy5Bc3NlcnQob3JpZ2luYWxTdGFydCA9PT0gb3JpZ2luYWxFbmQgKyAxLCAnb3JpZ2luYWxTdGFydCBzaG91bGQgb25seSBiZSBvbmUgbW9yZSB0aGFuIG9yaWdpbmFsRW5kJyk7XG4gICAgICAgICAgICAgICAgRGVidWcuQXNzZXJ0KG1vZGlmaWVkU3RhcnQgPT09IG1vZGlmaWVkRW5kICsgMSwgJ21vZGlmaWVkU3RhcnQgc2hvdWxkIG9ubHkgYmUgb25lIG1vcmUgdGhhbiBtb2RpZmllZEVuZCcpO1xuICAgICAgICAgICAgICAgIC8vIElkZW50aWNhbCBzZXF1ZW5jZXMgLSBObyBkaWZmZXJlbmNlc1xuICAgICAgICAgICAgICAgIGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjaGFuZ2VzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgcHJvYmxlbSBjYW4gYmUgc29sdmVkIHVzaW5nIHRoZSBEaXZpZGUtQW5kLUNvbnF1ZXIgdGVjaG5pcXVlLlxuICAgICAgICBjb25zdCBtaWRPcmlnaW5hbEFyciA9IFswXTtcbiAgICAgICAgY29uc3QgbWlkTW9kaWZpZWRBcnIgPSBbMF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuQ29tcHV0ZVJlY3Vyc2lvblBvaW50KG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1pZE1vZGlmaWVkQXJyLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICBjb25zdCBtaWRPcmlnaW5hbCA9IG1pZE9yaWdpbmFsQXJyWzBdO1xuICAgICAgICBjb25zdCBtaWRNb2RpZmllZCA9IG1pZE1vZGlmaWVkQXJyWzBdO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBSZXN1bHQgaXMgbm90LW51bGwgd2hlbiB0aGVyZSB3YXMgZW5vdWdoIG1lbW9yeSB0byBjb21wdXRlIHRoZSBjaGFuZ2VzIHdoaWxlXG4gICAgICAgICAgICAvLyBzZWFyY2hpbmcgZm9yIHRoZSByZWN1cnNpb24gcG9pbnRcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXF1aXRFYXJseUFyclswXSkge1xuICAgICAgICAgICAgLy8gV2UgY2FuIGJyZWFrIHRoZSBwcm9ibGVtIGRvd24gcmVjdXJzaXZlbHkgYnkgZmluZGluZyB0aGUgY2hhbmdlcyBpbiB0aGVcbiAgICAgICAgICAgIC8vIEZpcnN0IEhhbGY6ICAgKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpIHRvIChtaWRPcmlnaW5hbCwgbWlkTW9kaWZpZWQpXG4gICAgICAgICAgICAvLyBTZWNvbmQgSGFsZjogIChtaWRPcmlnaW5hbCArIDEsIG1pbk1vZGlmaWVkICsgMSkgdG8gKG9yaWdpbmFsRW5kLCBtb2RpZmllZEVuZClcbiAgICAgICAgICAgIC8vIE5PVEU6IENvbXB1dGVEaWZmKCkgaXMgaW5jbHVzaXZlLCB0aGVyZWZvcmUgdGhlIHNlY29uZCByYW5nZSBzdGFydHMgb24gdGhlIG5leHQgcG9pbnRcbiAgICAgICAgICAgIGNvbnN0IGxlZnRDaGFuZ2VzID0gdGhpcy5Db21wdXRlRGlmZlJlY3Vyc2l2ZShvcmlnaW5hbFN0YXJ0LCBtaWRPcmlnaW5hbCwgbW9kaWZpZWRTdGFydCwgbWlkTW9kaWZpZWQsIHF1aXRFYXJseUFycik7XG4gICAgICAgICAgICBsZXQgcmlnaHRDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBpZiAoIXF1aXRFYXJseUFyclswXSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0Q2hhbmdlcyA9IHRoaXMuQ29tcHV0ZURpZmZSZWN1cnNpdmUobWlkT3JpZ2luYWwgKyAxLCBvcmlnaW5hbEVuZCwgbWlkTW9kaWZpZWQgKyAxLCBtb2RpZmllZEVuZCwgcXVpdEVhcmx5QXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRpZG4ndCBoYXZlIHRpbWUgdG8gZmluaXNoIHRoZSBmaXJzdCBoYWxmLCBzbyB3ZSBkb24ndCBoYXZlIHRpbWUgdG8gY29tcHV0ZSB0aGlzIGhhbGYuXG4gICAgICAgICAgICAgICAgLy8gQ29uc2lkZXIgdGhlIGVudGlyZSByZXN0IG9mIHRoZSBzZXF1ZW5jZSBkaWZmZXJlbnQuXG4gICAgICAgICAgICAgICAgcmlnaHRDaGFuZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShtaWRPcmlnaW5hbCArIDEsIG9yaWdpbmFsRW5kIC0gKG1pZE9yaWdpbmFsICsgMSkgKyAxLCBtaWRNb2RpZmllZCArIDEsIG1vZGlmaWVkRW5kIC0gKG1pZE1vZGlmaWVkICsgMSkgKyAxKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5Db25jYXRlbmF0ZUNoYW5nZXMobGVmdENoYW5nZXMsIHJpZ2h0Q2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgaGl0IGhlcmUsIHdlIHF1aXQgZWFybHksIGFuZCBzbyBjYW4ndCByZXR1cm4gYW55dGhpbmcgbWVhbmluZ2Z1bFxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxFbmQgLSBvcmlnaW5hbFN0YXJ0ICsgMSwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0ICsgMSlcbiAgICAgICAgXTtcbiAgICB9XG4gICAgV0FMS1RSQUNFKGRpYWdvbmFsRm9yd2FyZEJhc2UsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCBkaWFnb25hbEZvcndhcmRFbmQsIGRpYWdvbmFsRm9yd2FyZE9mZnNldCwgZGlhZ29uYWxSZXZlcnNlQmFzZSwgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIGRpYWdvbmFsUmV2ZXJzZUVuZCwgZGlhZ29uYWxSZXZlcnNlT2Zmc2V0LCBmb3J3YXJkUG9pbnRzLCByZXZlcnNlUG9pbnRzLCBvcmlnaW5hbEluZGV4LCBvcmlnaW5hbEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1vZGlmaWVkSW5kZXgsIG1vZGlmaWVkRW5kLCBtaWRNb2RpZmllZEFyciwgZGVsdGFJc0V2ZW4sIHF1aXRFYXJseUFycikge1xuICAgICAgICBsZXQgZm9yd2FyZENoYW5nZXMgPSBudWxsO1xuICAgICAgICBsZXQgcmV2ZXJzZUNoYW5nZXMgPSBudWxsO1xuICAgICAgICAvLyBGaXJzdCwgd2FsayBiYWNrd2FyZCB0aHJvdWdoIHRoZSBmb3J3YXJkIGRpYWdvbmFscyBoaXN0b3J5XG4gICAgICAgIGxldCBjaGFuZ2VIZWxwZXIgPSBuZXcgRGlmZkNoYW5nZUhlbHBlcigpO1xuICAgICAgICBsZXQgZGlhZ29uYWxNaW4gPSBkaWFnb25hbEZvcndhcmRTdGFydDtcbiAgICAgICAgbGV0IGRpYWdvbmFsTWF4ID0gZGlhZ29uYWxGb3J3YXJkRW5kO1xuICAgICAgICBsZXQgZGlhZ29uYWxSZWxhdGl2ZSA9IChtaWRPcmlnaW5hbEFyclswXSAtIG1pZE1vZGlmaWVkQXJyWzBdKSAtIGRpYWdvbmFsRm9yd2FyZE9mZnNldDtcbiAgICAgICAgbGV0IGxhc3RPcmlnaW5hbEluZGV4ID0gLTEwNzM3NDE4MjQgLyogQ29uc3RhbnRzLk1JTl9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XG4gICAgICAgIGxldCBoaXN0b3J5SW5kZXggPSB0aGlzLm1fZm9yd2FyZEhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBkaWFnb25hbCBpbmRleCBmcm9tIHRoZSByZWxhdGl2ZSBkaWFnb25hbCBudW1iZXJcbiAgICAgICAgICAgIGNvbnN0IGRpYWdvbmFsID0gZGlhZ29uYWxSZWxhdGl2ZSArIGRpYWdvbmFsRm9yd2FyZEJhc2U7XG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IHdoZXJlIHdlIGNhbWUgZnJvbVxuICAgICAgICAgICAgaWYgKGRpYWdvbmFsID09PSBkaWFnb25hbE1pbiB8fCAoZGlhZ29uYWwgPCBkaWFnb25hbE1heCAmJiBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gPCBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgLy8gVmVydGljYWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYW4gaW5zZXJ0KVxuICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV07XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSBkaWFnb25hbFJlbGF0aXZlIC0gZGlhZ29uYWxGb3J3YXJkT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4IDwgbGFzdE9yaWdpbmFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkTW9kaWZpZWRFbGVtZW50KG9yaWdpbmFsSW5kZXggKyAxLCBtb2RpZmllZEluZGV4KTtcbiAgICAgICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gKGRpYWdvbmFsICsgMSkgLSBkaWFnb25hbEZvcndhcmRCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYSBkZWxldGlvbilcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gZm9yd2FyZFBvaW50c1tkaWFnb25hbCAtIDFdICsgMTtcbiAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIGRpYWdvbmFsUmVsYXRpdmUgLSBkaWFnb25hbEZvcndhcmRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPCBsYXN0T3JpZ2luYWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuTWFya05leHRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkT3JpZ2luYWxFbGVtZW50KG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBkaWFnb25hbFJlbGF0aXZlID0gKGRpYWdvbmFsIC0gMSkgLSBkaWFnb25hbEZvcndhcmRCYXNlOyAvL1NldHVwIGZvciB0aGUgbmV4dCBpdGVyYXRpb25cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaXN0b3J5SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIGZvcndhcmRQb2ludHMgPSB0aGlzLm1fZm9yd2FyZEhpc3RvcnlbaGlzdG9yeUluZGV4XTtcbiAgICAgICAgICAgICAgICBkaWFnb25hbEZvcndhcmRCYXNlID0gZm9yd2FyZFBvaW50c1swXTsgLy9XZSBzdG9yZWQgdGhpcyBpbiB0aGUgZmlyc3Qgc3BvdFxuICAgICAgICAgICAgICAgIGRpYWdvbmFsTWluID0gMTtcbiAgICAgICAgICAgICAgICBkaWFnb25hbE1heCA9IGZvcndhcmRQb2ludHMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAoLS1oaXN0b3J5SW5kZXggPj0gLTEpO1xuICAgICAgICAvLyBJcm9uaWNhbGx5LCB3ZSBnZXQgdGhlIGZvcndhcmQgY2hhbmdlcyBhcyB0aGUgcmV2ZXJzZSBvZiB0aGVcbiAgICAgICAgLy8gb3JkZXIgd2UgYWRkZWQgdGhlbSBzaW5jZSB3ZSB0ZWNobmljYWxseSBhZGRlZCB0aGVtIGJhY2t3YXJkc1xuICAgICAgICBmb3J3YXJkQ2hhbmdlcyA9IGNoYW5nZUhlbHBlci5nZXRSZXZlcnNlQ2hhbmdlcygpO1xuICAgICAgICBpZiAocXVpdEVhcmx5QXJyWzBdKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBDYWxjdWxhdGUgYSBwYXJ0aWFsIGZyb20gdGhlIHJldmVyc2UgZGlhZ29uYWxzLlxuICAgICAgICAgICAgLy8gICAgICAgRm9yIG5vdywganVzdCBhc3N1bWUgZXZlcnl0aGluZyBhZnRlciB0aGUgbWlkT3JpZ2luYWwvbWlkTW9kaWZpZWQgcG9pbnQgaXMgYSBkaWZmXG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxTdGFydFBvaW50ID0gbWlkT3JpZ2luYWxBcnJbMF0gKyAxO1xuICAgICAgICAgICAgbGV0IG1vZGlmaWVkU3RhcnRQb2ludCA9IG1pZE1vZGlmaWVkQXJyWzBdICsgMTtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkQ2hhbmdlcyAhPT0gbnVsbCAmJiBmb3J3YXJkQ2hhbmdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEZvcndhcmRDaGFuZ2UgPSBmb3J3YXJkQ2hhbmdlc1tmb3J3YXJkQ2hhbmdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0UG9pbnQgPSBNYXRoLm1heChvcmlnaW5hbFN0YXJ0UG9pbnQsIGxhc3RGb3J3YXJkQ2hhbmdlLmdldE9yaWdpbmFsRW5kKCkpO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRQb2ludCA9IE1hdGgubWF4KG1vZGlmaWVkU3RhcnRQb2ludCwgbGFzdEZvcndhcmRDaGFuZ2UuZ2V0TW9kaWZpZWRFbmQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXZlcnNlQ2hhbmdlcyA9IFtcbiAgICAgICAgICAgICAgICBuZXcgRGlmZkNoYW5nZShvcmlnaW5hbFN0YXJ0UG9pbnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydFBvaW50ICsgMSwgbW9kaWZpZWRTdGFydFBvaW50LCBtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnRQb2ludCArIDEpXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTm93IHdhbGsgYmFja3dhcmQgdGhyb3VnaCB0aGUgcmV2ZXJzZSBkaWFnb25hbHMgaGlzdG9yeVxuICAgICAgICAgICAgY2hhbmdlSGVscGVyID0gbmV3IERpZmZDaGFuZ2VIZWxwZXIoKTtcbiAgICAgICAgICAgIGRpYWdvbmFsTWluID0gZGlhZ29uYWxSZXZlcnNlU3RhcnQ7XG4gICAgICAgICAgICBkaWFnb25hbE1heCA9IGRpYWdvbmFsUmV2ZXJzZUVuZDtcbiAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAobWlkT3JpZ2luYWxBcnJbMF0gLSBtaWRNb2RpZmllZEFyclswXSkgLSBkaWFnb25hbFJldmVyc2VPZmZzZXQ7XG4gICAgICAgICAgICBsYXN0T3JpZ2luYWxJbmRleCA9IDEwNzM3NDE4MjQgLyogQ29uc3RhbnRzLk1BWF9TQUZFX1NNQUxMX0lOVEVHRVIgKi87XG4gICAgICAgICAgICBoaXN0b3J5SW5kZXggPSAoZGVsdGFJc0V2ZW4pID8gdGhpcy5tX3JldmVyc2VIaXN0b3J5Lmxlbmd0aCAtIDEgOiB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkubGVuZ3RoIC0gMjtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGRpYWdvbmFsIGluZGV4IGZyb20gdGhlIHJlbGF0aXZlIGRpYWdvbmFsIG51bWJlclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpYWdvbmFsID0gZGlhZ29uYWxSZWxhdGl2ZSArIGRpYWdvbmFsUmV2ZXJzZUJhc2U7XG4gICAgICAgICAgICAgICAgLy8gRmlndXJlIG91dCB3aGVyZSB3ZSBjYW1lIGZyb21cbiAgICAgICAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsTWluIHx8IChkaWFnb25hbCA8IGRpYWdvbmFsTWF4ICYmIHJldmVyc2VQb2ludHNbZGlhZ29uYWwgLSAxXSA+PSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZSAodGhlIGVsZW1lbnQgaXMgYSBkZWxldGlvbikpXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsICsgMV0gLSAxO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4ID0gb3JpZ2luYWxJbmRleCAtIGRpYWdvbmFsUmVsYXRpdmUgLSBkaWFnb25hbFJldmVyc2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ID4gbGFzdE9yaWdpbmFsSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5NYXJrTmV4dENoYW5nZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUhlbHBlci5BZGRPcmlnaW5hbEVsZW1lbnQob3JpZ2luYWxJbmRleCArIDEsIG1vZGlmaWVkSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgZGlhZ29uYWxSZWxhdGl2ZSA9IChkaWFnb25hbCArIDEpIC0gZGlhZ29uYWxSZXZlcnNlQmFzZTsgLy9TZXR1cCBmb3IgdGhlIG5leHQgaXRlcmF0aW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBsaW5lICh0aGUgZWxlbWVudCBpcyBhbiBpbnNlcnRpb24pXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkSW5kZXggPSBvcmlnaW5hbEluZGV4IC0gZGlhZ29uYWxSZWxhdGl2ZSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsSW5kZXggPiBsYXN0T3JpZ2luYWxJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGVscGVyLk1hcmtOZXh0Q2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VIZWxwZXIuQWRkTW9kaWZpZWRFbGVtZW50KG9yaWdpbmFsSW5kZXggKyAxLCBtb2RpZmllZEluZGV4ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsUmVsYXRpdmUgPSAoZGlhZ29uYWwgLSAxKSAtIGRpYWdvbmFsUmV2ZXJzZUJhc2U7IC8vU2V0dXAgZm9yIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGlzdG9yeUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZVBvaW50cyA9IHRoaXMubV9yZXZlcnNlSGlzdG9yeVtoaXN0b3J5SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBkaWFnb25hbFJldmVyc2VCYXNlID0gcmV2ZXJzZVBvaW50c1swXTsgLy9XZSBzdG9yZWQgdGhpcyBpbiB0aGUgZmlyc3Qgc3BvdFxuICAgICAgICAgICAgICAgICAgICBkaWFnb25hbE1pbiA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGRpYWdvbmFsTWF4ID0gcmV2ZXJzZVBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKC0taGlzdG9yeUluZGV4ID49IC0xKTtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBjYXNlcyB3aGVyZSB0aGUgcmV2ZXJzZSBoaXN0b3J5IHdpbGwgZmluZCBkaWZmcyB0aGF0XG4gICAgICAgICAgICAvLyBhcmUgY29ycmVjdCwgYnV0IG5vdCBpbnR1aXRpdmUsIHNvIHdlIG5lZWQgc2hpZnQgdGhlbS5cbiAgICAgICAgICAgIHJldmVyc2VDaGFuZ2VzID0gY2hhbmdlSGVscGVyLmdldENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5Db25jYXRlbmF0ZUNoYW5nZXMoZm9yd2FyZENoYW5nZXMsIHJldmVyc2VDaGFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIHJhbmdlIHRvIGNvbXB1dGUgdGhlIGRpZmYgb24sIHRoaXMgbWV0aG9kIGZpbmRzIHRoZSBwb2ludDpcbiAgICAgKiAobWlkT3JpZ2luYWwsIG1pZE1vZGlmaWVkKVxuICAgICAqIHRoYXQgZXhpc3RzIGluIHRoZSBtaWRkbGUgb2YgdGhlIExDUyBvZiB0aGUgdHdvIHNlcXVlbmNlcyBhbmRcbiAgICAgKiBpcyB0aGUgcG9pbnQgYXQgd2hpY2ggdGhlIExDUyBwcm9ibGVtIG1heSBiZSBicm9rZW4gZG93biByZWN1cnNpdmVseS5cbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHRyeSB0byBrZWVwIHRoZSBMQ1MgdHJhY2UgaW4gbWVtb3J5LiBJZiB0aGUgTENTIHJlY3Vyc2lvblxuICAgICAqIHBvaW50IGlzIGNhbGN1bGF0ZWQgYW5kIHRoZSBmdWxsIHRyYWNlIGlzIGF2YWlsYWJsZSBpbiBtZW1vcnksIHRoZW4gdGhpcyBtZXRob2RcbiAgICAgKiB3aWxsIHJldHVybiB0aGUgY2hhbmdlIGxpc3QuXG4gICAgICogQHBhcmFtIG9yaWdpbmFsU3RhcnQgVGhlIHN0YXJ0IGJvdW5kIG9mIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSByYW5nZVxuICAgICAqIEBwYXJhbSBvcmlnaW5hbEVuZCBUaGUgZW5kIGJvdW5kIG9mIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZSByYW5nZVxuICAgICAqIEBwYXJhbSBtb2RpZmllZFN0YXJ0IFRoZSBzdGFydCBib3VuZCBvZiB0aGUgbW9kaWZpZWQgc2VxdWVuY2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0gbW9kaWZpZWRFbmQgVGhlIGVuZCBib3VuZCBvZiB0aGUgbW9kaWZpZWQgc2VxdWVuY2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0gbWlkT3JpZ2luYWwgVGhlIG1pZGRsZSBwb2ludCBvZiB0aGUgb3JpZ2luYWwgc2VxdWVuY2UgcmFuZ2VcbiAgICAgKiBAcGFyYW0gbWlkTW9kaWZpZWQgVGhlIG1pZGRsZSBwb2ludCBvZiB0aGUgbW9kaWZpZWQgc2VxdWVuY2UgcmFuZ2VcbiAgICAgKiBAcmV0dXJucyBUaGUgZGlmZiBjaGFuZ2VzLCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBudWxsXG4gICAgICovXG4gICAgQ29tcHV0ZVJlY3Vyc2lvblBvaW50KG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kLCBtb2RpZmllZFN0YXJ0LCBtb2RpZmllZEVuZCwgbWlkT3JpZ2luYWxBcnIsIG1pZE1vZGlmaWVkQXJyLCBxdWl0RWFybHlBcnIpIHtcbiAgICAgICAgbGV0IG9yaWdpbmFsSW5kZXggPSAwLCBtb2RpZmllZEluZGV4ID0gMDtcbiAgICAgICAgbGV0IGRpYWdvbmFsRm9yd2FyZFN0YXJ0ID0gMCwgZGlhZ29uYWxGb3J3YXJkRW5kID0gMDtcbiAgICAgICAgbGV0IGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ID0gMCwgZGlhZ29uYWxSZXZlcnNlRW5kID0gMDtcbiAgICAgICAgLy8gVG8gdHJhdmVyc2UgdGhlIGVkaXQgZ3JhcGggYW5kIHByb2R1Y2UgdGhlIHByb3BlciBMQ1MsIG91ciBhY3R1YWxcbiAgICAgICAgLy8gc3RhcnQgcG9zaXRpb24gaXMganVzdCBvdXRzaWRlIHRoZSBnaXZlbiBib3VuZGFyeVxuICAgICAgICBvcmlnaW5hbFN0YXJ0LS07XG4gICAgICAgIG1vZGlmaWVkU3RhcnQtLTtcbiAgICAgICAgLy8gV2Ugc2V0IHRoZXNlIHVwIHRvIG1ha2UgdGhlIGNvbXBpbGVyIGhhcHB5LCBidXQgdGhleSB3aWxsXG4gICAgICAgIC8vIGJlIHJlcGxhY2VkIGJlZm9yZSB3ZSByZXR1cm4gd2l0aCB0aGUgYWN0dWFsIHJlY3Vyc2lvbiBwb2ludFxuICAgICAgICBtaWRPcmlnaW5hbEFyclswXSA9IDA7XG4gICAgICAgIG1pZE1vZGlmaWVkQXJyWzBdID0gMDtcbiAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBoaXN0b3J5XG4gICAgICAgIHRoaXMubV9mb3J3YXJkSGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLm1fcmV2ZXJzZUhpc3RvcnkgPSBbXTtcbiAgICAgICAgLy8gRWFjaCBjZWxsIGluIHRoZSB0d28gYXJyYXlzIGNvcnJlc3BvbmRzIHRvIGEgZGlhZ29uYWwgaW4gdGhlIGVkaXQgZ3JhcGguXG4gICAgICAgIC8vIFRoZSBpbnRlZ2VyIHZhbHVlIGluIHRoZSBjZWxsIHJlcHJlc2VudHMgdGhlIG9yaWdpbmFsSW5kZXggb2YgdGhlIGZ1cnRoZXN0XG4gICAgICAgIC8vIHJlYWNoaW5nIHBvaW50IGZvdW5kIHNvIGZhciB0aGF0IGVuZHMgaW4gdGhhdCBkaWFnb25hbC5cbiAgICAgICAgLy8gVGhlIG1vZGlmaWVkSW5kZXggY2FuIGJlIGNvbXB1dGVkIG1hdGhlbWF0aWNhbGx5IGZyb20gdGhlIG9yaWdpbmFsSW5kZXggYW5kIHRoZSBkaWFnb25hbCBudW1iZXIuXG4gICAgICAgIGNvbnN0IG1heERpZmZlcmVuY2VzID0gKG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCkgKyAobW9kaWZpZWRFbmQgLSBtb2RpZmllZFN0YXJ0KTtcbiAgICAgICAgY29uc3QgbnVtRGlhZ29uYWxzID0gbWF4RGlmZmVyZW5jZXMgKyAxO1xuICAgICAgICBjb25zdCBmb3J3YXJkUG9pbnRzID0gbmV3IEludDMyQXJyYXkobnVtRGlhZ29uYWxzKTtcbiAgICAgICAgY29uc3QgcmV2ZXJzZVBvaW50cyA9IG5ldyBJbnQzMkFycmF5KG51bURpYWdvbmFscyk7XG4gICAgICAgIC8vIGRpYWdvbmFsRm9yd2FyZEJhc2U6IEluZGV4IGludG8gZm9yd2FyZFBvaW50cyBvZiB0aGUgZGlhZ29uYWwgd2hpY2ggcGFzc2VzIHRocm91Z2ggKG9yaWdpbmFsU3RhcnQsIG1vZGlmaWVkU3RhcnQpXG4gICAgICAgIC8vIGRpYWdvbmFsUmV2ZXJzZUJhc2U6IEluZGV4IGludG8gcmV2ZXJzZVBvaW50cyBvZiB0aGUgZGlhZ29uYWwgd2hpY2ggcGFzc2VzIHRocm91Z2ggKG9yaWdpbmFsRW5kLCBtb2RpZmllZEVuZClcbiAgICAgICAgY29uc3QgZGlhZ29uYWxGb3J3YXJkQmFzZSA9IChtb2RpZmllZEVuZCAtIG1vZGlmaWVkU3RhcnQpO1xuICAgICAgICBjb25zdCBkaWFnb25hbFJldmVyc2VCYXNlID0gKG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCk7XG4gICAgICAgIC8vIGRpYWdvbmFsRm9yd2FyZE9mZnNldDogR2VvbWV0cmljIG9mZnNldCB3aGljaCBhbGxvd3MgbW9kaWZpZWRJbmRleCB0byBiZSBjb21wdXRlZCBmcm9tIG9yaWdpbmFsSW5kZXggYW5kIHRoZVxuICAgICAgICAvLyAgICBkaWFnb25hbCBudW1iZXIgKHJlbGF0aXZlIHRvIGRpYWdvbmFsRm9yd2FyZEJhc2UpXG4gICAgICAgIC8vIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDogR2VvbWV0cmljIG9mZnNldCB3aGljaCBhbGxvd3MgbW9kaWZpZWRJbmRleCB0byBiZSBjb21wdXRlZCBmcm9tIG9yaWdpbmFsSW5kZXggYW5kIHRoZVxuICAgICAgICAvLyAgICBkaWFnb25hbCBudW1iZXIgKHJlbGF0aXZlIHRvIGRpYWdvbmFsUmV2ZXJzZUJhc2UpXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsRm9yd2FyZE9mZnNldCA9IChvcmlnaW5hbFN0YXJ0IC0gbW9kaWZpZWRTdGFydCk7XG4gICAgICAgIGNvbnN0IGRpYWdvbmFsUmV2ZXJzZU9mZnNldCA9IChvcmlnaW5hbEVuZCAtIG1vZGlmaWVkRW5kKTtcbiAgICAgICAgLy8gZGVsdGE6IFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGVuZCBkaWFnb25hbCBhbmQgdGhlIHN0YXJ0IGRpYWdvbmFsLiBUaGlzIGlzIHVzZWQgdG8gcmVsYXRlIGRpYWdvbmFsIG51bWJlcnNcbiAgICAgICAgLy8gICByZWxhdGl2ZSB0byB0aGUgc3RhcnQgZGlhZ29uYWwgd2l0aCBkaWFnb25hbCBudW1iZXJzIHJlbGF0aXZlIHRvIHRoZSBlbmQgZGlhZ29uYWwuXG4gICAgICAgIC8vIFRoZSBFdmVuL09kZG4tbmVzcyBvZiB0aGlzIGRlbHRhIGlzIGltcG9ydGFudCBmb3IgZGV0ZXJtaW5pbmcgd2hlbiB3ZSBzaG91bGQgY2hlY2sgZm9yIG92ZXJsYXBcbiAgICAgICAgY29uc3QgZGVsdGEgPSBkaWFnb25hbFJldmVyc2VCYXNlIC0gZGlhZ29uYWxGb3J3YXJkQmFzZTtcbiAgICAgICAgY29uc3QgZGVsdGFJc0V2ZW4gPSAoZGVsdGEgJSAyID09PSAwKTtcbiAgICAgICAgLy8gSGVyZSB3ZSBzZXQgdXAgdGhlIHN0YXJ0IGFuZCBlbmQgcG9pbnRzIGFzIHRoZSBmdXJ0aGVzdCBwb2ludHMgZm91bmQgc28gZmFyXG4gICAgICAgIC8vIGluIGJvdGggdGhlIGZvcndhcmQgYW5kIHJldmVyc2UgZGlyZWN0aW9ucywgcmVzcGVjdGl2ZWx5XG4gICAgICAgIGZvcndhcmRQb2ludHNbZGlhZ29uYWxGb3J3YXJkQmFzZV0gPSBvcmlnaW5hbFN0YXJ0O1xuICAgICAgICByZXZlcnNlUG9pbnRzW2RpYWdvbmFsUmV2ZXJzZUJhc2VdID0gb3JpZ2luYWxFbmQ7XG4gICAgICAgIC8vIFJlbWVtYmVyIGlmIHdlIHF1aXQgZWFybHksIGFuZCB0aHVzIG5lZWQgdG8gZG8gYSBiZXN0LWVmZm9ydCByZXN1bHQgaW5zdGVhZCBvZiBhIHJlYWwgcmVzdWx0LlxuICAgICAgICBxdWl0RWFybHlBcnJbMF0gPSBmYWxzZTtcbiAgICAgICAgLy8gQSBjb3VwbGUgb2YgcG9pbnRzOlxuICAgICAgICAvLyAtLVdpdGggdGhpcyBtZXRob2QsIHdlIGl0ZXJhdGUgb24gdGhlIG51bWJlciBvZiBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoZSB0d28gc2VxdWVuY2VzLlxuICAgICAgICAvLyAgIFRoZSBtb3JlIGRpZmZlcmVuY2VzIHRoZXJlIGFjdHVhbGx5IGFyZSwgdGhlIGxvbmdlciB0aGlzIHdpbGwgdGFrZS5cbiAgICAgICAgLy8gLS1BbHNvLCBhcyB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzIGluY3JlYXNlcywgd2UgaGF2ZSB0byBzZWFyY2ggb24gZGlhZ29uYWxzIGZ1cnRoZXJcbiAgICAgICAgLy8gICBhd2F5IGZyb20gdGhlIHJlZmVyZW5jZSBkaWFnb25hbCAod2hpY2ggaXMgZGlhZ29uYWxGb3J3YXJkQmFzZSBmb3IgZm9yd2FyZCwgZGlhZ29uYWxSZXZlcnNlQmFzZSBmb3IgcmV2ZXJzZSkuXG4gICAgICAgIC8vIC0tV2UgZXh0ZW5kIG9uIGV2ZW4gZGlhZ29uYWxzIChyZWxhdGl2ZSB0byB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsKSBvbmx5IHdoZW4gbnVtRGlmZmVyZW5jZXNcbiAgICAgICAgLy8gICBpcyBldmVuIGFuZCBvZGQgZGlhZ29uYWxzIG9ubHkgd2hlbiBudW1EaWZmZXJlbmNlcyBpcyBvZGQuXG4gICAgICAgIGZvciAobGV0IG51bURpZmZlcmVuY2VzID0gMTsgbnVtRGlmZmVyZW5jZXMgPD0gKG1heERpZmZlcmVuY2VzIC8gMikgKyAxOyBudW1EaWZmZXJlbmNlcysrKSB7XG4gICAgICAgICAgICBsZXQgZnVydGhlc3RPcmlnaW5hbEluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBmdXJ0aGVzdE1vZGlmaWVkSW5kZXggPSAwO1xuICAgICAgICAgICAgLy8gUnVuIHRoZSBhbGdvcml0aG0gaW4gdGhlIGZvcndhcmQgZGlyZWN0aW9uXG4gICAgICAgICAgICBkaWFnb25hbEZvcndhcmRTdGFydCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxGb3J3YXJkQmFzZSAtIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxGb3J3YXJkQmFzZSwgbnVtRGlhZ29uYWxzKTtcbiAgICAgICAgICAgIGRpYWdvbmFsRm9yd2FyZEVuZCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxGb3J3YXJkQmFzZSArIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxGb3J3YXJkQmFzZSwgbnVtRGlhZ29uYWxzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRpYWdvbmFsID0gZGlhZ29uYWxGb3J3YXJkU3RhcnQ7IGRpYWdvbmFsIDw9IGRpYWdvbmFsRm9yd2FyZEVuZDsgZGlhZ29uYWwgKz0gMikge1xuICAgICAgICAgICAgICAgIC8vIFNURVAgMTogV2UgZXh0ZW5kIHRoZSBmdXJ0aGVzdCByZWFjaGluZyBwb2ludCBpbiB0aGUgcHJlc2VudCBkaWFnb25hbFxuICAgICAgICAgICAgICAgIC8vIGJ5IGxvb2tpbmcgYXQgdGhlIGRpYWdvbmFscyBhYm92ZSBhbmQgYmVsb3cgYW5kIHBpY2tpbmcgdGhlIG9uZSB3aG9zZSBwb2ludFxuICAgICAgICAgICAgICAgIC8vIGlzIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBzdGFydCBwb2ludCAob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydClcbiAgICAgICAgICAgICAgICBpZiAoZGlhZ29uYWwgPT09IGRpYWdvbmFsRm9yd2FyZFN0YXJ0IHx8IChkaWFnb25hbCA8IGRpYWdvbmFsRm9yd2FyZEVuZCAmJiBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsIC0gMV0gPCBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSBmb3J3YXJkUG9pbnRzW2RpYWdvbmFsICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEluZGV4ID0gZm9yd2FyZFBvaW50c1tkaWFnb25hbCAtIDFdICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSAoZGlhZ29uYWwgLSBkaWFnb25hbEZvcndhcmRCYXNlKSAtIGRpYWdvbmFsRm9yd2FyZE9mZnNldDtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IG9yaWdpbmFsSW5kZXggc28gd2UgY2FuIHRlc3QgZm9yIGZhbHNlIG92ZXJsYXAgaW4gc3RlcCAzXG4gICAgICAgICAgICAgICAgY29uc3QgdGVtcE9yaWdpbmFsSW5kZXggPSBvcmlnaW5hbEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIFNURVAgMjogV2UgY2FuIGNvbnRpbnVlIHRvIGV4dGVuZCB0aGUgZnVydGhlc3QgcmVhY2hpbmcgcG9pbnQgaW4gdGhlIHByZXNlbnQgZGlhZ29uYWxcbiAgICAgICAgICAgICAgICAvLyBzbyBsb25nIGFzIHRoZSBlbGVtZW50cyBhcmUgZXF1YWwuXG4gICAgICAgICAgICAgICAgd2hpbGUgKG9yaWdpbmFsSW5kZXggPCBvcmlnaW5hbEVuZCAmJiBtb2RpZmllZEluZGV4IDwgbW9kaWZpZWRFbmQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsSW5kZXggKyAxLCBtb2RpZmllZEluZGV4ICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcndhcmRQb2ludHNbZGlhZ29uYWxdID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxJbmRleCArIG1vZGlmaWVkSW5kZXggPiBmdXJ0aGVzdE9yaWdpbmFsSW5kZXggKyBmdXJ0aGVzdE1vZGlmaWVkSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVydGhlc3RPcmlnaW5hbEluZGV4ID0gb3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgZnVydGhlc3RNb2RpZmllZEluZGV4ID0gbW9kaWZpZWRJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAzOiBJZiBkZWx0YSBpcyBvZGQgKG92ZXJsYXAgZmlyc3QgaGFwcGVucyBvbiBmb3J3YXJkIHdoZW4gZGVsdGEgaXMgb2RkKVxuICAgICAgICAgICAgICAgIC8vIGFuZCBkaWFnb25hbCBpcyBpbiB0aGUgcmFuZ2Ugb2YgcmV2ZXJzZSBkaWFnb25hbHMgY29tcHV0ZWQgZm9yIG51bURpZmZlcmVuY2VzLTFcbiAgICAgICAgICAgICAgICAvLyAodGhlIHByZXZpb3VzIGl0ZXJhdGlvbjsgd2UgaGF2ZW4ndCBjb21wdXRlZCByZXZlcnNlIGRpYWdvbmFscyBmb3IgbnVtRGlmZmVyZW5jZXMgeWV0KVxuICAgICAgICAgICAgICAgIC8vIHRoZW4gY2hlY2sgZm9yIG92ZXJsYXAuXG4gICAgICAgICAgICAgICAgaWYgKCFkZWx0YUlzRXZlbiAmJiBNYXRoLmFicyhkaWFnb25hbCAtIGRpYWdvbmFsUmV2ZXJzZUJhc2UpIDw9IChudW1EaWZmZXJlbmNlcyAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4ID49IHJldmVyc2VQb2ludHNbZGlhZ29uYWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRPcmlnaW5hbEFyclswXSA9IG9yaWdpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRNb2RpZmllZEFyclswXSA9IG1vZGlmaWVkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcE9yaWdpbmFsSW5kZXggPD0gcmV2ZXJzZVBvaW50c1tkaWFnb25hbF0gJiYgMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gPiAwICYmIG51bURpZmZlcmVuY2VzIDw9ICgxNDQ3IC8qIExvY2FsQ29uc3RhbnRzLk1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQklOR08hIFdlIG92ZXJsYXBwZWQsIGFuZCB3ZSBoYXZlIHRoZSBmdWxsIHRyYWNlIGluIG1lbW9yeSFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5XQUxLVFJBQ0UoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciBmYWxzZSBvdmVybGFwLCBvciB3ZSBkaWRuJ3QgaGF2ZSBlbm91Z2ggbWVtb3J5IGZvciB0aGUgZnVsbCB0cmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSByZWN1cnNpb24gcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBzaG91bGQgYmUgcXVpdHRpbmcgZWFybHksIGJlZm9yZSBtb3Zpbmcgb24gdG8gdGhlIG5leHQgaXRlcmF0aW9uLlxuICAgICAgICAgICAgY29uc3QgbWF0Y2hMZW5ndGhPZkxvbmdlc3QgPSAoKGZ1cnRoZXN0T3JpZ2luYWxJbmRleCAtIG9yaWdpbmFsU3RhcnQpICsgKGZ1cnRoZXN0TW9kaWZpZWRJbmRleCAtIG1vZGlmaWVkU3RhcnQpIC0gbnVtRGlmZmVyZW5jZXMpIC8gMjtcbiAgICAgICAgICAgIGlmICh0aGlzLkNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSAhPT0gbnVsbCAmJiAhdGhpcy5Db250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUoZnVydGhlc3RPcmlnaW5hbEluZGV4LCBtYXRjaExlbmd0aE9mTG9uZ2VzdCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCBmaW5pc2gsIHNvIHNraXAgYWhlYWQgdG8gZ2VuZXJhdGluZyBhIHJlc3VsdCBmcm9tIHdoYXQgd2UgaGF2ZS5cbiAgICAgICAgICAgICAgICBxdWl0RWFybHlBcnJbMF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZnVydGhlc3QgZGlzdGFuY2Ugd2UgZ290IGluIHRoZSBmb3J3YXJkIGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAgICBtaWRPcmlnaW5hbEFyclswXSA9IGZ1cnRoZXN0T3JpZ2luYWxJbmRleDtcbiAgICAgICAgICAgICAgICBtaWRNb2RpZmllZEFyclswXSA9IGZ1cnRoZXN0TW9kaWZpZWRJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hMZW5ndGhPZkxvbmdlc3QgPiAwICYmIDE0NDcgLyogTG9jYWxDb25zdGFudHMuTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovID4gMCAmJiBudW1EaWZmZXJlbmNlcyA8PSAoMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbm91Z2ggb2YgdGhlIGhpc3RvcnkgaXMgaW4gbWVtb3J5IHRvIHdhbGsgaXQgYmFja3dhcmRzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLldBTEtUUkFDRShkaWFnb25hbEZvcndhcmRCYXNlLCBkaWFnb25hbEZvcndhcmRTdGFydCwgZGlhZ29uYWxGb3J3YXJkRW5kLCBkaWFnb25hbEZvcndhcmRPZmZzZXQsIGRpYWdvbmFsUmV2ZXJzZUJhc2UsIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0LCBkaWFnb25hbFJldmVyc2VFbmQsIGRpYWdvbmFsUmV2ZXJzZU9mZnNldCwgZm9yd2FyZFBvaW50cywgcmV2ZXJzZVBvaW50cywgb3JpZ2luYWxJbmRleCwgb3JpZ2luYWxFbmQsIG1pZE9yaWdpbmFsQXJyLCBtb2RpZmllZEluZGV4LCBtb2RpZmllZEVuZCwgbWlkTW9kaWZpZWRBcnIsIGRlbHRhSXNFdmVuLCBxdWl0RWFybHlBcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZGlkbid0IGFjdHVhbGx5IHJlbWVtYmVyIGVub3VnaCBvZiB0aGUgaGlzdG9yeS5cbiAgICAgICAgICAgICAgICAgICAgLy9TaW5jZSB3ZSBhcmUgcXVpdHRpbmcgdGhlIGRpZmYgZWFybHksIHdlIG5lZWQgdG8gc2hpZnQgYmFjayB0aGUgb3JpZ2luYWxTdGFydCBhbmQgbW9kaWZpZWQgc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgLy9iYWNrIGludG8gdGhlIGJvdW5kYXJ5IGxpbWl0cyBzaW5jZSB3ZSBkZWNyZW1lbnRlZCB0aGVpciB2YWx1ZSBhYm92ZSBiZXlvbmQgdGhlIGJvdW5kYXJ5IGxpbWl0LlxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Kys7XG4gICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBEaWZmQ2hhbmdlKG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsRW5kIC0gb3JpZ2luYWxTdGFydCArIDEsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkRW5kIC0gbW9kaWZpZWRTdGFydCArIDEpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUnVuIHRoZSBhbGdvcml0aG0gaW4gdGhlIHJldmVyc2UgZGlyZWN0aW9uXG4gICAgICAgICAgICBkaWFnb25hbFJldmVyc2VTdGFydCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxSZXZlcnNlQmFzZSAtIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxSZXZlcnNlQmFzZSwgbnVtRGlhZ29uYWxzKTtcbiAgICAgICAgICAgIGRpYWdvbmFsUmV2ZXJzZUVuZCA9IHRoaXMuQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWxSZXZlcnNlQmFzZSArIG51bURpZmZlcmVuY2VzLCBudW1EaWZmZXJlbmNlcywgZGlhZ29uYWxSZXZlcnNlQmFzZSwgbnVtRGlhZ29uYWxzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGRpYWdvbmFsID0gZGlhZ29uYWxSZXZlcnNlU3RhcnQ7IGRpYWdvbmFsIDw9IGRpYWdvbmFsUmV2ZXJzZUVuZDsgZGlhZ29uYWwgKz0gMikge1xuICAgICAgICAgICAgICAgIC8vIFNURVAgMTogV2UgZXh0ZW5kIHRoZSBmdXJ0aGVzdCByZWFjaGluZyBwb2ludCBpbiB0aGUgcHJlc2VudCBkaWFnb25hbFxuICAgICAgICAgICAgICAgIC8vIGJ5IGxvb2tpbmcgYXQgdGhlIGRpYWdvbmFscyBhYm92ZSBhbmQgYmVsb3cgYW5kIHBpY2tpbmcgdGhlIG9uZSB3aG9zZSBwb2ludFxuICAgICAgICAgICAgICAgIC8vIGlzIGZ1cnRoZXIgYXdheSBmcm9tIHRoZSBzdGFydCBwb2ludCAob3JpZ2luYWxFbmQsIG1vZGlmaWVkRW5kKVxuICAgICAgICAgICAgICAgIGlmIChkaWFnb25hbCA9PT0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgfHwgKGRpYWdvbmFsIDwgZGlhZ29uYWxSZXZlcnNlRW5kICYmIHJldmVyc2VQb2ludHNbZGlhZ29uYWwgLSAxXSA+PSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsICsgMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXggPSByZXZlcnNlUG9pbnRzW2RpYWdvbmFsICsgMV0gLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxJbmRleCA9IHJldmVyc2VQb2ludHNbZGlhZ29uYWwgLSAxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleCA9IG9yaWdpbmFsSW5kZXggLSAoZGlhZ29uYWwgLSBkaWFnb25hbFJldmVyc2VCYXNlKSAtIGRpYWdvbmFsUmV2ZXJzZU9mZnNldDtcbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IG9yaWdpbmFsSW5kZXggc28gd2UgY2FuIHRlc3QgZm9yIGZhbHNlIG92ZXJsYXBcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wT3JpZ2luYWxJbmRleCA9IG9yaWdpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCAyOiBXZSBjYW4gY29udGludWUgdG8gZXh0ZW5kIHRoZSBmdXJ0aGVzdCByZWFjaGluZyBwb2ludCBpbiB0aGUgcHJlc2VudCBkaWFnb25hbFxuICAgICAgICAgICAgICAgIC8vIGFzIGxvbmcgYXMgdGhlIGVsZW1lbnRzIGFyZSBlcXVhbC5cbiAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxJbmRleCA+IG9yaWdpbmFsU3RhcnQgJiYgbW9kaWZpZWRJbmRleCA+IG1vZGlmaWVkU3RhcnQgJiYgdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsSW5kZXgsIG1vZGlmaWVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsSW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRJbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXZlcnNlUG9pbnRzW2RpYWdvbmFsXSA9IG9yaWdpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgLy8gU1RFUCA0OiBJZiBkZWx0YSBpcyBldmVuIChvdmVybGFwIGZpcnN0IGhhcHBlbnMgb24gcmV2ZXJzZSB3aGVuIGRlbHRhIGlzIGV2ZW4pXG4gICAgICAgICAgICAgICAgLy8gYW5kIGRpYWdvbmFsIGlzIGluIHRoZSByYW5nZSBvZiBmb3J3YXJkIGRpYWdvbmFscyBjb21wdXRlZCBmb3IgbnVtRGlmZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAvLyB0aGVuIGNoZWNrIGZvciBvdmVybGFwLlxuICAgICAgICAgICAgICAgIGlmIChkZWx0YUlzRXZlbiAmJiBNYXRoLmFicyhkaWFnb25hbCAtIGRpYWdvbmFsRm9yd2FyZEJhc2UpIDw9IG51bURpZmZlcmVuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbEluZGV4IDw9IGZvcndhcmRQb2ludHNbZGlhZ29uYWxdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRPcmlnaW5hbEFyclswXSA9IG9yaWdpbmFsSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaWRNb2RpZmllZEFyclswXSA9IG1vZGlmaWVkSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcE9yaWdpbmFsSW5kZXggPj0gZm9yd2FyZFBvaW50c1tkaWFnb25hbF0gJiYgMTQ0NyAvKiBMb2NhbENvbnN0YW50cy5NYXhEaWZmZXJlbmNlc0hpc3RvcnkgKi8gPiAwICYmIG51bURpZmZlcmVuY2VzIDw9ICgxNDQ3IC8qIExvY2FsQ29uc3RhbnRzLk1heERpZmZlcmVuY2VzSGlzdG9yeSAqLyArIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQklOR08hIFdlIG92ZXJsYXBwZWQsIGFuZCB3ZSBoYXZlIHRoZSBmdWxsIHRyYWNlIGluIG1lbW9yeSFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5XQUxLVFJBQ0UoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVpdGhlciBmYWxzZSBvdmVybGFwLCBvciB3ZSBkaWRuJ3QgaGF2ZSBlbm91Z2ggbWVtb3J5IGZvciB0aGUgZnVsbCB0cmFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSByZWN1cnNpb24gcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNhdmUgY3VycmVudCB2ZWN0b3JzIHRvIGhpc3RvcnkgYmVmb3JlIHRoZSBuZXh0IGl0ZXJhdGlvblxuICAgICAgICAgICAgaWYgKG51bURpZmZlcmVuY2VzIDw9IDE0NDcgLyogTG9jYWxDb25zdGFudHMuTWF4RGlmZmVyZW5jZXNIaXN0b3J5ICovKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGFsbG9jYXRpbmcgc3BhY2UgZm9yIG9uZSBleHRyYSBpbnQsIHdoaWNoIHdlIGZpbGwgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHRoZSBpbmRleCBvZiB0aGUgZGlhZ29uYWwgYmFzZSBpbmRleFxuICAgICAgICAgICAgICAgIGxldCB0ZW1wID0gbmV3IEludDMyQXJyYXkoZGlhZ29uYWxGb3J3YXJkRW5kIC0gZGlhZ29uYWxGb3J3YXJkU3RhcnQgKyAyKTtcbiAgICAgICAgICAgICAgICB0ZW1wWzBdID0gZGlhZ29uYWxGb3J3YXJkQmFzZSAtIGRpYWdvbmFsRm9yd2FyZFN0YXJ0ICsgMTtcbiAgICAgICAgICAgICAgICBNeUFycmF5LkNvcHkyKGZvcndhcmRQb2ludHMsIGRpYWdvbmFsRm9yd2FyZFN0YXJ0LCB0ZW1wLCAxLCBkaWFnb25hbEZvcndhcmRFbmQgLSBkaWFnb25hbEZvcndhcmRTdGFydCArIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMubV9mb3J3YXJkSGlzdG9yeS5wdXNoKHRlbXApO1xuICAgICAgICAgICAgICAgIHRlbXAgPSBuZXcgSW50MzJBcnJheShkaWFnb25hbFJldmVyc2VFbmQgLSBkaWFnb25hbFJldmVyc2VTdGFydCArIDIpO1xuICAgICAgICAgICAgICAgIHRlbXBbMF0gPSBkaWFnb25hbFJldmVyc2VCYXNlIC0gZGlhZ29uYWxSZXZlcnNlU3RhcnQgKyAxO1xuICAgICAgICAgICAgICAgIE15QXJyYXkuQ29weTIocmV2ZXJzZVBvaW50cywgZGlhZ29uYWxSZXZlcnNlU3RhcnQsIHRlbXAsIDEsIGRpYWdvbmFsUmV2ZXJzZUVuZCAtIGRpYWdvbmFsUmV2ZXJzZVN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5tX3JldmVyc2VIaXN0b3J5LnB1c2godGVtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZ290IGhlcmUsIHRoZW4gd2UgaGF2ZSB0aGUgZnVsbCB0cmFjZSBpbiBoaXN0b3J5LiBXZSBqdXN0IGhhdmUgdG8gY29udmVydCBpdCB0byBhIGNoYW5nZSBsaXN0XG4gICAgICAgIC8vIE5PVEU6IFRoaXMgcGFydCBpcyBhIGJpdCBtZXNzeVxuICAgICAgICByZXR1cm4gdGhpcy5XQUxLVFJBQ0UoZGlhZ29uYWxGb3J3YXJkQmFzZSwgZGlhZ29uYWxGb3J3YXJkU3RhcnQsIGRpYWdvbmFsRm9yd2FyZEVuZCwgZGlhZ29uYWxGb3J3YXJkT2Zmc2V0LCBkaWFnb25hbFJldmVyc2VCYXNlLCBkaWFnb25hbFJldmVyc2VTdGFydCwgZGlhZ29uYWxSZXZlcnNlRW5kLCBkaWFnb25hbFJldmVyc2VPZmZzZXQsIGZvcndhcmRQb2ludHMsIHJldmVyc2VQb2ludHMsIG9yaWdpbmFsSW5kZXgsIG9yaWdpbmFsRW5kLCBtaWRPcmlnaW5hbEFyciwgbW9kaWZpZWRJbmRleCwgbW9kaWZpZWRFbmQsIG1pZE1vZGlmaWVkQXJyLCBkZWx0YUlzRXZlbiwgcXVpdEVhcmx5QXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hpZnRzIHRoZSBnaXZlbiBjaGFuZ2VzIHRvIHByb3ZpZGUgYSBtb3JlIGludHVpdGl2ZSBkaWZmLlxuICAgICAqIFdoaWxlIHRoZSBmaXJzdCBlbGVtZW50IGluIGEgZGlmZiBtYXRjaGVzIHRoZSBmaXJzdCBlbGVtZW50IGFmdGVyIHRoZSBkaWZmLFxuICAgICAqIHdlIHNoaWZ0IHRoZSBkaWZmIGRvd24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyBUaGUgbGlzdCBvZiBjaGFuZ2VzIHRvIHNoaWZ0XG4gICAgICogQHJldHVybnMgVGhlIHNoaWZ0ZWQgY2hhbmdlc1xuICAgICAqL1xuICAgIFByZXR0aWZ5Q2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIC8vIFNoaWZ0IGFsbCB0aGUgY2hhbmdlcyBkb3duIGZpcnN0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RvcCA9IChpIDwgY2hhbmdlcy5sZW5ndGggLSAxKSA/IGNoYW5nZXNbaSArIDFdLm9yaWdpbmFsU3RhcnQgOiB0aGlzLl9vcmlnaW5hbEVsZW1lbnRzT3JIYXNoLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkU3RvcCA9IChpIDwgY2hhbmdlcy5sZW5ndGggLSAxKSA/IGNoYW5nZXNbaSArIDFdLm1vZGlmaWVkU3RhcnQgOiB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrT3JpZ2luYWwgPSBjaGFuZ2Uub3JpZ2luYWxMZW5ndGggPiAwO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tNb2RpZmllZCA9IGNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDA7XG4gICAgICAgICAgICB3aGlsZSAoY2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjaGFuZ2Uub3JpZ2luYWxMZW5ndGggPCBvcmlnaW5hbFN0b3BcbiAgICAgICAgICAgICAgICAmJiBjaGFuZ2UubW9kaWZpZWRTdGFydCArIGNoYW5nZS5tb2RpZmllZExlbmd0aCA8IG1vZGlmaWVkU3RvcFxuICAgICAgICAgICAgICAgICYmICghY2hlY2tPcmlnaW5hbCB8fCB0aGlzLk9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChjaGFuZ2Uub3JpZ2luYWxTdGFydCwgY2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgpKVxuICAgICAgICAgICAgICAgICYmICghY2hlY2tNb2RpZmllZCB8fCB0aGlzLk1vZGlmaWVkRWxlbWVudHNBcmVFcXVhbChjaGFuZ2UubW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3RyaWN0RXF1YWwgPSB0aGlzLkVsZW1lbnRzQXJlU3RyaWN0RXF1YWwoY2hhbmdlLm9yaWdpbmFsU3RhcnQsIGNoYW5nZS5tb2RpZmllZFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRTdHJpY3RFcXVhbCA9IHRoaXMuRWxlbWVudHNBcmVTdHJpY3RFcXVhbChjaGFuZ2Uub3JpZ2luYWxTdGFydCArIGNoYW5nZS5vcmlnaW5hbExlbmd0aCwgY2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChlbmRTdHJpY3RFcXVhbCAmJiAhc3RhcnRTdHJpY3RFcXVhbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtb3ZpbmcgdGhlIGNoYW5nZSBkb3duIHdvdWxkIGNyZWF0ZSBhbiBlcXVhbCBjaGFuZ2UsIGJ1dCB0aGUgZWxlbWVudHMgYXJlIG5vdCBzdHJpY3QgZXF1YWxcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5nZS5vcmlnaW5hbFN0YXJ0Kys7XG4gICAgICAgICAgICAgICAgY2hhbmdlLm1vZGlmaWVkU3RhcnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZENoYW5nZUFyciA9IFtudWxsXTtcbiAgICAgICAgICAgIGlmIChpIDwgY2hhbmdlcy5sZW5ndGggLSAxICYmIHRoaXMuQ2hhbmdlc092ZXJsYXAoY2hhbmdlc1tpXSwgY2hhbmdlc1tpICsgMV0sIG1lcmdlZENoYW5nZUFycikpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzW2ldID0gbWVyZ2VkQ2hhbmdlQXJyWzBdO1xuICAgICAgICAgICAgICAgIGNoYW5nZXMuc3BsaWNlKGkgKyAxLCAxKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hpZnQgY2hhbmdlcyBiYWNrIHVwIHVudGlsIHdlIGhpdCBlbXB0eSBvciB3aGl0ZXNwYWNlLW9ubHkgbGluZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IGNoYW5nZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IGNoYW5nZXNbaV07XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxTdG9wID0gMDtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZFN0b3AgPSAwO1xuICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoYW5nZSA9IGNoYW5nZXNbaSAtIDFdO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RvcCA9IHByZXZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIHByZXZDaGFuZ2Uub3JpZ2luYWxMZW5ndGg7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRTdG9wID0gcHJldkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoZWNrT3JpZ2luYWwgPSBjaGFuZ2Uub3JpZ2luYWxMZW5ndGggPiAwO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tNb2RpZmllZCA9IGNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDA7XG4gICAgICAgICAgICBsZXQgYmVzdERlbHRhID0gMDtcbiAgICAgICAgICAgIGxldCBiZXN0U2NvcmUgPSB0aGlzLl9ib3VuZGFyeVNjb3JlKGNoYW5nZS5vcmlnaW5hbFN0YXJ0LCBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgsIGNoYW5nZS5tb2RpZmllZFN0YXJ0LCBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgZGVsdGEgPSAxOzsgZGVsdGErKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhcnQgPSBjaGFuZ2Uub3JpZ2luYWxTdGFydCAtIGRlbHRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkU3RhcnQgPSBjaGFuZ2UubW9kaWZpZWRTdGFydCAtIGRlbHRhO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbFN0YXJ0IDwgb3JpZ2luYWxTdG9wIHx8IG1vZGlmaWVkU3RhcnQgPCBtb2RpZmllZFN0b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja09yaWdpbmFsICYmICF0aGlzLk9yaWdpbmFsRWxlbWVudHNBcmVFcXVhbChvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZWQgJiYgIXRoaXMuTW9kaWZpZWRFbGVtZW50c0FyZUVxdWFsKG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkU3RhcnQgKyBjaGFuZ2UubW9kaWZpZWRMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaGluZ1ByZXZpb3VzQ2hhbmdlID0gKG9yaWdpbmFsU3RhcnQgPT09IG9yaWdpbmFsU3RvcCAmJiBtb2RpZmllZFN0YXJ0ID09PSBtb2RpZmllZFN0b3ApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjb3JlID0gKCh0b3VjaGluZ1ByZXZpb3VzQ2hhbmdlID8gNSA6IDApXG4gICAgICAgICAgICAgICAgICAgICsgdGhpcy5fYm91bmRhcnlTY29yZShvcmlnaW5hbFN0YXJ0LCBjaGFuZ2Uub3JpZ2luYWxMZW5ndGgsIG1vZGlmaWVkU3RhcnQsIGNoYW5nZS5tb2RpZmllZExlbmd0aCkpO1xuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IGJlc3RTY29yZSkge1xuICAgICAgICAgICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdERlbHRhID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbmdlLm9yaWdpbmFsU3RhcnQgLT0gYmVzdERlbHRhO1xuICAgICAgICAgICAgY2hhbmdlLm1vZGlmaWVkU3RhcnQgLT0gYmVzdERlbHRhO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkQ2hhbmdlQXJyID0gW251bGxdO1xuICAgICAgICAgICAgaWYgKGkgPiAwICYmIHRoaXMuQ2hhbmdlc092ZXJsYXAoY2hhbmdlc1tpIC0gMV0sIGNoYW5nZXNbaV0sIG1lcmdlZENoYW5nZUFycikpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzW2kgLSAxXSA9IG1lcmdlZENoYW5nZUFyclswXTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlcmUgY291bGQgYmUgbXVsdGlwbGUgbG9uZ2VzdCBjb21tb24gc3Vic3RyaW5ncy5cbiAgICAgICAgLy8gR2l2ZSBwcmVmZXJlbmNlIHRvIHRoZSBvbmVzIGNvbnRhaW5pbmcgbG9uZ2VyIGxpbmVzXG4gICAgICAgIGlmICh0aGlzLl9oYXNTdHJpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMSwgbGVuID0gY2hhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFDaGFuZ2UgPSBjaGFuZ2VzW2kgLSAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBiQ2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVkTGVuZ3RoID0gYkNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbExlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBhT3JpZ2luYWxTdGFydCA9IGFDaGFuZ2Uub3JpZ2luYWxTdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBiT3JpZ2luYWxFbmQgPSBiQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBiQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFiT3JpZ2luYWxMZW5ndGggPSBiT3JpZ2luYWxFbmQgLSBhT3JpZ2luYWxTdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBhTW9kaWZpZWRTdGFydCA9IGFDaGFuZ2UubW9kaWZpZWRTdGFydDtcbiAgICAgICAgICAgICAgICBjb25zdCBiTW9kaWZpZWRFbmQgPSBiQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBiQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFiTW9kaWZpZWRMZW5ndGggPSBiTW9kaWZpZWRFbmQgLSBhTW9kaWZpZWRTdGFydDtcbiAgICAgICAgICAgICAgICAvLyBBdm9pZCB3YXN0aW5nIGEgbG90IG9mIHRpbWUgd2l0aCB0aGVzZSBzZWFyY2hlc1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkTGVuZ3RoIDwgNSAmJiBhYk9yaWdpbmFsTGVuZ3RoIDwgMjAgJiYgYWJNb2RpZmllZExlbmd0aCA8IDIwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSB0aGlzLl9maW5kQmV0dGVyQ29udGlndW91c1NlcXVlbmNlKGFPcmlnaW5hbFN0YXJ0LCBhYk9yaWdpbmFsTGVuZ3RoLCBhTW9kaWZpZWRTdGFydCwgYWJNb2RpZmllZExlbmd0aCwgbWF0Y2hlZExlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbb3JpZ2luYWxNYXRjaFN0YXJ0LCBtb2RpZmllZE1hdGNoU3RhcnRdID0gdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbE1hdGNoU3RhcnQgIT09IGFDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGFDaGFuZ2Uub3JpZ2luYWxMZW5ndGggfHwgbW9kaWZpZWRNYXRjaFN0YXJ0ICE9PSBhQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBhQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3dpdGNoIHRvIGFub3RoZXIgc2VxdWVuY2UgdGhhdCBoYXMgYSBiZXR0ZXIgc2NvcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoID0gb3JpZ2luYWxNYXRjaFN0YXJ0IC0gYUNoYW5nZS5vcmlnaW5hbFN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDaGFuZ2UubW9kaWZpZWRMZW5ndGggPSBtb2RpZmllZE1hdGNoU3RhcnQgLSBhQ2hhbmdlLm1vZGlmaWVkU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZS5vcmlnaW5hbFN0YXJ0ID0gb3JpZ2luYWxNYXRjaFN0YXJ0ICsgbWF0Y2hlZExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiQ2hhbmdlLm1vZGlmaWVkU3RhcnQgPSBtb2RpZmllZE1hdGNoU3RhcnQgKyBtYXRjaGVkTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJDaGFuZ2Uub3JpZ2luYWxMZW5ndGggPSBiT3JpZ2luYWxFbmQgLSBiQ2hhbmdlLm9yaWdpbmFsU3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNoYW5nZS5tb2RpZmllZExlbmd0aCA9IGJNb2RpZmllZEVuZCAtIGJDaGFuZ2UubW9kaWZpZWRTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbmdlcztcbiAgICB9XG4gICAgX2ZpbmRCZXR0ZXJDb250aWd1b3VzU2VxdWVuY2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkTGVuZ3RoLCBkZXNpcmVkTGVuZ3RoKSB7XG4gICAgICAgIGlmIChvcmlnaW5hbExlbmd0aCA8IGRlc2lyZWRMZW5ndGggfHwgbW9kaWZpZWRMZW5ndGggPCBkZXNpcmVkTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbE1heCA9IG9yaWdpbmFsU3RhcnQgKyBvcmlnaW5hbExlbmd0aCAtIGRlc2lyZWRMZW5ndGggKyAxO1xuICAgICAgICBjb25zdCBtb2RpZmllZE1heCA9IG1vZGlmaWVkU3RhcnQgKyBtb2RpZmllZExlbmd0aCAtIGRlc2lyZWRMZW5ndGggKyAxO1xuICAgICAgICBsZXQgYmVzdFNjb3JlID0gMDtcbiAgICAgICAgbGV0IGJlc3RPcmlnaW5hbFN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGJlc3RNb2RpZmllZFN0YXJ0ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IG9yaWdpbmFsU3RhcnQ7IGkgPCBvcmlnaW5hbE1heDsgaSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gbW9kaWZpZWRTdGFydDsgaiA8IG1vZGlmaWVkTWF4OyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY29yZSA9IHRoaXMuX2NvbnRpZ3VvdXNTZXF1ZW5jZVNjb3JlKGksIGosIGRlc2lyZWRMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmIChzY29yZSA+IDAgJiYgc2NvcmUgPiBiZXN0U2NvcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7XG4gICAgICAgICAgICAgICAgICAgIGJlc3RPcmlnaW5hbFN0YXJ0ID0gaTtcbiAgICAgICAgICAgICAgICAgICAgYmVzdE1vZGlmaWVkU3RhcnQgPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVzdFNjb3JlID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtiZXN0T3JpZ2luYWxTdGFydCwgYmVzdE1vZGlmaWVkU3RhcnRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfY29udGlndW91c1NlcXVlbmNlU2NvcmUob3JpZ2luYWxTdGFydCwgbW9kaWZpZWRTdGFydCwgbGVuZ3RoKSB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgbGVuZ3RoOyBsKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5FbGVtZW50c0FyZUVxdWFsKG9yaWdpbmFsU3RhcnQgKyBsLCBtb2RpZmllZFN0YXJ0ICsgbCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNjb3JlICs9IHRoaXMuX29yaWdpbmFsU3RyaW5nRWxlbWVudHNbb3JpZ2luYWxTdGFydCArIGxdLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcmU7XG4gICAgfVxuICAgIF9PcmlnaW5hbElzQm91bmRhcnkoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDw9IDAgfHwgaW5kZXggPj0gdGhpcy5fb3JpZ2luYWxFbGVtZW50c09ySGFzaC5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHRoaXMuX2hhc1N0cmluZ3MgJiYgL15cXHMqJC8udGVzdCh0aGlzLl9vcmlnaW5hbFN0cmluZ0VsZW1lbnRzW2luZGV4XSkpO1xuICAgIH1cbiAgICBfT3JpZ2luYWxSZWdpb25Jc0JvdW5kYXJ5KG9yaWdpbmFsU3RhcnQsIG9yaWdpbmFsTGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLl9PcmlnaW5hbElzQm91bmRhcnkob3JpZ2luYWxTdGFydCkgfHwgdGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsU3RhcnQgLSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbmFsTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxFbmQgPSBvcmlnaW5hbFN0YXJ0ICsgb3JpZ2luYWxMZW5ndGg7XG4gICAgICAgICAgICBpZiAodGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsRW5kIC0gMSkgfHwgdGhpcy5fT3JpZ2luYWxJc0JvdW5kYXJ5KG9yaWdpbmFsRW5kKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgX01vZGlmaWVkSXNCb3VuZGFyeShpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPD0gMCB8fCBpbmRleCA+PSB0aGlzLl9tb2RpZmllZEVsZW1lbnRzT3JIYXNoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodGhpcy5faGFzU3RyaW5ncyAmJiAvXlxccyokLy50ZXN0KHRoaXMuX21vZGlmaWVkU3RyaW5nRWxlbWVudHNbaW5kZXhdKSk7XG4gICAgfVxuICAgIF9Nb2RpZmllZFJlZ2lvbklzQm91bmRhcnkobW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX01vZGlmaWVkSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0KSB8fCB0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRTdGFydCAtIDEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9kaWZpZWRMZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZEVuZCA9IG1vZGlmaWVkU3RhcnQgKyBtb2RpZmllZExlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRFbmQgLSAxKSB8fCB0aGlzLl9Nb2RpZmllZElzQm91bmRhcnkobW9kaWZpZWRFbmQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBfYm91bmRhcnlTY29yZShvcmlnaW5hbFN0YXJ0LCBvcmlnaW5hbExlbmd0aCwgbW9kaWZpZWRTdGFydCwgbW9kaWZpZWRMZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTY29yZSA9ICh0aGlzLl9PcmlnaW5hbFJlZ2lvbklzQm91bmRhcnkob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgpID8gMSA6IDApO1xuICAgICAgICBjb25zdCBtb2RpZmllZFNjb3JlID0gKHRoaXMuX01vZGlmaWVkUmVnaW9uSXNCb3VuZGFyeShtb2RpZmllZFN0YXJ0LCBtb2RpZmllZExlbmd0aCkgPyAxIDogMCk7XG4gICAgICAgIHJldHVybiAob3JpZ2luYWxTY29yZSArIG1vZGlmaWVkU2NvcmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25jYXRlbmF0ZXMgdGhlIHR3byBpbnB1dCBEaWZmQ2hhbmdlIGxpc3RzIGFuZCByZXR1cm5zIHRoZSByZXN1bHRpbmdcbiAgICAgKiBsaXN0LlxuICAgICAqIEBwYXJhbSBUaGUgbGVmdCBjaGFuZ2VzXG4gICAgICogQHBhcmFtIFRoZSByaWdodCBjaGFuZ2VzXG4gICAgICogQHJldHVybnMgVGhlIGNvbmNhdGVuYXRlZCBsaXN0XG4gICAgICovXG4gICAgQ29uY2F0ZW5hdGVDaGFuZ2VzKGxlZnQsIHJpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZENoYW5nZUFyciA9IFtdO1xuICAgICAgICBpZiAobGVmdC5sZW5ndGggPT09IDAgfHwgcmlnaHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gKHJpZ2h0Lmxlbmd0aCA+IDApID8gcmlnaHQgOiBsZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuQ2hhbmdlc092ZXJsYXAobGVmdFtsZWZ0Lmxlbmd0aCAtIDFdLCByaWdodFswXSwgbWVyZ2VkQ2hhbmdlQXJyKSkge1xuICAgICAgICAgICAgLy8gU2luY2Ugd2UgYnJlYWsgdGhlIHByb2JsZW0gZG93biByZWN1cnNpdmVseSwgaXQgaXMgcG9zc2libGUgdGhhdCB3ZVxuICAgICAgICAgICAgLy8gbWlnaHQgcmVjdXJzZSBpbiB0aGUgbWlkZGxlIG9mIGEgY2hhbmdlIHRoZXJlYnkgc3BsaXR0aW5nIGl0IGludG9cbiAgICAgICAgICAgIC8vIHR3byBjaGFuZ2VzLiBIZXJlIGluIHRoZSBjb21iaW5pbmcgc3RhZ2UsIHdlIGRldGVjdCBhbmQgZnVzZSB0aG9zZVxuICAgICAgICAgICAgLy8gY2hhbmdlcyBiYWNrIHRvZ2V0aGVyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobGVmdC5sZW5ndGggKyByaWdodC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShsZWZ0LCAwLCByZXN1bHQsIDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICByZXN1bHRbbGVmdC5sZW5ndGggLSAxXSA9IG1lcmdlZENoYW5nZUFyclswXTtcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShyaWdodCwgMSwgcmVzdWx0LCBsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KGxlZnQubGVuZ3RoICsgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShsZWZ0LCAwLCByZXN1bHQsIDAsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgIE15QXJyYXkuQ29weShyaWdodCwgMCwgcmVzdWx0LCBsZWZ0Lmxlbmd0aCwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gY2hhbmdlcyBvdmVybGFwIGFuZCBjYW4gYmUgbWVyZ2VkIGludG8gYSBzaW5nbGVcbiAgICAgKiBjaGFuZ2VcbiAgICAgKiBAcGFyYW0gbGVmdCBUaGUgbGVmdCBjaGFuZ2VcbiAgICAgKiBAcGFyYW0gcmlnaHQgVGhlIHJpZ2h0IGNoYW5nZVxuICAgICAqIEBwYXJhbSBtZXJnZWRDaGFuZ2UgVGhlIG1lcmdlZCBjaGFuZ2UgaWYgdGhlIHR3byBvdmVybGFwLCBudWxsIG90aGVyd2lzZVxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgdGhlIHR3byBjaGFuZ2VzIG92ZXJsYXBcbiAgICAgKi9cbiAgICBDaGFuZ2VzT3ZlcmxhcChsZWZ0LCByaWdodCwgbWVyZ2VkQ2hhbmdlQXJyKSB7XG4gICAgICAgIERlYnVnLkFzc2VydChsZWZ0Lm9yaWdpbmFsU3RhcnQgPD0gcmlnaHQub3JpZ2luYWxTdGFydCwgJ0xlZnQgY2hhbmdlIGlzIG5vdCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gcmlnaHQgY2hhbmdlJyk7XG4gICAgICAgIERlYnVnLkFzc2VydChsZWZ0Lm1vZGlmaWVkU3RhcnQgPD0gcmlnaHQubW9kaWZpZWRTdGFydCwgJ0xlZnQgY2hhbmdlIGlzIG5vdCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gcmlnaHQgY2hhbmdlJyk7XG4gICAgICAgIGlmIChsZWZ0Lm9yaWdpbmFsU3RhcnQgKyBsZWZ0Lm9yaWdpbmFsTGVuZ3RoID49IHJpZ2h0Lm9yaWdpbmFsU3RhcnQgfHwgbGVmdC5tb2RpZmllZFN0YXJ0ICsgbGVmdC5tb2RpZmllZExlbmd0aCA+PSByaWdodC5tb2RpZmllZFN0YXJ0KSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0YXJ0ID0gbGVmdC5vcmlnaW5hbFN0YXJ0O1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsTGVuZ3RoID0gbGVmdC5vcmlnaW5hbExlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkU3RhcnQgPSBsZWZ0Lm1vZGlmaWVkU3RhcnQ7XG4gICAgICAgICAgICBsZXQgbW9kaWZpZWRMZW5ndGggPSBsZWZ0Lm1vZGlmaWVkTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlZnQub3JpZ2luYWxTdGFydCArIGxlZnQub3JpZ2luYWxMZW5ndGggPj0gcmlnaHQub3JpZ2luYWxTdGFydCkge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTGVuZ3RoID0gcmlnaHQub3JpZ2luYWxTdGFydCArIHJpZ2h0Lm9yaWdpbmFsTGVuZ3RoIC0gbGVmdC5vcmlnaW5hbFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZnQubW9kaWZpZWRTdGFydCArIGxlZnQubW9kaWZpZWRMZW5ndGggPj0gcmlnaHQubW9kaWZpZWRTdGFydCkge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkTGVuZ3RoID0gcmlnaHQubW9kaWZpZWRTdGFydCArIHJpZ2h0Lm1vZGlmaWVkTGVuZ3RoIC0gbGVmdC5tb2RpZmllZFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVyZ2VkQ2hhbmdlQXJyWzBdID0gbmV3IERpZmZDaGFuZ2Uob3JpZ2luYWxTdGFydCwgb3JpZ2luYWxMZW5ndGgsIG1vZGlmaWVkU3RhcnQsIG1vZGlmaWVkTGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VkQ2hhbmdlQXJyWzBdID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHVzZWQgdG8gY2xpcCBhIGRpYWdvbmFsIGluZGV4IHRvIHRoZSByYW5nZSBvZiB2YWxpZFxuICAgICAqIGRpYWdvbmFscy4gVGhpcyBhbHNvIGRlY2lkZXMgd2hldGhlciBvciBub3QgdGhlIGRpYWdvbmFsIGluZGV4LFxuICAgICAqIGlmIGl0IGV4Y2VlZHMgdGhlIGJvdW5kYXJ5LCBzaG91bGQgYmUgY2xpcHBlZCB0byB0aGUgYm91bmRhcnkgb3IgY2xpcHBlZFxuICAgICAqIG9uZSBpbnNpZGUgdGhlIGJvdW5kYXJ5IGRlcGVuZGluZyBvbiB0aGUgRXZlbi9PZGQgc3RhdHVzIG9mIHRoZSBib3VuZGFyeVxuICAgICAqIGFuZCBudW1EaWZmZXJlbmNlcy5cbiAgICAgKiBAcGFyYW0gZGlhZ29uYWwgVGhlIGluZGV4IG9mIHRoZSBkaWFnb25hbCB0byBjbGlwLlxuICAgICAqIEBwYXJhbSBudW1EaWZmZXJlbmNlcyBUaGUgY3VycmVudCBudW1iZXIgb2YgZGlmZmVyZW5jZXMgYmVpbmcgaXRlcmF0ZWQgdXBvbi5cbiAgICAgKiBAcGFyYW0gZGlhZ29uYWxCYXNlSW5kZXggVGhlIGJhc2UgcmVmZXJlbmNlIGRpYWdvbmFsLlxuICAgICAqIEBwYXJhbSBudW1EaWFnb25hbHMgVGhlIHRvdGFsIG51bWJlciBvZiBkaWFnb25hbHMuXG4gICAgICogQHJldHVybnMgVGhlIGNsaXBwZWQgZGlhZ29uYWwgaW5kZXguXG4gICAgICovXG4gICAgQ2xpcERpYWdvbmFsQm91bmQoZGlhZ29uYWwsIG51bURpZmZlcmVuY2VzLCBkaWFnb25hbEJhc2VJbmRleCwgbnVtRGlhZ29uYWxzKSB7XG4gICAgICAgIGlmIChkaWFnb25hbCA+PSAwICYmIGRpYWdvbmFsIDwgbnVtRGlhZ29uYWxzKSB7XG4gICAgICAgICAgICAvLyBOb3RoaW5nIHRvIGNsaXAsIGl0cyBpbiByYW5nZVxuICAgICAgICAgICAgcmV0dXJuIGRpYWdvbmFsO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRpYWdvbmFsc0JlbG93OiBUaGUgbnVtYmVyIG9mIGRpYWdvbmFscyBiZWxvdyB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsXG4gICAgICAgIC8vIGRpYWdvbmFsc0Fib3ZlOiBUaGUgbnVtYmVyIG9mIGRpYWdvbmFscyBhYm92ZSB0aGUgcmVmZXJlbmNlIGRpYWdvbmFsXG4gICAgICAgIGNvbnN0IGRpYWdvbmFsc0JlbG93ID0gZGlhZ29uYWxCYXNlSW5kZXg7XG4gICAgICAgIGNvbnN0IGRpYWdvbmFsc0Fib3ZlID0gbnVtRGlhZ29uYWxzIC0gZGlhZ29uYWxCYXNlSW5kZXggLSAxO1xuICAgICAgICBjb25zdCBkaWZmRXZlbiA9IChudW1EaWZmZXJlbmNlcyAlIDIgPT09IDApO1xuICAgICAgICBpZiAoZGlhZ29uYWwgPCAwKSB7XG4gICAgICAgICAgICBjb25zdCBsb3dlckJvdW5kRXZlbiA9IChkaWFnb25hbHNCZWxvdyAlIDIgPT09IDApO1xuICAgICAgICAgICAgcmV0dXJuIChkaWZmRXZlbiA9PT0gbG93ZXJCb3VuZEV2ZW4pID8gMCA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kRXZlbiA9IChkaWFnb25hbHNBYm92ZSAlIDIgPT09IDApO1xuICAgICAgICAgICAgcmV0dXJuIChkaWZmRXZlbiA9PT0gdXBwZXJCb3VuZEV2ZW4pID8gbnVtRGlhZ29uYWxzIC0gMSA6IG51bURpYWdvbmFscyAtIDI7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGlzTWFjaW50b3NoLCBpc1dpbmRvd3MgfSBmcm9tICcuL3BsYXRmb3JtLmpzJztcbmxldCBzYWZlUHJvY2Vzcztcbi8vIE5hdGl2ZSBzYW5kYm94IGVudmlyb25tZW50XG5jb25zdCB2c2NvZGVHbG9iYWwgPSBnbG9iYWxUaGlzLnZzY29kZTtcbmlmICh0eXBlb2YgdnNjb2RlR2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdnNjb2RlR2xvYmFsLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3Qgc2FuZGJveFByb2Nlc3MgPSB2c2NvZGVHbG9iYWwucHJvY2VzcztcbiAgICBzYWZlUHJvY2VzcyA9IHtcbiAgICAgICAgZ2V0IHBsYXRmb3JtKCkgeyByZXR1cm4gc2FuZGJveFByb2Nlc3MucGxhdGZvcm07IH0sXG4gICAgICAgIGdldCBhcmNoKCkgeyByZXR1cm4gc2FuZGJveFByb2Nlc3MuYXJjaDsgfSxcbiAgICAgICAgZ2V0IGVudigpIHsgcmV0dXJuIHNhbmRib3hQcm9jZXNzLmVudjsgfSxcbiAgICAgICAgY3dkKCkgeyByZXR1cm4gc2FuZGJveFByb2Nlc3MuY3dkKCk7IH1cbiAgICB9O1xufVxuLy8gTmF0aXZlIG5vZGUuanMgZW52aXJvbm1lbnRcbmVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNhZmVQcm9jZXNzID0ge1xuICAgICAgICBnZXQgcGxhdGZvcm0oKSB7IHJldHVybiBwcm9jZXNzLnBsYXRmb3JtOyB9LFxuICAgICAgICBnZXQgYXJjaCgpIHsgcmV0dXJuIHByb2Nlc3MuYXJjaDsgfSxcbiAgICAgICAgZ2V0IGVudigpIHsgcmV0dXJuIHByb2Nlc3MuZW52OyB9LFxuICAgICAgICBjd2QoKSB7IHJldHVybiBwcm9jZXNzLmVudlsnVlNDT0RFX0NXRCddIHx8IHByb2Nlc3MuY3dkKCk7IH1cbiAgICB9O1xufVxuLy8gV2ViIGVudmlyb25tZW50XG5lbHNlIHtcbiAgICBzYWZlUHJvY2VzcyA9IHtcbiAgICAgICAgLy8gU3VwcG9ydGVkXG4gICAgICAgIGdldCBwbGF0Zm9ybSgpIHsgcmV0dXJuIGlzV2luZG93cyA/ICd3aW4zMicgOiBpc01hY2ludG9zaCA/ICdkYXJ3aW4nIDogJ2xpbnV4JzsgfSxcbiAgICAgICAgZ2V0IGFyY2goKSB7IHJldHVybiB1bmRlZmluZWQ7IC8qIGFyY2ggaXMgdW5kZWZpbmVkIGluIHdlYiAqLyB9LFxuICAgICAgICAvLyBVbnN1cHBvcnRlZFxuICAgICAgICBnZXQgZW52KCkgeyByZXR1cm4ge307IH0sXG4gICAgICAgIGN3ZCgpIHsgcmV0dXJuICcvJzsgfVxuICAgIH07XG59XG4vKipcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBgY3dkYCBwcm9wZXJ0eSBpbiBub2RlLmpzLCBzYW5kYm94ZWQgb3Igd2ViXG4gKiBlbnZpcm9ubWVudHMuXG4gKlxuICogTm90ZTogaW4gd2ViLCB0aGlzIHByb3BlcnR5IGlzIGhhcmRjb2RlZCB0byBiZSBgL2AuXG4gKlxuICogQHNraXBNYW5nbGVcbiAqL1xuZXhwb3J0IGNvbnN0IGN3ZCA9IHNhZmVQcm9jZXNzLmN3ZDtcbi8qKlxuICogUHJvdmlkZXMgc2FmZSBhY2Nlc3MgdG8gdGhlIGBlbnZgIHByb3BlcnR5IGluIG5vZGUuanMsIHNhbmRib3hlZCBvciB3ZWJcbiAqIGVudmlyb25tZW50cy5cbiAqXG4gKiBOb3RlOiBpbiB3ZWIsIHRoaXMgcHJvcGVydHkgaXMgaGFyZGNvZGVkIHRvIGJlIGB7fWAuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnYgPSBzYWZlUHJvY2Vzcy5lbnY7XG4vKipcbiAqIFByb3ZpZGVzIHNhZmUgYWNjZXNzIHRvIHRoZSBgcGxhdGZvcm1gIHByb3BlcnR5IGluIG5vZGUuanMsIHNhbmRib3hlZCBvciB3ZWJcbiAqIGVudmlyb25tZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IHBsYXRmb3JtID0gc2FmZVByb2Nlc3MucGxhdGZvcm07XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIE5PVEU6IFZTQ29kZSdzIGNvcHkgb2Ygbm9kZWpzIHBhdGggbGlicmFyeSB0byBiZSB1c2FibGUgaW4gY29tbW9uIChub24tbm9kZSkgbmFtZXNwYWNlXG4vLyBDb3BpZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjE2LjE0LjIvbGliL3BhdGguanNcbi8qKlxuICogQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbiAqIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbiAqIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuICogd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuICogZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuICogcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4gKiBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuICogaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuICogT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuICogTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuICogTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4gKiBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcbiAqIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbiAqIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4gKi9cbmltcG9ydCAqIGFzIHByb2Nlc3MgZnJvbSAnLi9wcm9jZXNzLmpzJztcbmNvbnN0IENIQVJfVVBQRVJDQVNFX0EgPSA2NTsgLyogQSAqL1xuY29uc3QgQ0hBUl9MT1dFUkNBU0VfQSA9IDk3OyAvKiBhICovXG5jb25zdCBDSEFSX1VQUEVSQ0FTRV9aID0gOTA7IC8qIFogKi9cbmNvbnN0IENIQVJfTE9XRVJDQVNFX1ogPSAxMjI7IC8qIHogKi9cbmNvbnN0IENIQVJfRE9UID0gNDY7IC8qIC4gKi9cbmNvbnN0IENIQVJfRk9SV0FSRF9TTEFTSCA9IDQ3OyAvKiAvICovXG5jb25zdCBDSEFSX0JBQ0tXQVJEX1NMQVNIID0gOTI7IC8qIFxcICovXG5jb25zdCBDSEFSX0NPTE9OID0gNTg7IC8qIDogKi9cbmNvbnN0IENIQVJfUVVFU1RJT05fTUFSSyA9IDYzOyAvKiA/ICovXG5jbGFzcyBFcnJvckludmFsaWRBcmdUeXBlIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgICAgICAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgICAgICAgbGV0IGRldGVybWluZXI7XG4gICAgICAgIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIGV4cGVjdGVkLmluZGV4T2YoJ25vdCAnKSA9PT0gMCkge1xuICAgICAgICAgICAgZGV0ZXJtaW5lciA9ICdtdXN0IG5vdCBiZSc7XG4gICAgICAgICAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gbmFtZS5pbmRleE9mKCcuJykgIT09IC0xID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgICAgIGxldCBtc2cgPSBgVGhlIFwiJHtuYW1lfVwiICR7dHlwZX0gJHtkZXRlcm1pbmVyfSBvZiB0eXBlICR7ZXhwZWN0ZWR9YDtcbiAgICAgICAgbXNnICs9IGAuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWA7XG4gICAgICAgIHN1cGVyKG1zZyk7XG4gICAgICAgIHRoaXMuY29kZSA9ICdFUlJfSU5WQUxJRF9BUkdfVFlQRSc7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVPYmplY3QocGF0aE9iamVjdCwgbmFtZSkge1xuICAgIGlmIChwYXRoT2JqZWN0ID09PSBudWxsIHx8IHR5cGVvZiBwYXRoT2JqZWN0ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbnZhbGlkQXJnVHlwZShuYW1lLCAnT2JqZWN0JywgcGF0aE9iamVjdCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVTdHJpbmcodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JJbnZhbGlkQXJnVHlwZShuYW1lLCAnc3RyaW5nJywgdmFsdWUpO1xuICAgIH1cbn1cbmNvbnN0IHBsYXRmb3JtSXNXaW4zMiA9IChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKTtcbmZ1bmN0aW9uIGlzUGF0aFNlcGFyYXRvcihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPT09IENIQVJfRk9SV0FSRF9TTEFTSCB8fCBjb2RlID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIO1xufVxuZnVuY3Rpb24gaXNQb3NpeFBhdGhTZXBhcmF0b3IoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XG59XG5mdW5jdGlvbiBpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpIHtcbiAgICByZXR1cm4gKGNvZGUgPj0gQ0hBUl9VUFBFUkNBU0VfQSAmJiBjb2RlIDw9IENIQVJfVVBQRVJDQVNFX1opIHx8XG4gICAgICAgIChjb2RlID49IENIQVJfTE9XRVJDQVNFX0EgJiYgY29kZSA8PSBDSEFSX0xPV0VSQ0FTRV9aKTtcbn1cbi8vIFJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCB3aXRoIGRpcmVjdG9yeSBuYW1lc1xuZnVuY3Rpb24gbm9ybWFsaXplU3RyaW5nKHBhdGgsIGFsbG93QWJvdmVSb290LCBzZXBhcmF0b3IsIGlzUGF0aFNlcGFyYXRvcikge1xuICAgIGxldCByZXMgPSAnJztcbiAgICBsZXQgbGFzdFNlZ21lbnRMZW5ndGggPSAwO1xuICAgIGxldCBsYXN0U2xhc2ggPSAtMTtcbiAgICBsZXQgZG90cyA9IDA7XG4gICAgbGV0IGNvZGUgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IHBhdGgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGkgPCBwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZSA9IENIQVJfRk9SV0FSRF9TTEFTSDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICBpZiAobGFzdFNsYXNoID09PSBpIC0gMSB8fCBkb3RzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gTk9PUFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZG90cyA9PT0gMikge1xuICAgICAgICAgICAgICAgIGlmIChyZXMubGVuZ3RoIDwgMiB8fCBsYXN0U2VnbWVudExlbmd0aCAhPT0gMiB8fFxuICAgICAgICAgICAgICAgICAgICByZXMuY2hhckNvZGVBdChyZXMubGVuZ3RoIC0gMSkgIT09IENIQVJfRE9UIHx8XG4gICAgICAgICAgICAgICAgICAgIHJlcy5jaGFyQ29kZUF0KHJlcy5sZW5ndGggLSAyKSAhPT0gQ0hBUl9ET1QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0U2xhc2hJbmRleCA9IHJlcy5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RTbGFzaEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zbGljZSgwLCBsYXN0U2xhc2hJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNlZ21lbnRMZW5ndGggPSByZXMubGVuZ3RoIC0gMSAtIHJlcy5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFNsYXNoID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdHMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2VnbWVudExlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IHJlcy5sZW5ndGggPiAwID8gYCR7c2VwYXJhdG9yfS4uYCA6ICcuLic7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGAke3NlcGFyYXRvcn0ke3BhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSl9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHBhdGguc2xpY2UobGFzdFNsYXNoICsgMSwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RTZWdtZW50TGVuZ3RoID0gaSAtIGxhc3RTbGFzaCAtIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0U2xhc2ggPSBpO1xuICAgICAgICAgICAgZG90cyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29kZSA9PT0gQ0hBUl9ET1QgJiYgZG90cyAhPT0gLTEpIHtcbiAgICAgICAgICAgICsrZG90cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvdHMgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gX2Zvcm1hdChzZXAsIHBhdGhPYmplY3QpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChwYXRoT2JqZWN0LCAncGF0aE9iamVjdCcpO1xuICAgIGNvbnN0IGRpciA9IHBhdGhPYmplY3QuZGlyIHx8IHBhdGhPYmplY3Qucm9vdDtcbiAgICBjb25zdCBiYXNlID0gcGF0aE9iamVjdC5iYXNlIHx8XG4gICAgICAgIGAke3BhdGhPYmplY3QubmFtZSB8fCAnJ30ke3BhdGhPYmplY3QuZXh0IHx8ICcnfWA7XG4gICAgaWYgKCFkaXIpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIHJldHVybiBkaXIgPT09IHBhdGhPYmplY3Qucm9vdCA/IGAke2Rpcn0ke2Jhc2V9YCA6IGAke2Rpcn0ke3NlcH0ke2Jhc2V9YDtcbn1cbmV4cG9ydCBjb25zdCB3aW4zMiA9IHtcbiAgICAvLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4gICAgcmVzb2x2ZSguLi5wYXRoU2VnbWVudHMpIHtcbiAgICAgICAgbGV0IHJlc29sdmVkRGV2aWNlID0gJyc7XG4gICAgICAgIGxldCByZXNvbHZlZFRhaWwgPSAnJztcbiAgICAgICAgbGV0IHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGhTZWdtZW50cy5sZW5ndGggLSAxOyBpID49IC0xOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBwYXRoO1xuICAgICAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoU2VnbWVudHNbaV07XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGVtcHR5IGVudHJpZXNcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzb2x2ZWREZXZpY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHByb2Nlc3MuY3dkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXaW5kb3dzIGhhcyB0aGUgY29uY2VwdCBvZiBkcml2ZS1zcGVjaWZpYyBjdXJyZW50IHdvcmtpbmdcbiAgICAgICAgICAgICAgICAvLyBkaXJlY3Rvcmllcy4gSWYgd2UndmUgcmVzb2x2ZWQgYSBkcml2ZSBsZXR0ZXIgYnV0IG5vdCB5ZXQgYW5cbiAgICAgICAgICAgICAgICAvLyBhYnNvbHV0ZSBwYXRoLCBnZXQgY3dkIGZvciB0aGF0IGRyaXZlLCBvciB0aGUgcHJvY2VzcyBjd2QgaWZcbiAgICAgICAgICAgICAgICAvLyB0aGUgZHJpdmUgY3dkIGlzIG5vdCBhdmFpbGFibGUuIFdlJ3JlIHN1cmUgdGhlIGRldmljZSBpcyBub3RcbiAgICAgICAgICAgICAgICAvLyBhIFVOQyBwYXRoIGF0IHRoaXMgcG9pbnRzLCBiZWNhdXNlIFVOQyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlLlxuICAgICAgICAgICAgICAgIHBhdGggPSBwcm9jZXNzLmVudltgPSR7cmVzb2x2ZWREZXZpY2V9YF0gfHwgcHJvY2Vzcy5jd2QoKTtcbiAgICAgICAgICAgICAgICAvLyBWZXJpZnkgdGhhdCBhIGN3ZCB3YXMgZm91bmQgYW5kIHRoYXQgaXQgYWN0dWFsbHkgcG9pbnRzXG4gICAgICAgICAgICAgICAgLy8gdG8gb3VyIGRyaXZlLiBJZiBub3QsIGRlZmF1bHQgdG8gdGhlIGRyaXZlJ3Mgcm9vdC5cbiAgICAgICAgICAgICAgICBpZiAocGF0aCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIChwYXRoLnNsaWNlKDAsIDIpLnRvTG93ZXJDYXNlKCkgIT09IHJlc29sdmVkRGV2aWNlLnRvTG93ZXJDYXNlKCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGguY2hhckNvZGVBdCgyKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IGAke3Jlc29sdmVkRGV2aWNlfVxcXFxgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHJvb3RFbmQgPSAwO1xuICAgICAgICAgICAgbGV0IGRldmljZSA9ICcnO1xuICAgICAgICAgICAgbGV0IGlzQWJzb2x1dGUgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYSByb290XG4gICAgICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIHBhdGggc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAxO1xuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBQb3NzaWJsZSBVTkMgcm9vdFxuICAgICAgICAgICAgICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCBhIHNlcGFyYXRvciwgd2Uga25vdyB3ZSBhdCBsZWFzdCBoYXZlIGFuXG4gICAgICAgICAgICAgICAgLy8gYWJzb2x1dGUgcGF0aCBvZiBzb21lIGtpbmQgKFVOQyBvciBvdGhlcndpc2UpXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgZG91YmxlIHBhdGggc2VwYXJhdG9yIGF0IGJlZ2lubmluZ1xuICAgICAgICAgICAgICAgICAgICBsZXQgaiA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gcGF0aC5zbGljZShsYXN0LCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBwYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gbGVuIHx8IGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZSA9IGBcXFxcXFxcXCR7Zmlyc3RQYXJ0fVxcXFwke3BhdGguc2xpY2UobGFzdCwgail9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByb290RW5kID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1dpbmRvd3NEZXZpY2VSb290KGNvZGUpICYmXG4gICAgICAgICAgICAgICAgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OKSB7XG4gICAgICAgICAgICAgICAgLy8gUG9zc2libGUgZGV2aWNlIHJvb3RcbiAgICAgICAgICAgICAgICBkZXZpY2UgPSBwYXRoLnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAyO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAyICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyZWF0IHNlcGFyYXRvciBmb2xsb3dpbmcgZHJpdmUgbmFtZSBhcyBhbiBhYnNvbHV0ZSBwYXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGljYXRvclxuICAgICAgICAgICAgICAgICAgICBpc0Fic29sdXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVuZCA9IDM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRldmljZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkRGV2aWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRldmljZS50b0xvd2VyQ2FzZSgpICE9PSByZXNvbHZlZERldmljZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHBhdGggcG9pbnRzIHRvIGFub3RoZXIgZGV2aWNlIHNvIGl0IGlzIG5vdCBhcHBsaWNhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZWREZXZpY2UgPSBkZXZpY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWREZXZpY2UubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFRhaWwgPSBgJHtwYXRoLnNsaWNlKHJvb3RFbmQpfVxcXFwke3Jlc29sdmVkVGFpbH1gO1xuICAgICAgICAgICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBpc0Fic29sdXRlO1xuICAgICAgICAgICAgICAgIGlmIChpc0Fic29sdXRlICYmIHJlc29sdmVkRGV2aWNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLFxuICAgICAgICAvLyBidXQgaGFuZGxlIHJlbGF0aXZlIHBhdGhzIHRvIGJlIHNhZmUgKG1pZ2h0IGhhcHBlbiB3aGVuIHByb2Nlc3MuY3dkKClcbiAgICAgICAgLy8gZmFpbHMpXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgdGFpbCBwYXRoXG4gICAgICAgIHJlc29sdmVkVGFpbCA9IG5vcm1hbGl6ZVN0cmluZyhyZXNvbHZlZFRhaWwsICFyZXNvbHZlZEFic29sdXRlLCAnXFxcXCcsIGlzUGF0aFNlcGFyYXRvcik7XG4gICAgICAgIHJldHVybiByZXNvbHZlZEFic29sdXRlID9cbiAgICAgICAgICAgIGAke3Jlc29sdmVkRGV2aWNlfVxcXFwke3Jlc29sdmVkVGFpbH1gIDpcbiAgICAgICAgICAgIGAke3Jlc29sdmVkRGV2aWNlfSR7cmVzb2x2ZWRUYWlsfWAgfHwgJy4nO1xuICAgIH0sXG4gICAgbm9ybWFsaXplKHBhdGgpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJvb3RFbmQgPSAwO1xuICAgICAgICBsZXQgZGV2aWNlO1xuICAgICAgICBsZXQgaXNBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYSByb290XG4gICAgICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgc2luZ2xlIGNoYXIsIGV4aXQgZWFybHkgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmtcbiAgICAgICAgICAgIHJldHVybiBpc1Bvc2l4UGF0aFNlcGFyYXRvcihjb2RlKSA/ICdcXFxcJyA6IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuICAgICAgICAgICAgLy8gUG9zc2libGUgVU5DIHJvb3RcbiAgICAgICAgICAgIC8vIElmIHdlIHN0YXJ0ZWQgd2l0aCBhIHNlcGFyYXRvciwgd2Uga25vdyB3ZSBhdCBsZWFzdCBoYXZlIGFuIGFic29sdXRlXG4gICAgICAgICAgICAvLyBwYXRoIG9mIHNvbWUga2luZCAoVU5DIG9yIG90aGVyd2lzZSlcbiAgICAgICAgICAgIGlzQWJzb2x1dGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMSkpKSB7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCBkb3VibGUgcGF0aCBzZXBhcmF0b3IgYXQgYmVnaW5uaW5nXG4gICAgICAgICAgICAgICAgbGV0IGogPSAyO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RQYXJ0ID0gcGF0aC5zbGljZShsYXN0LCBqKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBwYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdCA9IGo7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgbm9uLXBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogPT09IGxlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgYSBVTkMgcm9vdCBvbmx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBub3JtYWxpemVkIHZlcnNpb24gb2YgdGhlIFVOQyByb290IHNpbmNlIHRoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgbm90aGluZyBsZWZ0IHRvIHByb2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxcXFxcXFxcJHtmaXJzdFBhcnR9XFxcXCR7cGF0aC5zbGljZShsYXN0KX1cXFxcYDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IHdpdGggbGVmdG92ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlID0gYFxcXFxcXFxcJHtmaXJzdFBhcnR9XFxcXCR7cGF0aC5zbGljZShsYXN0LCBqKX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm9vdEVuZCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJiBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290XG4gICAgICAgICAgICBkZXZpY2UgPSBwYXRoLnNsaWNlKDAsIDIpO1xuICAgICAgICAgICAgcm9vdEVuZCA9IDI7XG4gICAgICAgICAgICBpZiAobGVuID4gMiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDIpKSkge1xuICAgICAgICAgICAgICAgIC8vIFRyZWF0IHNlcGFyYXRvciBmb2xsb3dpbmcgZHJpdmUgbmFtZSBhcyBhbiBhYnNvbHV0ZSBwYXRoXG4gICAgICAgICAgICAgICAgLy8gaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcm9vdEVuZCA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRhaWwgPSByb290RW5kIDwgbGVuID9cbiAgICAgICAgICAgIG5vcm1hbGl6ZVN0cmluZyhwYXRoLnNsaWNlKHJvb3RFbmQpLCAhaXNBYnNvbHV0ZSwgJ1xcXFwnLCBpc1BhdGhTZXBhcmF0b3IpIDpcbiAgICAgICAgICAgICcnO1xuICAgICAgICBpZiAodGFpbC5sZW5ndGggPT09IDAgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHRhaWwgPSAnLic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhaWwubGVuZ3RoID4gMCAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGxlbiAtIDEpKSkge1xuICAgICAgICAgICAgdGFpbCArPSAnXFxcXCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRldmljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBYnNvbHV0ZSA/IGBcXFxcJHt0YWlsfWAgOiB0YWlsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0Fic29sdXRlID8gYCR7ZGV2aWNlfVxcXFwke3RhaWx9YCA6IGAke2RldmljZX0ke3RhaWx9YDtcbiAgICB9LFxuICAgIGlzQWJzb2x1dGUocGF0aCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBjb25zdCBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHJldHVybiBpc1BhdGhTZXBhcmF0b3IoY29kZSkgfHxcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290XG4gICAgICAgICAgICAobGVuID4gMiAmJlxuICAgICAgICAgICAgICAgIGlzV2luZG93c0RldmljZVJvb3QoY29kZSkgJiZcbiAgICAgICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04gJiZcbiAgICAgICAgICAgICAgICBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDIpKSk7XG4gICAgfSxcbiAgICBqb2luKC4uLnBhdGhzKSB7XG4gICAgICAgIGlmIChwYXRocy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGpvaW5lZDtcbiAgICAgICAgbGV0IGZpcnN0UGFydDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYXJnID0gcGF0aHNbaV07XG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhhcmcsICdwYXRoJyk7XG4gICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkID0gZmlyc3RQYXJ0ID0gYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkICs9IGBcXFxcJHthcmd9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpvaW5lZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJy4nO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBqb2luZWQgcGF0aCBkb2Vzbid0IHN0YXJ0IHdpdGggdHdvIHNsYXNoZXMsIGJlY2F1c2VcbiAgICAgICAgLy8gbm9ybWFsaXplKCkgd2lsbCBtaXN0YWtlIGl0IGZvciBhIFVOQyBwYXRoIHRoZW4uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgc3RlcCBpcyBza2lwcGVkIHdoZW4gaXQgaXMgdmVyeSBjbGVhciB0aGF0IHRoZSB1c2VyIGFjdHVhbGx5XG4gICAgICAgIC8vIGludGVuZGVkIHRvIHBvaW50IGF0IGEgVU5DIHBhdGguIFRoaXMgaXMgYXNzdW1lZCB3aGVuIHRoZSBmaXJzdFxuICAgICAgICAvLyBub24tZW1wdHkgc3RyaW5nIGFyZ3VtZW50cyBzdGFydHMgd2l0aCBleGFjdGx5IHR3byBzbGFzaGVzIGZvbGxvd2VkIGJ5XG4gICAgICAgIC8vIGF0IGxlYXN0IG9uZSBtb3JlIG5vbi1zbGFzaCBjaGFyYWN0ZXIuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE5vdGUgdGhhdCBmb3Igbm9ybWFsaXplKCkgdG8gdHJlYXQgYSBwYXRoIGFzIGEgVU5DIHBhdGggaXQgbmVlZHMgdG9cbiAgICAgICAgLy8gaGF2ZSBhdCBsZWFzdCAyIGNvbXBvbmVudHMsIHNvIHdlIGRvbid0IGZpbHRlciBmb3IgdGhhdCBoZXJlLlxuICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIHVzZXIgY2FuIHVzZSBqb2luIHRvIGNvbnN0cnVjdCBVTkMgcGF0aHMgZnJvbVxuICAgICAgICAvLyBhIHNlcnZlciBuYW1lIGFuZCBhIHNoYXJlIG5hbWU7IGZvciBleGFtcGxlOlxuICAgICAgICAvLyAgIHBhdGguam9pbignLy9zZXJ2ZXInLCAnc2hhcmUnKSAtPiAnXFxcXFxcXFxzZXJ2ZXJcXFxcc2hhcmVcXFxcJylcbiAgICAgICAgbGV0IG5lZWRzUmVwbGFjZSA9IHRydWU7XG4gICAgICAgIGxldCBzbGFzaENvdW50ID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBmaXJzdFBhcnQgPT09ICdzdHJpbmcnICYmIGlzUGF0aFNlcGFyYXRvcihmaXJzdFBhcnQuY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgICsrc2xhc2hDb3VudDtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0TGVuID0gZmlyc3RQYXJ0Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChmaXJzdExlbiA+IDEgJiYgaXNQYXRoU2VwYXJhdG9yKGZpcnN0UGFydC5jaGFyQ29kZUF0KDEpKSkge1xuICAgICAgICAgICAgICAgICsrc2xhc2hDb3VudDtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RMZW4gPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoZmlyc3RQYXJ0LmNoYXJDb2RlQXQoMikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICArK3NsYXNoQ291bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHBhdGggaW4gdGhlIGZpcnN0IHBhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lZWRzUmVwbGFjZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1JlcGxhY2UpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgYW55IG1vcmUgY29uc2VjdXRpdmUgc2xhc2hlcyB3ZSBuZWVkIHRvIHJlcGxhY2VcbiAgICAgICAgICAgIHdoaWxlIChzbGFzaENvdW50IDwgam9pbmVkLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgIGlzUGF0aFNlcGFyYXRvcihqb2luZWQuY2hhckNvZGVBdChzbGFzaENvdW50KSkpIHtcbiAgICAgICAgICAgICAgICBzbGFzaENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBzbGFzaGVzIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHNsYXNoQ291bnQgPj0gMikge1xuICAgICAgICAgICAgICAgIGpvaW5lZCA9IGBcXFxcJHtqb2luZWQuc2xpY2Uoc2xhc2hDb3VudCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2luMzIubm9ybWFsaXplKGpvaW5lZCk7XG4gICAgfSxcbiAgICAvLyBJdCB3aWxsIHNvbHZlIHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gYGZyb21gIHRvIGB0b2AsIGZvciBpbnN0YW5jZTpcbiAgICAvLyAgZnJvbSA9ICdDOlxcXFxvcmFuZGVhXFxcXHRlc3RcXFxcYWFhJ1xuICAgIC8vICB0byA9ICdDOlxcXFxvcmFuZGVhXFxcXGltcGxcXFxcYmJiJ1xuICAgIC8vIFRoZSBvdXRwdXQgb2YgdGhlIGZ1bmN0aW9uIHNob3VsZCBiZTogJy4uXFxcXC4uXFxcXGltcGxcXFxcYmJiJ1xuICAgIHJlbGF0aXZlKGZyb20sIHRvKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKGZyb20sICdmcm9tJyk7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHRvLCAndG8nKTtcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJvbU9yaWcgPSB3aW4zMi5yZXNvbHZlKGZyb20pO1xuICAgICAgICBjb25zdCB0b09yaWcgPSB3aW4zMi5yZXNvbHZlKHRvKTtcbiAgICAgICAgaWYgKGZyb21PcmlnID09PSB0b09yaWcpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBmcm9tID0gZnJvbU9yaWcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdG8gPSB0b09yaWcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpbSBhbnkgbGVhZGluZyBiYWNrc2xhc2hlc1xuICAgICAgICBsZXQgZnJvbVN0YXJ0ID0gMDtcbiAgICAgICAgd2hpbGUgKGZyb21TdGFydCA8IGZyb20ubGVuZ3RoICYmXG4gICAgICAgICAgICBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0KSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgZnJvbVN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpbSB0cmFpbGluZyBiYWNrc2xhc2hlcyAoYXBwbGljYWJsZSB0byBVTkMgcGF0aHMgb25seSlcbiAgICAgICAgbGV0IGZyb21FbmQgPSBmcm9tLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGZyb21FbmQgLSAxID4gZnJvbVN0YXJ0ICYmXG4gICAgICAgICAgICBmcm9tLmNoYXJDb2RlQXQoZnJvbUVuZCAtIDEpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICBmcm9tRW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJvbUxlbiA9IGZyb21FbmQgLSBmcm9tU3RhcnQ7XG4gICAgICAgIC8vIFRyaW0gYW55IGxlYWRpbmcgYmFja3NsYXNoZXNcbiAgICAgICAgbGV0IHRvU3RhcnQgPSAwO1xuICAgICAgICB3aGlsZSAodG9TdGFydCA8IHRvLmxlbmd0aCAmJlxuICAgICAgICAgICAgdG8uY2hhckNvZGVBdCh0b1N0YXJ0KSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgdG9TdGFydCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyaW0gdHJhaWxpbmcgYmFja3NsYXNoZXMgKGFwcGxpY2FibGUgdG8gVU5DIHBhdGhzIG9ubHkpXG4gICAgICAgIGxldCB0b0VuZCA9IHRvLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHRvRW5kIC0gMSA+IHRvU3RhcnQgJiZcbiAgICAgICAgICAgIHRvLmNoYXJDb2RlQXQodG9FbmQgLSAxKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgdG9FbmQtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b0xlbiA9IHRvRW5kIC0gdG9TdGFydDtcbiAgICAgICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxuICAgICAgICBjb25zdCBsZW5ndGggPSBmcm9tTGVuIDwgdG9MZW4gPyBmcm9tTGVuIDogdG9MZW47XG4gICAgICAgIGxldCBsYXN0Q29tbW9uU2VwID0gLTE7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZnJvbUNvZGUgPSBmcm9tLmNoYXJDb2RlQXQoZnJvbVN0YXJ0ICsgaSk7XG4gICAgICAgICAgICBpZiAoZnJvbUNvZGUgIT09IHRvLmNoYXJDb2RlQXQodG9TdGFydCArIGkpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcm9tQ29kZSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGZvdW5kIGEgbWlzbWF0Y2ggYmVmb3JlIHRoZSBmaXJzdCBjb21tb24gcGF0aCBzZXBhcmF0b3Igd2FzIHNlZW4sIHNvXG4gICAgICAgIC8vIHJldHVybiB0aGUgb3JpZ2luYWwgYHRvYC5cbiAgICAgICAgaWYgKGkgIT09IGxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGxhc3RDb21tb25TZXAgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvT3JpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0b0xlbiA+IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmICh0by5jaGFyQ29kZUF0KHRvU3RhcnQgKyBpKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209J0M6XFxcXGZvb1xcXFxiYXInOyB0bz0nQzpcXFxcZm9vXFxcXGJhclxcXFxiYXonXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b09yaWcuc2xpY2UodG9TdGFydCArIGkgKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYGZyb21gIGlzIHRoZSBkZXZpY2Ugcm9vdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209J0M6XFxcXCc7IHRvPSdDOlxcXFxmb28nXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b09yaWcuc2xpY2UodG9TdGFydCArIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSBleGFjdCBiYXNlIHBhdGggZm9yIGBmcm9tYC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209J0M6XFxcXGZvb1xcXFxiYXInOyB0bz0nQzpcXFxcZm9vJ1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgdG9gIGlzIHRoZSBkZXZpY2Ugcm9vdC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209J0M6XFxcXGZvb1xcXFxiYXInOyB0bz0nQzpcXFxcJ1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdENvbW1vblNlcCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0ID0gJyc7XG4gICAgICAgIC8vIEdlbmVyYXRlIHRoZSByZWxhdGl2ZSBwYXRoIGJhc2VkIG9uIHRoZSBwYXRoIGRpZmZlcmVuY2UgYmV0d2VlbiBgdG9gIGFuZFxuICAgICAgICAvLyBgZnJvbWBcbiAgICAgICAgZm9yIChpID0gZnJvbVN0YXJ0ICsgbGFzdENvbW1vblNlcCArIDE7IGkgPD0gZnJvbUVuZDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gZnJvbUVuZCB8fCBmcm9tLmNoYXJDb2RlQXQoaSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICBvdXQgKz0gb3V0Lmxlbmd0aCA9PT0gMCA/ICcuLicgOiAnXFxcXC4uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0b1N0YXJ0ICs9IGxhc3RDb21tb25TZXA7XG4gICAgICAgIC8vIExhc3RseSwgYXBwZW5kIHRoZSByZXN0IG9mIHRoZSBkZXN0aW5hdGlvbiAoYHRvYCkgcGF0aCB0aGF0IGNvbWVzIGFmdGVyXG4gICAgICAgIC8vIHRoZSBjb21tb24gcGF0aCBwYXJ0c1xuICAgICAgICBpZiAob3V0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiBgJHtvdXR9JHt0b09yaWcuc2xpY2UodG9TdGFydCwgdG9FbmQpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvT3JpZy5jaGFyQ29kZUF0KHRvU3RhcnQpID09PSBDSEFSX0JBQ0tXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICArK3RvU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvT3JpZy5zbGljZSh0b1N0YXJ0LCB0b0VuZCk7XG4gICAgfSxcbiAgICB0b05hbWVzcGFjZWRQYXRoKHBhdGgpIHtcbiAgICAgICAgLy8gTm90ZTogdGhpcyB3aWxsICpwcm9iYWJseSogdGhyb3cgc29tZXdoZXJlLlxuICAgICAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnIHx8IHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlZFBhdGggPSB3aW4zMi5yZXNvbHZlKHBhdGgpO1xuICAgICAgICBpZiAocmVzb2x2ZWRQYXRoLmxlbmd0aCA8PSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQkFDS1dBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gcmVzb2x2ZWRQYXRoLmNoYXJDb2RlQXQoMik7XG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgIT09IENIQVJfUVVFU1RJT05fTUFSSyAmJiBjb2RlICE9PSBDSEFSX0RPVCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIG5vbi1sb25nIFVOQyByb290LCBjb252ZXJ0IHRoZSBwYXRoIHRvIGEgbG9uZyBVTkMgcGF0aFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFxcXFxcXFxcP1xcXFxVTkNcXFxcJHtyZXNvbHZlZFBhdGguc2xpY2UoMil9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChyZXNvbHZlZFBhdGguY2hhckNvZGVBdCgwKSkgJiZcbiAgICAgICAgICAgIHJlc29sdmVkUGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OICYmXG4gICAgICAgICAgICByZXNvbHZlZFBhdGguY2hhckNvZGVBdCgyKSA9PT0gQ0hBUl9CQUNLV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgLy8gTWF0Y2hlZCBkZXZpY2Ugcm9vdCwgY29udmVydCB0aGUgcGF0aCB0byBhIGxvbmcgVU5DIHBhdGhcbiAgICAgICAgICAgIHJldHVybiBgXFxcXFxcXFw/XFxcXCR7cmVzb2x2ZWRQYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcbiAgICBkaXJuYW1lKHBhdGgpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgY29uc3QgbGVuID0gcGF0aC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJvb3RFbmQgPSAtMTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgcGF0aCBzZXBhcmF0b3IsIGV4aXQgZWFybHkgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmsgb3IgYSBkb3QuXG4gICAgICAgICAgICByZXR1cm4gaXNQYXRoU2VwYXJhdG9yKGNvZGUpID8gcGF0aCA6ICcuJztcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggYSByb290XG4gICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IoY29kZSkpIHtcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIFVOQyByb290XG4gICAgICAgICAgICByb290RW5kID0gb2Zmc2V0ID0gMTtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KDEpKSkge1xuICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQgZG91YmxlIHBhdGggc2VwYXJhdG9yIGF0IGJlZ2lubmluZ1xuICAgICAgICAgICAgICAgIGxldCBqID0gMjtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGo7XG4gICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaiA8IGxlbiAmJiBqICE9PSBsYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCAxIG9yIG1vcmUgcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2hlZCFcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIG5vbi1wYXRoIHNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChqIDwgbGVuICYmICFpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqID09PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgb25seVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgd2l0aCBsZWZ0b3ZlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPZmZzZXQgYnkgMSB0byBpbmNsdWRlIHRoZSBzZXBhcmF0b3IgYWZ0ZXIgdGhlIFVOQyByb290IHRvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJlYXQgaXQgYXMgYSBcIm5vcm1hbCByb290XCIgb24gdG9wIG9mIGEgKFVOQykgcm9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvb3RFbmQgPSBvZmZzZXQgPSBqICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJiBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcbiAgICAgICAgICAgIHJvb3RFbmQgPSBsZW4gPiAyICYmIGlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoMikpID8gMyA6IDI7XG4gICAgICAgICAgICBvZmZzZXQgPSByb290RW5kO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbmQgPSAtMTtcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSBsZW4gLSAxOyBpID49IG9mZnNldDsgLS1pKSB7XG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChpKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICBpZiAocm9vdEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJy4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5kID0gcm9vdEVuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZSgwLCBlbmQpO1xuICAgIH0sXG4gICAgYmFzZW5hbWUocGF0aCwgZXh0KSB7XG4gICAgICAgIGlmIChleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsaWRhdGVTdHJpbmcoZXh0LCAnZXh0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIC8vIENoZWNrIGZvciBhIGRyaXZlIGxldHRlciBwcmVmaXggc28gYXMgbm90IHRvIG1pc3Rha2UgdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyBwYXRoIHNlcGFyYXRvciBhcyBhbiBleHRyYSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgcGF0aCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBkaXNyZWdhcmRlZFxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPj0gMiAmJlxuICAgICAgICAgICAgaXNXaW5kb3dzRGV2aWNlUm9vdChwYXRoLmNoYXJDb2RlQXQoMCkpICYmXG4gICAgICAgICAgICBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgZXh0Lmxlbmd0aCA+IDAgJiYgZXh0Lmxlbmd0aCA8PSBwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGV4dCA9PT0gcGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHRJZHggPSBleHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCBmaXJzdE5vblNsYXNoRW5kID0gLTE7XG4gICAgICAgICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzUGF0aFNlcGFyYXRvcihjb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0Tm9uU2xhc2hFbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgcmVtZW1iZXIgdGhpcyBpbmRleCBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIGl0IGlmIHRoZSBleHRlbnNpb24gZW5kcyB1cCBub3QgbWF0Y2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25TbGFzaEVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRJZHggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIHRoZSBleHBsaWNpdCBleHRlbnNpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBleHQuY2hhckNvZGVBdChleHRJZHgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC0tZXh0SWR4ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBleHRlbnNpb24sIHNvIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91ciBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dGVuc2lvbiBkb2VzIG5vdCBtYXRjaCwgc28gb3VyIHJlc3VsdCBpcyB0aGUgZW50aXJlIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRJZHggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBlbmQgPSBmaXJzdE5vblNsYXNoRW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgICAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAgICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG4gICAgfSxcbiAgICBleHRuYW1lKHBhdGgpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IHN0YXJ0RG90ID0gLTE7XG4gICAgICAgIGxldCBzdGFydFBhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gLTE7XG4gICAgICAgIGxldCBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAgICAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgICAgIC8vIENoZWNrIGZvciBhIGRyaXZlIGxldHRlciBwcmVmaXggc28gYXMgbm90IHRvIG1pc3Rha2UgdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyBwYXRoIHNlcGFyYXRvciBhcyBhbiBleHRyYSBzZXBhcmF0b3IgYXQgdGhlIGVuZCBvZiB0aGUgcGF0aCB0aGF0IGNhbiBiZVxuICAgICAgICAvLyBkaXNyZWdhcmRlZFxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPj0gMiAmJlxuICAgICAgICAgICAgcGF0aC5jaGFyQ29kZUF0KDEpID09PSBDSEFSX0NPTE9OICYmXG4gICAgICAgICAgICBpc1dpbmRvd3NEZXZpY2VSb290KHBhdGguY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnRQYXJ0ID0gMjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyAtLWkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9ET1QpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEgfHxcbiAgICAgICAgICAgIGVuZCA9PT0gLTEgfHxcbiAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgICAgICAgKHByZURvdFN0YXRlID09PSAxICYmXG4gICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IGVuZCAtIDEgJiZcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbiAgICB9LFxuICAgIGZvcm1hdDogX2Zvcm1hdC5iaW5kKG51bGwsICdcXFxcJyksXG4gICAgcGFyc2UocGF0aCkge1xuICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICBjb25zdCByZXQgPSB7IHJvb3Q6ICcnLCBkaXI6ICcnLCBiYXNlOiAnJywgZXh0OiAnJywgbmFtZTogJycgfTtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICBsZXQgcm9vdEVuZCA9IDA7XG4gICAgICAgIGxldCBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICAgICAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gYHBhdGhgIGNvbnRhaW5zIGp1c3QgYSBwYXRoIHNlcGFyYXRvciwgZXhpdCBlYXJseSB0byBhdm9pZFxuICAgICAgICAgICAgICAgIC8vIHVubmVjZXNzYXJ5IHdvcmtcbiAgICAgICAgICAgICAgICByZXQucm9vdCA9IHJldC5kaXIgPSBwYXRoO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXQuYmFzZSA9IHJldC5uYW1lID0gcGF0aDtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIG1hdGNoIGEgcm9vdFxuICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICAvLyBQb3NzaWJsZSBVTkMgcm9vdFxuICAgICAgICAgICAgcm9vdEVuZCA9IDE7XG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgxKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIGRvdWJsZSBwYXRoIHNlcGFyYXRvciBhdCBiZWdpbm5pbmdcbiAgICAgICAgICAgICAgICBsZXQgaiA9IDI7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3QgPSBqO1xuICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4gJiYgIWlzUGF0aFNlcGFyYXRvcihwYXRoLmNoYXJDb2RlQXQoaikpKSB7XG4gICAgICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGogPCBsZW4gJiYgaiAhPT0gbGFzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVkIVxuICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF0Y2ggMSBvciBtb3JlIHBhdGggc2VwYXJhdG9yc1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiBpc1BhdGhTZXBhcmF0b3IocGF0aC5jaGFyQ29kZUF0KGopKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChqIDwgbGVuICYmIGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoZWQhXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0ID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hdGNoIDEgb3IgbW9yZSBub24tcGF0aCBzZXBhcmF0b3JzXG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaiA8IGxlbiAmJiAhaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdChqKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaiA9PT0gbGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgbWF0Y2hlZCBhIFVOQyByb290IG9ubHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW5kID0gajtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGogIT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXRjaGVkIGEgVU5DIHJvb3Qgd2l0aCBsZWZ0b3ZlcnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb290RW5kID0gaiArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNXaW5kb3dzRGV2aWNlUm9vdChjb2RlKSAmJiBwYXRoLmNoYXJDb2RlQXQoMSkgPT09IENIQVJfQ09MT04pIHtcbiAgICAgICAgICAgIC8vIFBvc3NpYmxlIGRldmljZSByb290XG4gICAgICAgICAgICBpZiAobGVuIDw9IDIpIHtcbiAgICAgICAgICAgICAgICAvLyBgcGF0aGAgY29udGFpbnMganVzdCBhIGRyaXZlIHJvb3QsIGV4aXQgZWFybHkgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrXG4gICAgICAgICAgICAgICAgcmV0LnJvb3QgPSByZXQuZGlyID0gcGF0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm9vdEVuZCA9IDI7XG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKHBhdGguY2hhckNvZGVBdCgyKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAobGVuID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBwYXRoYCBjb250YWlucyBqdXN0IGEgZHJpdmUgcm9vdCwgZXhpdCBlYXJseSB0byBhdm9pZFxuICAgICAgICAgICAgICAgICAgICAvLyB1bm5lY2Vzc2FyeSB3b3JrXG4gICAgICAgICAgICAgICAgICAgIHJldC5yb290ID0gcmV0LmRpciA9IHBhdGg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvb3RFbmQgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyb290RW5kID4gMCkge1xuICAgICAgICAgICAgcmV0LnJvb3QgPSBwYXRoLnNsaWNlKDAsIHJvb3RFbmQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGFydERvdCA9IC0xO1xuICAgICAgICBsZXQgc3RhcnRQYXJ0ID0gcm9vdEVuZDtcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgbGV0IGkgPSBwYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgIC8vIFRyYWNrIHRoZSBzdGF0ZSBvZiBjaGFyYWN0ZXJzIChpZiBhbnkpIHdlIHNlZSBiZWZvcmUgb3VyIGZpcnN0IGRvdCBhbmRcbiAgICAgICAgLy8gYWZ0ZXIgYW55IHBhdGggc2VwYXJhdG9yIHdlIGZpbmRcbiAgICAgICAgbGV0IHByZURvdFN0YXRlID0gMDtcbiAgICAgICAgLy8gR2V0IG5vbi1kaXIgaW5mb1xuICAgICAgICBmb3IgKDsgaSA+PSByb290RW5kOyAtLWkpIHtcbiAgICAgICAgICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoaXNQYXRoU2VwYXJhdG9yKGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZW5kID0gaSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9ET1QpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJlRG90U3RhdGUgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gaGF2ZSBhIGdvb2QgY2hhbmNlIGF0IGhhdmluZyBhIG5vbi1lbXB0eSBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmQgIT09IC0xKSB7XG4gICAgICAgICAgICBpZiAoc3RhcnREb3QgPT09IC0xIHx8XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIC8vIFRoZSAocmlnaHQtbW9zdCkgdHJpbW1lZCBwYXRoIGNvbXBvbmVudCBpcyBleGFjdGx5ICcuLidcbiAgICAgICAgICAgICAgICAocHJlRG90U3RhdGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IGVuZCAtIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpKSB7XG4gICAgICAgICAgICAgICAgcmV0LmJhc2UgPSByZXQubmFtZSA9IHBhdGguc2xpY2Uoc3RhcnRQYXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0UGFydCwgc3RhcnREb3QpO1xuICAgICAgICAgICAgICAgIHJldC5iYXNlID0gcGF0aC5zbGljZShzdGFydFBhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgcmV0LmV4dCA9IHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIGRpcmVjdG9yeSBpcyB0aGUgcm9vdCwgdXNlIHRoZSBlbnRpcmUgcm9vdCBhcyB0aGUgYGRpcmAgaW5jbHVkaW5nXG4gICAgICAgIC8vIHRoZSB0cmFpbGluZyBzbGFzaCBpZiBhbnkgKGBDOlxcYWJjYCAtPiBgQzpcXGApLiBPdGhlcndpc2UsIHN0cmlwIG91dCB0aGVcbiAgICAgICAgLy8gdHJhaWxpbmcgc2xhc2ggKGBDOlxcYWJjXFxkZWZgIC0+IGBDOlxcYWJjYCkuXG4gICAgICAgIGlmIChzdGFydFBhcnQgPiAwICYmIHN0YXJ0UGFydCAhPT0gcm9vdEVuZCkge1xuICAgICAgICAgICAgcmV0LmRpciA9IHBhdGguc2xpY2UoMCwgc3RhcnRQYXJ0IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXQuZGlyID0gcmV0LnJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9LFxuICAgIHNlcDogJ1xcXFwnLFxuICAgIGRlbGltaXRlcjogJzsnLFxuICAgIHdpbjMyOiBudWxsLFxuICAgIHBvc2l4OiBudWxsXG59O1xuY29uc3QgcG9zaXhDd2QgPSAoKCkgPT4ge1xuICAgIGlmIChwbGF0Zm9ybUlzV2luMzIpIHtcbiAgICAgICAgLy8gQ29udmVydHMgV2luZG93cycgYmFja3NsYXNoIHBhdGggc2VwYXJhdG9ycyB0byBQT1NJWCBmb3J3YXJkIHNsYXNoZXNcbiAgICAgICAgLy8gYW5kIHRydW5jYXRlcyBhbnkgZHJpdmUgaW5kaWNhdG9yXG4gICAgICAgIGNvbnN0IHJlZ2V4cCA9IC9cXFxcL2c7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjd2QgPSBwcm9jZXNzLmN3ZCgpLnJlcGxhY2UocmVnZXhwLCAnLycpO1xuICAgICAgICAgICAgcmV0dXJuIGN3ZC5zbGljZShjd2QuaW5kZXhPZignLycpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gV2UncmUgYWxyZWFkeSBvbiBQT1NJWCwgbm8gbmVlZCBmb3IgYW55IHRyYW5zZm9ybWF0aW9uc1xuICAgIHJldHVybiAoKSA9PiBwcm9jZXNzLmN3ZCgpO1xufSkoKTtcbmV4cG9ydCBjb25zdCBwb3NpeCA9IHtcbiAgICAvLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4gICAgcmVzb2x2ZSguLi5wYXRoU2VnbWVudHMpIHtcbiAgICAgICAgbGV0IHJlc29sdmVkUGF0aCA9ICcnO1xuICAgICAgICBsZXQgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gcGF0aFNlZ21lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgcGF0aCA9IGkgPj0gMCA/IHBhdGhTZWdtZW50c1tpXSA6IHBvc2l4Q3dkKCk7XG4gICAgICAgICAgICB2YWxpZGF0ZVN0cmluZyhwYXRoLCAncGF0aCcpO1xuICAgICAgICAgICAgLy8gU2tpcCBlbXB0eSBlbnRyaWVzXG4gICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmVkUGF0aCA9IGAke3BhdGh9LyR7cmVzb2x2ZWRQYXRofWA7XG4gICAgICAgICAgICByZXNvbHZlZEFic29sdXRlID0gcGF0aC5jaGFyQ29kZUF0KDApID09PSBDSEFSX0ZPUldBUkRfU0xBU0g7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAgICAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgICAgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZVN0cmluZyhyZXNvbHZlZFBhdGgsICFyZXNvbHZlZEFic29sdXRlLCAnLycsIGlzUG9zaXhQYXRoU2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKHJlc29sdmVkQWJzb2x1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBgLyR7cmVzb2x2ZWRQYXRofWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkUGF0aC5sZW5ndGggPiAwID8gcmVzb2x2ZWRQYXRoIDogJy4nO1xuICAgIH0sXG4gICAgbm9ybWFsaXplKHBhdGgpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzQWJzb2x1dGUgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcbiAgICAgICAgY29uc3QgdHJhaWxpbmdTZXBhcmF0b3IgPSBwYXRoLmNoYXJDb2RlQXQocGF0aC5sZW5ndGggLSAxKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgICAgICAgcGF0aCA9IG5vcm1hbGl6ZVN0cmluZyhwYXRoLCAhaXNBYnNvbHV0ZSwgJy8nLCBpc1Bvc2l4UGF0aFNlcGFyYXRvcik7XG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJy8nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYWlsaW5nU2VwYXJhdG9yID8gJy4vJyA6ICcuJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhaWxpbmdTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHBhdGggKz0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0Fic29sdXRlID8gYC8ke3BhdGh9YCA6IHBhdGg7XG4gICAgfSxcbiAgICBpc0Fic29sdXRlKHBhdGgpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoID4gMCAmJiBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcbiAgICB9LFxuICAgIGpvaW4oLi4ucGF0aHMpIHtcbiAgICAgICAgaWYgKHBhdGhzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuICcuJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgam9pbmVkO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBhcmcgPSBwYXRoc1tpXTtcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKGFyZywgJ3BhdGgnKTtcbiAgICAgICAgICAgIGlmIChhcmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGlmIChqb2luZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBqb2luZWQgPSBhcmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqb2luZWQgKz0gYC8ke2FyZ31gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoam9pbmVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnLic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvc2l4Lm5vcm1hbGl6ZShqb2luZWQpO1xuICAgIH0sXG4gICAgcmVsYXRpdmUoZnJvbSwgdG8pIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcoZnJvbSwgJ2Zyb20nKTtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcodG8sICd0bycpO1xuICAgICAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBUcmltIGxlYWRpbmcgZm9yd2FyZCBzbGFzaGVzLlxuICAgICAgICBmcm9tID0gcG9zaXgucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgdG8gPSBwb3NpeC5yZXNvbHZlKHRvKTtcbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnJvbVN0YXJ0ID0gMTtcbiAgICAgICAgY29uc3QgZnJvbUVuZCA9IGZyb20ubGVuZ3RoO1xuICAgICAgICBjb25zdCBmcm9tTGVuID0gZnJvbUVuZCAtIGZyb21TdGFydDtcbiAgICAgICAgY29uc3QgdG9TdGFydCA9IDE7XG4gICAgICAgIGNvbnN0IHRvTGVuID0gdG8ubGVuZ3RoIC0gdG9TdGFydDtcbiAgICAgICAgLy8gQ29tcGFyZSBwYXRocyB0byBmaW5kIHRoZSBsb25nZXN0IGNvbW1vbiBwYXRoIGZyb20gcm9vdFxuICAgICAgICBjb25zdCBsZW5ndGggPSAoZnJvbUxlbiA8IHRvTGVuID8gZnJvbUxlbiA6IHRvTGVuKTtcbiAgICAgICAgbGV0IGxhc3RDb21tb25TZXAgPSAtMTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBmcm9tQ29kZSA9IGZyb20uY2hhckNvZGVBdChmcm9tU3RhcnQgKyBpKTtcbiAgICAgICAgICAgIGlmIChmcm9tQ29kZSAhPT0gdG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21Db2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAodG9MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodG8uY2hhckNvZGVBdCh0b1N0YXJ0ICsgaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBnZXQgaGVyZSBpZiBgZnJvbWAgaXMgdGhlIGV4YWN0IGJhc2UgcGF0aCBmb3IgYHRvYC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGU6IGZyb209Jy9mb28vYmFyJzsgdG89Jy9mb28vYmFyL2JheidcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvLnNsaWNlKHRvU3RhcnQgKyBpICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGBmcm9tYCBpcyB0aGUgcm9vdFxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgZXhhbXBsZTogZnJvbT0nLyc7IHRvPScvZm9vJ1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG8uc2xpY2UodG9TdGFydCArIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZyb21MZW4gPiBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbS5jaGFyQ29kZUF0KGZyb21TdGFydCArIGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgZ2V0IGhlcmUgaWYgYHRvYCBpcyB0aGUgZXhhY3QgYmFzZSBwYXRoIGZvciBgZnJvbWAuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhci9iYXonOyB0bz0nL2Zvby9iYXInXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb21tb25TZXAgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGdldCBoZXJlIGlmIGB0b2AgaXMgdGhlIHJvb3QuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBleGFtcGxlOiBmcm9tPScvZm9vL2Jhcic7IHRvPScvJ1xuICAgICAgICAgICAgICAgICAgICBsYXN0Q29tbW9uU2VwID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICAvLyBHZW5lcmF0ZSB0aGUgcmVsYXRpdmUgcGF0aCBiYXNlZCBvbiB0aGUgcGF0aCBkaWZmZXJlbmNlIGJldHdlZW4gYHRvYFxuICAgICAgICAvLyBhbmQgYGZyb21gLlxuICAgICAgICBmb3IgKGkgPSBmcm9tU3RhcnQgKyBsYXN0Q29tbW9uU2VwICsgMTsgaSA8PSBmcm9tRW5kOyArK2kpIHtcbiAgICAgICAgICAgIGlmIChpID09PSBmcm9tRW5kIHx8IGZyb20uY2hhckNvZGVBdChpKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IG91dC5sZW5ndGggPT09IDAgPyAnLi4nIDogJy8uLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGFzdGx5LCBhcHBlbmQgdGhlIHJlc3Qgb2YgdGhlIGRlc3RpbmF0aW9uIChgdG9gKSBwYXRoIHRoYXQgY29tZXMgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIGNvbW1vbiBwYXRoIHBhcnRzLlxuICAgICAgICByZXR1cm4gYCR7b3V0fSR7dG8uc2xpY2UodG9TdGFydCArIGxhc3RDb21tb25TZXApfWA7XG4gICAgfSxcbiAgICB0b05hbWVzcGFjZWRQYXRoKHBhdGgpIHtcbiAgICAgICAgLy8gTm9uLW9wIG9uIHBvc2l4IHN5c3RlbXNcbiAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfSxcbiAgICBkaXJuYW1lKHBhdGgpIHtcbiAgICAgICAgdmFsaWRhdGVTdHJpbmcocGF0aCwgJ3BhdGgnKTtcbiAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJy4nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc1Jvb3QgPSBwYXRoLmNoYXJDb2RlQXQoMCkgPT09IENIQVJfRk9SV0FSRF9TTEFTSDtcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICAgICAgICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IENIQVJfRk9SV0FSRF9TTEFTSCkge1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuICcvLyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbiAgICB9LFxuICAgIGJhc2VuYW1lKHBhdGgsIGV4dCkge1xuICAgICAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlU3RyaW5nKGV4dCwgJ2V4dCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSAtMTtcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBpZiAoZXh0ICE9PSB1bmRlZmluZWQgJiYgZXh0Lmxlbmd0aCA+IDAgJiYgZXh0Lmxlbmd0aCA8PSBwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGV4dCA9PT0gcGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBleHRJZHggPSBleHQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGxldCBmaXJzdE5vblNsYXNoRW5kID0gLTE7XG4gICAgICAgICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29kZSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3ROb25TbGFzaEVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCByZW1lbWJlciB0aGlzIGluZGV4IGluIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgaXQgaWYgdGhlIGV4dGVuc2lvbiBlbmRzIHVwIG5vdCBtYXRjaGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblNsYXNoRW5kID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dElkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gbWF0Y2ggdGhlIGV4cGxpY2l0IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IGV4dC5jaGFyQ29kZUF0KGV4dElkeCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1leHRJZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIGV4dGVuc2lvbiwgc28gbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyIHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29tcG9uZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0ZW5zaW9uIGRvZXMgbm90IG1hdGNoLCBzbyBvdXIgcmVzdWx0IGlzIHRoZSBlbnRpcmUgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dElkeCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGZpcnN0Tm9uU2xhc2hFbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBpZiAocGF0aC5jaGFyQ29kZUF0KGkpID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGVuZCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAgICAgICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgIH0sXG4gICAgZXh0bmFtZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGxldCBzdGFydERvdCA9IC0xO1xuICAgICAgICBsZXQgc3RhcnRQYXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IC0xO1xuICAgICAgICBsZXQgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgICAgICAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAgICAgICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICAgICAgICBsZXQgcHJlRG90U3RhdGUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fFxuICAgICAgICAgICAgZW5kID09PSAtMSB8fFxuICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgICAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgICAgICAocHJlRG90U3RhdGUgPT09IDEgJiZcbiAgICAgICAgICAgICAgICBzdGFydERvdCA9PT0gZW5kIC0gMSAmJlxuICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgIH0sXG4gICAgZm9ybWF0OiBfZm9ybWF0LmJpbmQobnVsbCwgJy8nKSxcbiAgICBwYXJzZShwYXRoKSB7XG4gICAgICAgIHZhbGlkYXRlU3RyaW5nKHBhdGgsICdwYXRoJyk7XG4gICAgICAgIGNvbnN0IHJldCA9IHsgcm9vdDogJycsIGRpcjogJycsIGJhc2U6ICcnLCBleHQ6ICcnLCBuYW1lOiAnJyB9O1xuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBYnNvbHV0ZSA9IHBhdGguY2hhckNvZGVBdCgwKSA9PT0gQ0hBUl9GT1JXQVJEX1NMQVNIO1xuICAgICAgICBsZXQgc3RhcnQ7XG4gICAgICAgIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICByZXQucm9vdCA9ICcvJztcbiAgICAgICAgICAgIHN0YXJ0ID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnREb3QgPSAtMTtcbiAgICAgICAgbGV0IHN0YXJ0UGFydCA9IDA7XG4gICAgICAgIGxldCBlbmQgPSAtMTtcbiAgICAgICAgbGV0IG1hdGNoZWRTbGFzaCA9IHRydWU7XG4gICAgICAgIGxldCBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gICAgICAgIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gICAgICAgIGxldCBwcmVEb3RTdGF0ZSA9IDA7XG4gICAgICAgIC8vIEdldCBub24tZGlyIGluZm9cbiAgICAgICAgZm9yICg7IGkgPj0gc3RhcnQ7IC0taSkge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0ZPUldBUkRfU0xBU0gpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAgICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yLCBtYXJrIHRoaXMgYXMgdGhlIGVuZCBvZiBvdXJcbiAgICAgICAgICAgICAgICAvLyBleHRlbnNpb25cbiAgICAgICAgICAgICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbmQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2RlID09PSBDSEFSX0RPVCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgb3VyIGZpcnN0IGRvdCwgbWFyayBpdCBhcyB0aGUgc3RhcnQgb2Ygb3VyIGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnREb3QgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgICAgICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgICAgICAgICAgIHByZURvdFN0YXRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RhcnRQYXJ0ID09PSAwICYmIGlzQWJzb2x1dGUgPyAxIDogc3RhcnRQYXJ0O1xuICAgICAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSB8fFxuICAgICAgICAgICAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICAgICAgICAgICAgcHJlRG90U3RhdGUgPT09IDAgfHxcbiAgICAgICAgICAgICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICAgICAgICAgICAgKHByZURvdFN0YXRlID09PSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBlbmQgLSAxICYmXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RG90ID09PSBzdGFydFBhcnQgKyAxKSkge1xuICAgICAgICAgICAgICAgIHJldC5iYXNlID0gcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0Lm5hbWUgPSBwYXRoLnNsaWNlKHN0YXJ0LCBzdGFydERvdCk7XG4gICAgICAgICAgICAgICAgcmV0LmJhc2UgPSBwYXRoLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICAgICAgICAgIHJldC5leHQgPSBwYXRoLnNsaWNlKHN0YXJ0RG90LCBlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFBhcnQgPiAwKSB7XG4gICAgICAgICAgICByZXQuZGlyID0gcGF0aC5zbGljZSgwLCBzdGFydFBhcnQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Fic29sdXRlKSB7XG4gICAgICAgICAgICByZXQuZGlyID0gJy8nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSxcbiAgICBzZXA6ICcvJyxcbiAgICBkZWxpbWl0ZXI6ICc6JyxcbiAgICB3aW4zMjogbnVsbCxcbiAgICBwb3NpeDogbnVsbFxufTtcbnBvc2l4LndpbjMyID0gd2luMzIud2luMzIgPSB3aW4zMjtcbnBvc2l4LnBvc2l4ID0gd2luMzIucG9zaXggPSBwb3NpeDtcbmV4cG9ydCBjb25zdCBub3JtYWxpemUgPSAocGxhdGZvcm1Jc1dpbjMyID8gd2luMzIubm9ybWFsaXplIDogcG9zaXgubm9ybWFsaXplKTtcbmV4cG9ydCBjb25zdCByZXNvbHZlID0gKHBsYXRmb3JtSXNXaW4zMiA/IHdpbjMyLnJlc29sdmUgOiBwb3NpeC5yZXNvbHZlKTtcbmV4cG9ydCBjb25zdCByZWxhdGl2ZSA9IChwbGF0Zm9ybUlzV2luMzIgPyB3aW4zMi5yZWxhdGl2ZSA6IHBvc2l4LnJlbGF0aXZlKTtcbmV4cG9ydCBjb25zdCBkaXJuYW1lID0gKHBsYXRmb3JtSXNXaW4zMiA/IHdpbjMyLmRpcm5hbWUgOiBwb3NpeC5kaXJuYW1lKTtcbmV4cG9ydCBjb25zdCBiYXNlbmFtZSA9IChwbGF0Zm9ybUlzV2luMzIgPyB3aW4zMi5iYXNlbmFtZSA6IHBvc2l4LmJhc2VuYW1lKTtcbmV4cG9ydCBjb25zdCBleHRuYW1lID0gKHBsYXRmb3JtSXNXaW4zMiA/IHdpbjMyLmV4dG5hbWUgOiBwb3NpeC5leHRuYW1lKTtcbmV4cG9ydCBjb25zdCBzZXAgPSAocGxhdGZvcm1Jc1dpbjMyID8gd2luMzIuc2VwIDogcG9zaXguc2VwKTtcbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0ICogYXMgcGF0aHMgZnJvbSAnLi9wYXRoLmpzJztcbmltcG9ydCB7IGlzV2luZG93cyB9IGZyb20gJy4vcGxhdGZvcm0uanMnO1xuY29uc3QgX3NjaGVtZVBhdHRlcm4gPSAvXlxcd1tcXHdcXGQrLi1dKiQvO1xuY29uc3QgX3NpbmdsZVNsYXNoU3RhcnQgPSAvXlxcLy87XG5jb25zdCBfZG91YmxlU2xhc2hTdGFydCA9IC9eXFwvXFwvLztcbmZ1bmN0aW9uIF92YWxpZGF0ZVVyaShyZXQsIF9zdHJpY3QpIHtcbiAgICAvLyBzY2hlbWUsIG11c3QgYmUgc2V0XG4gICAgaWYgKCFyZXQuc2NoZW1lICYmIF9zdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbVXJpRXJyb3JdOiBTY2hlbWUgaXMgbWlzc2luZzoge3NjaGVtZTogXCJcIiwgYXV0aG9yaXR5OiBcIiR7cmV0LmF1dGhvcml0eX1cIiwgcGF0aDogXCIke3JldC5wYXRofVwiLCBxdWVyeTogXCIke3JldC5xdWVyeX1cIiwgZnJhZ21lbnQ6IFwiJHtyZXQuZnJhZ21lbnR9XCJ9YCk7XG4gICAgfVxuICAgIC8vIHNjaGVtZSwgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjFcbiAgICAvLyBBTFBIQSAqKCBBTFBIQSAvIERJR0lUIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIClcbiAgICBpZiAocmV0LnNjaGVtZSAmJiAhX3NjaGVtZVBhdHRlcm4udGVzdChyZXQuc2NoZW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IFNjaGVtZSBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMuJyk7XG4gICAgfVxuICAgIC8vIHBhdGgsIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi0zLjNcbiAgICAvLyBJZiBhIFVSSSBjb250YWlucyBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNvbXBvbmVudFxuICAgIC8vIG11c3QgZWl0aGVyIGJlIGVtcHR5IG9yIGJlZ2luIHdpdGggYSBzbGFzaCAoXCIvXCIpIGNoYXJhY3Rlci4gIElmIGEgVVJJXG4gICAgLy8gZG9lcyBub3QgY29udGFpbiBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNhbm5vdCBiZWdpblxuICAgIC8vIHdpdGggdHdvIHNsYXNoIGNoYXJhY3RlcnMgKFwiLy9cIikuXG4gICAgaWYgKHJldC5wYXRoKSB7XG4gICAgICAgIGlmIChyZXQuYXV0aG9yaXR5KSB7XG4gICAgICAgICAgICBpZiAoIV9zaW5nbGVTbGFzaFN0YXJ0LnRlc3QocmV0LnBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbVXJpRXJyb3JdOiBJZiBhIFVSSSBjb250YWlucyBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNvbXBvbmVudCBtdXN0IGVpdGhlciBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgc2xhc2ggKFwiL1wiKSBjaGFyYWN0ZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChfZG91YmxlU2xhc2hTdGFydC50ZXN0KHJldC5wYXRoKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgZG9lcyBub3QgY29udGFpbiBhbiBhdXRob3JpdHkgY29tcG9uZW50LCB0aGVuIHRoZSBwYXRoIGNhbm5vdCBiZWdpbiB3aXRoIHR3byBzbGFzaCBjaGFyYWN0ZXJzIChcIi8vXCIpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBmb3IgYSB3aGlsZSB3ZSBhbGxvd2VkIHVyaXMgKndpdGhvdXQqIHNjaGVtZXMgYW5kIHRoaXMgaXMgdGhlIG1pZ3JhdGlvblxuLy8gZm9yIHRoZW0sIGUuZy4gYW4gdXJpIHdpdGhvdXQgc2NoZW1lIGFuZCB3aXRob3V0IHN0cmljdC1tb2RlIHdhcm5zIGFuZCBmYWxsc1xuLy8gYmFjayB0byB0aGUgZmlsZS1zY2hlbWUuIHRoYXQgc2hvdWxkIGNhdXNlIHRoZSBsZWFzdCBjYXJuYWdlIGFuZCBzdGlsbCBiZSBhXG4vLyBjbGVhciB3YXJuaW5nXG5mdW5jdGlvbiBfc2NoZW1lRml4KHNjaGVtZSwgX3N0cmljdCkge1xuICAgIGlmICghc2NoZW1lICYmICFfc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiAnZmlsZSc7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWU7XG59XG4vLyBpbXBsZW1lbnRzIGEgYml0IG9mIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNVxuZnVuY3Rpb24gX3JlZmVyZW5jZVJlc29sdXRpb24oc2NoZW1lLCBwYXRoKSB7XG4gICAgLy8gdGhlIHNsYXNoLWNoYXJhY3RlciBpcyBvdXIgJ2RlZmF1bHQgYmFzZScgYXMgd2UgZG9uJ3RcbiAgICAvLyBzdXBwb3J0IGNvbnN0cnVjdGluZyBVUklzIHJlbGF0aXZlIHRvIG90aGVyIFVSSXMuIFRoaXNcbiAgICAvLyBhbHNvIG1lYW5zIHRoYXQgd2UgYWx0ZXIgYW5kIHBvdGVudGlhbGx5IGJyZWFrIHBhdGhzLlxuICAgIC8vIHNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMS40XG4gICAgc3dpdGNoIChzY2hlbWUpIHtcbiAgICAgICAgY2FzZSAnaHR0cHMnOlxuICAgICAgICBjYXNlICdodHRwJzpcbiAgICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gX3NsYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGF0aFswXSAhPT0gX3NsYXNoKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IF9zbGFzaCArIHBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5jb25zdCBfZW1wdHkgPSAnJztcbmNvbnN0IF9zbGFzaCA9ICcvJztcbmNvbnN0IF9yZWdleHAgPSAvXigoW146Lz8jXSs/KTopPyhcXC9cXC8oW14vPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/Lztcbi8qKlxuICogVW5pZm9ybSBSZXNvdXJjZSBJZGVudGlmaWVyIChVUkkpIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYuXG4gKiBUaGlzIGNsYXNzIGlzIGEgc2ltcGxlIHBhcnNlciB3aGljaCBjcmVhdGVzIHRoZSBiYXNpYyBjb21wb25lbnQgcGFydHNcbiAqIChodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMykgd2l0aCBtaW5pbWFsIHZhbGlkYXRpb25cbiAqIGFuZCBlbmNvZGluZy5cbiAqXG4gKiBgYGB0eHRcbiAqICAgICAgIGZvbzovL2V4YW1wbGUuY29tOjgwNDIvb3Zlci90aGVyZT9uYW1lPWZlcnJldCNub3NlXG4gKiAgICAgICBcXF8vICAgXFxfX19fX19fX19fX19fXy9cXF9fX19fX19fXy8gXFxfX19fX19fX18vIFxcX18vXG4gKiAgICAgICAgfCAgICAgICAgICAgfCAgICAgICAgICAgIHwgICAgICAgICAgICB8ICAgICAgICB8XG4gKiAgICAgc2NoZW1lICAgICBhdXRob3JpdHkgICAgICAgcGF0aCAgICAgICAgcXVlcnkgICBmcmFnbWVudFxuICogICAgICAgIHwgICBfX19fX19fX19fX19fX19fX19fX198X19cbiAqICAgICAgIC8gXFwgLyAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gKiAgICAgICB1cm46ZXhhbXBsZTphbmltYWw6ZmVycmV0Om5vc2VcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgVVJJIHtcbiAgICBzdGF0aWMgaXNVcmkodGhpbmcpIHtcbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgVVJJKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGluZy5hdXRob3JpdHkgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcuZnJhZ21lbnQgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcucGF0aCA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5xdWVyeSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy5zY2hlbWUgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcuZnNQYXRoID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgJiYgdHlwZW9mIHRoaW5nLndpdGggPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICYmIHR5cGVvZiB0aGluZy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2NoZW1lT3JEYXRhLCBhdXRob3JpdHksIHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCwgX3N0cmljdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1lT3JEYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5zY2hlbWUgPSBzY2hlbWVPckRhdGEuc2NoZW1lIHx8IF9lbXB0eTtcbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5ID0gc2NoZW1lT3JEYXRhLmF1dGhvcml0eSB8fCBfZW1wdHk7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBzY2hlbWVPckRhdGEucGF0aCB8fCBfZW1wdHk7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gc2NoZW1lT3JEYXRhLnF1ZXJ5IHx8IF9lbXB0eTtcbiAgICAgICAgICAgIHRoaXMuZnJhZ21lbnQgPSBzY2hlbWVPckRhdGEuZnJhZ21lbnQgfHwgX2VtcHR5O1xuICAgICAgICAgICAgLy8gbm8gdmFsaWRhdGlvbiBiZWNhdXNlIGl0J3MgdGhpcyBVUklcbiAgICAgICAgICAgIC8vIHRoYXQgY3JlYXRlcyB1cmkgY29tcG9uZW50cy5cbiAgICAgICAgICAgIC8vIF92YWxpZGF0ZVVyaSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZW1lID0gX3NjaGVtZUZpeChzY2hlbWVPckRhdGEsIF9zdHJpY3QpO1xuICAgICAgICAgICAgdGhpcy5hdXRob3JpdHkgPSBhdXRob3JpdHkgfHwgX2VtcHR5O1xuICAgICAgICAgICAgdGhpcy5wYXRoID0gX3JlZmVyZW5jZVJlc29sdXRpb24odGhpcy5zY2hlbWUsIHBhdGggfHwgX2VtcHR5KTtcbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeSB8fCBfZW1wdHk7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnQgfHwgX2VtcHR5O1xuICAgICAgICAgICAgX3ZhbGlkYXRlVXJpKHRoaXMsIF9zdHJpY3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIC0tLS0gZmlsZXN5c3RlbSBwYXRoIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvcnJlc3BvbmRpbmcgZmlsZSBzeXN0ZW0gcGF0aCBvZiB0aGlzIFVSSS5cbiAgICAgKiBXaWxsIGhhbmRsZSBVTkMgcGF0aHMsIG5vcm1hbGl6ZXMgd2luZG93cyBkcml2ZSBsZXR0ZXJzIHRvIGxvd2VyLWNhc2UsIGFuZCB1c2VzIHRoZVxuICAgICAqIHBsYXRmb3JtIHNwZWNpZmljIHBhdGggc2VwYXJhdG9yLlxuICAgICAqXG4gICAgICogKiBXaWxsICpub3QqIHZhbGlkYXRlIHRoZSBwYXRoIGZvciBpbnZhbGlkIGNoYXJhY3RlcnMgYW5kIHNlbWFudGljcy5cbiAgICAgKiAqIFdpbGwgKm5vdCogbG9vayBhdCB0aGUgc2NoZW1lIG9mIHRoaXMgVVJJLlxuICAgICAqICogVGhlIHJlc3VsdCBzaGFsbCAqbm90KiBiZSB1c2VkIGZvciBkaXNwbGF5IHB1cnBvc2VzIGJ1dCBmb3IgYWNjZXNzaW5nIGEgZmlsZSBvbiBkaXNrLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBUaGUgKmRpZmZlcmVuY2UqIHRvIGBVUkkjcGF0aGAgaXMgdGhlIHVzZSBvZiB0aGUgcGxhdGZvcm0gc3BlY2lmaWMgc2VwYXJhdG9yIGFuZCB0aGUgaGFuZGxpbmdcbiAgICAgKiBvZiBVTkMgcGF0aHMuIFNlZSB0aGUgYmVsb3cgc2FtcGxlIG9mIGEgZmlsZS11cmkgd2l0aCBhbiBhdXRob3JpdHkgKFVOQyBwYXRoKS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICAgIGNvbnN0IHUgPSBVUkkucGFyc2UoJ2ZpbGU6Ly9zZXJ2ZXIvYyQvZm9sZGVyL2ZpbGUudHh0JylcbiAgICAgICAgdS5hdXRob3JpdHkgPT09ICdzZXJ2ZXInXG4gICAgICAgIHUucGF0aCA9PT0gJy9zaGFyZXMvYyQvZmlsZS50eHQnXG4gICAgICAgIHUuZnNQYXRoID09PSAnXFxcXHNlcnZlclxcYyRcXGZvbGRlclxcZmlsZS50eHQnXG4gICAgYGBgXG4gICAgICpcbiAgICAgKiBVc2luZyBgVVJJI3BhdGhgIHRvIHJlYWQgYSBmaWxlICh1c2luZyBmcy1hcGlzKSB3b3VsZCBub3QgYmUgZW5vdWdoIGJlY2F1c2UgcGFydHMgb2YgdGhlIHBhdGgsXG4gICAgICogbmFtZWx5IHRoZSBzZXJ2ZXIgbmFtZSwgd291bGQgYmUgbWlzc2luZy4gVGhlcmVmb3JlIGBVUkkjZnNQYXRoYCBleGlzdHMgLSBpdCdzIHN1Z2FyIHRvIGVhc2Ugd29ya2luZ1xuICAgICAqIHdpdGggVVJJcyB0aGF0IHJlcHJlc2VudCBmaWxlcyBvbiBkaXNrIChgZmlsZWAgc2NoZW1lKS5cbiAgICAgKi9cbiAgICBnZXQgZnNQYXRoKCkge1xuICAgICAgICAvLyBpZiAodGhpcy5zY2hlbWUgIT09ICdmaWxlJykge1xuICAgICAgICAvLyBcdGNvbnNvbGUud2FybihgW1VyaUVycm9yXSBjYWxsaW5nIGZzUGF0aCB3aXRoIHNjaGVtZSAke3RoaXMuc2NoZW1lfWApO1xuICAgICAgICAvLyB9XG4gICAgICAgIHJldHVybiB1cmlUb0ZzUGF0aCh0aGlzLCBmYWxzZSk7XG4gICAgfVxuICAgIC8vIC0tLS0gbW9kaWZ5IHRvIG5ldyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgd2l0aChjaGFuZ2UpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IHNjaGVtZSwgYXV0aG9yaXR5LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQgfSA9IGNoYW5nZTtcbiAgICAgICAgaWYgKHNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2hlbWUgPSB0aGlzLnNjaGVtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzY2hlbWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHNjaGVtZSA9IF9lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXV0aG9yaXR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGF1dGhvcml0eSA9IHRoaXMuYXV0aG9yaXR5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGF1dGhvcml0eSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYXV0aG9yaXR5ID0gX2VtcHR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcGF0aCA9IF9lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocXVlcnkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcXVlcnkgPSB0aGlzLnF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHF1ZXJ5ID09PSBudWxsKSB7XG4gICAgICAgICAgICBxdWVyeSA9IF9lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmZyYWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZyYWdtZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBmcmFnbWVudCA9IF9lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1lID09PSB0aGlzLnNjaGVtZVxuICAgICAgICAgICAgJiYgYXV0aG9yaXR5ID09PSB0aGlzLmF1dGhvcml0eVxuICAgICAgICAgICAgJiYgcGF0aCA9PT0gdGhpcy5wYXRoXG4gICAgICAgICAgICAmJiBxdWVyeSA9PT0gdGhpcy5xdWVyeVxuICAgICAgICAgICAgJiYgZnJhZ21lbnQgPT09IHRoaXMuZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVXJpKHNjaGVtZSwgYXV0aG9yaXR5LCBwYXRoLCBxdWVyeSwgZnJhZ21lbnQpO1xuICAgIH1cbiAgICAvLyAtLS0tIHBhcnNlICYgdmFsaWRhdGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBVUkkgZnJvbSBhIHN0cmluZywgZS5nLiBgaHR0cDovL3d3dy5leGFtcGxlLmNvbS9zb21lL3BhdGhgLFxuICAgICAqIGBmaWxlOi8vL3Vzci9ob21lYCwgb3IgYHNjaGVtZTp3aXRoL3BhdGhgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIEEgc3RyaW5nIHdoaWNoIHJlcHJlc2VudHMgYW4gVVJJIChzZWUgYFVSSSN0b1N0cmluZ2ApLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZSh2YWx1ZSwgX3N0cmljdCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gX3JlZ2V4cC5leGVjKHZhbHVlKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcmkoX2VtcHR5LCBfZW1wdHksIF9lbXB0eSwgX2VtcHR5LCBfZW1wdHkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVXJpKG1hdGNoWzJdIHx8IF9lbXB0eSwgcGVyY2VudERlY29kZShtYXRjaFs0XSB8fCBfZW1wdHkpLCBwZXJjZW50RGVjb2RlKG1hdGNoWzVdIHx8IF9lbXB0eSksIHBlcmNlbnREZWNvZGUobWF0Y2hbN10gfHwgX2VtcHR5KSwgcGVyY2VudERlY29kZShtYXRjaFs5XSB8fCBfZW1wdHkpLCBfc3RyaWN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBVUkkgZnJvbSBhIGZpbGUgc3lzdGVtIHBhdGgsIGUuZy4gYGM6XFxteVxcZmlsZXNgLFxuICAgICAqIGAvdXNyL2hvbWVgLCBvciBgXFxcXHNlcnZlclxcc2hhcmVcXHNvbWVcXHBhdGhgLlxuICAgICAqXG4gICAgICogVGhlICpkaWZmZXJlbmNlKiBiZXR3ZWVuIGBVUkkjcGFyc2VgIGFuZCBgVVJJI2ZpbGVgIGlzIHRoYXQgdGhlIGxhdHRlciB0cmVhdHMgdGhlIGFyZ3VtZW50XG4gICAgICogYXMgcGF0aCwgbm90IGFzIHN0cmluZ2lmaWVkLXVyaS4gRS5nLiBgVVJJLmZpbGUocGF0aClgIGlzICoqbm90IHRoZSBzYW1lIGFzKipcbiAgICAgKiBgVVJJLnBhcnNlKCdmaWxlOi8vJyArIHBhdGgpYCBiZWNhdXNlIHRoZSBwYXRoIG1pZ2h0IGNvbnRhaW4gY2hhcmFjdGVycyB0aGF0IGFyZVxuICAgICAqIGludGVycHJldGVkICgjIGFuZCA/KS4gU2VlIHRoZSBmb2xsb3dpbmcgc2FtcGxlOlxuICAgICAqIGBgYHRzXG4gICAgY29uc3QgZ29vZCA9IFVSSS5maWxlKCcvY29kaW5nL2MjL3Byb2plY3QxJyk7XG4gICAgZ29vZC5zY2hlbWUgPT09ICdmaWxlJztcbiAgICBnb29kLnBhdGggPT09ICcvY29kaW5nL2MjL3Byb2plY3QxJztcbiAgICBnb29kLmZyYWdtZW50ID09PSAnJztcbiAgICBjb25zdCBiYWQgPSBVUkkucGFyc2UoJ2ZpbGU6Ly8nICsgJy9jb2RpbmcvYyMvcHJvamVjdDEnKTtcbiAgICBiYWQuc2NoZW1lID09PSAnZmlsZSc7XG4gICAgYmFkLnBhdGggPT09ICcvY29kaW5nL2MnOyAvLyBwYXRoIGlzIG5vdyBicm9rZW5cbiAgICBiYWQuZnJhZ21lbnQgPT09ICcvcHJvamVjdDEnO1xuICAgIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhdGggQSBmaWxlIHN5c3RlbSBwYXRoIChzZWUgYFVSSSNmc1BhdGhgKVxuICAgICAqL1xuICAgIHN0YXRpYyBmaWxlKHBhdGgpIHtcbiAgICAgICAgbGV0IGF1dGhvcml0eSA9IF9lbXB0eTtcbiAgICAgICAgLy8gbm9ybWFsaXplIHRvIGZ3ZC1zbGFzaGVzIG9uIHdpbmRvd3MsXG4gICAgICAgIC8vIG9uIG90aGVyIHN5c3RlbXMgYndkLXNsYXNoZXMgYXJlIHZhbGlkXG4gICAgICAgIC8vIGZpbGVuYW1lIGNoYXJhY3RlciwgZWcgL2ZcXG9vL2JhXFxyLnR4dFxuICAgICAgICBpZiAoaXNXaW5kb3dzKSB7XG4gICAgICAgICAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFxcL2csIF9zbGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hlY2sgZm9yIGF1dGhvcml0eSBhcyB1c2VkIGluIFVOQyBzaGFyZXNcbiAgICAgICAgLy8gb3IgdXNlIHRoZSBwYXRoIGFzIGdpdmVuXG4gICAgICAgIGlmIChwYXRoWzBdID09PSBfc2xhc2ggJiYgcGF0aFsxXSA9PT0gX3NsYXNoKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSBwYXRoLmluZGV4T2YoX3NsYXNoLCAyKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYXV0aG9yaXR5ID0gcGF0aC5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICAgICAgcGF0aCA9IF9zbGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGF1dGhvcml0eSA9IHBhdGguc3Vic3RyaW5nKDIsIGlkeCk7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGguc3Vic3RyaW5nKGlkeCkgfHwgX3NsYXNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVXJpKCdmaWxlJywgYXV0aG9yaXR5LCBwYXRoLCBfZW1wdHksIF9lbXB0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IFVSSSBmcm9tIHVyaSBjb21wb25lbnRzLlxuICAgICAqXG4gICAgICogVW5sZXNzIGBzdHJpY3RgIGlzIGB0cnVlYCB0aGUgc2NoZW1lIGlzIGRlZmF1bHRzIHRvIGJlIGBmaWxlYC4gVGhpcyBmdW5jdGlvbiBwZXJmb3Jtc1xuICAgICAqIHZhbGlkYXRpb24gYW5kIHNob3VsZCBiZSB1c2VkIGZvciB1bnRydXN0ZWQgdXJpIGNvbXBvbmVudHMgcmV0cmlldmVkIGZyb20gc3RvcmFnZSxcbiAgICAgKiB1c2VyIGlucHV0LCBjb21tYW5kIGFyZ3VtZW50cyBldGNcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbShjb21wb25lbnRzLCBzdHJpY3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVyaShjb21wb25lbnRzLnNjaGVtZSwgY29tcG9uZW50cy5hdXRob3JpdHksIGNvbXBvbmVudHMucGF0aCwgY29tcG9uZW50cy5xdWVyeSwgY29tcG9uZW50cy5mcmFnbWVudCwgc3RyaWN0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbiBhIFVSSSBwYXRoIHdpdGggcGF0aCBmcmFnbWVudHMgYW5kIG5vcm1hbGl6ZXMgdGhlIHJlc3VsdGluZyBwYXRoLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVyaSBUaGUgaW5wdXQgVVJJLlxuICAgICAqIEBwYXJhbSBwYXRoRnJhZ21lbnQgVGhlIHBhdGggZnJhZ21lbnQgdG8gYWRkIHRvIHRoZSBVUkkgcGF0aC5cbiAgICAgKiBAcmV0dXJucyBUaGUgcmVzdWx0aW5nIFVSSS5cbiAgICAgKi9cbiAgICBzdGF0aWMgam9pblBhdGgodXJpLCAuLi5wYXRoRnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKCF1cmkucGF0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbVXJpRXJyb3JdOiBjYW5ub3QgY2FsbCBqb2luUGF0aCBvbiBVUkkgd2l0aG91dCBwYXRoYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld1BhdGg7XG4gICAgICAgIGlmIChpc1dpbmRvd3MgJiYgdXJpLnNjaGVtZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICBuZXdQYXRoID0gVVJJLmZpbGUocGF0aHMud2luMzIuam9pbih1cmlUb0ZzUGF0aCh1cmksIHRydWUpLCAuLi5wYXRoRnJhZ21lbnQpKS5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3UGF0aCA9IHBhdGhzLnBvc2l4LmpvaW4odXJpLnBhdGgsIC4uLnBhdGhGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS53aXRoKHsgcGF0aDogbmV3UGF0aCB9KTtcbiAgICB9XG4gICAgLy8gLS0tLSBwcmludGluZy9leHRlcm5hbGl6ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGZvciB0aGlzIFVSSS4gSXQncyBndWFyYW50ZWVkIHRoYXQgY2FsbGluZ1xuICAgICAqIGBVUkkucGFyc2VgIHdpdGggdGhlIHJlc3VsdCBvZiB0aGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gVVJJIHdoaWNoIGlzIGVxdWFsXG4gICAgICogdG8gdGhpcyBVUkkuXG4gICAgICpcbiAgICAgKiAqIFRoZSByZXN1bHQgc2hhbGwgKm5vdCogYmUgdXNlZCBmb3IgZGlzcGxheSBwdXJwb3NlcyBidXQgZm9yIGV4dGVybmFsaXphdGlvbiBvciB0cmFuc3BvcnQuXG4gICAgICogKiBUaGUgcmVzdWx0IHdpbGwgYmUgZW5jb2RlZCB1c2luZyB0aGUgcGVyY2VudGFnZSBlbmNvZGluZyBhbmQgZW5jb2RpbmcgaGFwcGVucyBtb3N0bHlcbiAgICAgKiBpZ25vcmUgdGhlIHNjaGVtZS1zcGVjaWZpYyBlbmNvZGluZyBydWxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBza2lwRW5jb2RpbmcgRG8gbm90IGVuY29kZSB0aGUgcmVzdWx0LCBkZWZhdWx0IGlzIGBmYWxzZWBcbiAgICAgKi9cbiAgICB0b1N0cmluZyhza2lwRW5jb2RpbmcgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gX2FzRm9ybWF0dGVkKHRoaXMsIHNraXBFbmNvZGluZyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHN0YXRpYyByZXZpdmUoZGF0YSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBVUkkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVyaShkYXRhKTtcbiAgICAgICAgICAgIHJlc3VsdC5fZm9ybWF0dGVkID0gKF9hID0gZGF0YS5leHRlcm5hbCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgICAgIHJlc3VsdC5fZnNQYXRoID0gZGF0YS5fc2VwID09PSBfcGF0aFNlcE1hcmtlciA/IChfYiA9IGRhdGEuZnNQYXRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsIDogbnVsbDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBfcGF0aFNlcE1hcmtlciA9IGlzV2luZG93cyA/IDEgOiB1bmRlZmluZWQ7XG4vLyBUaGlzIGNsYXNzIGV4aXN0cyBzbyB0aGF0IFVSSSBpcyBjb21wYXRpYmxlIHdpdGggdnNjb2RlLlVyaSAoQVBJKS5cbmNsYXNzIFVyaSBleHRlbmRzIFVSSSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2Zvcm1hdHRlZCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2ZzUGF0aCA9IG51bGw7XG4gICAgfVxuICAgIGdldCBmc1BhdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZnNQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLl9mc1BhdGggPSB1cmlUb0ZzUGF0aCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZzUGF0aDtcbiAgICB9XG4gICAgdG9TdHJpbmcoc2tpcEVuY29kaW5nID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFza2lwRW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZm9ybWF0dGVkID0gX2FzRm9ybWF0dGVkKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3JtYXR0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBjYWNoZSB0aGF0XG4gICAgICAgICAgICByZXR1cm4gX2FzRm9ybWF0dGVkKHRoaXMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgcmVzID0ge1xuICAgICAgICAgICAgJG1pZDogMSAvKiBNYXJzaGFsbGVkSWQuVXJpICovXG4gICAgICAgIH07XG4gICAgICAgIC8vIGNhY2hlZCBzdGF0ZVxuICAgICAgICBpZiAodGhpcy5fZnNQYXRoKSB7XG4gICAgICAgICAgICByZXMuZnNQYXRoID0gdGhpcy5fZnNQYXRoO1xuICAgICAgICAgICAgcmVzLl9zZXAgPSBfcGF0aFNlcE1hcmtlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZm9ybWF0dGVkKSB7XG4gICAgICAgICAgICByZXMuZXh0ZXJuYWwgPSB0aGlzLl9mb3JtYXR0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gdXJpIGNvbXBvbmVudHNcbiAgICAgICAgaWYgKHRoaXMucGF0aCkge1xuICAgICAgICAgICAgcmVzLnBhdGggPSB0aGlzLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyB0aGlzIGlzbid0IGNvcnJlY3QgYW5kIGNhbiB2aW9sYXRlIHRoZSBVcmlDb21wb25lbnRzIGNvbnRyYWN0IGJ1dFxuICAgICAgICAvLyB0aGlzIGlzIHBhcnQgb2YgdGhlIHZzY29kZS5VcmkgQVBJIGFuZCB3ZSBzaG91bGRuJ3QgY2hhbmdlIGhvdyB0aGF0XG4gICAgICAgIC8vIHdvcmtzIGFueW1vcmVcbiAgICAgICAgaWYgKHRoaXMuc2NoZW1lKSB7XG4gICAgICAgICAgICByZXMuc2NoZW1lID0gdGhpcy5zY2hlbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYXV0aG9yaXR5KSB7XG4gICAgICAgICAgICByZXMuYXV0aG9yaXR5ID0gdGhpcy5hdXRob3JpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgICAgICAgIHJlcy5xdWVyeSA9IHRoaXMucXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJlcy5mcmFnbWVudCA9IHRoaXMuZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG4vLyByZXNlcnZlZCBjaGFyYWN0ZXJzOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTIuMlxuY29uc3QgZW5jb2RlVGFibGUgPSB7XG4gICAgWzU4IC8qIENoYXJDb2RlLkNvbG9uICovXTogJyUzQScsIC8vIGdlbi1kZWxpbXNcbiAgICBbNDcgLyogQ2hhckNvZGUuU2xhc2ggKi9dOiAnJTJGJyxcbiAgICBbNjMgLyogQ2hhckNvZGUuUXVlc3Rpb25NYXJrICovXTogJyUzRicsXG4gICAgWzM1IC8qIENoYXJDb2RlLkhhc2ggKi9dOiAnJTIzJyxcbiAgICBbOTEgLyogQ2hhckNvZGUuT3BlblNxdWFyZUJyYWNrZXQgKi9dOiAnJTVCJyxcbiAgICBbOTMgLyogQ2hhckNvZGUuQ2xvc2VTcXVhcmVCcmFja2V0ICovXTogJyU1RCcsXG4gICAgWzY0IC8qIENoYXJDb2RlLkF0U2lnbiAqL106ICclNDAnLFxuICAgIFszMyAvKiBDaGFyQ29kZS5FeGNsYW1hdGlvbk1hcmsgKi9dOiAnJTIxJywgLy8gc3ViLWRlbGltc1xuICAgIFszNiAvKiBDaGFyQ29kZS5Eb2xsYXJTaWduICovXTogJyUyNCcsXG4gICAgWzM4IC8qIENoYXJDb2RlLkFtcGVyc2FuZCAqL106ICclMjYnLFxuICAgIFszOSAvKiBDaGFyQ29kZS5TaW5nbGVRdW90ZSAqL106ICclMjcnLFxuICAgIFs0MCAvKiBDaGFyQ29kZS5PcGVuUGFyZW4gKi9dOiAnJTI4JyxcbiAgICBbNDEgLyogQ2hhckNvZGUuQ2xvc2VQYXJlbiAqL106ICclMjknLFxuICAgIFs0MiAvKiBDaGFyQ29kZS5Bc3RlcmlzayAqL106ICclMkEnLFxuICAgIFs0MyAvKiBDaGFyQ29kZS5QbHVzICovXTogJyUyQicsXG4gICAgWzQ0IC8qIENoYXJDb2RlLkNvbW1hICovXTogJyUyQycsXG4gICAgWzU5IC8qIENoYXJDb2RlLlNlbWljb2xvbiAqL106ICclM0InLFxuICAgIFs2MSAvKiBDaGFyQ29kZS5FcXVhbHMgKi9dOiAnJTNEJyxcbiAgICBbMzIgLyogQ2hhckNvZGUuU3BhY2UgKi9dOiAnJTIwJyxcbn07XG5mdW5jdGlvbiBlbmNvZGVVUklDb21wb25lbnRGYXN0KHVyaUNvbXBvbmVudCwgaXNQYXRoLCBpc0F1dGhvcml0eSkge1xuICAgIGxldCByZXMgPSB1bmRlZmluZWQ7XG4gICAgbGV0IG5hdGl2ZUVuY29kZVBvcyA9IC0xO1xuICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IHVyaUNvbXBvbmVudC5sZW5ndGg7IHBvcysrKSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPSB1cmlDb21wb25lbnQuY2hhckNvZGVBdChwb3MpO1xuICAgICAgICAvLyB1bnJlc2VydmVkIGNoYXJhY3RlcnM6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tMi4zXG4gICAgICAgIGlmICgoY29kZSA+PSA5NyAvKiBDaGFyQ29kZS5hICovICYmIGNvZGUgPD0gMTIyIC8qIENoYXJDb2RlLnogKi8pXG4gICAgICAgICAgICB8fCAoY29kZSA+PSA2NSAvKiBDaGFyQ29kZS5BICovICYmIGNvZGUgPD0gOTAgLyogQ2hhckNvZGUuWiAqLylcbiAgICAgICAgICAgIHx8IChjb2RlID49IDQ4IC8qIENoYXJDb2RlLkRpZ2l0MCAqLyAmJiBjb2RlIDw9IDU3IC8qIENoYXJDb2RlLkRpZ2l0OSAqLylcbiAgICAgICAgICAgIHx8IGNvZGUgPT09IDQ1IC8qIENoYXJDb2RlLkRhc2ggKi9cbiAgICAgICAgICAgIHx8IGNvZGUgPT09IDQ2IC8qIENoYXJDb2RlLlBlcmlvZCAqL1xuICAgICAgICAgICAgfHwgY29kZSA9PT0gOTUgLyogQ2hhckNvZGUuVW5kZXJsaW5lICovXG4gICAgICAgICAgICB8fCBjb2RlID09PSAxMjYgLyogQ2hhckNvZGUuVGlsZGUgKi9cbiAgICAgICAgICAgIHx8IChpc1BhdGggJiYgY29kZSA9PT0gNDcgLyogQ2hhckNvZGUuU2xhc2ggKi8pXG4gICAgICAgICAgICB8fCAoaXNBdXRob3JpdHkgJiYgY29kZSA9PT0gOTEgLyogQ2hhckNvZGUuT3BlblNxdWFyZUJyYWNrZXQgKi8pXG4gICAgICAgICAgICB8fCAoaXNBdXRob3JpdHkgJiYgY29kZSA9PT0gOTMgLyogQ2hhckNvZGUuQ2xvc2VTcXVhcmVCcmFja2V0ICovKVxuICAgICAgICAgICAgfHwgKGlzQXV0aG9yaXR5ICYmIGNvZGUgPT09IDU4IC8qIENoYXJDb2RlLkNvbG9uICovKSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgd2UgYXJlIGRlbGF5aW5nIG5hdGl2ZSBlbmNvZGVcbiAgICAgICAgICAgIGlmIChuYXRpdmVFbmNvZGVQb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZVVSSUNvbXBvbmVudCh1cmlDb21wb25lbnQuc3Vic3RyaW5nKG5hdGl2ZUVuY29kZVBvcywgcG9zKSk7XG4gICAgICAgICAgICAgICAgbmF0aXZlRW5jb2RlUG9zID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSB3cml0ZSBpbnRvIGEgbmV3IHN0cmluZyAoYnkgZGVmYXVsdCB3ZSB0cnkgdG8gcmV0dXJuIHRoZSBwYXJhbSlcbiAgICAgICAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcyArPSB1cmlDb21wb25lbnQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmNvZGluZyBuZWVkZWQsIHdlIG5lZWQgdG8gYWxsb2NhdGUgYSBuZXcgc3RyaW5nXG4gICAgICAgICAgICBpZiAocmVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMgPSB1cmlDb21wb25lbnQuc3Vic3RyKDAsIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayB3aXRoIGRlZmF1bHQgdGFibGUgZmlyc3RcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZWQgPSBlbmNvZGVUYWJsZVtjb2RlXTtcbiAgICAgICAgICAgIGlmIChlc2NhcGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBhcmUgZGVsYXlpbmcgbmF0aXZlIGVuY29kZVxuICAgICAgICAgICAgICAgIGlmIChuYXRpdmVFbmNvZGVQb3MgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyArPSBlbmNvZGVVUklDb21wb25lbnQodXJpQ29tcG9uZW50LnN1YnN0cmluZyhuYXRpdmVFbmNvZGVQb3MsIHBvcykpO1xuICAgICAgICAgICAgICAgICAgICBuYXRpdmVFbmNvZGVQb3MgPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIGVzY2FwZWQgdmFyaWFudCB0byByZXN1bHRcbiAgICAgICAgICAgICAgICByZXMgKz0gZXNjYXBlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5hdGl2ZUVuY29kZVBvcyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2UgbmF0aXZlIGVuY29kZSBvbmx5IHdoZW4gbmVlZGVkXG4gICAgICAgICAgICAgICAgbmF0aXZlRW5jb2RlUG9zID0gcG9zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChuYXRpdmVFbmNvZGVQb3MgIT09IC0xKSB7XG4gICAgICAgIHJlcyArPSBlbmNvZGVVUklDb21wb25lbnQodXJpQ29tcG9uZW50LnN1YnN0cmluZyhuYXRpdmVFbmNvZGVQb3MpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcyAhPT0gdW5kZWZpbmVkID8gcmVzIDogdXJpQ29tcG9uZW50O1xufVxuZnVuY3Rpb24gZW5jb2RlVVJJQ29tcG9uZW50TWluaW1hbChwYXRoKSB7XG4gICAgbGV0IHJlcyA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBwYXRoLmxlbmd0aDsgcG9zKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdChwb3MpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMzUgLyogQ2hhckNvZGUuSGFzaCAqLyB8fCBjb2RlID09PSA2MyAvKiBDaGFyQ29kZS5RdWVzdGlvbk1hcmsgKi8pIHtcbiAgICAgICAgICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcyA9IHBhdGguc3Vic3RyKDAsIHBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgKz0gZW5jb2RlVGFibGVbY29kZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXMgKz0gcGF0aFtwb3NdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMgIT09IHVuZGVmaW5lZCA/IHJlcyA6IHBhdGg7XG59XG4vKipcbiAqIENvbXB1dGUgYGZzUGF0aGAgZm9yIHRoZSBnaXZlbiB1cmlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVyaVRvRnNQYXRoKHVyaSwga2VlcERyaXZlTGV0dGVyQ2FzaW5nKSB7XG4gICAgbGV0IHZhbHVlO1xuICAgIGlmICh1cmkuYXV0aG9yaXR5ICYmIHVyaS5wYXRoLmxlbmd0aCA+IDEgJiYgdXJpLnNjaGVtZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgIC8vIHVuYyBwYXRoOiBmaWxlOi8vc2hhcmVzL2MkL2Zhci9ib29cbiAgICAgICAgdmFsdWUgPSBgLy8ke3VyaS5hdXRob3JpdHl9JHt1cmkucGF0aH1gO1xuICAgIH1cbiAgICBlbHNlIGlmICh1cmkucGF0aC5jaGFyQ29kZUF0KDApID09PSA0NyAvKiBDaGFyQ29kZS5TbGFzaCAqL1xuICAgICAgICAmJiAodXJpLnBhdGguY2hhckNvZGVBdCgxKSA+PSA2NSAvKiBDaGFyQ29kZS5BICovICYmIHVyaS5wYXRoLmNoYXJDb2RlQXQoMSkgPD0gOTAgLyogQ2hhckNvZGUuWiAqLyB8fCB1cmkucGF0aC5jaGFyQ29kZUF0KDEpID49IDk3IC8qIENoYXJDb2RlLmEgKi8gJiYgdXJpLnBhdGguY2hhckNvZGVBdCgxKSA8PSAxMjIgLyogQ2hhckNvZGUueiAqLylcbiAgICAgICAgJiYgdXJpLnBhdGguY2hhckNvZGVBdCgyKSA9PT0gNTggLyogQ2hhckNvZGUuQ29sb24gKi8pIHtcbiAgICAgICAgaWYgKCFrZWVwRHJpdmVMZXR0ZXJDYXNpbmcpIHtcbiAgICAgICAgICAgIC8vIHdpbmRvd3MgZHJpdmUgbGV0dGVyOiBmaWxlOi8vL2M6L2Zhci9ib29cbiAgICAgICAgICAgIHZhbHVlID0gdXJpLnBhdGhbMV0udG9Mb3dlckNhc2UoKSArIHVyaS5wYXRoLnN1YnN0cigyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdXJpLnBhdGguc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBvdGhlciBwYXRoXG4gICAgICAgIHZhbHVlID0gdXJpLnBhdGg7XG4gICAgfVxuICAgIGlmIChpc1dpbmRvd3MpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXC8vZywgJ1xcXFwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBDcmVhdGUgdGhlIGV4dGVybmFsIHZlcnNpb24gb2YgYSB1cmlcbiAqL1xuZnVuY3Rpb24gX2FzRm9ybWF0dGVkKHVyaSwgc2tpcEVuY29kaW5nKSB7XG4gICAgY29uc3QgZW5jb2RlciA9ICFza2lwRW5jb2RpbmdcbiAgICAgICAgPyBlbmNvZGVVUklDb21wb25lbnRGYXN0XG4gICAgICAgIDogZW5jb2RlVVJJQ29tcG9uZW50TWluaW1hbDtcbiAgICBsZXQgcmVzID0gJyc7XG4gICAgbGV0IHsgc2NoZW1lLCBhdXRob3JpdHksIHBhdGgsIHF1ZXJ5LCBmcmFnbWVudCB9ID0gdXJpO1xuICAgIGlmIChzY2hlbWUpIHtcbiAgICAgICAgcmVzICs9IHNjaGVtZTtcbiAgICAgICAgcmVzICs9ICc6JztcbiAgICB9XG4gICAgaWYgKGF1dGhvcml0eSB8fCBzY2hlbWUgPT09ICdmaWxlJykge1xuICAgICAgICByZXMgKz0gX3NsYXNoO1xuICAgICAgICByZXMgKz0gX3NsYXNoO1xuICAgIH1cbiAgICBpZiAoYXV0aG9yaXR5KSB7XG4gICAgICAgIGxldCBpZHggPSBhdXRob3JpdHkuaW5kZXhPZignQCcpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gPHVzZXI+QDxhdXRoPlxuICAgICAgICAgICAgY29uc3QgdXNlcmluZm8gPSBhdXRob3JpdHkuc3Vic3RyKDAsIGlkeCk7XG4gICAgICAgICAgICBhdXRob3JpdHkgPSBhdXRob3JpdHkuc3Vic3RyKGlkeCArIDEpO1xuICAgICAgICAgICAgaWR4ID0gdXNlcmluZm8ubGFzdEluZGV4T2YoJzonKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZXIodXNlcmluZm8sIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyA8dXNlcj46PHBhc3M+QDxhdXRoPlxuICAgICAgICAgICAgICAgIHJlcyArPSBlbmNvZGVyKHVzZXJpbmZvLnN1YnN0cigwLCBpZHgpLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJlcyArPSAnOic7XG4gICAgICAgICAgICAgICAgcmVzICs9IGVuY29kZXIodXNlcmluZm8uc3Vic3RyKGlkeCArIDEpLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgKz0gJ0AnO1xuICAgICAgICB9XG4gICAgICAgIGF1dGhvcml0eSA9IGF1dGhvcml0eS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZHggPSBhdXRob3JpdHkubGFzdEluZGV4T2YoJzonKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJlcyArPSBlbmNvZGVyKGF1dGhvcml0eSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gPGF1dGg+Ojxwb3J0PlxuICAgICAgICAgICAgcmVzICs9IGVuY29kZXIoYXV0aG9yaXR5LnN1YnN0cigwLCBpZHgpLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICByZXMgKz0gYXV0aG9yaXR5LnN1YnN0cihpZHgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoKSB7XG4gICAgICAgIC8vIGxvd2VyLWNhc2Ugd2luZG93cyBkcml2ZSBsZXR0ZXJzIGluIC9DOi9mZmYgb3IgQzovZmZmXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA+PSAzICYmIHBhdGguY2hhckNvZGVBdCgwKSA9PT0gNDcgLyogQ2hhckNvZGUuU2xhc2ggKi8gJiYgcGF0aC5jaGFyQ29kZUF0KDIpID09PSA1OCAvKiBDaGFyQ29kZS5Db2xvbiAqLykge1xuICAgICAgICAgICAgY29uc3QgY29kZSA9IHBhdGguY2hhckNvZGVBdCgxKTtcbiAgICAgICAgICAgIGlmIChjb2RlID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgY29kZSA8PSA5MCAvKiBDaGFyQ29kZS5aICovKSB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IGAvJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAzMil9OiR7cGF0aC5zdWJzdHIoMyl9YDsgLy8gXCIvYzpcIi5sZW5ndGggPT09IDNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXRoLmxlbmd0aCA+PSAyICYmIHBhdGguY2hhckNvZGVBdCgxKSA9PT0gNTggLyogQ2hhckNvZGUuQ29sb24gKi8pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICBpZiAoY29kZSA+PSA2NSAvKiBDaGFyQ29kZS5BICovICYmIGNvZGUgPD0gOTAgLyogQ2hhckNvZGUuWiAqLykge1xuICAgICAgICAgICAgICAgIHBhdGggPSBgJHtTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUgKyAzMil9OiR7cGF0aC5zdWJzdHIoMil9YDsgLy8gXCIvYzpcIi5sZW5ndGggPT09IDNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBlbmNvZGUgdGhlIHJlc3Qgb2YgdGhlIHBhdGhcbiAgICAgICAgcmVzICs9IGVuY29kZXIocGF0aCwgdHJ1ZSwgZmFsc2UpO1xuICAgIH1cbiAgICBpZiAocXVlcnkpIHtcbiAgICAgICAgcmVzICs9ICc/JztcbiAgICAgICAgcmVzICs9IGVuY29kZXIocXVlcnksIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChmcmFnbWVudCkge1xuICAgICAgICByZXMgKz0gJyMnO1xuICAgICAgICByZXMgKz0gIXNraXBFbmNvZGluZyA/IGVuY29kZVVSSUNvbXBvbmVudEZhc3QoZnJhZ21lbnQsIGZhbHNlLCBmYWxzZSkgOiBmcmFnbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIC0tLSBkZWNvZGVcbmZ1bmN0aW9uIGRlY29kZVVSSUNvbXBvbmVudEdyYWNlZnVsKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgMykgKyBkZWNvZGVVUklDb21wb25lbnRHcmFjZWZ1bChzdHIuc3Vic3RyKDMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdHI7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBfckVuY29kZWRBc0hleCA9IC8oJVswLTlBLVphLXpdWzAtOUEtWmEtel0pKy9nO1xuZnVuY3Rpb24gcGVyY2VudERlY29kZShzdHIpIHtcbiAgICBpZiAoIXN0ci5tYXRjaChfckVuY29kZWRBc0hleCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKF9yRW5jb2RlZEFzSGV4LCAobWF0Y2gpID0+IGRlY29kZVVSSUNvbXBvbmVudEdyYWNlZnVsKG1hdGNoKSk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogQSBwb3NpdGlvbiBpbiB0aGUgZWRpdG9yLlxuICovXG5leHBvcnQgY2xhc3MgUG9zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGxpbmVOdW1iZXIsIGNvbHVtbikge1xuICAgICAgICB0aGlzLmxpbmVOdW1iZXIgPSBsaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHBvc2l0aW9uIGZyb20gdGhpcyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdMaW5lTnVtYmVyIG5ldyBsaW5lIG51bWJlclxuICAgICAqIEBwYXJhbSBuZXdDb2x1bW4gbmV3IGNvbHVtblxuICAgICAqL1xuICAgIHdpdGgobmV3TGluZU51bWJlciA9IHRoaXMubGluZU51bWJlciwgbmV3Q29sdW1uID0gdGhpcy5jb2x1bW4pIHtcbiAgICAgICAgaWYgKG5ld0xpbmVOdW1iZXIgPT09IHRoaXMubGluZU51bWJlciAmJiBuZXdDb2x1bW4gPT09IHRoaXMuY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24obmV3TGluZU51bWJlciwgbmV3Q29sdW1uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXJpdmUgYSBuZXcgcG9zaXRpb24gZnJvbSB0aGlzIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlbHRhTGluZU51bWJlciBsaW5lIG51bWJlciBkZWx0YVxuICAgICAqIEBwYXJhbSBkZWx0YUNvbHVtbiBjb2x1bW4gZGVsdGFcbiAgICAgKi9cbiAgICBkZWx0YShkZWx0YUxpbmVOdW1iZXIgPSAwLCBkZWx0YUNvbHVtbiA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aCh0aGlzLmxpbmVOdW1iZXIgKyBkZWx0YUxpbmVOdW1iZXIsIHRoaXMuY29sdW1uICsgZGVsdGFDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoaXMgcG9zaXRpb24gZXF1YWxzIG90aGVyIHBvc2l0aW9uXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBQb3NpdGlvbi5lcXVhbHModGhpcywgb3RoZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHBvc2l0aW9uIGBhYCBlcXVhbHMgcG9zaXRpb24gYGJgXG4gICAgICovXG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICghIWEgJiZcbiAgICAgICAgICAgICEhYiAmJlxuICAgICAgICAgICAgYS5saW5lTnVtYmVyID09PSBiLmxpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgIGEuY29sdW1uID09PSBiLmNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgb3RoZXIgcG9zaXRpb24uXG4gICAgICogSWYgdGhlIHR3byBwb3NpdGlvbnMgYXJlIGVxdWFsLCB0aGUgcmVzdWx0IHdpbGwgYmUgZmFsc2UuXG4gICAgICovXG4gICAgaXNCZWZvcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmlzQmVmb3JlKHRoaXMsIG90aGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBgYWAgaXMgYmVmb3JlIHBvc2l0aW9uIGBiYC5cbiAgICAgKiBJZiB0aGUgdHdvIHBvc2l0aW9ucyBhcmUgZXF1YWwsIHRoZSByZXN1bHQgd2lsbCBiZSBmYWxzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCZWZvcmUoYSwgYikge1xuICAgICAgICBpZiAoYS5saW5lTnVtYmVyIDwgYi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYi5saW5lTnVtYmVyIDwgYS5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEuY29sdW1uIDwgYi5jb2x1bW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhpcyBwb3NpdGlvbiBpcyBiZWZvcmUgb3RoZXIgcG9zaXRpb24uXG4gICAgICogSWYgdGhlIHR3byBwb3NpdGlvbnMgYXJlIGVxdWFsLCB0aGUgcmVzdWx0IHdpbGwgYmUgdHJ1ZS5cbiAgICAgKi9cbiAgICBpc0JlZm9yZU9yRXF1YWwob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmlzQmVmb3JlT3JFcXVhbCh0aGlzLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgcG9zaXRpb24gYGFgIGlzIGJlZm9yZSBwb3NpdGlvbiBgYmAuXG4gICAgICogSWYgdGhlIHR3byBwb3NpdGlvbnMgYXJlIGVxdWFsLCB0aGUgcmVzdWx0IHdpbGwgYmUgdHJ1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNCZWZvcmVPckVxdWFsKGEsIGIpIHtcbiAgICAgICAgaWYgKGEubGluZU51bWJlciA8IGIubGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIubGluZU51bWJlciA8IGEubGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmNvbHVtbiA8PSBiLmNvbHVtbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IGNvbXBhcmVzIHBvc2l0aW9ucywgdXNlZnVsIGZvciBzb3J0aW5nXG4gICAgICovXG4gICAgc3RhdGljIGNvbXBhcmUoYSwgYikge1xuICAgICAgICBjb25zdCBhTGluZU51bWJlciA9IGEubGluZU51bWJlciB8IDA7XG4gICAgICAgIGNvbnN0IGJMaW5lTnVtYmVyID0gYi5saW5lTnVtYmVyIHwgMDtcbiAgICAgICAgaWYgKGFMaW5lTnVtYmVyID09PSBiTGluZU51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgYUNvbHVtbiA9IGEuY29sdW1uIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IGJDb2x1bW4gPSBiLmNvbHVtbiB8IDA7XG4gICAgICAgICAgICByZXR1cm4gYUNvbHVtbiAtIGJDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFMaW5lTnVtYmVyIC0gYkxpbmVOdW1iZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb25lIHRoaXMgcG9zaXRpb24uXG4gICAgICovXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lTnVtYmVyLCB0aGlzLmNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdG8gYSBodW1hbi1yZWFkYWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICcoJyArIHRoaXMubGluZU51bWJlciArICcsJyArIHRoaXMuY29sdW1uICsgJyknO1xuICAgIH1cbiAgICAvLyAtLS1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBgUG9zaXRpb25gIGZyb20gYW4gYElQb3NpdGlvbmAuXG4gICAgICovXG4gICAgc3RhdGljIGxpZnQocG9zKSB7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocG9zLmxpbmVOdW1iZXIsIHBvcy5jb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJUG9zaXRpb25gLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0lQb3NpdGlvbihvYmopIHtcbiAgICAgICAgcmV0dXJuIChvYmpcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLmxpbmVOdW1iZXIgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouY29sdW1uID09PSAnbnVtYmVyJykpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uXG4gICAgICAgIH07XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4vcG9zaXRpb24uanMnO1xuLyoqXG4gKiBBIHJhbmdlIGluIHRoZSBlZGl0b3IuIChzdGFydExpbmVOdW1iZXIsc3RhcnRDb2x1bW4pIGlzIDw9IChlbmRMaW5lTnVtYmVyLGVuZENvbHVtbilcbiAqL1xuZXhwb3J0IGNsYXNzIFJhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pIHtcbiAgICAgICAgaWYgKChzdGFydExpbmVOdW1iZXIgPiBlbmRMaW5lTnVtYmVyKSB8fCAoc3RhcnRMaW5lTnVtYmVyID09PSBlbmRMaW5lTnVtYmVyICYmIHN0YXJ0Q29sdW1uID4gZW5kQ29sdW1uKSkge1xuICAgICAgICAgICAgdGhpcy5zdGFydExpbmVOdW1iZXIgPSBlbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgdGhpcy5zdGFydENvbHVtbiA9IGVuZENvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kTGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHRoaXMuZW5kQ29sdW1uID0gc3RhcnRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0TGluZU51bWJlciA9IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRDb2x1bW4gPSBzdGFydENvbHVtbjtcbiAgICAgICAgICAgIHRoaXMuZW5kTGluZU51bWJlciA9IGVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICB0aGlzLmVuZENvbHVtbiA9IGVuZENvbHVtbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoaXMgcmFuZ2UgaXMgZW1wdHkuXG4gICAgICovXG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmlzRW1wdHkodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYHJhbmdlYCBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBzdGF0aWMgaXNFbXB0eShyYW5nZSkge1xuICAgICAgICByZXR1cm4gKHJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiByYW5nZS5zdGFydENvbHVtbiA9PT0gcmFuZ2UuZW5kQ29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBwb3NpdGlvbiBpcyBpbiB0aGlzIHJhbmdlLiBJZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIGVkZ2VzLCB3aWxsIHJldHVybiB0cnVlLlxuICAgICAqL1xuICAgIGNvbnRhaW5zUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmNvbnRhaW5zUG9zaXRpb24odGhpcywgcG9zaXRpb24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGBwb3NpdGlvbmAgaXMgaW4gYHJhbmdlYC4gSWYgdGhlIHBvc2l0aW9uIGlzIGF0IHRoZSBlZGdlcywgd2lsbCByZXR1cm4gdHJ1ZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udGFpbnNQb3NpdGlvbihyYW5nZSwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIgfHwgcG9zaXRpb24ubGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIHBvc2l0aW9uLmNvbHVtbiA8IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgcG9zaXRpb24uY29sdW1uID4gcmFuZ2UuZW5kQ29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYHBvc2l0aW9uYCBpcyBpbiBgcmFuZ2VgLiBJZiB0aGUgcG9zaXRpb24gaXMgYXQgdGhlIGVkZ2VzLCB3aWxsIHJldHVybiBmYWxzZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgc3RyaWN0Q29udGFpbnNQb3NpdGlvbihyYW5nZSwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIgfHwgcG9zaXRpb24ubGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24ubGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIHBvc2l0aW9uLmNvbHVtbiA8PSByYW5nZS5zdGFydENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbi5saW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyICYmIHBvc2l0aW9uLmNvbHVtbiA+PSByYW5nZS5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiByYW5nZSBpcyBpbiB0aGlzIHJhbmdlLiBJZiB0aGUgcmFuZ2UgaXMgZXF1YWwgdG8gdGhpcyByYW5nZSwgd2lsbCByZXR1cm4gdHJ1ZS5cbiAgICAgKi9cbiAgICBjb250YWluc1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5jb250YWluc1JhbmdlKHRoaXMsIHJhbmdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgb3RoZXJSYW5nZWAgaXMgaW4gYHJhbmdlYC4gSWYgdGhlIHJhbmdlcyBhcmUgZXF1YWwsIHdpbGwgcmV0dXJuIHRydWUuXG4gICAgICovXG4gICAgc3RhdGljIGNvbnRhaW5zUmFuZ2UocmFuZ2UsIG90aGVyUmFuZ2UpIHtcbiAgICAgICAgaWYgKG90aGVyUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIHx8IG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIgfHwgb3RoZXJSYW5nZS5lbmRMaW5lTnVtYmVyID4gcmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICYmIG90aGVyUmFuZ2Uuc3RhcnRDb2x1bW4gPCByYW5nZS5zdGFydENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIgJiYgb3RoZXJSYW5nZS5lbmRDb2x1bW4gPiByYW5nZS5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiBgcmFuZ2VgIGlzIHN0cmljdGx5IGluIHRoaXMgcmFuZ2UuIGByYW5nZWAgbXVzdCBzdGFydCBhZnRlciBhbmQgZW5kIGJlZm9yZSB0aGlzIHJhbmdlIGZvciB0aGUgcmVzdWx0IHRvIGJlIHRydWUuXG4gICAgICovXG4gICAgc3RyaWN0Q29udGFpbnNSYW5nZShyYW5nZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2Uuc3RyaWN0Q29udGFpbnNSYW5nZSh0aGlzLCByYW5nZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYG90aGVyUmFuZ2VgIGlzIHN0cmljdGx5IGluIGByYW5nZWAgKG11c3Qgc3RhcnQgYWZ0ZXIsIGFuZCBlbmQgYmVmb3JlKS4gSWYgdGhlIHJhbmdlcyBhcmUgZXF1YWwsIHdpbGwgcmV0dXJuIGZhbHNlLlxuICAgICAqL1xuICAgIHN0YXRpYyBzdHJpY3RDb250YWluc1JhbmdlKHJhbmdlLCBvdGhlclJhbmdlKSB7XG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TGluZU51bWJlciA8IHJhbmdlLnN0YXJ0TGluZU51bWJlciB8fCBvdGhlclJhbmdlLmVuZExpbmVOdW1iZXIgPCByYW5nZS5zdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJSYW5nZS5zdGFydExpbmVOdW1iZXIgPiByYW5nZS5lbmRMaW5lTnVtYmVyIHx8IG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA+IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJSYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHJhbmdlLnN0YXJ0TGluZU51bWJlciAmJiBvdGhlclJhbmdlLnN0YXJ0Q29sdW1uIDw9IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyUmFuZ2UuZW5kTGluZU51bWJlciA9PT0gcmFuZ2UuZW5kTGluZU51bWJlciAmJiBvdGhlclJhbmdlLmVuZENvbHVtbiA+PSByYW5nZS5lbmRDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZXVuaW9uIG9mIHRoZSB0d28gcmFuZ2VzLlxuICAgICAqIFRoZSBzbWFsbGVzdCBwb3NpdGlvbiB3aWxsIGJlIHVzZWQgYXMgdGhlIHN0YXJ0IHBvaW50LCBhbmQgdGhlIGxhcmdlc3Qgb25lIGFzIHRoZSBlbmQgcG9pbnQuXG4gICAgICovXG4gICAgcGx1c1JhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5wbHVzUmFuZ2UodGhpcywgcmFuZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJldW5pb24gb2YgdGhlIHR3byByYW5nZXMuXG4gICAgICogVGhlIHNtYWxsZXN0IHBvc2l0aW9uIHdpbGwgYmUgdXNlZCBhcyB0aGUgc3RhcnQgcG9pbnQsIGFuZCB0aGUgbGFyZ2VzdCBvbmUgYXMgdGhlIGVuZCBwb2ludC5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGx1c1JhbmdlKGEsIGIpIHtcbiAgICAgICAgbGV0IHN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgbGV0IHN0YXJ0Q29sdW1uO1xuICAgICAgICBsZXQgZW5kTGluZU51bWJlcjtcbiAgICAgICAgbGV0IGVuZENvbHVtbjtcbiAgICAgICAgaWYgKGIuc3RhcnRMaW5lTnVtYmVyIDwgYS5zdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IGIuc3RhcnRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgc3RhcnRDb2x1bW4gPSBiLnN0YXJ0Q29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuc3RhcnRMaW5lTnVtYmVyID09PSBhLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gYi5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IE1hdGgubWluKGIuc3RhcnRDb2x1bW4sIGEuc3RhcnRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyID0gYS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgICAgICBzdGFydENvbHVtbiA9IGEuc3RhcnRDb2x1bW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIuZW5kTGluZU51bWJlciA+IGEuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgZW5kTGluZU51bWJlciA9IGIuZW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgIGVuZENvbHVtbiA9IGIuZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGIuZW5kTGluZU51bWJlciA9PT0gYS5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICBlbmRMaW5lTnVtYmVyID0gYi5lbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgZW5kQ29sdW1uID0gTWF0aC5tYXgoYi5lbmRDb2x1bW4sIGEuZW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZExpbmVOdW1iZXIgPSBhLmVuZExpbmVOdW1iZXI7XG4gICAgICAgICAgICBlbmRDb2x1bW4gPSBhLmVuZENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgaW50ZXJzZWN0aW9uIG9mIHRoZSB0d28gcmFuZ2VzLlxuICAgICAqL1xuICAgIGludGVyc2VjdFJhbmdlcyhyYW5nZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2UuaW50ZXJzZWN0UmFuZ2VzKHRoaXMsIHJhbmdlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByYW5nZXMuXG4gICAgICovXG4gICAgc3RhdGljIGludGVyc2VjdFJhbmdlcyhhLCBiKSB7XG4gICAgICAgIGxldCByZXN1bHRTdGFydExpbmVOdW1iZXIgPSBhLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgbGV0IHJlc3VsdFN0YXJ0Q29sdW1uID0gYS5zdGFydENvbHVtbjtcbiAgICAgICAgbGV0IHJlc3VsdEVuZExpbmVOdW1iZXIgPSBhLmVuZExpbmVOdW1iZXI7XG4gICAgICAgIGxldCByZXN1bHRFbmRDb2x1bW4gPSBhLmVuZENvbHVtbjtcbiAgICAgICAgY29uc3Qgb3RoZXJTdGFydExpbmVOdW1iZXIgPSBiLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgY29uc3Qgb3RoZXJTdGFydENvbHVtbiA9IGIuc3RhcnRDb2x1bW47XG4gICAgICAgIGNvbnN0IG90aGVyRW5kTGluZU51bWJlciA9IGIuZW5kTGluZU51bWJlcjtcbiAgICAgICAgY29uc3Qgb3RoZXJFbmRDb2x1bW4gPSBiLmVuZENvbHVtbjtcbiAgICAgICAgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA8IG90aGVyU3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXN1bHRTdGFydExpbmVOdW1iZXIgPSBvdGhlclN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIHJlc3VsdFN0YXJ0Q29sdW1uID0gb3RoZXJTdGFydENvbHVtbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXN1bHRTdGFydExpbmVOdW1iZXIgPT09IG90aGVyU3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXN1bHRTdGFydENvbHVtbiA9IE1hdGgubWF4KHJlc3VsdFN0YXJ0Q29sdW1uLCBvdGhlclN0YXJ0Q29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0RW5kTGluZU51bWJlciA+IG90aGVyRW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmVzdWx0RW5kTGluZU51bWJlciA9IG90aGVyRW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgIHJlc3VsdEVuZENvbHVtbiA9IG90aGVyRW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdEVuZExpbmVOdW1iZXIgPT09IG90aGVyRW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmVzdWx0RW5kQ29sdW1uID0gTWF0aC5taW4ocmVzdWx0RW5kQ29sdW1uLCBvdGhlckVuZENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgc2VsZWN0aW9uIGlzIG5vdyBlbXB0eVxuICAgICAgICBpZiAocmVzdWx0U3RhcnRMaW5lTnVtYmVyID4gcmVzdWx0RW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdFN0YXJ0TGluZU51bWJlciA9PT0gcmVzdWx0RW5kTGluZU51bWJlciAmJiByZXN1bHRTdGFydENvbHVtbiA+IHJlc3VsdEVuZENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyZXN1bHRTdGFydExpbmVOdW1iZXIsIHJlc3VsdFN0YXJ0Q29sdW1uLCByZXN1bHRFbmRMaW5lTnVtYmVyLCByZXN1bHRFbmRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIHRoaXMgcmFuZ2UgZXF1YWxzIG90aGVyLlxuICAgICAqL1xuICAgIGVxdWFsc1JhbmdlKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5lcXVhbHNSYW5nZSh0aGlzLCBvdGhlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgcmFuZ2UgYGFgIGVxdWFscyBgYmAuXG4gICAgICovXG4gICAgc3RhdGljIGVxdWFsc1JhbmdlKGEsIGIpIHtcbiAgICAgICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCEhYSAmJlxuICAgICAgICAgICAgISFiICYmXG4gICAgICAgICAgICBhLnN0YXJ0TGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgIGEuc3RhcnRDb2x1bW4gPT09IGIuc3RhcnRDb2x1bW4gJiZcbiAgICAgICAgICAgIGEuZW5kTGluZU51bWJlciA9PT0gYi5lbmRMaW5lTnVtYmVyICYmXG4gICAgICAgICAgICBhLmVuZENvbHVtbiA9PT0gYi5lbmRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVuZCBwb3NpdGlvbiAod2hpY2ggd2lsbCBiZSBhZnRlciBvciBlcXVhbCB0byB0aGUgc3RhcnQgcG9zaXRpb24pXG4gICAgICovXG4gICAgZ2V0RW5kUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5nZXRFbmRQb3NpdGlvbih0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBlbmQgcG9zaXRpb24gKHdoaWNoIHdpbGwgYmUgYWZ0ZXIgb3IgZXF1YWwgdG8gdGhlIHN0YXJ0IHBvc2l0aW9uKVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRFbmRQb3NpdGlvbihyYW5nZSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHJhbmdlLmVuZExpbmVOdW1iZXIsIHJhbmdlLmVuZENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3RhcnQgcG9zaXRpb24gKHdoaWNoIHdpbGwgYmUgYmVmb3JlIG9yIGVxdWFsIHRvIHRoZSBlbmQgcG9zaXRpb24pXG4gICAgICovXG4gICAgZ2V0U3RhcnRQb3NpdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmdldFN0YXJ0UG9zaXRpb24odGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgc3RhcnQgcG9zaXRpb24gKHdoaWNoIHdpbGwgYmUgYmVmb3JlIG9yIGVxdWFsIHRvIHRoZSBlbmQgcG9zaXRpb24pXG4gICAgICovXG4gICAgc3RhdGljIGdldFN0YXJ0UG9zaXRpb24ocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHRvIGEgdXNlciBwcmVzZW50YWJsZSBzdHJpbmcgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnWycgKyB0aGlzLnN0YXJ0TGluZU51bWJlciArICcsJyArIHRoaXMuc3RhcnRDb2x1bW4gKyAnIC0+ICcgKyB0aGlzLmVuZExpbmVOdW1iZXIgKyAnLCcgKyB0aGlzLmVuZENvbHVtbiArICddJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHJhbmdlIHVzaW5nIHRoaXMgcmFuZ2UncyBzdGFydCBwb3NpdGlvbiwgYW5kIHVzaW5nIGVuZExpbmVOdW1iZXIgYW5kIGVuZENvbHVtbiBhcyB0aGUgZW5kIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHNldEVuZFBvc2l0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbikge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnRMaW5lTnVtYmVyLCB0aGlzLnN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIGVuZCBwb3NpdGlvbiwgYW5kIHVzaW5nIHN0YXJ0TGluZU51bWJlciBhbmQgc3RhcnRDb2x1bW4gYXMgdGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIHNldFN0YXJ0UG9zaXRpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbikge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIHRoaXMuZW5kTGluZU51bWJlciwgdGhpcy5lbmRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZW1wdHkgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGNvbGxhcHNlVG9TdGFydCgpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmNvbGxhcHNlVG9TdGFydCh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGVtcHR5IHJhbmdlIHVzaW5nIHRoaXMgcmFuZ2UncyBzdGFydCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29sbGFwc2VUb1N0YXJ0KHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbiwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5zdGFydENvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBlbXB0eSByYW5nZSB1c2luZyB0aGlzIHJhbmdlJ3MgZW5kIHBvc2l0aW9uLlxuICAgICAqL1xuICAgIGNvbGxhcHNlVG9FbmQoKSB7XG4gICAgICAgIHJldHVybiBSYW5nZS5jb2xsYXBzZVRvRW5kKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgZW1wdHkgcmFuZ2UgdXNpbmcgdGhpcyByYW5nZSdzIGVuZCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29sbGFwc2VUb0VuZChyYW5nZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLmVuZExpbmVOdW1iZXIsIHJhbmdlLmVuZENvbHVtbiwgcmFuZ2UuZW5kTGluZU51bWJlciwgcmFuZ2UuZW5kQ29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW92ZXMgdGhlIHJhbmdlIGJ5IHRoZSBnaXZlbiBhbW91bnQgb2YgbGluZXMuXG4gICAgICovXG4gICAgZGVsdGEobGluZUNvdW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIgKyBsaW5lQ291bnQsIHRoaXMuc3RhcnRDb2x1bW4sIHRoaXMuZW5kTGluZU51bWJlciArIGxpbmVDb3VudCwgdGhpcy5lbmRDb2x1bW4pO1xuICAgIH1cbiAgICAvLyAtLS1cbiAgICBzdGF0aWMgZnJvbVBvc2l0aW9ucyhzdGFydCwgZW5kID0gc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydC5saW5lTnVtYmVyLCBzdGFydC5jb2x1bW4sIGVuZC5saW5lTnVtYmVyLCBlbmQuY29sdW1uKTtcbiAgICB9XG4gICAgc3RhdGljIGxpZnQocmFuZ2UpIHtcbiAgICAgICAgaWYgKCFyYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZShyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLnN0YXJ0Q29sdW1uLCByYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUZXN0IGlmIGBvYmpgIGlzIGFuIGBJUmFuZ2VgLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0lSYW5nZShvYmopIHtcbiAgICAgICAgcmV0dXJuIChvYmpcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLnN0YXJ0TGluZU51bWJlciA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5zdGFydENvbHVtbiA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5lbmRMaW5lTnVtYmVyID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLmVuZENvbHVtbiA9PT0gJ251bWJlcicpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVzdCBpZiB0aGUgdHdvIHJhbmdlcyBhcmUgdG91Y2hpbmcgaW4gYW55IHdheS5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXJlSW50ZXJzZWN0aW5nT3JUb3VjaGluZyhhLCBiKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGBhYCBpcyBiZWZvcmUgYGJgXG4gICAgICAgIGlmIChhLmVuZExpbmVOdW1iZXIgPCBiLnN0YXJ0TGluZU51bWJlciB8fCAoYS5lbmRMaW5lTnVtYmVyID09PSBiLnN0YXJ0TGluZU51bWJlciAmJiBhLmVuZENvbHVtbiA8IGIuc3RhcnRDb2x1bW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgYGJgIGlzIGJlZm9yZSBgYWBcbiAgICAgICAgaWYgKGIuZW5kTGluZU51bWJlciA8IGEuc3RhcnRMaW5lTnVtYmVyIHx8IChiLmVuZExpbmVOdW1iZXIgPT09IGEuc3RhcnRMaW5lTnVtYmVyICYmIGIuZW5kQ29sdW1uIDwgYS5zdGFydENvbHVtbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVzZSByYW5nZXMgbXVzdCBpbnRlcnNlY3RcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhlIHR3byByYW5nZXMgYXJlIGludGVyc2VjdGluZy4gSWYgdGhlIHJhbmdlcyBhcmUgdG91Y2hpbmcgaXQgcmV0dXJucyB0cnVlLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcmVJbnRlcnNlY3RpbmcoYSwgYikge1xuICAgICAgICAvLyBDaGVjayBpZiBgYWAgaXMgYmVmb3JlIGBiYFxuICAgICAgICBpZiAoYS5lbmRMaW5lTnVtYmVyIDwgYi5zdGFydExpbmVOdW1iZXIgfHwgKGEuZW5kTGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIgJiYgYS5lbmRDb2x1bW4gPD0gYi5zdGFydENvbHVtbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBgYmAgaXMgYmVmb3JlIGBhYFxuICAgICAgICBpZiAoYi5lbmRMaW5lTnVtYmVyIDwgYS5zdGFydExpbmVOdW1iZXIgfHwgKGIuZW5kTGluZU51bWJlciA9PT0gYS5zdGFydExpbmVOdW1iZXIgJiYgYi5lbmRDb2x1bW4gPD0gYS5zdGFydENvbHVtbikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVzZSByYW5nZXMgbXVzdCBpbnRlcnNlY3RcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCBjb21wYXJlcyByYW5nZXMsIHVzZWZ1bCBmb3Igc29ydGluZyByYW5nZXNcbiAgICAgKiBJdCB3aWxsIGZpcnN0IGNvbXBhcmUgcmFuZ2VzIG9uIHRoZSBzdGFydFBvc2l0aW9uIGFuZCB0aGVuIG9uIHRoZSBlbmRQb3NpdGlvblxuICAgICAqL1xuICAgIHN0YXRpYyBjb21wYXJlUmFuZ2VzVXNpbmdTdGFydHMoYSwgYikge1xuICAgICAgICBpZiAoYSAmJiBiKSB7XG4gICAgICAgICAgICBjb25zdCBhU3RhcnRMaW5lTnVtYmVyID0gYS5zdGFydExpbmVOdW1iZXIgfCAwO1xuICAgICAgICAgICAgY29uc3QgYlN0YXJ0TGluZU51bWJlciA9IGIuc3RhcnRMaW5lTnVtYmVyIHwgMDtcbiAgICAgICAgICAgIGlmIChhU3RhcnRMaW5lTnVtYmVyID09PSBiU3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVN0YXJ0Q29sdW1uID0gYS5zdGFydENvbHVtbiB8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgYlN0YXJ0Q29sdW1uID0gYi5zdGFydENvbHVtbiB8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGFTdGFydENvbHVtbiA9PT0gYlN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFFbmRMaW5lTnVtYmVyID0gYS5lbmRMaW5lTnVtYmVyIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYkVuZExpbmVOdW1iZXIgPSBiLmVuZExpbmVOdW1iZXIgfCAwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYUVuZExpbmVOdW1iZXIgPT09IGJFbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhRW5kQ29sdW1uID0gYS5lbmRDb2x1bW4gfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYkVuZENvbHVtbiA9IGIuZW5kQ29sdW1uIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhRW5kQ29sdW1uIC0gYkVuZENvbHVtbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYUVuZExpbmVOdW1iZXIgLSBiRW5kTGluZU51bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFTdGFydENvbHVtbiAtIGJTdGFydENvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhU3RhcnRMaW5lTnVtYmVyIC0gYlN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhRXhpc3RzID0gKGEgPyAxIDogMCk7XG4gICAgICAgIGNvbnN0IGJFeGlzdHMgPSAoYiA/IDEgOiAwKTtcbiAgICAgICAgcmV0dXJuIGFFeGlzdHMgLSBiRXhpc3RzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY29tcGFyZXMgcmFuZ2VzLCB1c2VmdWwgZm9yIHNvcnRpbmcgcmFuZ2VzXG4gICAgICogSXQgd2lsbCBmaXJzdCBjb21wYXJlIHJhbmdlcyBvbiB0aGUgZW5kUG9zaXRpb24gYW5kIHRoZW4gb24gdGhlIHN0YXJ0UG9zaXRpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgY29tcGFyZVJhbmdlc1VzaW5nRW5kcyhhLCBiKSB7XG4gICAgICAgIGlmIChhLmVuZExpbmVOdW1iZXIgPT09IGIuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgaWYgKGEuZW5kQ29sdW1uID09PSBiLmVuZENvbHVtbikge1xuICAgICAgICAgICAgICAgIGlmIChhLnN0YXJ0TGluZU51bWJlciA9PT0gYi5zdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnRDb2x1bW4gLSBiLnN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYS5zdGFydExpbmVOdW1iZXIgLSBiLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLmVuZENvbHVtbiAtIGIuZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhLmVuZExpbmVOdW1iZXIgLSBiLmVuZExpbmVOdW1iZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhlIHJhbmdlIHNwYW5zIG11bHRpcGxlIGxpbmVzLlxuICAgICAqL1xuICAgIHN0YXRpYyBzcGFuc011bHRpcGxlTGluZXMocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLmVuZExpbmVOdW1iZXIgPiByYW5nZS5zdGFydExpbmVOdW1iZXI7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuIiwiLyoqXG4gKiBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5LlxuICogQHBhcmFtIG4gV2hpY2ggZWxlbWVudCBmcm9tIHRoZSBlbmQgKGRlZmF1bHQgaXMgemVybykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWlsKGFycmF5LCBuID0gMCkge1xuICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAoMSArIG4pXTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0YWlsMihhcnIpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFpbCBjYWxsJyk7XG4gICAgfVxuICAgIHJldHVybiBbYXJyLnNsaWNlKDAsIGFyci5sZW5ndGggLSAxKSwgYXJyW2Fyci5sZW5ndGggLSAxXV07XG59XG5leHBvcnQgZnVuY3Rpb24gZXF1YWxzKG9uZSwgb3RoZXIsIGl0ZW1FcXVhbHMgPSAoYSwgYikgPT4gYSA9PT0gYikge1xuICAgIGlmIChvbmUgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIW9uZSB8fCAhb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAob25lLmxlbmd0aCAhPT0gb3RoZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG9uZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAoIWl0ZW1FcXVhbHMob25lW2ldLCBvdGhlcltpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogUmVtb3ZlIHRoZSBlbGVtZW50IGF0IGBpbmRleGAgYnkgcmVwbGFjaW5nIGl0IHdpdGggdGhlIGxhc3QgZWxlbWVudC4gVGhpcyBpcyBmYXN0ZXIgdGhhbiBgc3BsaWNlYFxuICogYnV0IGNoYW5nZXMgdGhlIG9yZGVyIG9mIHRoZSBhcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRmFzdFdpdGhvdXRLZWVwaW5nT3JkZXIoYXJyYXksIGluZGV4KSB7XG4gICAgY29uc3QgbGFzdCA9IGFycmF5Lmxlbmd0aCAtIDE7XG4gICAgaWYgKGluZGV4IDwgbGFzdCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBhcnJheVtsYXN0XTtcbiAgICB9XG4gICAgYXJyYXkucG9wKCk7XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgYmluYXJ5IHNlYXJjaCBhbGdvcml0aG0gb3ZlciBhIHNvcnRlZCBhcnJheS5cbiAqXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IGJlaW5nIHNlYXJjaGVkLlxuICogQHBhcmFtIGtleSBUaGUgdmFsdWUgd2Ugc2VhcmNoIGZvci5cbiAqIEBwYXJhbSBjb21wYXJhdG9yIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0d28gYXJyYXkgZWxlbWVudHMgYW5kIHJldHVybnMgemVyb1xuICogICBpZiB0aGV5IGFyZSBlcXVhbCwgYSBuZWdhdGl2ZSBudW1iZXIgaWYgdGhlIGZpcnN0IGVsZW1lbnQgcHJlY2VkZXMgdGhlXG4gKiAgIHNlY29uZCBvbmUgaW4gdGhlIHNvcnRpbmcgb3JkZXIsIG9yIGEgcG9zaXRpdmUgbnVtYmVyIGlmIHRoZSBzZWNvbmQgZWxlbWVudFxuICogICBwcmVjZWRlcyB0aGUgZmlyc3Qgb25lLlxuICogQHJldHVybiBTZWUge0BsaW5rIGJpbmFyeVNlYXJjaDJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2goYXJyYXksIGtleSwgY29tcGFyYXRvcikge1xuICAgIHJldHVybiBiaW5hcnlTZWFyY2gyKGFycmF5Lmxlbmd0aCwgaSA9PiBjb21wYXJhdG9yKGFycmF5W2ldLCBrZXkpKTtcbn1cbi8qKlxuICogUGVyZm9ybXMgYSBiaW5hcnkgc2VhcmNoIGFsZ29yaXRobSBvdmVyIGEgc29ydGVkIGNvbGxlY3Rpb24uIFVzZWZ1bCBmb3IgY2FzZXNcbiAqIHdoZW4gd2UgbmVlZCB0byBwZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvdmVyIHNvbWV0aGluZyB0aGF0IGlzbid0IGFjdHVhbGx5IGFuXG4gKiBhcnJheSwgYW5kIGNvbnZlcnRpbmcgZGF0YSB0byBhbiBhcnJheSB3b3VsZCBkZWZlYXQgdGhlIHVzZSBvZiBiaW5hcnkgc2VhcmNoXG4gKiBpbiB0aGUgZmlyc3QgcGxhY2UuXG4gKlxuICogQHBhcmFtIGxlbmd0aCBUaGUgY29sbGVjdGlvbiBsZW5ndGguXG4gKiBAcGFyYW0gY29tcGFyZVRvS2V5IEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBpbmRleCBvZiBhbiBlbGVtZW50IGluIHRoZVxuICogICBjb2xsZWN0aW9uIGFuZCByZXR1cm5zIHplcm8gaWYgdGhlIHZhbHVlIGF0IHRoaXMgaW5kZXggaXMgZXF1YWwgdG8gdGhlXG4gKiAgIHNlYXJjaCBrZXksIGEgbmVnYXRpdmUgbnVtYmVyIGlmIHRoZSB2YWx1ZSBwcmVjZWRlcyB0aGUgc2VhcmNoIGtleSBpbiB0aGVcbiAqICAgc29ydGluZyBvcmRlciwgb3IgYSBwb3NpdGl2ZSBudW1iZXIgaWYgdGhlIHNlYXJjaCBrZXkgcHJlY2VkZXMgdGhlIHZhbHVlLlxuICogQHJldHVybiBBIG5vbi1uZWdhdGl2ZSBpbmRleCBvZiBhbiBlbGVtZW50LCBpZiBmb3VuZC4gSWYgbm90IGZvdW5kLCB0aGVcbiAqICAgcmVzdWx0IGlzIC0obisxKSAob3Igfm4sIHVzaW5nIGJpdHdpc2Ugbm90YXRpb24pLCB3aGVyZSBuIGlzIHRoZSBpbmRleFxuICogICB3aGVyZSB0aGUga2V5IHNob3VsZCBiZSBpbnNlcnRlZCB0byBtYWludGFpbiB0aGUgc29ydGluZyBvcmRlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaDIobGVuZ3RoLCBjb21wYXJlVG9LZXkpIHtcbiAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAgIGNvbnN0IG1pZCA9ICgobG93ICsgaGlnaCkgLyAyKSB8IDA7XG4gICAgICAgIGNvbnN0IGNvbXAgPSBjb21wYXJlVG9LZXkobWlkKTtcbiAgICAgICAgaWYgKGNvbXAgPCAwKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXAgPiAwKSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0obG93ICsgMSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcXVpY2tTZWxlY3QobnRoLCBkYXRhLCBjb21wYXJlKSB7XG4gICAgbnRoID0gbnRoIHwgMDtcbiAgICBpZiAobnRoID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgaW5kZXgnKTtcbiAgICB9XG4gICAgY29uc3QgcGl2b3RWYWx1ZSA9IGRhdGFbTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAqIE1hdGgucmFuZG9tKCkpXTtcbiAgICBjb25zdCBsb3dlciA9IFtdO1xuICAgIGNvbnN0IGhpZ2hlciA9IFtdO1xuICAgIGNvbnN0IHBpdm90cyA9IFtdO1xuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZGF0YSkge1xuICAgICAgICBjb25zdCB2YWwgPSBjb21wYXJlKHZhbHVlLCBwaXZvdFZhbHVlKTtcbiAgICAgICAgaWYgKHZhbCA8IDApIHtcbiAgICAgICAgICAgIGxvd2VyLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbCA+IDApIHtcbiAgICAgICAgICAgIGhpZ2hlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBpdm90cy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobnRoIDwgbG93ZXIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBxdWlja1NlbGVjdChudGgsIGxvd2VyLCBjb21wYXJlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobnRoIDwgbG93ZXIubGVuZ3RoICsgcGl2b3RzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGl2b3RzWzBdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHF1aWNrU2VsZWN0KG50aCAtIChsb3dlci5sZW5ndGggKyBwaXZvdHMubGVuZ3RoKSwgaGlnaGVyLCBjb21wYXJlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ3JvdXBCeShkYXRhLCBjb21wYXJlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGN1cnJlbnRHcm91cCA9IHVuZGVmaW5lZDtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZGF0YS5zbGljZSgwKS5zb3J0KGNvbXBhcmUpKSB7XG4gICAgICAgIGlmICghY3VycmVudEdyb3VwIHx8IGNvbXBhcmUoY3VycmVudEdyb3VwWzBdLCBlbGVtZW50KSAhPT0gMCkge1xuICAgICAgICAgICAgY3VycmVudEdyb3VwID0gW2VsZW1lbnRdO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFNwbGl0cyB0aGUgZ2l2ZW4gaXRlbXMgaW50byBhIGxpc3Qgb2YgKG5vbi1lbXB0eSkgZ3JvdXBzLlxuICogYHNob3VsZEJlR3JvdXBlZGAgaXMgdXNlZCB0byBkZWNpZGUgaWYgdHdvIGNvbnNlY3V0aXZlIGl0ZW1zIHNob3VsZCBiZSBpbiB0aGUgc2FtZSBncm91cC5cbiAqIFRoZSBvcmRlciBvZiB0aGUgaXRlbXMgaXMgcHJlc2VydmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24qIGdyb3VwQWRqYWNlbnRCeShpdGVtcywgc2hvdWxkQmVHcm91cGVkKSB7XG4gICAgbGV0IGN1cnJlbnRHcm91cDtcbiAgICBsZXQgbGFzdDtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgaWYgKGxhc3QgIT09IHVuZGVmaW5lZCAmJiBzaG91bGRCZUdyb3VwZWQobGFzdCwgaXRlbSkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRHcm91cC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRHcm91cCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGN1cnJlbnRHcm91cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRHcm91cCA9IFtpdGVtXTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0ID0gaXRlbTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRHcm91cCkge1xuICAgICAgICB5aWVsZCBjdXJyZW50R3JvdXA7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hBZGphY2VudChhcnIsIGYpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZihpID09PSAwID8gdW5kZWZpbmVkIDogYXJyW2kgLSAxXSwgaSA9PT0gYXJyLmxlbmd0aCA/IHVuZGVmaW5lZCA6IGFycltpXSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hXaXRoTmVpZ2hib3JzKGFyciwgZikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGYoaSA9PT0gMCA/IHVuZGVmaW5lZCA6IGFycltpIC0gMV0sIGFycltpXSwgaSArIDEgPT09IGFyci5sZW5ndGggPyB1bmRlZmluZWQgOiBhcnJbaSArIDFdKTtcbiAgICB9XG59XG4vKipcbiAqIEByZXR1cm5zIE5ldyBhcnJheSB3aXRoIGFsbCBmYWxzeSB2YWx1ZXMgcmVtb3ZlZC4gVGhlIG9yaWdpbmFsIGFycmF5IElTIE5PVCBtb2RpZmllZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvYWxlc2NlKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5LmZpbHRlcigoZSkgPT4gISFlKTtcbn1cbi8qKlxuICogUmVtb3ZlIGFsbCBmYWxzeSB2YWx1ZXMgZnJvbSBgYXJyYXlgLiBUaGUgb3JpZ2luYWwgYXJyYXkgSVMgbW9kaWZpZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb2FsZXNjZUluUGxhY2UoYXJyYXkpIHtcbiAgICBsZXQgdG8gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCEhYXJyYXlbaV0pIHtcbiAgICAgICAgICAgIGFycmF5W3RvXSA9IGFycmF5W2ldO1xuICAgICAgICAgICAgdG8gKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhcnJheS5sZW5ndGggPSB0bztcbn1cbi8qKlxuICogQHJldHVybnMgZmFsc2UgaWYgdGhlIHByb3ZpZGVkIG9iamVjdCBpcyBhbiBhcnJheSBhbmQgbm90IGVtcHR5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGYWxzeU9yRW1wdHkob2JqKSB7XG4gICAgcmV0dXJuICFBcnJheS5pc0FycmF5KG9iaikgfHwgb2JqLmxlbmd0aCA9PT0gMDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc05vbkVtcHR5QXJyYXkob2JqKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID4gMDtcbn1cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGVzIGZyb20gdGhlIGdpdmVuIGFycmF5LiBUaGUgb3B0aW9uYWwga2V5Rm4gYWxsb3dzIHRvIHNwZWNpZnlcbiAqIGhvdyBlbGVtZW50cyBhcmUgY2hlY2tlZCBmb3IgZXF1YWxpdHkgYnkgcmV0dXJuaW5nIGFuIGFsdGVybmF0ZSB2YWx1ZSBmb3IgZWFjaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RpbmN0KGFycmF5LCBrZXlGbiA9IHZhbHVlID0+IHZhbHVlKSB7XG4gICAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBrZXlGbihlbGVtZW50KTtcbiAgICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdE9yRGVmYXVsdChhcnJheSwgbm90Rm91bmRWYWx1ZSkge1xuICAgIHJldHVybiBhcnJheS5sZW5ndGggPiAwID8gYXJyYXlbMF0gOiBub3RGb3VuZFZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmdlKGFyZywgdG8pIHtcbiAgICBsZXQgZnJvbSA9IHR5cGVvZiB0byA9PT0gJ251bWJlcicgPyBhcmcgOiAwO1xuICAgIGlmICh0eXBlb2YgdG8gPT09ICdudW1iZXInKSB7XG4gICAgICAgIGZyb20gPSBhcmc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgdG8gPSBhcmc7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGlmIChmcm9tIDw9IHRvKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpID4gdG87IGktLSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogSW5zZXJ0IGBpbnNlcnRBcnJgIGluc2lkZSBgdGFyZ2V0YCBhdCBgaW5zZXJ0SW5kZXhgLlxuICogUGxlYXNlIGRvbid0IHRvdWNoIHVubGVzcyB5b3UgdW5kZXJzdGFuZCBodHRwczovL2pzcGVyZi5jb20vaW5zZXJ0aW5nLWFuLWFycmF5LXdpdGhpbi1hbi1hcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlJbnNlcnQodGFyZ2V0LCBpbnNlcnRJbmRleCwgaW5zZXJ0QXJyKSB7XG4gICAgY29uc3QgYmVmb3JlID0gdGFyZ2V0LnNsaWNlKDAsIGluc2VydEluZGV4KTtcbiAgICBjb25zdCBhZnRlciA9IHRhcmdldC5zbGljZShpbnNlcnRJbmRleCk7XG4gICAgcmV0dXJuIGJlZm9yZS5jb25jYXQoaW5zZXJ0QXJyLCBhZnRlcik7XG59XG4vKipcbiAqIFB1c2hlcyBhbiBlbGVtZW50IHRvIHRoZSBzdGFydCBvZiB0aGUgYXJyYXksIGlmIGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHVzaFRvU3RhcnQoYXJyLCB2YWx1ZSkge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YodmFsdWUpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBhcnIudW5zaGlmdCh2YWx1ZSk7XG4gICAgfVxufVxuLyoqXG4gKiBQdXNoZXMgYW4gZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheSwgaWYgZm91bmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdXNoVG9FbmQoYXJyLCB2YWx1ZSkge1xuICAgIGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YodmFsdWUpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBhcnIucHVzaCh2YWx1ZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHB1c2hNYW55KGFyciwgaXRlbXMpIHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFzQXJyYXkoeCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHgpID8geCA6IFt4XTtcbn1cbi8qKlxuICogSW5zZXJ0IHRoZSBuZXcgaXRlbXMgaW4gdGhlIGFycmF5LlxuICogQHBhcmFtIGFycmF5IFRoZSBvcmlnaW5hbCBhcnJheS5cbiAqIEBwYXJhbSBzdGFydCBUaGUgemVyby1iYXNlZCBsb2NhdGlvbiBpbiB0aGUgYXJyYXkgZnJvbSB3aGljaCB0byBzdGFydCBpbnNlcnRpbmcgZWxlbWVudHMuXG4gKiBAcGFyYW0gbmV3SXRlbXMgVGhlIGl0ZW1zIHRvIGJlIGluc2VydGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRJbnRvKGFycmF5LCBzdGFydCwgbmV3SXRlbXMpIHtcbiAgICBjb25zdCBzdGFydElkeCA9IGdldEFjdHVhbFN0YXJ0SW5kZXgoYXJyYXksIHN0YXJ0KTtcbiAgICBjb25zdCBvcmlnaW5hbExlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBjb25zdCBuZXdJdGVtc0xlbmd0aCA9IG5ld0l0ZW1zLmxlbmd0aDtcbiAgICBhcnJheS5sZW5ndGggPSBvcmlnaW5hbExlbmd0aCArIG5ld0l0ZW1zTGVuZ3RoO1xuICAgIC8vIE1vdmUgdGhlIGl0ZW1zIGFmdGVyIHRoZSBzdGFydCBpbmRleCwgc3RhcnQgZnJvbSB0aGUgZW5kIHNvIHRoYXQgd2UgZG9uJ3Qgb3ZlcndyaXRlIGFueSB2YWx1ZS5cbiAgICBmb3IgKGxldCBpID0gb3JpZ2luYWxMZW5ndGggLSAxOyBpID49IHN0YXJ0SWR4OyBpLS0pIHtcbiAgICAgICAgYXJyYXlbaSArIG5ld0l0ZW1zTGVuZ3RoXSA9IGFycmF5W2ldO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0l0ZW1zTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaSArIHN0YXJ0SWR4XSA9IG5ld0l0ZW1zW2ldO1xuICAgIH1cbn1cbi8qKlxuICogUmVtb3ZlcyBlbGVtZW50cyBmcm9tIGFuIGFycmF5IGFuZCBpbnNlcnRzIG5ldyBlbGVtZW50cyBpbiB0aGVpciBwbGFjZSwgcmV0dXJuaW5nIHRoZSBkZWxldGVkIGVsZW1lbnRzLiBBbHRlcm5hdGl2ZSB0byB0aGUgbmF0aXZlIEFycmF5LnNwbGljZSBtZXRob2QsIGl0XG4gKiBjYW4gb25seSBzdXBwb3J0IGxpbWl0ZWQgbnVtYmVyIG9mIGl0ZW1zIGR1ZSB0byB0aGUgbWF4aW11bSBjYWxsIHN0YWNrIHNpemUgbGltaXQuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIG9yaWdpbmFsIGFycmF5LlxuICogQHBhcmFtIHN0YXJ0IFRoZSB6ZXJvLWJhc2VkIGxvY2F0aW9uIGluIHRoZSBhcnJheSBmcm9tIHdoaWNoIHRvIHN0YXJ0IHJlbW92aW5nIGVsZW1lbnRzLlxuICogQHBhcmFtIGRlbGV0ZUNvdW50IFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLlxuICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgZWxlbWVudHMgdGhhdCB3ZXJlIGRlbGV0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGxpY2UoYXJyYXksIHN0YXJ0LCBkZWxldGVDb3VudCwgbmV3SXRlbXMpIHtcbiAgICBjb25zdCBpbmRleCA9IGdldEFjdHVhbFN0YXJ0SW5kZXgoYXJyYXksIHN0YXJ0KTtcbiAgICBsZXQgcmVzdWx0ID0gYXJyYXkuc3BsaWNlKGluZGV4LCBkZWxldGVDb3VudCk7XG4gICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjYxMTQwXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuICAgIH1cbiAgICBpbnNlcnRJbnRvKGFycmF5LCBpbmRleCwgbmV3SXRlbXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIERldGVybWluZSB0aGUgYWN0dWFsIHN0YXJ0IGluZGV4IChzYW1lIGxvZ2ljIGFzIHRoZSBuYXRpdmUgc3BsaWNlKCkgb3Igc2xpY2UoKSlcbiAqIElmIGdyZWF0ZXIgdGhhbiB0aGUgbGVuZ3RoIG9mIHRoZSBhcnJheSwgc3RhcnQgd2lsbCBiZSBzZXQgdG8gdGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkuIEluIHRoaXMgY2FzZSwgbm8gZWxlbWVudCB3aWxsIGJlIGRlbGV0ZWQgYnV0IHRoZSBtZXRob2Qgd2lsbCBiZWhhdmUgYXMgYW4gYWRkaW5nIGZ1bmN0aW9uLCBhZGRpbmcgYXMgbWFueSBlbGVtZW50IGFzIGl0ZW1bbipdIHByb3ZpZGVkLlxuICogSWYgbmVnYXRpdmUsIGl0IHdpbGwgYmVnaW4gdGhhdCBtYW55IGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXkuIChJbiB0aGlzIGNhc2UsIHRoZSBvcmlnaW4gLTEsIG1lYW5pbmcgLW4gaXMgdGhlIGluZGV4IG9mIHRoZSBudGggbGFzdCBlbGVtZW50LCBhbmQgaXMgdGhlcmVmb3JlIGVxdWl2YWxlbnQgdG8gdGhlIGluZGV4IG9mIGFycmF5Lmxlbmd0aCAtIG4uKSBJZiBhcnJheS5sZW5ndGggKyBzdGFydCBpcyBsZXNzIHRoYW4gMCwgaXQgd2lsbCBiZWdpbiBmcm9tIGluZGV4IDAuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIHRhcmdldCBhcnJheS5cbiAqIEBwYXJhbSBzdGFydCBUaGUgb3BlcmF0aW9uIGluZGV4LlxuICovXG5mdW5jdGlvbiBnZXRBY3R1YWxTdGFydEluZGV4KGFycmF5LCBzdGFydCkge1xuICAgIHJldHVybiBzdGFydCA8IDAgPyBNYXRoLm1heChzdGFydCArIGFycmF5Lmxlbmd0aCwgMCkgOiBNYXRoLm1pbihzdGFydCwgYXJyYXkubGVuZ3RoKTtcbn1cbmV4cG9ydCB2YXIgQ29tcGFyZVJlc3VsdDtcbihmdW5jdGlvbiAoQ29tcGFyZVJlc3VsdCkge1xuICAgIGZ1bmN0aW9uIGlzTGVzc1RoYW4ocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgPCAwO1xuICAgIH1cbiAgICBDb21wYXJlUmVzdWx0LmlzTGVzc1RoYW4gPSBpc0xlc3NUaGFuO1xuICAgIGZ1bmN0aW9uIGlzTGVzc1RoYW5PckVxdWFsKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0IDw9IDA7XG4gICAgfVxuICAgIENvbXBhcmVSZXN1bHQuaXNMZXNzVGhhbk9yRXF1YWwgPSBpc0xlc3NUaGFuT3JFcXVhbDtcbiAgICBmdW5jdGlvbiBpc0dyZWF0ZXJUaGFuKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0ID4gMDtcbiAgICB9XG4gICAgQ29tcGFyZVJlc3VsdC5pc0dyZWF0ZXJUaGFuID0gaXNHcmVhdGVyVGhhbjtcbiAgICBmdW5jdGlvbiBpc05laXRoZXJMZXNzT3JHcmVhdGVyVGhhbihyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gMDtcbiAgICB9XG4gICAgQ29tcGFyZVJlc3VsdC5pc05laXRoZXJMZXNzT3JHcmVhdGVyVGhhbiA9IGlzTmVpdGhlckxlc3NPckdyZWF0ZXJUaGFuO1xuICAgIENvbXBhcmVSZXN1bHQuZ3JlYXRlclRoYW4gPSAxO1xuICAgIENvbXBhcmVSZXN1bHQubGVzc1RoYW4gPSAtMTtcbiAgICBDb21wYXJlUmVzdWx0Lm5laXRoZXJMZXNzT3JHcmVhdGVyVGhhbiA9IDA7XG59KShDb21wYXJlUmVzdWx0IHx8IChDb21wYXJlUmVzdWx0ID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlQnkoc2VsZWN0b3IsIGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gKGEsIGIpID0+IGNvbXBhcmF0b3Ioc2VsZWN0b3IoYSksIHNlbGVjdG9yKGIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0aWVCcmVha0NvbXBhcmF0b3JzKC4uLmNvbXBhcmF0b3JzKSB7XG4gICAgcmV0dXJuIChpdGVtMSwgaXRlbTIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjb21wYXJhdG9yIG9mIGNvbXBhcmF0b3JzKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJhdG9yKGl0ZW0xLCBpdGVtMik7XG4gICAgICAgICAgICBpZiAoIUNvbXBhcmVSZXN1bHQuaXNOZWl0aGVyTGVzc09yR3JlYXRlclRoYW4ocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIENvbXBhcmVSZXN1bHQubmVpdGhlckxlc3NPckdyZWF0ZXJUaGFuO1xuICAgIH07XG59XG4vKipcbiAqIFRoZSBuYXR1cmFsIG9yZGVyIG9uIG51bWJlcnMuXG4qL1xuZXhwb3J0IGNvbnN0IG51bWJlckNvbXBhcmF0b3IgPSAoYSwgYikgPT4gYSAtIGI7XG5leHBvcnQgY29uc3QgYm9vbGVhbkNvbXBhcmF0b3IgPSAoYSwgYikgPT4gbnVtYmVyQ29tcGFyYXRvcihhID8gMSA6IDAsIGIgPyAxIDogMCk7XG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZU9yZGVyKGNvbXBhcmF0b3IpIHtcbiAgICByZXR1cm4gKGEsIGIpID0+IC1jb21wYXJhdG9yKGEsIGIpO1xufVxuZXhwb3J0IGNsYXNzIEFycmF5UXVldWUge1xuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBxdWV1ZSB0aGF0IGlzIGJhY2tlZCBieSB0aGUgZ2l2ZW4gYXJyYXkuIFJ1bnRpbWUgaXMgTygxKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5maXJzdElkeCA9IDA7XG4gICAgICAgIHRoaXMubGFzdElkeCA9IHRoaXMuaXRlbXMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdElkeCAtIHRoaXMuZmlyc3RJZHggKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdW1lcyBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlIGFzIGxvbmcgYXMgdGhlIHByZWRpY2F0ZSByZXR1cm5zIHRydWUuXG4gICAgICogSWYgbm8gZWxlbWVudHMgd2VyZSBjb25zdW1lZCwgYG51bGxgIGlzIHJldHVybmVkLiBIYXMgYSBydW50aW1lIG9mIE8ocmVzdWx0Lmxlbmd0aCkuXG4gICAgKi9cbiAgICB0YWtlV2hpbGUocHJlZGljYXRlKSB7XG4gICAgICAgIC8vIFAoaykgOj0gayA8PSB0aGlzLmxhc3RJZHggJiYgcHJlZGljYXRlKHRoaXMuaXRlbXNba10pXG4gICAgICAgIC8vIEZpbmQgcyA6PSBtaW4geyBrIHwgayA+PSB0aGlzLmZpcnN0SWR4ICYmICFQKGspIH0gYW5kIHJldHVybiB0aGlzLmRhdGFbdGhpcy5maXJzdElkeC4uLnMpXG4gICAgICAgIGxldCBzdGFydElkeCA9IHRoaXMuZmlyc3RJZHg7XG4gICAgICAgIHdoaWxlIChzdGFydElkeCA8IHRoaXMuaXRlbXMubGVuZ3RoICYmIHByZWRpY2F0ZSh0aGlzLml0ZW1zW3N0YXJ0SWR4XSkpIHtcbiAgICAgICAgICAgIHN0YXJ0SWR4Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc3RhcnRJZHggPT09IHRoaXMuZmlyc3RJZHggPyBudWxsIDogdGhpcy5pdGVtcy5zbGljZSh0aGlzLmZpcnN0SWR4LCBzdGFydElkeCk7XG4gICAgICAgIHRoaXMuZmlyc3RJZHggPSBzdGFydElkeDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29uc3VtZXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBxdWV1ZSBhcyBsb25nIGFzIHRoZSBwcmVkaWNhdGUgcmV0dXJucyB0cnVlLlxuICAgICAqIElmIG5vIGVsZW1lbnRzIHdlcmUgY29uc3VtZWQsIGBudWxsYCBpcyByZXR1cm5lZC5cbiAgICAgKiBUaGUgcmVzdWx0IGhhcyB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdW5kZXJseWluZyBhcnJheSFcbiAgICAqL1xuICAgIHRha2VGcm9tRW5kV2hpbGUocHJlZGljYXRlKSB7XG4gICAgICAgIC8vIFAoaykgOj0gdGhpcy5maXJzdElkeCA+PSBrICYmIHByZWRpY2F0ZSh0aGlzLml0ZW1zW2tdKVxuICAgICAgICAvLyBGaW5kIHMgOj0gbWF4IHsgayB8IGsgPD0gdGhpcy5sYXN0SWR4ICYmICFQKGspIH0gYW5kIHJldHVybiB0aGlzLmRhdGEocy4uLnRoaXMubGFzdElkeF1cbiAgICAgICAgbGV0IGVuZElkeCA9IHRoaXMubGFzdElkeDtcbiAgICAgICAgd2hpbGUgKGVuZElkeCA+PSAwICYmIHByZWRpY2F0ZSh0aGlzLml0ZW1zW2VuZElkeF0pKSB7XG4gICAgICAgICAgICBlbmRJZHgtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBlbmRJZHggPT09IHRoaXMubGFzdElkeCA/IG51bGwgOiB0aGlzLml0ZW1zLnNsaWNlKGVuZElkeCArIDEsIHRoaXMubGFzdElkeCArIDEpO1xuICAgICAgICB0aGlzLmxhc3RJZHggPSBlbmRJZHg7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHBlZWsoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pdGVtc1t0aGlzLmZpcnN0SWR4XTtcbiAgICB9XG4gICAgZGVxdWV1ZSgpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5pdGVtc1t0aGlzLmZpcnN0SWR4XTtcbiAgICAgICAgdGhpcy5maXJzdElkeCsrO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0YWtlQ291bnQoY291bnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5pdGVtcy5zbGljZSh0aGlzLmZpcnN0SWR4LCB0aGlzLmZpcnN0SWR4ICsgY291bnQpO1xuICAgICAgICB0aGlzLmZpcnN0SWR4ICs9IGNvdW50O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBjbGFzcyBpcyBmYXN0ZXIgdGhhbiBhbiBpdGVyYXRvciBhbmQgYXJyYXkgZm9yIGxhenkgY29tcHV0ZWQgZGF0YS5cbiovXG5leHBvcnQgY2xhc3MgQ2FsbGJhY2tJdGVyYWJsZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogQ2FsbHMgdGhlIGNhbGxiYWNrIGZvciBldmVyeSBpdGVtLlxuICAgICAqIFN0b3BzIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgZmFsc2UuXG4gICAgKi9cbiAgICBpdGVyYXRlKSB7XG4gICAgICAgIHRoaXMuaXRlcmF0ZSA9IGl0ZXJhdGU7XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLml0ZXJhdGUoaXRlbSA9PiB7IHJlc3VsdC5wdXNoKGl0ZW0pOyByZXR1cm4gdHJ1ZTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbHRlcihwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja0l0ZXJhYmxlKGNiID0+IHRoaXMuaXRlcmF0ZShpdGVtID0+IHByZWRpY2F0ZShpdGVtKSA/IGNiKGl0ZW0pIDogdHJ1ZSkpO1xuICAgIH1cbiAgICBtYXAobWFwRm4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWxsYmFja0l0ZXJhYmxlKGNiID0+IHRoaXMuaXRlcmF0ZShpdGVtID0+IGNiKG1hcEZuKGl0ZW0pKSkpO1xuICAgIH1cbiAgICBmaW5kTGFzdChwcmVkaWNhdGUpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgdGhpcy5pdGVyYXRlKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmRMYXN0TWF4QnkoY29tcGFyYXRvcikge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgICAgICB0aGlzLml0ZXJhdGUoaXRlbSA9PiB7XG4gICAgICAgICAgICBpZiAoZmlyc3QgfHwgQ29tcGFyZVJlc3VsdC5pc0dyZWF0ZXJUaGFuKGNvbXBhcmF0b3IoaXRlbSwgcmVzdWx0KSkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuQ2FsbGJhY2tJdGVyYWJsZS5lbXB0eSA9IG5ldyBDYWxsYmFja0l0ZXJhYmxlKF9jYWxsYmFjayA9PiB7IH0pO1xuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmUtYXJyYW5nZW1lbnQgb2YgaXRlbXMgaW4gYW4gYXJyYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBQZXJtdXRhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoX2luZGV4TWFwKSB7XG4gICAgICAgIHRoaXMuX2luZGV4TWFwID0gX2luZGV4TWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcGVybXV0YXRpb24gdGhhdCBzb3J0cyB0aGUgZ2l2ZW4gYXJyYXkgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBjb21wYXJlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVTb3J0UGVybXV0YXRpb24oYXJyLCBjb21wYXJlRm4pIHtcbiAgICAgICAgY29uc3Qgc29ydEluZGljZXMgPSBBcnJheS5mcm9tKGFyci5rZXlzKCkpLnNvcnQoKGluZGV4MSwgaW5kZXgyKSA9PiBjb21wYXJlRm4oYXJyW2luZGV4MV0sIGFycltpbmRleDJdKSk7XG4gICAgICAgIHJldHVybiBuZXcgUGVybXV0YXRpb24oc29ydEluZGljZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHdpdGggdGhlIGVsZW1lbnRzIG9mIHRoZSBnaXZlbiBhcnJheSByZS1hcnJhbmdlZCBhY2NvcmRpbmcgdG8gdGhpcyBwZXJtdXRhdGlvbi5cbiAgICAgKi9cbiAgICBhcHBseShhcnIpIHtcbiAgICAgICAgcmV0dXJuIGFyci5tYXAoKF8sIGluZGV4KSA9PiBhcnJbdGhpcy5faW5kZXhNYXBbaW5kZXhdXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcGVybXV0YXRpb24gdGhhdCB1bmRvZXMgdGhlIHJlLWFycmFuZ2VtZW50IG9mIHRoaXMgcGVybXV0YXRpb24uXG4gICAgKi9cbiAgICBpbnZlcnNlKCkge1xuICAgICAgICBjb25zdCBpbnZlcnNlSW5kZXhNYXAgPSB0aGlzLl9pbmRleE1hcC5zbGljZSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2luZGV4TWFwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnZlcnNlSW5kZXhNYXBbdGhpcy5faW5kZXhNYXBbaV1dID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFBlcm11dGF0aW9uKGludmVyc2VJbmRleE1hcCk7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgZnVuY3Rpb24gdG9VaW50OCh2KSB7XG4gICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAodiA+IDI1NSAvKiBDb25zdGFudHMuTUFYX1VJTlRfOCAqLykge1xuICAgICAgICByZXR1cm4gMjU1IC8qIENvbnN0YW50cy5NQVhfVUlOVF84ICovO1xuICAgIH1cbiAgICByZXR1cm4gdiB8IDA7XG59XG5leHBvcnQgZnVuY3Rpb24gdG9VaW50MzIodikge1xuICAgIGlmICh2IDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKHYgPiA0Mjk0OTY3Mjk1IC8qIENvbnN0YW50cy5NQVhfVUlOVF8zMiAqLykge1xuICAgICAgICByZXR1cm4gNDI5NDk2NzI5NSAvKiBDb25zdGFudHMuTUFYX1VJTlRfMzIgKi87XG4gICAgfVxuICAgIHJldHVybiB2IHwgMDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgYXJyYXlJbnNlcnQgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xuaW1wb3J0IHsgdG9VaW50MzIgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91aW50LmpzJztcbmV4cG9ydCBjbGFzcyBQcmVmaXhTdW1Db21wdXRlciB7XG4gICAgY29uc3RydWN0b3IodmFsdWVzKSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLnByZWZpeFN1bSA9IG5ldyBVaW50MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4ID0gbmV3IEludDMyQXJyYXkoMSk7XG4gICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IC0xO1xuICAgIH1cbiAgICBpbnNlcnRWYWx1ZXMoaW5zZXJ0SW5kZXgsIGluc2VydFZhbHVlcykge1xuICAgICAgICBpbnNlcnRJbmRleCA9IHRvVWludDMyKGluc2VydEluZGV4KTtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IG9sZFByZWZpeFN1bSA9IHRoaXMucHJlZml4U3VtO1xuICAgICAgICBjb25zdCBpbnNlcnRWYWx1ZXNMZW4gPSBpbnNlcnRWYWx1ZXMubGVuZ3RoO1xuICAgICAgICBpZiAoaW5zZXJ0VmFsdWVzTGVuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZXMgPSBuZXcgVWludDMyQXJyYXkob2xkVmFsdWVzLmxlbmd0aCArIGluc2VydFZhbHVlc0xlbik7XG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoMCwgaW5zZXJ0SW5kZXgpLCAwKTtcbiAgICAgICAgdGhpcy52YWx1ZXMuc2V0KG9sZFZhbHVlcy5zdWJhcnJheShpbnNlcnRJbmRleCksIGluc2VydEluZGV4ICsgaW5zZXJ0VmFsdWVzTGVuKTtcbiAgICAgICAgdGhpcy52YWx1ZXMuc2V0KGluc2VydFZhbHVlcywgaW5zZXJ0SW5kZXgpO1xuICAgICAgICBpZiAoaW5zZXJ0SW5kZXggLSAxIDwgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPSBpbnNlcnRJbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVmaXhTdW0gPSBuZXcgVWludDMyQXJyYXkodGhpcy52YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgaWYgKHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bS5zZXQob2xkUHJlZml4U3VtLnN1YmFycmF5KDAsIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc2V0VmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGluZGV4ID0gdG9VaW50MzIoaW5kZXgpO1xuICAgICAgICB2YWx1ZSA9IHRvVWludDMyKHZhbHVlKTtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVzW2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGluZGV4IC0gMSA8IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW1WYWxpZEluZGV4WzBdID0gaW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZW1vdmVWYWx1ZXMoc3RhcnRJbmRleCwgY291bnQpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9IHRvVWludDMyKHN0YXJ0SW5kZXgpO1xuICAgICAgICBjb3VudCA9IHRvVWludDMyKGNvdW50KTtcbiAgICAgICAgY29uc3Qgb2xkVmFsdWVzID0gdGhpcy52YWx1ZXM7XG4gICAgICAgIGNvbnN0IG9sZFByZWZpeFN1bSA9IHRoaXMucHJlZml4U3VtO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCA+PSBvbGRWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWF4Q291bnQgPSBvbGRWYWx1ZXMubGVuZ3RoIC0gc3RhcnRJbmRleDtcbiAgICAgICAgaWYgKGNvdW50ID49IG1heENvdW50KSB7XG4gICAgICAgICAgICBjb3VudCA9IG1heENvdW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IFVpbnQzMkFycmF5KG9sZFZhbHVlcy5sZW5ndGggLSBjb3VudCk7XG4gICAgICAgIHRoaXMudmFsdWVzLnNldChvbGRWYWx1ZXMuc3ViYXJyYXkoMCwgc3RhcnRJbmRleCksIDApO1xuICAgICAgICB0aGlzLnZhbHVlcy5zZXQob2xkVmFsdWVzLnN1YmFycmF5KHN0YXJ0SW5kZXggKyBjb3VudCksIHN0YXJ0SW5kZXgpO1xuICAgICAgICB0aGlzLnByZWZpeFN1bSA9IG5ldyBVaW50MzJBcnJheSh0aGlzLnZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBpZiAoc3RhcnRJbmRleCAtIDEgPCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0pIHtcbiAgICAgICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IHN0YXJ0SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVmaXhTdW0uc2V0KG9sZFByZWZpeFN1bS5zdWJhcnJheSgwLCB0aGlzLnByZWZpeFN1bVZhbGlkSW5kZXhbMF0gKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGdldFRvdGFsU3VtKCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJlZml4U3VtKHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGZpcnN0IGBpbmRleCArIDFgIG1hbnkgaXRlbXMuXG4gICAgICogQHJldHVybnMgYFNVTSgwIDw9IGogPD0gaW5kZXgsIHZhbHVlc1tqXSlgLlxuICAgICAqL1xuICAgIGdldFByZWZpeFN1bShpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IHRvVWludDMyKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFByZWZpeFN1bShpbmRleCk7XG4gICAgfVxuICAgIF9nZXRQcmVmaXhTdW0oaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDw9IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJlZml4U3VtW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSArIDE7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVswXSA9IHRoaXMudmFsdWVzWzBdO1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy52YWx1ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8PSBpbmRleDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnByZWZpeFN1bVtpXSA9IHRoaXMucHJlZml4U3VtW2kgLSAxXSArIHRoaXMudmFsdWVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSA9IE1hdGgubWF4KHRoaXMucHJlZml4U3VtVmFsaWRJbmRleFswXSwgaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wcmVmaXhTdW1baW5kZXhdO1xuICAgIH1cbiAgICBnZXRJbmRleE9mKHN1bSkge1xuICAgICAgICBzdW0gPSBNYXRoLmZsb29yKHN1bSk7XG4gICAgICAgIC8vIENvbXB1dGUgYWxsIHN1bXMgKHRvIGdldCBhIGZ1bGx5IHZhbGlkIHByZWZpeFN1bSlcbiAgICAgICAgdGhpcy5nZXRUb3RhbFN1bSgpO1xuICAgICAgICBsZXQgbG93ID0gMDtcbiAgICAgICAgbGV0IGhpZ2ggPSB0aGlzLnZhbHVlcy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgbWlkID0gMDtcbiAgICAgICAgbGV0IG1pZFN0b3AgPSAwO1xuICAgICAgICBsZXQgbWlkU3RhcnQgPSAwO1xuICAgICAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgICAgIG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgLyAyKSB8IDA7XG4gICAgICAgICAgICBtaWRTdG9wID0gdGhpcy5wcmVmaXhTdW1bbWlkXTtcbiAgICAgICAgICAgIG1pZFN0YXJ0ID0gbWlkU3RvcCAtIHRoaXMudmFsdWVzW21pZF07XG4gICAgICAgICAgICBpZiAoc3VtIDwgbWlkU3RhcnQpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1bSA+PSBtaWRTdG9wKSB7XG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJlZml4U3VtSW5kZXhPZlJlc3VsdChtaWQsIHN1bSAtIG1pZFN0YXJ0KTtcbiAgICB9XG59XG4vKipcbiAqIHtAbGluayBnZXRJbmRleE9mfSBoYXMgYW4gYW1vcnRpemVkIHJ1bnRpbWUgY29tcGxleGl0eSBvZiBPKDEpLlxuICpcbiAqICh7QGxpbmsgUHJlZml4U3VtQ29tcHV0ZXIuZ2V0SW5kZXhPZn0gaXMganVzdCAgTyhsb2cgbikpXG4qL1xuZXhwb3J0IGNsYXNzIENvbnN0YW50VGltZVByZWZpeFN1bUNvbXB1dGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3ZhbGlkRW5kSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fcHJlZml4U3VtID0gW107XG4gICAgICAgIHRoaXMuX2luZGV4QnlTdW0gPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgU1VNKDAgPD0gaiA8IHZhbHVlcy5sZW5ndGgsIHZhbHVlc1tqXSlcbiAgICAgKi9cbiAgICBnZXRUb3RhbFN1bSgpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4QnlTdW0ubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzdW0gb2YgdGhlIGZpcnN0IGBjb3VudGAgbWFueSBpdGVtcy5cbiAgICAgKiBAcmV0dXJucyBgU1VNKDAgPD0gaiA8IGNvdW50LCB2YWx1ZXNbal0pYC5cbiAgICAgKi9cbiAgICBnZXRQcmVmaXhTdW0oY291bnQpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWQoKTtcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcHJlZml4U3VtW2NvdW50IC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIGByZXN1bHRgLCBzdWNoIHRoYXQgYGdldFByZWZpeFN1bShyZXN1bHQuaW5kZXgpICsgcmVzdWx0LnJlbWFpbmRlciA9IHN1bWBcbiAgICAgKi9cbiAgICBnZXRJbmRleE9mKHN1bSkge1xuICAgICAgICB0aGlzLl9lbnN1cmVWYWxpZCgpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9pbmRleEJ5U3VtW3N1bV07XG4gICAgICAgIGNvbnN0IHZpZXdMaW5lc0Fib3ZlID0gaWR4ID4gMCA/IHRoaXMuX3ByZWZpeFN1bVtpZHggLSAxXSA6IDA7XG4gICAgICAgIHJldHVybiBuZXcgUHJlZml4U3VtSW5kZXhPZlJlc3VsdChpZHgsIHN1bSAtIHZpZXdMaW5lc0Fib3ZlKTtcbiAgICB9XG4gICAgcmVtb3ZlVmFsdWVzKHN0YXJ0LCBkZWxldGVDb3VudCkge1xuICAgICAgICB0aGlzLl92YWx1ZXMuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCk7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGUoc3RhcnQpO1xuICAgIH1cbiAgICBpbnNlcnRWYWx1ZXMoaW5zZXJ0SW5kZXgsIGluc2VydEFycikge1xuICAgICAgICB0aGlzLl92YWx1ZXMgPSBhcnJheUluc2VydCh0aGlzLl92YWx1ZXMsIGluc2VydEluZGV4LCBpbnNlcnRBcnIpO1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlKGluc2VydEluZGV4KTtcbiAgICB9XG4gICAgX2ludmFsaWRhdGUoaW5kZXgpIHtcbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl92YWxpZEVuZEluZGV4ID0gTWF0aC5taW4odGhpcy5fdmFsaWRFbmRJbmRleCwgaW5kZXggLSAxKTtcbiAgICB9XG4gICAgX2Vuc3VyZVZhbGlkKCkge1xuICAgICAgICBpZiAodGhpcy5faXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl92YWxpZEVuZEluZGV4ICsgMSwgbGVuID0gdGhpcy5fdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHN1bUFib3ZlID0gaSA+IDAgPyB0aGlzLl9wcmVmaXhTdW1baSAtIDFdIDogMDtcbiAgICAgICAgICAgIHRoaXMuX3ByZWZpeFN1bVtpXSA9IHN1bUFib3ZlICsgdmFsdWU7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbHVlOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9pbmRleEJ5U3VtW3N1bUFib3ZlICsgal0gPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRyaW0gdGhpbmdzXG4gICAgICAgIHRoaXMuX3ByZWZpeFN1bS5sZW5ndGggPSB0aGlzLl92YWx1ZXMubGVuZ3RoO1xuICAgICAgICB0aGlzLl9pbmRleEJ5U3VtLmxlbmd0aCA9IHRoaXMuX3ByZWZpeFN1bVt0aGlzLl9wcmVmaXhTdW0ubGVuZ3RoIC0gMV07XG4gICAgICAgIC8vIG1hcmsgYXMgdmFsaWRcbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZhbGlkRW5kSW5kZXggPSB0aGlzLl92YWx1ZXMubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgc2V0VmFsdWUoaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLl92YWx1ZXNbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gbm8gY2hhbmdlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlKGluZGV4KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUHJlZml4U3VtSW5kZXhPZlJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IoaW5kZXgsIHJlbWFpbmRlcikge1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMucmVtYWluZGVyID0gcmVtYWluZGVyO1xuICAgICAgICB0aGlzLl9wcmVmaXhTdW1JbmRleE9mUmVzdWx0QnJhbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5yZW1haW5kZXIgPSByZW1haW5kZXI7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBzcGxpdExpbmVzIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJy4uL2NvcmUvcG9zaXRpb24uanMnO1xuaW1wb3J0IHsgUHJlZml4U3VtQ29tcHV0ZXIgfSBmcm9tICcuL3ByZWZpeFN1bUNvbXB1dGVyLmpzJztcbmV4cG9ydCBjbGFzcyBNaXJyb3JUZXh0TW9kZWwge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGluZXMsIGVvbCwgdmVyc2lvbklkKSB7XG4gICAgICAgIHRoaXMuX3VyaSA9IHVyaTtcbiAgICAgICAgdGhpcy5fbGluZXMgPSBsaW5lcztcbiAgICAgICAgdGhpcy5fZW9sID0gZW9sO1xuICAgICAgICB0aGlzLl92ZXJzaW9uSWQgPSB2ZXJzaW9uSWQ7XG4gICAgICAgIHRoaXMuX2xpbmVTdGFydHMgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZWRUZXh0VmFsdWUgPSBudWxsO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLl9saW5lcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBnZXQgdmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcnNpb25JZDtcbiAgICB9XG4gICAgZ2V0VGV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZFRleHRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVkVGV4dFZhbHVlID0gdGhpcy5fbGluZXMuam9pbih0aGlzLl9lb2wpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRUZXh0VmFsdWU7XG4gICAgfVxuICAgIG9uRXZlbnRzKGUpIHtcbiAgICAgICAgaWYgKGUuZW9sICYmIGUuZW9sICE9PSB0aGlzLl9lb2wpIHtcbiAgICAgICAgICAgIHRoaXMuX2VvbCA9IGUuZW9sO1xuICAgICAgICAgICAgdGhpcy5fbGluZVN0YXJ0cyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIG15IGxpbmVzXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBlLmNoYW5nZXM7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjY2VwdERlbGV0ZVJhbmdlKGNoYW5nZS5yYW5nZSk7XG4gICAgICAgICAgICB0aGlzLl9hY2NlcHRJbnNlcnRUZXh0KG5ldyBQb3NpdGlvbihjaGFuZ2UucmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCBjaGFuZ2UucmFuZ2Uuc3RhcnRDb2x1bW4pLCBjaGFuZ2UudGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVyc2lvbklkID0gZS52ZXJzaW9uSWQ7XG4gICAgICAgIHRoaXMuX2NhY2hlZFRleHRWYWx1ZSA9IG51bGw7XG4gICAgfVxuICAgIF9lbnN1cmVMaW5lU3RhcnRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xpbmVTdGFydHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVvbExlbmd0aCA9IHRoaXMuX2VvbC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBsaW5lc0xlbmd0aCA9IHRoaXMuX2xpbmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVTdGFydFZhbHVlcyA9IG5ldyBVaW50MzJBcnJheShsaW5lc0xlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsaW5lU3RhcnRWYWx1ZXNbaV0gPSB0aGlzLl9saW5lc1tpXS5sZW5ndGggKyBlb2xMZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzID0gbmV3IFByZWZpeFN1bUNvbXB1dGVyKGxpbmVTdGFydFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsIGNoYW5nZXMgdG8gYSBsaW5lJ3MgdGV4dCBnbyB0aHJvdWdoIHRoaXMgbWV0aG9kXG4gICAgICovXG4gICAgX3NldExpbmVUZXh0KGxpbmVJbmRleCwgbmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbGluZXNbbGluZUluZGV4XSA9IG5ld1ZhbHVlO1xuICAgICAgICBpZiAodGhpcy5fbGluZVN0YXJ0cykge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHByZWZpeCBzdW1cbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMuc2V0VmFsdWUobGluZUluZGV4LCB0aGlzLl9saW5lc1tsaW5lSW5kZXhdLmxlbmd0aCArIHRoaXMuX2VvbC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hY2NlcHREZWxldGVSYW5nZShyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID09PSByYW5nZS5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAocmFuZ2Uuc3RhcnRDb2x1bW4gPT09IHJhbmdlLmVuZENvbHVtbikge1xuICAgICAgICAgICAgICAgIC8vIE5vdGhpbmcgdG8gZGVsZXRlXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVsZXRlIHRleHQgb24gdGhlIGFmZmVjdGVkIGxpbmVcbiAgICAgICAgICAgIHRoaXMuX3NldExpbmVUZXh0KHJhbmdlLnN0YXJ0TGluZU51bWJlciAtIDEsIHRoaXMuX2xpbmVzW3JhbmdlLnN0YXJ0TGluZU51bWJlciAtIDFdLnN1YnN0cmluZygwLCByYW5nZS5zdGFydENvbHVtbiAtIDEpXG4gICAgICAgICAgICAgICAgKyB0aGlzLl9saW5lc1tyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocmFuZ2UuZW5kQ29sdW1uIC0gMSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRha2UgcmVtYWluaW5nIHRleHQgb24gbGFzdCBsaW5lIGFuZCBhcHBlbmQgaXQgdG8gcmVtYWluaW5nIHRleHQgb24gZmlyc3QgbGluZVxuICAgICAgICB0aGlzLl9zZXRMaW5lVGV4dChyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxLCB0aGlzLl9saW5lc1tyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcoMCwgcmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKVxuICAgICAgICAgICAgKyB0aGlzLl9saW5lc1tyYW5nZS5lbmRMaW5lTnVtYmVyIC0gMV0uc3Vic3RyaW5nKHJhbmdlLmVuZENvbHVtbiAtIDEpKTtcbiAgICAgICAgLy8gRGVsZXRlIG1pZGRsZSBsaW5lc1xuICAgICAgICB0aGlzLl9saW5lcy5zcGxpY2UocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyIC0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgaWYgKHRoaXMuX2xpbmVTdGFydHMpIHtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSBwcmVmaXggc3VtXG4gICAgICAgICAgICB0aGlzLl9saW5lU3RhcnRzLnJlbW92ZVZhbHVlcyhyYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLmVuZExpbmVOdW1iZXIgLSByYW5nZS5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hY2NlcHRJbnNlcnRUZXh0KHBvc2l0aW9uLCBpbnNlcnRUZXh0KSB7XG4gICAgICAgIGlmIChpbnNlcnRUZXh0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gTm90aGluZyB0byBpbnNlcnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnNlcnRMaW5lcyA9IHNwbGl0TGluZXMoaW5zZXJ0VGV4dCk7XG4gICAgICAgIGlmIChpbnNlcnRMaW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIEluc2VydGluZyB0ZXh0IG9uIG9uZSBsaW5lXG4gICAgICAgICAgICB0aGlzLl9zZXRMaW5lVGV4dChwb3NpdGlvbi5saW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZygwLCBwb3NpdGlvbi5jb2x1bW4gLSAxKVxuICAgICAgICAgICAgICAgICsgaW5zZXJ0TGluZXNbMF1cbiAgICAgICAgICAgICAgICArIHRoaXMuX2xpbmVzW3Bvc2l0aW9uLmxpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocG9zaXRpb24uY29sdW1uIC0gMSkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFwcGVuZCBvdmVyZmxvd2luZyB0ZXh0IGZyb20gZmlyc3QgbGluZSB0byB0aGUgZW5kIG9mIHRleHQgdG8gaW5zZXJ0XG4gICAgICAgIGluc2VydExpbmVzW2luc2VydExpbmVzLmxlbmd0aCAtIDFdICs9IHRoaXMuX2xpbmVzW3Bvc2l0aW9uLmxpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocG9zaXRpb24uY29sdW1uIC0gMSk7XG4gICAgICAgIC8vIERlbGV0ZSBvdmVyZmxvd2luZyB0ZXh0IGZyb20gZmlyc3QgbGluZSBhbmQgaW5zZXJ0IHRleHQgb24gZmlyc3QgbGluZVxuICAgICAgICB0aGlzLl9zZXRMaW5lVGV4dChwb3NpdGlvbi5saW5lTnVtYmVyIC0gMSwgdGhpcy5fbGluZXNbcG9zaXRpb24ubGluZU51bWJlciAtIDFdLnN1YnN0cmluZygwLCBwb3NpdGlvbi5jb2x1bW4gLSAxKVxuICAgICAgICAgICAgKyBpbnNlcnRMaW5lc1swXSk7XG4gICAgICAgIC8vIEluc2VydCBuZXcgbGluZXMgJiBzdG9yZSBsZW5ndGhzXG4gICAgICAgIGNvbnN0IG5ld0xlbmd0aHMgPSBuZXcgVWludDMyQXJyYXkoaW5zZXJ0TGluZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5zZXJ0TGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzLnNwbGljZShwb3NpdGlvbi5saW5lTnVtYmVyICsgaSAtIDEsIDAsIGluc2VydExpbmVzW2ldKTtcbiAgICAgICAgICAgIG5ld0xlbmd0aHNbaSAtIDFdID0gaW5zZXJ0TGluZXNbaV0ubGVuZ3RoICsgdGhpcy5fZW9sLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbGluZVN0YXJ0cykge1xuICAgICAgICAgICAgLy8gdXBkYXRlIHByZWZpeCBzdW1cbiAgICAgICAgICAgIHRoaXMuX2xpbmVTdGFydHMuaW5zZXJ0VmFsdWVzKHBvc2l0aW9uLmxpbmVOdW1iZXIsIG5ld0xlbmd0aHMpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBJdGVyYWJsZSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2l0ZXJhdG9yLmpzJztcbmltcG9ydCB7IExpbmtlZExpc3QgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9saW5rZWRMaXN0LmpzJztcbmV4cG9ydCBjb25zdCBVU1VBTF9XT1JEX1NFUEFSQVRPUlMgPSAnYH4hQCMkJV4mKigpLT0rW3tdfVxcXFx8OzpcXCdcIiwuPD4vPyc7XG4vKipcbiAqIENyZWF0ZSBhIHdvcmQgZGVmaW5pdGlvbiByZWd1bGFyIGV4cHJlc3Npb24gYmFzZWQgb24gZGVmYXVsdCB3b3JkIHNlcGFyYXRvcnMuXG4gKiBPcHRpb25hbGx5IHByb3ZpZGUgYWxsb3dlZCBzZXBhcmF0b3JzIHRoYXQgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHdvcmRzLlxuICpcbiAqIFRoZSBkZWZhdWx0IHdvdWxkIGxvb2sgbGlrZSB0aGlzOlxuICogLygtP1xcZCpcXC5cXGRcXHcqKXwoW15cXGBcXH5cXCFcXEBcXCNcXCRcXCVcXF5cXCZcXCpcXChcXClcXC1cXD1cXCtcXFtcXHtcXF1cXH1cXFxcXFx8XFw7XFw6XFwnXFxcIlxcLFxcLlxcPFxcPlxcL1xcP1xcc10rKS9nXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVdvcmRSZWdFeHAoYWxsb3dJbldvcmRzID0gJycpIHtcbiAgICBsZXQgc291cmNlID0gJygtP1xcXFxkKlxcXFwuXFxcXGRcXFxcdyopfChbXic7XG4gICAgZm9yIChjb25zdCBzZXAgb2YgVVNVQUxfV09SRF9TRVBBUkFUT1JTKSB7XG4gICAgICAgIGlmIChhbGxvd0luV29yZHMuaW5kZXhPZihzZXApID49IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNvdXJjZSArPSAnXFxcXCcgKyBzZXA7XG4gICAgfVxuICAgIHNvdXJjZSArPSAnXFxcXHNdKyknO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHNvdXJjZSwgJ2cnKTtcbn1cbi8vIGNhdGNoZXMgbnVtYmVycyAoaW5jbHVkaW5nIGZsb2F0aW5nIG51bWJlcnMpIGluIHRoZSBmaXJzdCBncm91cCwgYW5kIGFscGhhbnVtIGluIHRoZSBzZWNvbmRcbmV4cG9ydCBjb25zdCBERUZBVUxUX1dPUkRfUkVHRVhQID0gY3JlYXRlV29yZFJlZ0V4cCgpO1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVZhbGlkV29yZERlZmluaXRpb24od29yZERlZmluaXRpb24pIHtcbiAgICBsZXQgcmVzdWx0ID0gREVGQVVMVF9XT1JEX1JFR0VYUDtcbiAgICBpZiAod29yZERlZmluaXRpb24gJiYgKHdvcmREZWZpbml0aW9uIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICBpZiAoIXdvcmREZWZpbml0aW9uLmdsb2JhbCkge1xuICAgICAgICAgICAgbGV0IGZsYWdzID0gJ2cnO1xuICAgICAgICAgICAgaWYgKHdvcmREZWZpbml0aW9uLmlnbm9yZUNhc2UpIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSAnaSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod29yZERlZmluaXRpb24ubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gJ20nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdvcmREZWZpbml0aW9uLnVuaWNvZGUpIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSAndSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgUmVnRXhwKHdvcmREZWZpbml0aW9uLnNvdXJjZSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gd29yZERlZmluaXRpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lmxhc3RJbmRleCA9IDA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IF9kZWZhdWx0Q29uZmlnID0gbmV3IExpbmtlZExpc3QoKTtcbl9kZWZhdWx0Q29uZmlnLnVuc2hpZnQoe1xuICAgIG1heExlbjogMTAwMCxcbiAgICB3aW5kb3dTaXplOiAxNSxcbiAgICB0aW1lQnVkZ2V0OiAxNTBcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFdvcmRBdFRleHQoY29sdW1uLCB3b3JkRGVmaW5pdGlvbiwgdGV4dCwgdGV4dE9mZnNldCwgY29uZmlnKSB7XG4gICAgLy8gRW5zdXJlIHRoZSByZWdleCBoYXMgdGhlICdnJyBmbGFnLCBvdGhlcndpc2UgdGhpcyB3aWxsIGxvb3AgZm9yZXZlclxuICAgIHdvcmREZWZpbml0aW9uID0gZW5zdXJlVmFsaWRXb3JkRGVmaW5pdGlvbih3b3JkRGVmaW5pdGlvbik7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgY29uZmlnID0gSXRlcmFibGUuZmlyc3QoX2RlZmF1bHRDb25maWcpO1xuICAgIH1cbiAgICBpZiAodGV4dC5sZW5ndGggPiBjb25maWcubWF4TGVuKSB7XG4gICAgICAgIC8vIGRvbid0IHRocm93IHN0cmluZ3MgdGhhdCBsb25nIGF0IHRoZSByZWdleHBcbiAgICAgICAgLy8gYnV0IHVzZSBhIHN1Yi1zdHJpbmcgaW4gd2hpY2ggYSB3b3JkIG11c3Qgb2NjdXJcbiAgICAgICAgbGV0IHN0YXJ0ID0gY29sdW1uIC0gY29uZmlnLm1heExlbiAvIDI7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgKz0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0LCBjb2x1bW4gKyBjb25maWcubWF4TGVuIC8gMik7XG4gICAgICAgIHJldHVybiBnZXRXb3JkQXRUZXh0KGNvbHVtbiwgd29yZERlZmluaXRpb24sIHRleHQsIHRleHRPZmZzZXQsIGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IHQxID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBwb3MgPSBjb2x1bW4gLSAxIC0gdGV4dE9mZnNldDtcbiAgICBsZXQgcHJldlJlZ2V4SW5kZXggPSAtMTtcbiAgICBsZXQgbWF0Y2ggPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAxOzsgaSsrKSB7XG4gICAgICAgIC8vIGNoZWNrIHRpbWUgYnVkZ2V0XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdDEgPj0gY29uZmlnLnRpbWVCdWRnZXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IHRoZSBpbmRleCBhdCB3aGljaCB0aGUgcmVnZXhwIHNob3VsZCBzdGFydCBtYXRjaGluZywgYWxzbyBrbm93IHdoZXJlIGl0XG4gICAgICAgIC8vIHNob3VsZCBzdG9wIHNvIHRoYXQgc3Vic2VxdWVudCBzZWFyY2ggZG9uJ3QgcmVwZWF0IHByZXZpb3VzIHNlYXJjaGVzXG4gICAgICAgIGNvbnN0IHJlZ2V4SW5kZXggPSBwb3MgLSBjb25maWcud2luZG93U2l6ZSAqIGk7XG4gICAgICAgIHdvcmREZWZpbml0aW9uLmxhc3RJbmRleCA9IE1hdGgubWF4KDAsIHJlZ2V4SW5kZXgpO1xuICAgICAgICBjb25zdCB0aGlzTWF0Y2ggPSBfZmluZFJlZ2V4TWF0Y2hFbmNsb3NpbmdQb3NpdGlvbih3b3JkRGVmaW5pdGlvbiwgdGV4dCwgcG9zLCBwcmV2UmVnZXhJbmRleCk7XG4gICAgICAgIGlmICghdGhpc01hdGNoICYmIG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBzdG9wOiB3ZSBoYXZlIHNvbWV0aGluZ1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbWF0Y2ggPSB0aGlzTWF0Y2g7XG4gICAgICAgIC8vIHN0b3A6IHNlYXJjaGVkIGF0IHN0YXJ0XG4gICAgICAgIGlmIChyZWdleEluZGV4IDw9IDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHByZXZSZWdleEluZGV4ID0gcmVnZXhJbmRleDtcbiAgICB9XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIHdvcmQ6IG1hdGNoWzBdLFxuICAgICAgICAgICAgc3RhcnRDb2x1bW46IHRleHRPZmZzZXQgKyAxICsgbWF0Y2guaW5kZXgsXG4gICAgICAgICAgICBlbmRDb2x1bW46IHRleHRPZmZzZXQgKyAxICsgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgd29yZERlZmluaXRpb24ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfZmluZFJlZ2V4TWF0Y2hFbmNsb3NpbmdQb3NpdGlvbih3b3JkRGVmaW5pdGlvbiwgdGV4dCwgcG9zLCBzdG9wUG9zKSB7XG4gICAgbGV0IG1hdGNoO1xuICAgIHdoaWxlIChtYXRjaCA9IHdvcmREZWZpbml0aW9uLmV4ZWModGV4dCkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hJbmRleCA9IG1hdGNoLmluZGV4IHx8IDA7XG4gICAgICAgIGlmIChtYXRjaEluZGV4IDw9IHBvcyAmJiB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPj0gcG9zKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RvcFBvcyA+IDAgJiYgbWF0Y2hJbmRleCA+IHN0b3BQb3MpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyB0b1VpbnQ4IH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vdWludC5qcyc7XG4vKipcbiAqIEEgZmFzdCBjaGFyYWN0ZXIgY2xhc3NpZmllciB0aGF0IHVzZXMgYSBjb21wYWN0IGFycmF5IGZvciBBU0NJSSB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBDaGFyYWN0ZXJDbGFzc2lmaWVyIHtcbiAgICBjb25zdHJ1Y3RvcihfZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRvVWludDgoX2RlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX2RlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgdGhpcy5fYXNjaWlNYXAgPSBDaGFyYWN0ZXJDbGFzc2lmaWVyLl9jcmVhdGVBc2NpaU1hcChkZWZhdWx0VmFsdWUpO1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHN0YXRpYyBfY3JlYXRlQXNjaWlNYXAoZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFzY2lpTWFwID0gbmV3IFVpbnQ4QXJyYXkoMjU2KTtcbiAgICAgICAgYXNjaWlNYXAuZmlsbChkZWZhdWx0VmFsdWUpO1xuICAgICAgICByZXR1cm4gYXNjaWlNYXA7XG4gICAgfVxuICAgIHNldChjaGFyQ29kZSwgX3ZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9VaW50OChfdmFsdWUpO1xuICAgICAgICBpZiAoY2hhckNvZGUgPj0gMCAmJiBjaGFyQ29kZSA8IDI1Nikge1xuICAgICAgICAgICAgdGhpcy5fYXNjaWlNYXBbY2hhckNvZGVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuc2V0KGNoYXJDb2RlLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0KGNoYXJDb2RlKSB7XG4gICAgICAgIGlmIChjaGFyQ29kZSA+PSAwICYmIGNoYXJDb2RlIDwgMjU2KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXNjaWlNYXBbY2hhckNvZGVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9tYXAuZ2V0KGNoYXJDb2RlKSB8fCB0aGlzLl9kZWZhdWx0VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9hc2NpaU1hcC5maWxsKHRoaXMuX2RlZmF1bHRWYWx1ZSk7XG4gICAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDaGFyYWN0ZXJTZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9hY3R1YWwgPSBuZXcgQ2hhcmFjdGVyQ2xhc3NpZmllcigwIC8qIEJvb2xlYW4uRmFsc2UgKi8pO1xuICAgIH1cbiAgICBhZGQoY2hhckNvZGUpIHtcbiAgICAgICAgdGhpcy5fYWN0dWFsLnNldChjaGFyQ29kZSwgMSAvKiBCb29sZWFuLlRydWUgKi8pO1xuICAgIH1cbiAgICBoYXMoY2hhckNvZGUpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9hY3R1YWwuZ2V0KGNoYXJDb2RlKSA9PT0gMSAvKiBCb29sZWFuLlRydWUgKi8pO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdHVhbC5jbGVhcigpO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgQ2hhcmFjdGVyQ2xhc3NpZmllciB9IGZyb20gJy4uL2NvcmUvY2hhcmFjdGVyQ2xhc3NpZmllci5qcyc7XG5jbGFzcyBVaW50OE1hdHJpeCB7XG4gICAgY29uc3RydWN0b3Iocm93cywgY29scywgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShyb3dzICogY29scyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSByb3dzICogY29sczsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhW2ldID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgICAgICB0aGlzLmNvbHMgPSBjb2xzO1xuICAgIH1cbiAgICBnZXQocm93LCBjb2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFbcm93ICogdGhpcy5jb2xzICsgY29sXTtcbiAgICB9XG4gICAgc2V0KHJvdywgY29sLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kYXRhW3JvdyAqIHRoaXMuY29scyArIGNvbF0gPSB2YWx1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3RhdGVNYWNoaW5lIHtcbiAgICBjb25zdHJ1Y3RvcihlZGdlcykge1xuICAgICAgICBsZXQgbWF4Q2hhckNvZGUgPSAwO1xuICAgICAgICBsZXQgbWF4U3RhdGUgPSAwIC8qIFN0YXRlLkludmFsaWQgKi87XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlZGdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgW2Zyb20sIGNoQ29kZSwgdG9dID0gZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoY2hDb2RlID4gbWF4Q2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICBtYXhDaGFyQ29kZSA9IGNoQ29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tID4gbWF4U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBtYXhTdGF0ZSA9IGZyb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG8gPiBtYXhTdGF0ZSkge1xuICAgICAgICAgICAgICAgIG1heFN0YXRlID0gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWF4Q2hhckNvZGUrKztcbiAgICAgICAgbWF4U3RhdGUrKztcbiAgICAgICAgY29uc3Qgc3RhdGVzID0gbmV3IFVpbnQ4TWF0cml4KG1heFN0YXRlLCBtYXhDaGFyQ29kZSwgMCAvKiBTdGF0ZS5JbnZhbGlkICovKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGVkZ2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBbZnJvbSwgY2hDb2RlLCB0b10gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIHN0YXRlcy5zZXQoZnJvbSwgY2hDb2RlLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc3RhdGVzID0gc3RhdGVzO1xuICAgICAgICB0aGlzLl9tYXhDaGFyQ29kZSA9IG1heENoYXJDb2RlO1xuICAgIH1cbiAgICBuZXh0U3RhdGUoY3VycmVudFN0YXRlLCBjaENvZGUpIHtcbiAgICAgICAgaWYgKGNoQ29kZSA8IDAgfHwgY2hDb2RlID49IHRoaXMuX21heENoYXJDb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBTdGF0ZS5JbnZhbGlkICovO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZXMuZ2V0KGN1cnJlbnRTdGF0ZSwgY2hDb2RlKTtcbiAgICB9XG59XG4vLyBTdGF0ZSBtYWNoaW5lIGZvciBodHRwOi8vIG9yIGh0dHBzOi8vIG9yIGZpbGU6Ly9cbmxldCBfc3RhdGVNYWNoaW5lID0gbnVsbDtcbmZ1bmN0aW9uIGdldFN0YXRlTWFjaGluZSgpIHtcbiAgICBpZiAoX3N0YXRlTWFjaGluZSA9PT0gbnVsbCkge1xuICAgICAgICBfc3RhdGVNYWNoaW5lID0gbmV3IFN0YXRlTWFjaGluZShbXG4gICAgICAgICAgICBbMSAvKiBTdGF0ZS5TdGFydCAqLywgMTA0IC8qIENoYXJDb2RlLmggKi8sIDIgLyogU3RhdGUuSCAqL10sXG4gICAgICAgICAgICBbMSAvKiBTdGF0ZS5TdGFydCAqLywgNzIgLyogQ2hhckNvZGUuSCAqLywgMiAvKiBTdGF0ZS5IICovXSxcbiAgICAgICAgICAgIFsxIC8qIFN0YXRlLlN0YXJ0ICovLCAxMDIgLyogQ2hhckNvZGUuZiAqLywgNiAvKiBTdGF0ZS5GICovXSxcbiAgICAgICAgICAgIFsxIC8qIFN0YXRlLlN0YXJ0ICovLCA3MCAvKiBDaGFyQ29kZS5GICovLCA2IC8qIFN0YXRlLkYgKi9dLFxuICAgICAgICAgICAgWzIgLyogU3RhdGUuSCAqLywgMTE2IC8qIENoYXJDb2RlLnQgKi8sIDMgLyogU3RhdGUuSFQgKi9dLFxuICAgICAgICAgICAgWzIgLyogU3RhdGUuSCAqLywgODQgLyogQ2hhckNvZGUuVCAqLywgMyAvKiBTdGF0ZS5IVCAqL10sXG4gICAgICAgICAgICBbMyAvKiBTdGF0ZS5IVCAqLywgMTE2IC8qIENoYXJDb2RlLnQgKi8sIDQgLyogU3RhdGUuSFRUICovXSxcbiAgICAgICAgICAgIFszIC8qIFN0YXRlLkhUICovLCA4NCAvKiBDaGFyQ29kZS5UICovLCA0IC8qIFN0YXRlLkhUVCAqL10sXG4gICAgICAgICAgICBbNCAvKiBTdGF0ZS5IVFQgKi8sIDExMiAvKiBDaGFyQ29kZS5wICovLCA1IC8qIFN0YXRlLkhUVFAgKi9dLFxuICAgICAgICAgICAgWzQgLyogU3RhdGUuSFRUICovLCA4MCAvKiBDaGFyQ29kZS5QICovLCA1IC8qIFN0YXRlLkhUVFAgKi9dLFxuICAgICAgICAgICAgWzUgLyogU3RhdGUuSFRUUCAqLywgMTE1IC8qIENoYXJDb2RlLnMgKi8sIDkgLyogU3RhdGUuQmVmb3JlQ29sb24gKi9dLFxuICAgICAgICAgICAgWzUgLyogU3RhdGUuSFRUUCAqLywgODMgLyogQ2hhckNvZGUuUyAqLywgOSAvKiBTdGF0ZS5CZWZvcmVDb2xvbiAqL10sXG4gICAgICAgICAgICBbNSAvKiBTdGF0ZS5IVFRQICovLCA1OCAvKiBDaGFyQ29kZS5Db2xvbiAqLywgMTAgLyogU3RhdGUuQWZ0ZXJDb2xvbiAqL10sXG4gICAgICAgICAgICBbNiAvKiBTdGF0ZS5GICovLCAxMDUgLyogQ2hhckNvZGUuaSAqLywgNyAvKiBTdGF0ZS5GSSAqL10sXG4gICAgICAgICAgICBbNiAvKiBTdGF0ZS5GICovLCA3MyAvKiBDaGFyQ29kZS5JICovLCA3IC8qIFN0YXRlLkZJICovXSxcbiAgICAgICAgICAgIFs3IC8qIFN0YXRlLkZJICovLCAxMDggLyogQ2hhckNvZGUubCAqLywgOCAvKiBTdGF0ZS5GSUwgKi9dLFxuICAgICAgICAgICAgWzcgLyogU3RhdGUuRkkgKi8sIDc2IC8qIENoYXJDb2RlLkwgKi8sIDggLyogU3RhdGUuRklMICovXSxcbiAgICAgICAgICAgIFs4IC8qIFN0YXRlLkZJTCAqLywgMTAxIC8qIENoYXJDb2RlLmUgKi8sIDkgLyogU3RhdGUuQmVmb3JlQ29sb24gKi9dLFxuICAgICAgICAgICAgWzggLyogU3RhdGUuRklMICovLCA2OSAvKiBDaGFyQ29kZS5FICovLCA5IC8qIFN0YXRlLkJlZm9yZUNvbG9uICovXSxcbiAgICAgICAgICAgIFs5IC8qIFN0YXRlLkJlZm9yZUNvbG9uICovLCA1OCAvKiBDaGFyQ29kZS5Db2xvbiAqLywgMTAgLyogU3RhdGUuQWZ0ZXJDb2xvbiAqL10sXG4gICAgICAgICAgICBbMTAgLyogU3RhdGUuQWZ0ZXJDb2xvbiAqLywgNDcgLyogQ2hhckNvZGUuU2xhc2ggKi8sIDExIC8qIFN0YXRlLkFsbW9zdFRoZXJlICovXSxcbiAgICAgICAgICAgIFsxMSAvKiBTdGF0ZS5BbG1vc3RUaGVyZSAqLywgNDcgLyogQ2hhckNvZGUuU2xhc2ggKi8sIDEyIC8qIFN0YXRlLkVuZCAqL10sXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICByZXR1cm4gX3N0YXRlTWFjaGluZTtcbn1cbmxldCBfY2xhc3NpZmllciA9IG51bGw7XG5mdW5jdGlvbiBnZXRDbGFzc2lmaWVyKCkge1xuICAgIGlmIChfY2xhc3NpZmllciA9PT0gbnVsbCkge1xuICAgICAgICBfY2xhc3NpZmllciA9IG5ldyBDaGFyYWN0ZXJDbGFzc2lmaWVyKDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLyk7XG4gICAgICAgIC8vIGFsbG93LWFueS11bmljb2RlLW5leHQtbGluZVxuICAgICAgICBjb25zdCBGT1JDRV9URVJNSU5BVElPTl9DSEFSQUNURVJTID0gJyBcXHQ8PlxcJ1xcXCLjgIHjgILvvaHvvaTvvIzvvI7vvJrvvJvigJjjgIjjgIzjgI7jgJTvvIjvvLvvvZvvvaLvvaPvvZ3vvL3vvInjgJXjgI/jgI3jgInigJnvvYDvvZ7igKYnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEZPUkNFX1RFUk1JTkFUSU9OX0NIQVJBQ1RFUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9jbGFzc2lmaWVyLnNldChGT1JDRV9URVJNSU5BVElPTl9DSEFSQUNURVJTLmNoYXJDb2RlQXQoaSksIDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgQ0FOTk9UX0VORF9XSVRIX0NIQVJBQ1RFUlMgPSAnLiw7Oic7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQ0FOTk9UX0VORF9XSVRIX0NIQVJBQ1RFUlMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9jbGFzc2lmaWVyLnNldChDQU5OT1RfRU5EX1dJVEhfQ0hBUkFDVEVSUy5jaGFyQ29kZUF0KGkpLCAyIC8qIENoYXJhY3RlckNsYXNzLkNhbm5vdEVuZEluICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2NsYXNzaWZpZXI7XG59XG5leHBvcnQgY2xhc3MgTGlua0NvbXB1dGVyIHtcbiAgICBzdGF0aWMgX2NyZWF0ZUxpbmsoY2xhc3NpZmllciwgbGluZSwgbGluZU51bWJlciwgbGlua0JlZ2luSW5kZXgsIGxpbmtFbmRJbmRleCkge1xuICAgICAgICAvLyBEbyBub3QgYWxsb3cgdG8gZW5kIGxpbmsgaW4gY2VydGFpbiBjaGFyYWN0ZXJzLi4uXG4gICAgICAgIGxldCBsYXN0SW5jbHVkZWRDaGFySW5kZXggPSBsaW5rRW5kSW5kZXggLSAxO1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBjb25zdCBjaENvZGUgPSBsaW5lLmNoYXJDb2RlQXQobGFzdEluY2x1ZGVkQ2hhckluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IGNoQ2xhc3MgPSBjbGFzc2lmaWVyLmdldChjaENvZGUpO1xuICAgICAgICAgICAgaWYgKGNoQ2xhc3MgIT09IDIgLyogQ2hhcmFjdGVyQ2xhc3MuQ2Fubm90RW5kSW4gKi8pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RJbmNsdWRlZENoYXJJbmRleC0tO1xuICAgICAgICB9IHdoaWxlIChsYXN0SW5jbHVkZWRDaGFySW5kZXggPiBsaW5rQmVnaW5JbmRleCk7XG4gICAgICAgIC8vIEhhbmRsZSBsaW5rcyBlbmNsb3NlZCBpbiBwYXJlbnMsIHNxdWFyZSBicmFja2V0cyBhbmQgY3VybHlzLlxuICAgICAgICBpZiAobGlua0JlZ2luSW5kZXggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyQ29kZUJlZm9yZUxpbmsgPSBsaW5lLmNoYXJDb2RlQXQobGlua0JlZ2luSW5kZXggLSAxKTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RDaGFyQ29kZUluTGluayA9IGxpbmUuY2hhckNvZGVBdChsYXN0SW5jbHVkZWRDaGFySW5kZXgpO1xuICAgICAgICAgICAgaWYgKChjaGFyQ29kZUJlZm9yZUxpbmsgPT09IDQwIC8qIENoYXJDb2RlLk9wZW5QYXJlbiAqLyAmJiBsYXN0Q2hhckNvZGVJbkxpbmsgPT09IDQxIC8qIENoYXJDb2RlLkNsb3NlUGFyZW4gKi8pXG4gICAgICAgICAgICAgICAgfHwgKGNoYXJDb2RlQmVmb3JlTGluayA9PT0gOTEgLyogQ2hhckNvZGUuT3BlblNxdWFyZUJyYWNrZXQgKi8gJiYgbGFzdENoYXJDb2RlSW5MaW5rID09PSA5MyAvKiBDaGFyQ29kZS5DbG9zZVNxdWFyZUJyYWNrZXQgKi8pXG4gICAgICAgICAgICAgICAgfHwgKGNoYXJDb2RlQmVmb3JlTGluayA9PT0gMTIzIC8qIENoYXJDb2RlLk9wZW5DdXJseUJyYWNlICovICYmIGxhc3RDaGFyQ29kZUluTGluayA9PT0gMTI1IC8qIENoYXJDb2RlLkNsb3NlQ3VybHlCcmFjZSAqLykpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgZW5kIGluICkgaWYgKCBpcyBiZWZvcmUgdGhlIGxpbmsgc3RhcnRcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgZW5kIGluIF0gaWYgWyBpcyBiZWZvcmUgdGhlIGxpbmsgc3RhcnRcbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgZW5kIGluIH0gaWYgeyBpcyBiZWZvcmUgdGhlIGxpbmsgc3RhcnRcbiAgICAgICAgICAgICAgICBsYXN0SW5jbHVkZWRDaGFySW5kZXgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IGxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IGxpbmtCZWdpbkluZGV4ICsgMSxcbiAgICAgICAgICAgICAgICBlbmRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIGVuZENvbHVtbjogbGFzdEluY2x1ZGVkQ2hhckluZGV4ICsgMlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVybDogbGluZS5zdWJzdHJpbmcobGlua0JlZ2luSW5kZXgsIGxhc3RJbmNsdWRlZENoYXJJbmRleCArIDEpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBjb21wdXRlTGlua3MobW9kZWwsIHN0YXRlTWFjaGluZSA9IGdldFN0YXRlTWFjaGluZSgpKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzaWZpZXIgPSBnZXRDbGFzc2lmaWVyKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMSwgbGluZUNvdW50ID0gbW9kZWwuZ2V0TGluZUNvdW50KCk7IGkgPD0gbGluZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBtb2RlbC5nZXRMaW5lQ29udGVudChpKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICAgICAgbGV0IGxpbmtCZWdpbkluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBsaW5rQmVnaW5DaENvZGUgPSAwO1xuICAgICAgICAgICAgbGV0IHN0YXRlID0gMSAvKiBTdGF0ZS5TdGFydCAqLztcbiAgICAgICAgICAgIGxldCBoYXNPcGVuUGFyZW5zID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaGFzT3BlblNxdWFyZUJyYWNrZXQgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpblNxdWFyZUJyYWNrZXRzID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaGFzT3BlbkN1cmx5QnJhY2tldCA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzZXRTdGF0ZU1hY2hpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaENvZGUgPSBsaW5lLmNoYXJDb2RlQXQoaik7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSAxMyAvKiBTdGF0ZS5BY2NlcHQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNoQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQwIC8qIENoYXJDb2RlLk9wZW5QYXJlbiAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNPcGVuUGFyZW5zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MSAvKiBDaGFyQ29kZS5DbG9zZVBhcmVuICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAoaGFzT3BlblBhcmVucyA/IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLyA6IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkxIC8qIENoYXJDb2RlLk9wZW5TcXVhcmVCcmFja2V0ICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluU3F1YXJlQnJhY2tldHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc09wZW5TcXVhcmVCcmFja2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gMCAvKiBDaGFyYWN0ZXJDbGFzcy5Ob25lICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MyAvKiBDaGFyQ29kZS5DbG9zZVNxdWFyZUJyYWNrZXQgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5TcXVhcmVCcmFja2V0cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAoaGFzT3BlblNxdWFyZUJyYWNrZXQgPyAwIC8qIENoYXJhY3RlckNsYXNzLk5vbmUgKi8gOiAxIC8qIENoYXJhY3RlckNsYXNzLkZvcmNlVGVybWluYXRpb24gKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjMgLyogQ2hhckNvZGUuT3BlbkN1cmx5QnJhY2UgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzT3BlbkN1cmx5QnJhY2tldCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI1IC8qIENoYXJDb2RlLkNsb3NlQ3VybHlCcmFjZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gKGhhc09wZW5DdXJseUJyYWNrZXQgPyAwIC8qIENoYXJhY3RlckNsYXNzLk5vbmUgKi8gOiAxIC8qIENoYXJhY3RlckNsYXNzLkZvcmNlVGVybWluYXRpb24gKi8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyB0aHJlZSBydWxlcyBtYWtlIGl0IHRoYXQgJyBvciBcIiBvciBgIGFyZSBhbGxvd2VkIGluc2lkZSBsaW5rc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBpZiB0aGUgbGluayBpcyB3cmFwcGVkIGJ5IHNvbWUgb3RoZXIgcXVvdGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM5IC8qIENoYXJDb2RlLlNpbmdsZVF1b3RlICovOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzNCAvKiBDaGFyQ29kZS5Eb3VibGVRdW90ZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTYgLyogQ2hhckNvZGUuQmFja1RpY2sgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpbmtCZWdpbkNoQ29kZSA9PT0gY2hDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAxIC8qIENoYXJhY3RlckNsYXNzLkZvcmNlVGVybWluYXRpb24gKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxpbmtCZWdpbkNoQ29kZSA9PT0gMzkgLyogQ2hhckNvZGUuU2luZ2xlUXVvdGUgKi8gfHwgbGlua0JlZ2luQ2hDb2RlID09PSAzNCAvKiBDaGFyQ29kZS5Eb3VibGVRdW90ZSAqLyB8fCBsaW5rQmVnaW5DaENvZGUgPT09IDk2IC8qIENoYXJDb2RlLkJhY2tUaWNrICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIENoYXJhY3RlckNsYXNzLk5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gMSAvKiBDaGFyYWN0ZXJDbGFzcy5Gb3JjZVRlcm1pbmF0aW9uICovO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDIgLyogQ2hhckNvZGUuQXN0ZXJpc2sgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYCpgIHRlcm1pbmF0ZXMgYSBsaW5rIGlmIHRoZSBsaW5rIGJlZ2FuIHdpdGggYCpgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDQyIC8qIENoYXJDb2RlLkFzdGVyaXNrICovKSA/IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLyA6IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI0IC8qIENoYXJDb2RlLlBpcGUgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYHxgIHRlcm1pbmF0ZXMgYSBsaW5rIGlmIHRoZSBsaW5rIGJlZ2FuIHdpdGggYHxgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hDbGFzcyA9IChsaW5rQmVnaW5DaENvZGUgPT09IDEyNCAvKiBDaGFyQ29kZS5QaXBlICovKSA/IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLyA6IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzIgLyogQ2hhckNvZGUuU3BhY2UgKi86XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYCBgIGFsbG93IHNwYWNlIGluIGJldHdlZW4gWyBhbmQgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAoaW5TcXVhcmVCcmFja2V0cyA/IDAgLyogQ2hhcmFjdGVyQ2xhc3MuTm9uZSAqLyA6IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSBjbGFzc2lmaWVyLmdldChjaENvZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGNoYXJhY3RlciB0ZXJtaW5hdGVzIGxpbmtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoQ2xhc3MgPT09IDEgLyogQ2hhcmFjdGVyQ2xhc3MuRm9yY2VUZXJtaW5hdGlvbiAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goTGlua0NvbXB1dGVyLl9jcmVhdGVMaW5rKGNsYXNzaWZpZXIsIGxpbmUsIGksIGxpbmtCZWdpbkluZGV4LCBqKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0YXRlTWFjaGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc3RhdGUgPT09IDEyIC8qIFN0YXRlLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hDbGFzcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoQ29kZSA9PT0gOTEgLyogQ2hhckNvZGUuT3BlblNxdWFyZUJyYWNrZXQgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGZvciB0aGUgYXV0aG9yaXR5IHBhcnQgdG8gY29udGFpbiBpcHY2IGFkZHJlc3NlcyB3aGljaCBjb250YWluIFsgYW5kIF1cbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc09wZW5TcXVhcmVCcmFja2V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoQ2xhc3MgPSAwIC8qIENoYXJhY3RlckNsYXNzLk5vbmUgKi87XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaENsYXNzID0gY2xhc3NpZmllci5nZXQoY2hDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBjaGFyYWN0ZXIgdGVybWluYXRlcyBsaW5rXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaENsYXNzID09PSAxIC8qIENoYXJhY3RlckNsYXNzLkZvcmNlVGVybWluYXRpb24gKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0U3RhdGVNYWNoaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMTMgLyogU3RhdGUuQWNjZXB0ICovO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHN0YXRlTWFjaGluZS5uZXh0U3RhdGUoc3RhdGUsIGNoQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gMCAvKiBTdGF0ZS5JbnZhbGlkICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0YXRlTWFjaGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc2V0U3RhdGVNYWNoaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMSAvKiBTdGF0ZS5TdGFydCAqLztcbiAgICAgICAgICAgICAgICAgICAgaGFzT3BlblBhcmVucyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNPcGVuU3F1YXJlQnJhY2tldCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBoYXNPcGVuQ3VybHlCcmFja2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29yZCB3aGVyZSB0aGUgbGluayBzdGFydGVkXG4gICAgICAgICAgICAgICAgICAgIGxpbmtCZWdpbkluZGV4ID0gaiArIDE7XG4gICAgICAgICAgICAgICAgICAgIGxpbmtCZWdpbkNoQ29kZSA9IGNoQ29kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSAxMyAvKiBTdGF0ZS5BY2NlcHQgKi8pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChMaW5rQ29tcHV0ZXIuX2NyZWF0ZUxpbmsoY2xhc3NpZmllciwgbGluZSwgaSwgbGlua0JlZ2luSW5kZXgsIGxlbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBsaW5rcyBjb250YWlucyBpbiB0aGUgcHJvdmlkZWRcbiAqIGRvY3VtZW50LiAqTm90ZSogdGhhdCB0aGlzIG9wZXJhdGlvbiBpcyBjb21wdXRhdGlvbmFsXG4gKiBleHBlbnNpdmUgYW5kIHNob3VsZCBub3QgcnVuIGluIHRoZSBVSSB0aHJlYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlTGlua3MobW9kZWwpIHtcbiAgICBpZiAoIW1vZGVsIHx8IHR5cGVvZiBtb2RlbC5nZXRMaW5lQ291bnQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIG1vZGVsLmdldExpbmVDb250ZW50ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVua25vd24gY2FsbGVyIVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBMaW5rQ29tcHV0ZXIuY29tcHV0ZUxpbmtzKG1vZGVsKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZXhwb3J0IGNsYXNzIEJhc2ljSW5wbGFjZVJlcGxhY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9kZWZhdWx0VmFsdWVTZXQgPSBbXG4gICAgICAgICAgICBbJ3RydWUnLCAnZmFsc2UnXSxcbiAgICAgICAgICAgIFsnVHJ1ZScsICdGYWxzZSddLFxuICAgICAgICAgICAgWydQcml2YXRlJywgJ1B1YmxpYycsICdGcmllbmQnLCAnUmVhZE9ubHknLCAnUGFydGlhbCcsICdQcm90ZWN0ZWQnLCAnV3JpdGVPbmx5J10sXG4gICAgICAgICAgICBbJ3B1YmxpYycsICdwcm90ZWN0ZWQnLCAncHJpdmF0ZSddLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBuYXZpZ2F0ZVZhbHVlU2V0KHJhbmdlMSwgdGV4dDEsIHJhbmdlMiwgdGV4dDIsIHVwKSB7XG4gICAgICAgIGlmIChyYW5nZTEgJiYgdGV4dDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZG9OYXZpZ2F0ZVZhbHVlU2V0KHRleHQxLCB1cCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlMSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmdlMiAmJiB0ZXh0Mikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5kb05hdmlnYXRlVmFsdWVTZXQodGV4dDIsIHVwKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByYW5nZTogcmFuZ2UyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZG9OYXZpZ2F0ZVZhbHVlU2V0KHRleHQsIHVwKSB7XG4gICAgICAgIGNvbnN0IG51bWJlclJlc3VsdCA9IHRoaXMubnVtYmVyUmVwbGFjZSh0ZXh0LCB1cCk7XG4gICAgICAgIGlmIChudW1iZXJSZXN1bHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1iZXJSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dFJlcGxhY2UodGV4dCwgdXApO1xuICAgIH1cbiAgICBudW1iZXJSZXBsYWNlKHZhbHVlLCB1cCkge1xuICAgICAgICBjb25zdCBwcmVjaXNpb24gPSBNYXRoLnBvdygxMCwgdmFsdWUubGVuZ3RoIC0gKHZhbHVlLmxhc3RJbmRleE9mKCcuJykgKyAxKSk7XG4gICAgICAgIGxldCBuMSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgIGNvbnN0IG4yID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNOYU4objEpICYmICFpc05hTihuMikgJiYgbjEgPT09IG4yKSB7XG4gICAgICAgICAgICBpZiAobjEgPT09IDAgJiYgIXVwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIGRvbid0IGRvIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgLy9cdFx0XHR9IGVsc2UgaWYobjEgPT09IDkgJiYgdXApIHtcbiAgICAgICAgICAgICAgICAvL1x0XHRcdFx0cmV0dXJuIG51bGw7IC8vIGRvbid0IGluc2VydCAxMCBpbnRvIGEgbnVtYmVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuMSA9IE1hdGguZmxvb3IobjEgKiBwcmVjaXNpb24pO1xuICAgICAgICAgICAgICAgIG4xICs9IHVwID8gcHJlY2lzaW9uIDogLXByZWNpc2lvbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKG4xIC8gcHJlY2lzaW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdGV4dFJlcGxhY2UodmFsdWUsIHVwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlU2V0c1JlcGxhY2UodGhpcy5fZGVmYXVsdFZhbHVlU2V0LCB2YWx1ZSwgdXApO1xuICAgIH1cbiAgICB2YWx1ZVNldHNSZXBsYWNlKHZhbHVlU2V0cywgdmFsdWUsIHVwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdmFsdWVTZXRzLmxlbmd0aDsgcmVzdWx0ID09PSBudWxsICYmIGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy52YWx1ZVNldFJlcGxhY2UodmFsdWVTZXRzW2ldLCB2YWx1ZSwgdXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhbHVlU2V0UmVwbGFjZSh2YWx1ZVNldCwgdmFsdWUsIHVwKSB7XG4gICAgICAgIGxldCBpZHggPSB2YWx1ZVNldC5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICBpZHggKz0gdXAgPyArMSA6IC0xO1xuICAgICAgICAgICAgaWYgKGlkeCA8IDApIHtcbiAgICAgICAgICAgICAgICBpZHggPSB2YWx1ZVNldC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWR4ICU9IHZhbHVlU2V0Lmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVNldFtpZHhdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbkJhc2ljSW5wbGFjZVJlcGxhY2UuSU5TVEFOQ0UgPSBuZXcgQmFzaWNJbnBsYWNlUmVwbGFjZSgpO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBFbWl0dGVyLCBFdmVudCB9IGZyb20gJy4vZXZlbnQuanMnO1xuY29uc3Qgc2hvcnRjdXRFdmVudCA9IE9iamVjdC5mcmVlemUoZnVuY3Rpb24gKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChjYWxsYmFjay5iaW5kKGNvbnRleHQpLCAwKTtcbiAgICByZXR1cm4geyBkaXNwb3NlKCkgeyBjbGVhclRpbWVvdXQoaGFuZGxlKTsgfSB9O1xufSk7XG5leHBvcnQgdmFyIENhbmNlbGxhdGlvblRva2VuO1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25Ub2tlbikge1xuICAgIGZ1bmN0aW9uIGlzQ2FuY2VsbGF0aW9uVG9rZW4odGhpbmcpIHtcbiAgICAgICAgaWYgKHRoaW5nID09PSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lIHx8IHRoaW5nID09PSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGluZyBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGluZyB8fCB0eXBlb2YgdGhpbmcgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGluZy5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCA9PT0gJ2Jvb2xlYW4nXG4gICAgICAgICAgICAmJiB0eXBlb2YgdGhpbmcub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQgPT09ICdmdW5jdGlvbic7XG4gICAgfVxuICAgIENhbmNlbGxhdGlvblRva2VuLmlzQ2FuY2VsbGF0aW9uVG9rZW4gPSBpc0NhbmNlbGxhdGlvblRva2VuO1xuICAgIENhbmNlbGxhdGlvblRva2VuLk5vbmUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogdHJ1ZSxcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IHNob3J0Y3V0RXZlbnRcbiAgICB9KTtcbn0pKENhbmNlbGxhdGlvblRva2VuIHx8IChDYW5jZWxsYXRpb25Ub2tlbiA9IHt9KSk7XG5jbGFzcyBNdXRhYmxlVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9lbWl0dGVyID0gbnVsbDtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXQgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3J0Y3V0RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgICAgICB0aGlzLl90b2tlbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcGFyZW50TGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3BhcmVudExpc3RlbmVyID0gcGFyZW50ICYmIHBhcmVudC5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCh0aGlzLmNhbmNlbCwgdGhpcyk7XG4gICAgfVxuICAgIGdldCB0b2tlbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gYmUgbGF6eSBhbmQgY3JlYXRlIHRoZSB0b2tlbiBvbmx5IHdoZW5cbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IG5lZWRlZFxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBuZXcgTXV0YWJsZVRva2VuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYW4gb2JqZWN0IGJ5IHJldHVybmluZyB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgLy8gY2FuY2VsbGVkIHRva2VuIHdoZW4gY2FuY2VsbGF0aW9uIGhhcHBlbnNcbiAgICAgICAgICAgIC8vIGJlZm9yZSBzb21lb25lIGFza3MgZm9yIHRoZSB0b2tlblxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5DYW5jZWxsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5fdG9rZW4gaW5zdGFuY2VvZiBNdXRhYmxlVG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IGNhbmNlbFxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZShjYW5jZWwgPSBmYWxzZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChjYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gdGhpcy5fcGFyZW50TGlzdGVuZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNwb3NlKCk7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0byBpbml0aWFsaXplIHdpdGggYW4gZW1wdHkgdG9rZW4gaWYgd2UgaGFkIG5vbmVcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl90b2tlbiBpbnN0YW5jZW9mIE11dGFibGVUb2tlbikge1xuICAgICAgICAgICAgLy8gYWN0dWFsbHkgZGlzcG9zZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4uZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNhbmNlbE9uRGlzcG9zZShzdG9yZSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IG5ldyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSgpO1xuICAgIHN0b3JlLmFkZCh7IGRpc3Bvc2UoKSB7IHNvdXJjZS5jYW5jZWwoKTsgfSB9KTtcbiAgICByZXR1cm4gc291cmNlLnRva2VuO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5jbGFzcyBLZXlDb2RlU3RyTWFwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fa2V5Q29kZVRvU3RyID0gW107XG4gICAgICAgIHRoaXMuX3N0clRvS2V5Q29kZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIGRlZmluZShrZXlDb2RlLCBzdHIpIHtcbiAgICAgICAgdGhpcy5fa2V5Q29kZVRvU3RyW2tleUNvZGVdID0gc3RyO1xuICAgICAgICB0aGlzLl9zdHJUb0tleUNvZGVbc3RyLnRvTG93ZXJDYXNlKCldID0ga2V5Q29kZTtcbiAgICB9XG4gICAga2V5Q29kZVRvU3RyKGtleUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleUNvZGVUb1N0cltrZXlDb2RlXTtcbiAgICB9XG4gICAgc3RyVG9LZXlDb2RlKHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyVG9LZXlDb2RlW3N0ci50b0xvd2VyQ2FzZSgpXSB8fCAwIC8qIEtleUNvZGUuVW5rbm93biAqLztcbiAgICB9XG59XG5jb25zdCB1aU1hcCA9IG5ldyBLZXlDb2RlU3RyTWFwKCk7XG5jb25zdCB1c2VyU2V0dGluZ3NVU01hcCA9IG5ldyBLZXlDb2RlU3RyTWFwKCk7XG5jb25zdCB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwID0gbmV3IEtleUNvZGVTdHJNYXAoKTtcbmV4cG9ydCBjb25zdCBFVkVOVF9LRVlfQ09ERV9NQVAgPSBuZXcgQXJyYXkoMjMwKTtcbmV4cG9ydCBjb25zdCBOQVRJVkVfV0lORE9XU19LRVlfQ09ERV9UT19LRVlfQ09ERSA9IHt9O1xuY29uc3Qgc2NhbkNvZGVJbnRUb1N0ciA9IFtdO1xuY29uc3Qgc2NhbkNvZGVTdHJUb0ludCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBzY2FuQ29kZUxvd2VyQ2FzZVN0clRvSW50ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuICogLTEgaWYgYSBTY2FuQ29kZSA9PiBLZXlDb2RlIG1hcHBpbmcgZGVwZW5kcyBvbiBrYiBsYXlvdXQuXG4gKi9cbmV4cG9ydCBjb25zdCBJTU1VVEFCTEVfQ09ERV9UT19LRVlfQ09ERSA9IFtdO1xuLyoqXG4gKiAtMSBpZiBhIEtleUNvZGUgPT4gU2NhbkNvZGUgbWFwcGluZyBkZXBlbmRzIG9uIGtiIGxheW91dC5cbiAqL1xuZXhwb3J0IGNvbnN0IElNTVVUQUJMRV9LRVlfQ09ERV9UT19DT0RFID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8PSAxOTMgLyogU2NhbkNvZGUuTUFYX1ZBTFVFICovOyBpKyspIHtcbiAgICBJTU1VVEFCTEVfQ09ERV9UT19LRVlfQ09ERVtpXSA9IC0xIC8qIEtleUNvZGUuRGVwZW5kc09uS2JMYXlvdXQgKi87XG59XG5mb3IgKGxldCBpID0gMDsgaSA8PSAxMzIgLyogS2V5Q29kZS5NQVhfVkFMVUUgKi87IGkrKykge1xuICAgIElNTVVUQUJMRV9LRVlfQ09ERV9UT19DT0RFW2ldID0gLTEgLyogU2NhbkNvZGUuRGVwZW5kc09uS2JMYXlvdXQgKi87XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIC8vIFNlZSBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L3dpbmRvd3MvZGVza3RvcC9kZDM3NTczMSh2PXZzLjg1KS5hc3B4XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvbm9kZS1uYXRpdmUta2V5bWFwL2Jsb2IvODhjMGIwZTUvZGVwcy9jaHJvbWl1bS9rZXlib2FyZF9jb2Rlc193aW4uaFxuICAgIGNvbnN0IGVtcHR5ID0gJyc7XG4gICAgY29uc3QgbWFwcGluZ3MgPSBbXG4gICAgICAgIC8vIGltbXV0YWJsZSwgc2NhbkNvZGUsIHNjYW5Db2RlU3RyLCBrZXlDb2RlLCBrZXlDb2RlU3RyLCBldmVudEtleUNvZGUsIHZrZXksIHVzVXNlclNldHRpbmdzTGFiZWwsIGdlbmVyYWxVc2VyU2V0dGluZ3NMYWJlbFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCAnTm9uZScsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCAndW5rbm93bicsIDAsICdWS19VTktOT1dOJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEgLyogU2NhbkNvZGUuSHlwZXIgKi8sICdIeXBlcicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAyIC8qIFNjYW5Db2RlLlN1cGVyICovLCAnU3VwZXInLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMyAvKiBTY2FuQ29kZS5GbiAqLywgJ0ZuJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDQgLyogU2NhbkNvZGUuRm5Mb2NrICovLCAnRm5Mb2NrJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDUgLyogU2NhbkNvZGUuU3VzcGVuZCAqLywgJ1N1c3BlbmQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNiAvKiBTY2FuQ29kZS5SZXN1bWUgKi8sICdSZXN1bWUnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNyAvKiBTY2FuQ29kZS5UdXJibyAqLywgJ1R1cmJvJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDggLyogU2NhbkNvZGUuU2xlZXAgKi8sICdTbGVlcCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1NMRUVQJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDkgLyogU2NhbkNvZGUuV2FrZVVwICovLCAnV2FrZVVwJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEwIC8qIFNjYW5Db2RlLktleUEgKi8sICdLZXlBJywgMzEgLyogS2V5Q29kZS5LZXlBICovLCAnQScsIDY1LCAnVktfQScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxMSAvKiBTY2FuQ29kZS5LZXlCICovLCAnS2V5QicsIDMyIC8qIEtleUNvZGUuS2V5QiAqLywgJ0InLCA2NiwgJ1ZLX0InLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMTIgLyogU2NhbkNvZGUuS2V5QyAqLywgJ0tleUMnLCAzMyAvKiBLZXlDb2RlLktleUMgKi8sICdDJywgNjcsICdWS19DJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEzIC8qIFNjYW5Db2RlLktleUQgKi8sICdLZXlEJywgMzQgLyogS2V5Q29kZS5LZXlEICovLCAnRCcsIDY4LCAnVktfRCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxNCAvKiBTY2FuQ29kZS5LZXlFICovLCAnS2V5RScsIDM1IC8qIEtleUNvZGUuS2V5RSAqLywgJ0UnLCA2OSwgJ1ZLX0UnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMTUgLyogU2NhbkNvZGUuS2V5RiAqLywgJ0tleUYnLCAzNiAvKiBLZXlDb2RlLktleUYgKi8sICdGJywgNzAsICdWS19GJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDE2IC8qIFNjYW5Db2RlLktleUcgKi8sICdLZXlHJywgMzcgLyogS2V5Q29kZS5LZXlHICovLCAnRycsIDcxLCAnVktfRycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxNyAvKiBTY2FuQ29kZS5LZXlIICovLCAnS2V5SCcsIDM4IC8qIEtleUNvZGUuS2V5SCAqLywgJ0gnLCA3MiwgJ1ZLX0gnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMTggLyogU2NhbkNvZGUuS2V5SSAqLywgJ0tleUknLCAzOSAvKiBLZXlDb2RlLktleUkgKi8sICdJJywgNzMsICdWS19JJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDE5IC8qIFNjYW5Db2RlLktleUogKi8sICdLZXlKJywgNDAgLyogS2V5Q29kZS5LZXlKICovLCAnSicsIDc0LCAnVktfSicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAyMCAvKiBTY2FuQ29kZS5LZXlLICovLCAnS2V5SycsIDQxIC8qIEtleUNvZGUuS2V5SyAqLywgJ0snLCA3NSwgJ1ZLX0snLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMjEgLyogU2NhbkNvZGUuS2V5TCAqLywgJ0tleUwnLCA0MiAvKiBLZXlDb2RlLktleUwgKi8sICdMJywgNzYsICdWS19MJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDIyIC8qIFNjYW5Db2RlLktleU0gKi8sICdLZXlNJywgNDMgLyogS2V5Q29kZS5LZXlNICovLCAnTScsIDc3LCAnVktfTScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAyMyAvKiBTY2FuQ29kZS5LZXlOICovLCAnS2V5TicsIDQ0IC8qIEtleUNvZGUuS2V5TiAqLywgJ04nLCA3OCwgJ1ZLX04nLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMjQgLyogU2NhbkNvZGUuS2V5TyAqLywgJ0tleU8nLCA0NSAvKiBLZXlDb2RlLktleU8gKi8sICdPJywgNzksICdWS19PJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDI1IC8qIFNjYW5Db2RlLktleVAgKi8sICdLZXlQJywgNDYgLyogS2V5Q29kZS5LZXlQICovLCAnUCcsIDgwLCAnVktfUCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAyNiAvKiBTY2FuQ29kZS5LZXlRICovLCAnS2V5UScsIDQ3IC8qIEtleUNvZGUuS2V5USAqLywgJ1EnLCA4MSwgJ1ZLX1EnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMjcgLyogU2NhbkNvZGUuS2V5UiAqLywgJ0tleVInLCA0OCAvKiBLZXlDb2RlLktleVIgKi8sICdSJywgODIsICdWS19SJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDI4IC8qIFNjYW5Db2RlLktleVMgKi8sICdLZXlTJywgNDkgLyogS2V5Q29kZS5LZXlTICovLCAnUycsIDgzLCAnVktfUycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAyOSAvKiBTY2FuQ29kZS5LZXlUICovLCAnS2V5VCcsIDUwIC8qIEtleUNvZGUuS2V5VCAqLywgJ1QnLCA4NCwgJ1ZLX1QnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMzAgLyogU2NhbkNvZGUuS2V5VSAqLywgJ0tleVUnLCA1MSAvKiBLZXlDb2RlLktleVUgKi8sICdVJywgODUsICdWS19VJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDMxIC8qIFNjYW5Db2RlLktleVYgKi8sICdLZXlWJywgNTIgLyogS2V5Q29kZS5LZXlWICovLCAnVicsIDg2LCAnVktfVicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAzMiAvKiBTY2FuQ29kZS5LZXlXICovLCAnS2V5VycsIDUzIC8qIEtleUNvZGUuS2V5VyAqLywgJ1cnLCA4NywgJ1ZLX1cnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMzMgLyogU2NhbkNvZGUuS2V5WCAqLywgJ0tleVgnLCA1NCAvKiBLZXlDb2RlLktleVggKi8sICdYJywgODgsICdWS19YJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDM0IC8qIFNjYW5Db2RlLktleVkgKi8sICdLZXlZJywgNTUgLyogS2V5Q29kZS5LZXlZICovLCAnWScsIDg5LCAnVktfWScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAzNSAvKiBTY2FuQ29kZS5LZXlaICovLCAnS2V5WicsIDU2IC8qIEtleUNvZGUuS2V5WiAqLywgJ1onLCA5MCwgJ1ZLX1onLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMzYgLyogU2NhbkNvZGUuRGlnaXQxICovLCAnRGlnaXQxJywgMjIgLyogS2V5Q29kZS5EaWdpdDEgKi8sICcxJywgNDksICdWS18xJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDM3IC8qIFNjYW5Db2RlLkRpZ2l0MiAqLywgJ0RpZ2l0MicsIDIzIC8qIEtleUNvZGUuRGlnaXQyICovLCAnMicsIDUwLCAnVktfMicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAzOCAvKiBTY2FuQ29kZS5EaWdpdDMgKi8sICdEaWdpdDMnLCAyNCAvKiBLZXlDb2RlLkRpZ2l0MyAqLywgJzMnLCA1MSwgJ1ZLXzMnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgMzkgLyogU2NhbkNvZGUuRGlnaXQ0ICovLCAnRGlnaXQ0JywgMjUgLyogS2V5Q29kZS5EaWdpdDQgKi8sICc0JywgNTIsICdWS180JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDQwIC8qIFNjYW5Db2RlLkRpZ2l0NSAqLywgJ0RpZ2l0NScsIDI2IC8qIEtleUNvZGUuRGlnaXQ1ICovLCAnNScsIDUzLCAnVktfNScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCA0MSAvKiBTY2FuQ29kZS5EaWdpdDYgKi8sICdEaWdpdDYnLCAyNyAvKiBLZXlDb2RlLkRpZ2l0NiAqLywgJzYnLCA1NCwgJ1ZLXzYnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgNDIgLyogU2NhbkNvZGUuRGlnaXQ3ICovLCAnRGlnaXQ3JywgMjggLyogS2V5Q29kZS5EaWdpdDcgKi8sICc3JywgNTUsICdWS183JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDQzIC8qIFNjYW5Db2RlLkRpZ2l0OCAqLywgJ0RpZ2l0OCcsIDI5IC8qIEtleUNvZGUuRGlnaXQ4ICovLCAnOCcsIDU2LCAnVktfOCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCA0NCAvKiBTY2FuQ29kZS5EaWdpdDkgKi8sICdEaWdpdDknLCAzMCAvKiBLZXlDb2RlLkRpZ2l0OSAqLywgJzknLCA1NywgJ1ZLXzknLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgNDUgLyogU2NhbkNvZGUuRGlnaXQwICovLCAnRGlnaXQwJywgMjEgLyogS2V5Q29kZS5EaWdpdDAgKi8sICcwJywgNDgsICdWS18wJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDQ2IC8qIFNjYW5Db2RlLkVudGVyICovLCAnRW50ZXInLCAzIC8qIEtleUNvZGUuRW50ZXIgKi8sICdFbnRlcicsIDEzLCAnVktfUkVUVVJOJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDQ3IC8qIFNjYW5Db2RlLkVzY2FwZSAqLywgJ0VzY2FwZScsIDkgLyogS2V5Q29kZS5Fc2NhcGUgKi8sICdFc2NhcGUnLCAyNywgJ1ZLX0VTQ0FQRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA0OCAvKiBTY2FuQ29kZS5CYWNrc3BhY2UgKi8sICdCYWNrc3BhY2UnLCAxIC8qIEtleUNvZGUuQmFja3NwYWNlICovLCAnQmFja3NwYWNlJywgOCwgJ1ZLX0JBQ0snLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNDkgLyogU2NhbkNvZGUuVGFiICovLCAnVGFiJywgMiAvKiBLZXlDb2RlLlRhYiAqLywgJ1RhYicsIDksICdWS19UQUInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNTAgLyogU2NhbkNvZGUuU3BhY2UgKi8sICdTcGFjZScsIDEwIC8qIEtleUNvZGUuU3BhY2UgKi8sICdTcGFjZScsIDMyLCAnVktfU1BBQ0UnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMCwgNTEgLyogU2NhbkNvZGUuTWludXMgKi8sICdNaW51cycsIDg4IC8qIEtleUNvZGUuTWludXMgKi8sICctJywgMTg5LCAnVktfT0VNX01JTlVTJywgJy0nLCAnT0VNX01JTlVTJ10sXG4gICAgICAgIFswLCA1MiAvKiBTY2FuQ29kZS5FcXVhbCAqLywgJ0VxdWFsJywgODYgLyogS2V5Q29kZS5FcXVhbCAqLywgJz0nLCAxODcsICdWS19PRU1fUExVUycsICc9JywgJ09FTV9QTFVTJ10sXG4gICAgICAgIFswLCA1MyAvKiBTY2FuQ29kZS5CcmFja2V0TGVmdCAqLywgJ0JyYWNrZXRMZWZ0JywgOTIgLyogS2V5Q29kZS5CcmFja2V0TGVmdCAqLywgJ1snLCAyMTksICdWS19PRU1fNCcsICdbJywgJ09FTV80J10sXG4gICAgICAgIFswLCA1NCAvKiBTY2FuQ29kZS5CcmFja2V0UmlnaHQgKi8sICdCcmFja2V0UmlnaHQnLCA5NCAvKiBLZXlDb2RlLkJyYWNrZXRSaWdodCAqLywgJ10nLCAyMjEsICdWS19PRU1fNicsICddJywgJ09FTV82J10sXG4gICAgICAgIFswLCA1NSAvKiBTY2FuQ29kZS5CYWNrc2xhc2ggKi8sICdCYWNrc2xhc2gnLCA5MyAvKiBLZXlDb2RlLkJhY2tzbGFzaCAqLywgJ1xcXFwnLCAyMjAsICdWS19PRU1fNScsICdcXFxcJywgJ09FTV81J10sXG4gICAgICAgIFswLCA1NiAvKiBTY2FuQ29kZS5JbnRsSGFzaCAqLywgJ0ludGxIYXNoJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSwgLy8gaGFzIGJlZW4gZHJvcHBlZCBmcm9tIHRoZSB3M2Mgc3BlY1xuICAgICAgICBbMCwgNTcgLyogU2NhbkNvZGUuU2VtaWNvbG9uICovLCAnU2VtaWNvbG9uJywgODUgLyogS2V5Q29kZS5TZW1pY29sb24gKi8sICc7JywgMTg2LCAnVktfT0VNXzEnLCAnOycsICdPRU1fMSddLFxuICAgICAgICBbMCwgNTggLyogU2NhbkNvZGUuUXVvdGUgKi8sICdRdW90ZScsIDk1IC8qIEtleUNvZGUuUXVvdGUgKi8sICdcXCcnLCAyMjIsICdWS19PRU1fNycsICdcXCcnLCAnT0VNXzcnXSxcbiAgICAgICAgWzAsIDU5IC8qIFNjYW5Db2RlLkJhY2txdW90ZSAqLywgJ0JhY2txdW90ZScsIDkxIC8qIEtleUNvZGUuQmFja3F1b3RlICovLCAnYCcsIDE5MiwgJ1ZLX09FTV8zJywgJ2AnLCAnT0VNXzMnXSxcbiAgICAgICAgWzAsIDYwIC8qIFNjYW5Db2RlLkNvbW1hICovLCAnQ29tbWEnLCA4NyAvKiBLZXlDb2RlLkNvbW1hICovLCAnLCcsIDE4OCwgJ1ZLX09FTV9DT01NQScsICcsJywgJ09FTV9DT01NQSddLFxuICAgICAgICBbMCwgNjEgLyogU2NhbkNvZGUuUGVyaW9kICovLCAnUGVyaW9kJywgODkgLyogS2V5Q29kZS5QZXJpb2QgKi8sICcuJywgMTkwLCAnVktfT0VNX1BFUklPRCcsICcuJywgJ09FTV9QRVJJT0QnXSxcbiAgICAgICAgWzAsIDYyIC8qIFNjYW5Db2RlLlNsYXNoICovLCAnU2xhc2gnLCA5MCAvKiBLZXlDb2RlLlNsYXNoICovLCAnLycsIDE5MSwgJ1ZLX09FTV8yJywgJy8nLCAnT0VNXzInXSxcbiAgICAgICAgWzEsIDYzIC8qIFNjYW5Db2RlLkNhcHNMb2NrICovLCAnQ2Fwc0xvY2snLCA4IC8qIEtleUNvZGUuQ2Fwc0xvY2sgKi8sICdDYXBzTG9jaycsIDIwLCAnVktfQ0FQSVRBTCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA2NCAvKiBTY2FuQ29kZS5GMSAqLywgJ0YxJywgNTkgLyogS2V5Q29kZS5GMSAqLywgJ0YxJywgMTEyLCAnVktfRjEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNjUgLyogU2NhbkNvZGUuRjIgKi8sICdGMicsIDYwIC8qIEtleUNvZGUuRjIgKi8sICdGMicsIDExMywgJ1ZLX0YyJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDY2IC8qIFNjYW5Db2RlLkYzICovLCAnRjMnLCA2MSAvKiBLZXlDb2RlLkYzICovLCAnRjMnLCAxMTQsICdWS19GMycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA2NyAvKiBTY2FuQ29kZS5GNCAqLywgJ0Y0JywgNjIgLyogS2V5Q29kZS5GNCAqLywgJ0Y0JywgMTE1LCAnVktfRjQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNjggLyogU2NhbkNvZGUuRjUgKi8sICdGNScsIDYzIC8qIEtleUNvZGUuRjUgKi8sICdGNScsIDExNiwgJ1ZLX0Y1JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDY5IC8qIFNjYW5Db2RlLkY2ICovLCAnRjYnLCA2NCAvKiBLZXlDb2RlLkY2ICovLCAnRjYnLCAxMTcsICdWS19GNicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA3MCAvKiBTY2FuQ29kZS5GNyAqLywgJ0Y3JywgNjUgLyogS2V5Q29kZS5GNyAqLywgJ0Y3JywgMTE4LCAnVktfRjcnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgNzEgLyogU2NhbkNvZGUuRjggKi8sICdGOCcsIDY2IC8qIEtleUNvZGUuRjggKi8sICdGOCcsIDExOSwgJ1ZLX0Y4JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDcyIC8qIFNjYW5Db2RlLkY5ICovLCAnRjknLCA2NyAvKiBLZXlDb2RlLkY5ICovLCAnRjknLCAxMjAsICdWS19GOScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA3MyAvKiBTY2FuQ29kZS5GMTAgKi8sICdGMTAnLCA2OCAvKiBLZXlDb2RlLkYxMCAqLywgJ0YxMCcsIDEyMSwgJ1ZLX0YxMCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA3NCAvKiBTY2FuQ29kZS5GMTEgKi8sICdGMTEnLCA2OSAvKiBLZXlDb2RlLkYxMSAqLywgJ0YxMScsIDEyMiwgJ1ZLX0YxMScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA3NSAvKiBTY2FuQ29kZS5GMTIgKi8sICdGMTInLCA3MCAvKiBLZXlDb2RlLkYxMiAqLywgJ0YxMicsIDEyMywgJ1ZLX0YxMicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA3NiAvKiBTY2FuQ29kZS5QcmludFNjcmVlbiAqLywgJ1ByaW50U2NyZWVuJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDc3IC8qIFNjYW5Db2RlLlNjcm9sbExvY2sgKi8sICdTY3JvbGxMb2NrJywgODQgLyogS2V5Q29kZS5TY3JvbGxMb2NrICovLCAnU2Nyb2xsTG9jaycsIDE0NSwgJ1ZLX1NDUk9MTCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA3OCAvKiBTY2FuQ29kZS5QYXVzZSAqLywgJ1BhdXNlJywgNyAvKiBLZXlDb2RlLlBhdXNlQnJlYWsgKi8sICdQYXVzZUJyZWFrJywgMTksICdWS19QQVVTRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA3OSAvKiBTY2FuQ29kZS5JbnNlcnQgKi8sICdJbnNlcnQnLCAxOSAvKiBLZXlDb2RlLkluc2VydCAqLywgJ0luc2VydCcsIDQ1LCAnVktfSU5TRVJUJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDgwIC8qIFNjYW5Db2RlLkhvbWUgKi8sICdIb21lJywgMTQgLyogS2V5Q29kZS5Ib21lICovLCAnSG9tZScsIDM2LCAnVktfSE9NRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA4MSAvKiBTY2FuQ29kZS5QYWdlVXAgKi8sICdQYWdlVXAnLCAxMSAvKiBLZXlDb2RlLlBhZ2VVcCAqLywgJ1BhZ2VVcCcsIDMzLCAnVktfUFJJT1InLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgODIgLyogU2NhbkNvZGUuRGVsZXRlICovLCAnRGVsZXRlJywgMjAgLyogS2V5Q29kZS5EZWxldGUgKi8sICdEZWxldGUnLCA0NiwgJ1ZLX0RFTEVURScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA4MyAvKiBTY2FuQ29kZS5FbmQgKi8sICdFbmQnLCAxMyAvKiBLZXlDb2RlLkVuZCAqLywgJ0VuZCcsIDM1LCAnVktfRU5EJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDg0IC8qIFNjYW5Db2RlLlBhZ2VEb3duICovLCAnUGFnZURvd24nLCAxMiAvKiBLZXlDb2RlLlBhZ2VEb3duICovLCAnUGFnZURvd24nLCAzNCwgJ1ZLX05FWFQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgODUgLyogU2NhbkNvZGUuQXJyb3dSaWdodCAqLywgJ0Fycm93UmlnaHQnLCAxNyAvKiBLZXlDb2RlLlJpZ2h0QXJyb3cgKi8sICdSaWdodEFycm93JywgMzksICdWS19SSUdIVCcsICdSaWdodCcsIGVtcHR5XSxcbiAgICAgICAgWzEsIDg2IC8qIFNjYW5Db2RlLkFycm93TGVmdCAqLywgJ0Fycm93TGVmdCcsIDE1IC8qIEtleUNvZGUuTGVmdEFycm93ICovLCAnTGVmdEFycm93JywgMzcsICdWS19MRUZUJywgJ0xlZnQnLCBlbXB0eV0sXG4gICAgICAgIFsxLCA4NyAvKiBTY2FuQ29kZS5BcnJvd0Rvd24gKi8sICdBcnJvd0Rvd24nLCAxOCAvKiBLZXlDb2RlLkRvd25BcnJvdyAqLywgJ0Rvd25BcnJvdycsIDQwLCAnVktfRE9XTicsICdEb3duJywgZW1wdHldLFxuICAgICAgICBbMSwgODggLyogU2NhbkNvZGUuQXJyb3dVcCAqLywgJ0Fycm93VXAnLCAxNiAvKiBLZXlDb2RlLlVwQXJyb3cgKi8sICdVcEFycm93JywgMzgsICdWS19VUCcsICdVcCcsIGVtcHR5XSxcbiAgICAgICAgWzEsIDg5IC8qIFNjYW5Db2RlLk51bUxvY2sgKi8sICdOdW1Mb2NrJywgODMgLyogS2V5Q29kZS5OdW1Mb2NrICovLCAnTnVtTG9jaycsIDE0NCwgJ1ZLX05VTUxPQ0snLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgOTAgLyogU2NhbkNvZGUuTnVtcGFkRGl2aWRlICovLCAnTnVtcGFkRGl2aWRlJywgMTEzIC8qIEtleUNvZGUuTnVtcGFkRGl2aWRlICovLCAnTnVtUGFkX0RpdmlkZScsIDExMSwgJ1ZLX0RJVklERScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA5MSAvKiBTY2FuQ29kZS5OdW1wYWRNdWx0aXBseSAqLywgJ051bXBhZE11bHRpcGx5JywgMTA4IC8qIEtleUNvZGUuTnVtcGFkTXVsdGlwbHkgKi8sICdOdW1QYWRfTXVsdGlwbHknLCAxMDYsICdWS19NVUxUSVBMWScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA5MiAvKiBTY2FuQ29kZS5OdW1wYWRTdWJ0cmFjdCAqLywgJ051bXBhZFN1YnRyYWN0JywgMTExIC8qIEtleUNvZGUuTnVtcGFkU3VidHJhY3QgKi8sICdOdW1QYWRfU3VidHJhY3QnLCAxMDksICdWS19TVUJUUkFDVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA5MyAvKiBTY2FuQ29kZS5OdW1wYWRBZGQgKi8sICdOdW1wYWRBZGQnLCAxMDkgLyogS2V5Q29kZS5OdW1wYWRBZGQgKi8sICdOdW1QYWRfQWRkJywgMTA3LCAnVktfQUREJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDk0IC8qIFNjYW5Db2RlLk51bXBhZEVudGVyICovLCAnTnVtcGFkRW50ZXInLCAzIC8qIEtleUNvZGUuRW50ZXIgKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDk1IC8qIFNjYW5Db2RlLk51bXBhZDEgKi8sICdOdW1wYWQxJywgOTkgLyogS2V5Q29kZS5OdW1wYWQxICovLCAnTnVtUGFkMScsIDk3LCAnVktfTlVNUEFEMScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCA5NiAvKiBTY2FuQ29kZS5OdW1wYWQyICovLCAnTnVtcGFkMicsIDEwMCAvKiBLZXlDb2RlLk51bXBhZDIgKi8sICdOdW1QYWQyJywgOTgsICdWS19OVU1QQUQyJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDk3IC8qIFNjYW5Db2RlLk51bXBhZDMgKi8sICdOdW1wYWQzJywgMTAxIC8qIEtleUNvZGUuTnVtcGFkMyAqLywgJ051bVBhZDMnLCA5OSwgJ1ZLX05VTVBBRDMnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgOTggLyogU2NhbkNvZGUuTnVtcGFkNCAqLywgJ051bXBhZDQnLCAxMDIgLyogS2V5Q29kZS5OdW1wYWQ0ICovLCAnTnVtUGFkNCcsIDEwMCwgJ1ZLX05VTVBBRDQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgOTkgLyogU2NhbkNvZGUuTnVtcGFkNSAqLywgJ051bXBhZDUnLCAxMDMgLyogS2V5Q29kZS5OdW1wYWQ1ICovLCAnTnVtUGFkNScsIDEwMSwgJ1ZLX05VTVBBRDUnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTAwIC8qIFNjYW5Db2RlLk51bXBhZDYgKi8sICdOdW1wYWQ2JywgMTA0IC8qIEtleUNvZGUuTnVtcGFkNiAqLywgJ051bVBhZDYnLCAxMDIsICdWS19OVU1QQUQ2JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEwMSAvKiBTY2FuQ29kZS5OdW1wYWQ3ICovLCAnTnVtcGFkNycsIDEwNSAvKiBLZXlDb2RlLk51bXBhZDcgKi8sICdOdW1QYWQ3JywgMTAzLCAnVktfTlVNUEFENycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMDIgLyogU2NhbkNvZGUuTnVtcGFkOCAqLywgJ051bXBhZDgnLCAxMDYgLyogS2V5Q29kZS5OdW1wYWQ4ICovLCAnTnVtUGFkOCcsIDEwNCwgJ1ZLX05VTVBBRDgnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTAzIC8qIFNjYW5Db2RlLk51bXBhZDkgKi8sICdOdW1wYWQ5JywgMTA3IC8qIEtleUNvZGUuTnVtcGFkOSAqLywgJ051bVBhZDknLCAxMDUsICdWS19OVU1QQUQ5JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEwNCAvKiBTY2FuQ29kZS5OdW1wYWQwICovLCAnTnVtcGFkMCcsIDk4IC8qIEtleUNvZGUuTnVtcGFkMCAqLywgJ051bVBhZDAnLCA5NiwgJ1ZLX05VTVBBRDAnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTA1IC8qIFNjYW5Db2RlLk51bXBhZERlY2ltYWwgKi8sICdOdW1wYWREZWNpbWFsJywgMTEyIC8qIEtleUNvZGUuTnVtcGFkRGVjaW1hbCAqLywgJ051bVBhZF9EZWNpbWFsJywgMTEwLCAnVktfREVDSU1BTCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxMDYgLyogU2NhbkNvZGUuSW50bEJhY2tzbGFzaCAqLywgJ0ludGxCYWNrc2xhc2gnLCA5NyAvKiBLZXlDb2RlLkludGxCYWNrc2xhc2ggKi8sICdPRU1fMTAyJywgMjI2LCAnVktfT0VNXzEwMicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMDcgLyogU2NhbkNvZGUuQ29udGV4dE1lbnUgKi8sICdDb250ZXh0TWVudScsIDU4IC8qIEtleUNvZGUuQ29udGV4dE1lbnUgKi8sICdDb250ZXh0TWVudScsIDkzLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEwOCAvKiBTY2FuQ29kZS5Qb3dlciAqLywgJ1Bvd2VyJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEwOSAvKiBTY2FuQ29kZS5OdW1wYWRFcXVhbCAqLywgJ051bXBhZEVxdWFsJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDExMCAvKiBTY2FuQ29kZS5GMTMgKi8sICdGMTMnLCA3MSAvKiBLZXlDb2RlLkYxMyAqLywgJ0YxMycsIDEyNCwgJ1ZLX0YxMycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMTEgLyogU2NhbkNvZGUuRjE0ICovLCAnRjE0JywgNzIgLyogS2V5Q29kZS5GMTQgKi8sICdGMTQnLCAxMjUsICdWS19GMTQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTEyIC8qIFNjYW5Db2RlLkYxNSAqLywgJ0YxNScsIDczIC8qIEtleUNvZGUuRjE1ICovLCAnRjE1JywgMTI2LCAnVktfRjE1JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDExMyAvKiBTY2FuQ29kZS5GMTYgKi8sICdGMTYnLCA3NCAvKiBLZXlDb2RlLkYxNiAqLywgJ0YxNicsIDEyNywgJ1ZLX0YxNicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMTQgLyogU2NhbkNvZGUuRjE3ICovLCAnRjE3JywgNzUgLyogS2V5Q29kZS5GMTcgKi8sICdGMTcnLCAxMjgsICdWS19GMTcnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTE1IC8qIFNjYW5Db2RlLkYxOCAqLywgJ0YxOCcsIDc2IC8qIEtleUNvZGUuRjE4ICovLCAnRjE4JywgMTI5LCAnVktfRjE4JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDExNiAvKiBTY2FuQ29kZS5GMTkgKi8sICdGMTknLCA3NyAvKiBLZXlDb2RlLkYxOSAqLywgJ0YxOScsIDEzMCwgJ1ZLX0YxOScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMTcgLyogU2NhbkNvZGUuRjIwICovLCAnRjIwJywgNzggLyogS2V5Q29kZS5GMjAgKi8sICdGMjAnLCAxMzEsICdWS19GMjAnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTE4IC8qIFNjYW5Db2RlLkYyMSAqLywgJ0YyMScsIDc5IC8qIEtleUNvZGUuRjIxICovLCAnRjIxJywgMTMyLCAnVktfRjIxJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDExOSAvKiBTY2FuQ29kZS5GMjIgKi8sICdGMjInLCA4MCAvKiBLZXlDb2RlLkYyMiAqLywgJ0YyMicsIDEzMywgJ1ZLX0YyMicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMjAgLyogU2NhbkNvZGUuRjIzICovLCAnRjIzJywgODEgLyogS2V5Q29kZS5GMjMgKi8sICdGMjMnLCAxMzQsICdWS19GMjMnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTIxIC8qIFNjYW5Db2RlLkYyNCAqLywgJ0YyNCcsIDgyIC8qIEtleUNvZGUuRjI0ICovLCAnRjI0JywgMTM1LCAnVktfRjI0JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEyMiAvKiBTY2FuQ29kZS5PcGVuICovLCAnT3BlbicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMjMgLyogU2NhbkNvZGUuSGVscCAqLywgJ0hlbHAnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTI0IC8qIFNjYW5Db2RlLlNlbGVjdCAqLywgJ1NlbGVjdCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMjUgLyogU2NhbkNvZGUuQWdhaW4gKi8sICdBZ2FpbicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMjYgLyogU2NhbkNvZGUuVW5kbyAqLywgJ1VuZG8nLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTI3IC8qIFNjYW5Db2RlLkN1dCAqLywgJ0N1dCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMjggLyogU2NhbkNvZGUuQ29weSAqLywgJ0NvcHknLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTI5IC8qIFNjYW5Db2RlLlBhc3RlICovLCAnUGFzdGUnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTMwIC8qIFNjYW5Db2RlLkZpbmQgKi8sICdGaW5kJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEzMSAvKiBTY2FuQ29kZS5BdWRpb1ZvbHVtZU11dGUgKi8sICdBdWRpb1ZvbHVtZU11dGUnLCAxMTcgLyogS2V5Q29kZS5BdWRpb1ZvbHVtZU11dGUgKi8sICdBdWRpb1ZvbHVtZU11dGUnLCAxNzMsICdWS19WT0xVTUVfTVVURScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMzIgLyogU2NhbkNvZGUuQXVkaW9Wb2x1bWVVcCAqLywgJ0F1ZGlvVm9sdW1lVXAnLCAxMTggLyogS2V5Q29kZS5BdWRpb1ZvbHVtZVVwICovLCAnQXVkaW9Wb2x1bWVVcCcsIDE3NSwgJ1ZLX1ZPTFVNRV9VUCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMzMgLyogU2NhbkNvZGUuQXVkaW9Wb2x1bWVEb3duICovLCAnQXVkaW9Wb2x1bWVEb3duJywgMTE5IC8qIEtleUNvZGUuQXVkaW9Wb2x1bWVEb3duICovLCAnQXVkaW9Wb2x1bWVEb3duJywgMTc0LCAnVktfVk9MVU1FX0RPV04nLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTM0IC8qIFNjYW5Db2RlLk51bXBhZENvbW1hICovLCAnTnVtcGFkQ29tbWEnLCAxMTAgLyogS2V5Q29kZS5OVU1QQURfU0VQQVJBVE9SICovLCAnTnVtUGFkX1NlcGFyYXRvcicsIDEwOCwgJ1ZLX1NFUEFSQVRPUicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFswLCAxMzUgLyogU2NhbkNvZGUuSW50bFJvICovLCAnSW50bFJvJywgMTE1IC8qIEtleUNvZGUuQUJOVF9DMSAqLywgJ0FCTlRfQzEnLCAxOTMsICdWS19BQk5UX0MxJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDEzNiAvKiBTY2FuQ29kZS5LYW5hTW9kZSAqLywgJ0thbmFNb2RlJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzAsIDEzNyAvKiBTY2FuQ29kZS5JbnRsWWVuICovLCAnSW50bFllbicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxMzggLyogU2NhbkNvZGUuQ29udmVydCAqLywgJ0NvbnZlcnQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTM5IC8qIFNjYW5Db2RlLk5vbkNvbnZlcnQgKi8sICdOb25Db252ZXJ0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE0MCAvKiBTY2FuQ29kZS5MYW5nMSAqLywgJ0xhbmcxJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE0MSAvKiBTY2FuQ29kZS5MYW5nMiAqLywgJ0xhbmcyJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE0MiAvKiBTY2FuQ29kZS5MYW5nMyAqLywgJ0xhbmczJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE0MyAvKiBTY2FuQ29kZS5MYW5nNCAqLywgJ0xhbmc0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE0NCAvKiBTY2FuQ29kZS5MYW5nNSAqLywgJ0xhbmc1JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE0NSAvKiBTY2FuQ29kZS5BYm9ydCAqLywgJ0Fib3J0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE0NiAvKiBTY2FuQ29kZS5Qcm9wcyAqLywgJ1Byb3BzJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE0NyAvKiBTY2FuQ29kZS5OdW1wYWRQYXJlbkxlZnQgKi8sICdOdW1wYWRQYXJlbkxlZnQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTQ4IC8qIFNjYW5Db2RlLk51bXBhZFBhcmVuUmlnaHQgKi8sICdOdW1wYWRQYXJlblJpZ2h0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE0OSAvKiBTY2FuQ29kZS5OdW1wYWRCYWNrc3BhY2UgKi8sICdOdW1wYWRCYWNrc3BhY2UnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTUwIC8qIFNjYW5Db2RlLk51bXBhZE1lbW9yeVN0b3JlICovLCAnTnVtcGFkTWVtb3J5U3RvcmUnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTUxIC8qIFNjYW5Db2RlLk51bXBhZE1lbW9yeVJlY2FsbCAqLywgJ051bXBhZE1lbW9yeVJlY2FsbCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNTIgLyogU2NhbkNvZGUuTnVtcGFkTWVtb3J5Q2xlYXIgKi8sICdOdW1wYWRNZW1vcnlDbGVhcicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNTMgLyogU2NhbkNvZGUuTnVtcGFkTWVtb3J5QWRkICovLCAnTnVtcGFkTWVtb3J5QWRkJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE1NCAvKiBTY2FuQ29kZS5OdW1wYWRNZW1vcnlTdWJ0cmFjdCAqLywgJ051bXBhZE1lbW9yeVN1YnRyYWN0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE1NSAvKiBTY2FuQ29kZS5OdW1wYWRDbGVhciAqLywgJ051bXBhZENsZWFyJywgMTMxIC8qIEtleUNvZGUuQ2xlYXIgKi8sICdDbGVhcicsIDEyLCAnVktfQ0xFQVInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTU2IC8qIFNjYW5Db2RlLk51bXBhZENsZWFyRW50cnkgKi8sICdOdW1wYWRDbGVhckVudHJ5JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDUgLyogS2V5Q29kZS5DdHJsICovLCAnQ3RybCcsIDE3LCAnVktfQ09OVFJPTCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCA0IC8qIEtleUNvZGUuU2hpZnQgKi8sICdTaGlmdCcsIDE2LCAnVktfU0hJRlQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgNiAvKiBLZXlDb2RlLkFsdCAqLywgJ0FsdCcsIDE4LCAnVktfTUVOVScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCA1NyAvKiBLZXlDb2RlLk1ldGEgKi8sICdNZXRhJywgOTEsICdWS19DT01NQU5EJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE1NyAvKiBTY2FuQ29kZS5Db250cm9sTGVmdCAqLywgJ0NvbnRyb2xMZWZ0JywgNSAvKiBLZXlDb2RlLkN0cmwgKi8sIGVtcHR5LCAwLCAnVktfTENPTlRST0wnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTU4IC8qIFNjYW5Db2RlLlNoaWZ0TGVmdCAqLywgJ1NoaWZ0TGVmdCcsIDQgLyogS2V5Q29kZS5TaGlmdCAqLywgZW1wdHksIDAsICdWS19MU0hJRlQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTU5IC8qIFNjYW5Db2RlLkFsdExlZnQgKi8sICdBbHRMZWZ0JywgNiAvKiBLZXlDb2RlLkFsdCAqLywgZW1wdHksIDAsICdWS19MTUVOVScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNjAgLyogU2NhbkNvZGUuTWV0YUxlZnQgKi8sICdNZXRhTGVmdCcsIDU3IC8qIEtleUNvZGUuTWV0YSAqLywgZW1wdHksIDAsICdWS19MV0lOJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE2MSAvKiBTY2FuQ29kZS5Db250cm9sUmlnaHQgKi8sICdDb250cm9sUmlnaHQnLCA1IC8qIEtleUNvZGUuQ3RybCAqLywgZW1wdHksIDAsICdWS19SQ09OVFJPTCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNjIgLyogU2NhbkNvZGUuU2hpZnRSaWdodCAqLywgJ1NoaWZ0UmlnaHQnLCA0IC8qIEtleUNvZGUuU2hpZnQgKi8sIGVtcHR5LCAwLCAnVktfUlNISUZUJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE2MyAvKiBTY2FuQ29kZS5BbHRSaWdodCAqLywgJ0FsdFJpZ2h0JywgNiAvKiBLZXlDb2RlLkFsdCAqLywgZW1wdHksIDAsICdWS19STUVOVScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNjQgLyogU2NhbkNvZGUuTWV0YVJpZ2h0ICovLCAnTWV0YVJpZ2h0JywgNTcgLyogS2V5Q29kZS5NZXRhICovLCBlbXB0eSwgMCwgJ1ZLX1JXSU4nLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTY1IC8qIFNjYW5Db2RlLkJyaWdodG5lc3NVcCAqLywgJ0JyaWdodG5lc3NVcCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNjYgLyogU2NhbkNvZGUuQnJpZ2h0bmVzc0Rvd24gKi8sICdCcmlnaHRuZXNzRG93bicsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNjcgLyogU2NhbkNvZGUuTWVkaWFQbGF5ICovLCAnTWVkaWFQbGF5JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE2OCAvKiBTY2FuQ29kZS5NZWRpYVJlY29yZCAqLywgJ01lZGlhUmVjb3JkJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE2OSAvKiBTY2FuQ29kZS5NZWRpYUZhc3RGb3J3YXJkICovLCAnTWVkaWFGYXN0Rm9yd2FyZCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNzAgLyogU2NhbkNvZGUuTWVkaWFSZXdpbmQgKi8sICdNZWRpYVJld2luZCcsIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgZW1wdHksIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNzEgLyogU2NhbkNvZGUuTWVkaWFUcmFja05leHQgKi8sICdNZWRpYVRyYWNrTmV4dCcsIDEyNCAvKiBLZXlDb2RlLk1lZGlhVHJhY2tOZXh0ICovLCAnTWVkaWFUcmFja05leHQnLCAxNzYsICdWS19NRURJQV9ORVhUX1RSQUNLJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE3MiAvKiBTY2FuQ29kZS5NZWRpYVRyYWNrUHJldmlvdXMgKi8sICdNZWRpYVRyYWNrUHJldmlvdXMnLCAxMjUgLyogS2V5Q29kZS5NZWRpYVRyYWNrUHJldmlvdXMgKi8sICdNZWRpYVRyYWNrUHJldmlvdXMnLCAxNzcsICdWS19NRURJQV9QUkVWX1RSQUNLJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE3MyAvKiBTY2FuQ29kZS5NZWRpYVN0b3AgKi8sICdNZWRpYVN0b3AnLCAxMjYgLyogS2V5Q29kZS5NZWRpYVN0b3AgKi8sICdNZWRpYVN0b3AnLCAxNzgsICdWS19NRURJQV9TVE9QJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE3NCAvKiBTY2FuQ29kZS5FamVjdCAqLywgJ0VqZWN0JywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE3NSAvKiBTY2FuQ29kZS5NZWRpYVBsYXlQYXVzZSAqLywgJ01lZGlhUGxheVBhdXNlJywgMTI3IC8qIEtleUNvZGUuTWVkaWFQbGF5UGF1c2UgKi8sICdNZWRpYVBsYXlQYXVzZScsIDE3OSwgJ1ZLX01FRElBX1BMQVlfUEFVU0UnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTc2IC8qIFNjYW5Db2RlLk1lZGlhU2VsZWN0ICovLCAnTWVkaWFTZWxlY3QnLCAxMjggLyogS2V5Q29kZS5MYXVuY2hNZWRpYVBsYXllciAqLywgJ0xhdW5jaE1lZGlhUGxheWVyJywgMTgxLCAnVktfTUVESUFfTEFVTkNIX01FRElBX1NFTEVDVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxNzcgLyogU2NhbkNvZGUuTGF1bmNoTWFpbCAqLywgJ0xhdW5jaE1haWwnLCAxMjkgLyogS2V5Q29kZS5MYXVuY2hNYWlsICovLCAnTGF1bmNoTWFpbCcsIDE4MCwgJ1ZLX01FRElBX0xBVU5DSF9NQUlMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE3OCAvKiBTY2FuQ29kZS5MYXVuY2hBcHAyICovLCAnTGF1bmNoQXBwMicsIDEzMCAvKiBLZXlDb2RlLkxhdW5jaEFwcDIgKi8sICdMYXVuY2hBcHAyJywgMTgzLCAnVktfTUVESUFfTEFVTkNIX0FQUDInLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTc5IC8qIFNjYW5Db2RlLkxhdW5jaEFwcDEgKi8sICdMYXVuY2hBcHAxJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfTUVESUFfTEFVTkNIX0FQUDEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTgwIC8qIFNjYW5Db2RlLlNlbGVjdFRhc2sgKi8sICdTZWxlY3RUYXNrJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE4MSAvKiBTY2FuQ29kZS5MYXVuY2hTY3JlZW5TYXZlciAqLywgJ0xhdW5jaFNjcmVlblNhdmVyJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE4MiAvKiBTY2FuQ29kZS5Ccm93c2VyU2VhcmNoICovLCAnQnJvd3NlclNlYXJjaCcsIDEyMCAvKiBLZXlDb2RlLkJyb3dzZXJTZWFyY2ggKi8sICdCcm93c2VyU2VhcmNoJywgMTcwLCAnVktfQlJPV1NFUl9TRUFSQ0gnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTgzIC8qIFNjYW5Db2RlLkJyb3dzZXJIb21lICovLCAnQnJvd3NlckhvbWUnLCAxMjEgLyogS2V5Q29kZS5Ccm93c2VySG9tZSAqLywgJ0Jyb3dzZXJIb21lJywgMTcyLCAnVktfQlJPV1NFUl9IT01FJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE4NCAvKiBTY2FuQ29kZS5Ccm93c2VyQmFjayAqLywgJ0Jyb3dzZXJCYWNrJywgMTIyIC8qIEtleUNvZGUuQnJvd3NlckJhY2sgKi8sICdCcm93c2VyQmFjaycsIDE2NiwgJ1ZLX0JST1dTRVJfQkFDSycsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAxODUgLyogU2NhbkNvZGUuQnJvd3NlckZvcndhcmQgKi8sICdCcm93c2VyRm9yd2FyZCcsIDEyMyAvKiBLZXlDb2RlLkJyb3dzZXJGb3J3YXJkICovLCAnQnJvd3NlckZvcndhcmQnLCAxNjcsICdWS19CUk9XU0VSX0ZPUldBUkQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTg2IC8qIFNjYW5Db2RlLkJyb3dzZXJTdG9wICovLCAnQnJvd3NlclN0b3AnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19CUk9XU0VSX1NUT1AnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTg3IC8qIFNjYW5Db2RlLkJyb3dzZXJSZWZyZXNoICovLCAnQnJvd3NlclJlZnJlc2gnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19CUk9XU0VSX1JFRlJFU0gnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTg4IC8qIFNjYW5Db2RlLkJyb3dzZXJGYXZvcml0ZXMgKi8sICdCcm93c2VyRmF2b3JpdGVzJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfQlJPV1NFUl9GQVZPUklURVMnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTg5IC8qIFNjYW5Db2RlLlpvb21Ub2dnbGUgKi8sICdab29tVG9nZ2xlJywgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCBlbXB0eSwgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDE5MCAvKiBTY2FuQ29kZS5NYWlsUmVwbHkgKi8sICdNYWlsUmVwbHknLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTkxIC8qIFNjYW5Db2RlLk1haWxGb3J3YXJkICovLCAnTWFpbEZvcndhcmQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMTkyIC8qIFNjYW5Db2RlLk1haWxTZW5kICovLCAnTWFpbFNlbmQnLCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9saXN0cy53My5vcmcvQXJjaGl2ZXMvUHVibGljL3d3dy1kb20vMjAxMEp1bFNlcC9hdHQtMDE4Mi9rZXlDb2RlLXNwZWMuaHRtbFxuICAgICAgICAvLyBJZiBhbiBJbnB1dCBNZXRob2QgRWRpdG9yIGlzIHByb2Nlc3Npbmcga2V5IGlucHV0IGFuZCB0aGUgZXZlbnQgaXMga2V5ZG93biwgcmV0dXJuIDIyOS5cbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDExNCAvKiBLZXlDb2RlLktFWV9JTl9DT01QT1NJVElPTiAqLywgJ0tleUluQ29tcG9zaXRpb24nLCAyMjksIGVtcHR5LCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMTE2IC8qIEtleUNvZGUuQUJOVF9DMiAqLywgJ0FCTlRfQzInLCAxOTQsICdWS19BQk5UX0MyJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDk2IC8qIEtleUNvZGUuT0VNXzggKi8sICdPRU1fOCcsIDIyMywgJ1ZLX09FTV84JywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0tBTkEnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfSEFOR1VMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0pVTkpBJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0ZJTkFMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0hBTkpBJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0tBTkpJJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0NPTlZFUlQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfTk9OQ09OVkVSVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19BQ0NFUFQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfTU9ERUNIQU5HRScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19TRUxFQ1QnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfUFJJTlQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfRVhFQ1VURScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19TTkFQU0hPVCcsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19IRUxQJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0FQUFMnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfUFJPQ0VTU0tFWScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19QQUNLRVQnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfREJFX1NCQ1NDSEFSJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0RCRV9EQkNTQ0hBUicsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19BVFROJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0NSU0VMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0VYU0VMJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX0VSRU9GJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX1BMQVknLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfWk9PTScsIGVtcHR5LCBlbXB0eV0sXG4gICAgICAgIFsxLCAwIC8qIFNjYW5Db2RlLk5vbmUgKi8sIGVtcHR5LCAwIC8qIEtleUNvZGUuVW5rbm93biAqLywgZW1wdHksIDAsICdWS19OT05BTUUnLCBlbXB0eSwgZW1wdHldLFxuICAgICAgICBbMSwgMCAvKiBTY2FuQ29kZS5Ob25lICovLCBlbXB0eSwgMCAvKiBLZXlDb2RlLlVua25vd24gKi8sIGVtcHR5LCAwLCAnVktfUEExJywgZW1wdHksIGVtcHR5XSxcbiAgICAgICAgWzEsIDAgLyogU2NhbkNvZGUuTm9uZSAqLywgZW1wdHksIDAgLyogS2V5Q29kZS5Vbmtub3duICovLCBlbXB0eSwgMCwgJ1ZLX09FTV9DTEVBUicsIGVtcHR5LCBlbXB0eV0sXG4gICAgXTtcbiAgICBjb25zdCBzZWVuS2V5Q29kZSA9IFtdO1xuICAgIGNvbnN0IHNlZW5TY2FuQ29kZSA9IFtdO1xuICAgIGZvciAoY29uc3QgbWFwcGluZyBvZiBtYXBwaW5ncykge1xuICAgICAgICBjb25zdCBbaW1tdXRhYmxlLCBzY2FuQ29kZSwgc2NhbkNvZGVTdHIsIGtleUNvZGUsIGtleUNvZGVTdHIsIGV2ZW50S2V5Q29kZSwgdmtleSwgdXNVc2VyU2V0dGluZ3NMYWJlbCwgZ2VuZXJhbFVzZXJTZXR0aW5nc0xhYmVsXSA9IG1hcHBpbmc7XG4gICAgICAgIGlmICghc2VlblNjYW5Db2RlW3NjYW5Db2RlXSkge1xuICAgICAgICAgICAgc2VlblNjYW5Db2RlW3NjYW5Db2RlXSA9IHRydWU7XG4gICAgICAgICAgICBzY2FuQ29kZUludFRvU3RyW3NjYW5Db2RlXSA9IHNjYW5Db2RlU3RyO1xuICAgICAgICAgICAgc2NhbkNvZGVTdHJUb0ludFtzY2FuQ29kZVN0cl0gPSBzY2FuQ29kZTtcbiAgICAgICAgICAgIHNjYW5Db2RlTG93ZXJDYXNlU3RyVG9JbnRbc2NhbkNvZGVTdHIudG9Mb3dlckNhc2UoKV0gPSBzY2FuQ29kZTtcbiAgICAgICAgICAgIGlmIChpbW11dGFibGUpIHtcbiAgICAgICAgICAgICAgICBJTU1VVEFCTEVfQ09ERV9UT19LRVlfQ09ERVtzY2FuQ29kZV0gPSBrZXlDb2RlO1xuICAgICAgICAgICAgICAgIGlmICgoa2V5Q29kZSAhPT0gMCAvKiBLZXlDb2RlLlVua25vd24gKi8pXG4gICAgICAgICAgICAgICAgICAgICYmIChrZXlDb2RlICE9PSAzIC8qIEtleUNvZGUuRW50ZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICYmIChrZXlDb2RlICE9PSA1IC8qIEtleUNvZGUuQ3RybCAqLylcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDQgLyogS2V5Q29kZS5TaGlmdCAqLylcbiAgICAgICAgICAgICAgICAgICAgJiYgKGtleUNvZGUgIT09IDYgLyogS2V5Q29kZS5BbHQgKi8pXG4gICAgICAgICAgICAgICAgICAgICYmIChrZXlDb2RlICE9PSA1NyAvKiBLZXlDb2RlLk1ldGEgKi8pKSB7XG4gICAgICAgICAgICAgICAgICAgIElNTVVUQUJMRV9LRVlfQ09ERV9UT19DT0RFW2tleUNvZGVdID0gc2NhbkNvZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghc2VlbktleUNvZGVba2V5Q29kZV0pIHtcbiAgICAgICAgICAgIHNlZW5LZXlDb2RlW2tleUNvZGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICgha2V5Q29kZVN0cikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgU3RyaW5nIHJlcHJlc2VudGF0aW9uIG1pc3NpbmcgZm9yIGtleSBjb2RlICR7a2V5Q29kZX0gYXJvdW5kIHNjYW4gY29kZSAke3NjYW5Db2RlU3RyfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdWlNYXAuZGVmaW5lKGtleUNvZGUsIGtleUNvZGVTdHIpO1xuICAgICAgICAgICAgdXNlclNldHRpbmdzVVNNYXAuZGVmaW5lKGtleUNvZGUsIHVzVXNlclNldHRpbmdzTGFiZWwgfHwga2V5Q29kZVN0cik7XG4gICAgICAgICAgICB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwLmRlZmluZShrZXlDb2RlLCBnZW5lcmFsVXNlclNldHRpbmdzTGFiZWwgfHwgdXNVc2VyU2V0dGluZ3NMYWJlbCB8fCBrZXlDb2RlU3RyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRLZXlDb2RlKSB7XG4gICAgICAgICAgICBFVkVOVF9LRVlfQ09ERV9NQVBbZXZlbnRLZXlDb2RlXSA9IGtleUNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZrZXkpIHtcbiAgICAgICAgICAgIE5BVElWRV9XSU5ET1dTX0tFWV9DT0RFX1RPX0tFWV9DT0RFW3ZrZXldID0ga2V5Q29kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNYW51YWxseSBhZGRlZCBkdWUgdG8gdGhlIGV4Y2x1c2lvbiBhYm92ZSAoZHVlIHRvIGR1cGxpY2F0aW9uIHdpdGggTnVtcGFkRW50ZXIpXG4gICAgSU1NVVRBQkxFX0tFWV9DT0RFX1RPX0NPREVbMyAvKiBLZXlDb2RlLkVudGVyICovXSA9IDQ2IC8qIFNjYW5Db2RlLkVudGVyICovO1xufSkoKTtcbmV4cG9ydCB2YXIgS2V5Q29kZVV0aWxzO1xuKGZ1bmN0aW9uIChLZXlDb2RlVXRpbHMpIHtcbiAgICBmdW5jdGlvbiB0b1N0cmluZyhrZXlDb2RlKSB7XG4gICAgICAgIHJldHVybiB1aU1hcC5rZXlDb2RlVG9TdHIoa2V5Q29kZSk7XG4gICAgfVxuICAgIEtleUNvZGVVdGlscy50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcoa2V5KSB7XG4gICAgICAgIHJldHVybiB1aU1hcC5zdHJUb0tleUNvZGUoa2V5KTtcbiAgICB9XG4gICAgS2V5Q29kZVV0aWxzLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nO1xuICAgIGZ1bmN0aW9uIHRvVXNlclNldHRpbmdzVVMoa2V5Q29kZSkge1xuICAgICAgICByZXR1cm4gdXNlclNldHRpbmdzVVNNYXAua2V5Q29kZVRvU3RyKGtleUNvZGUpO1xuICAgIH1cbiAgICBLZXlDb2RlVXRpbHMudG9Vc2VyU2V0dGluZ3NVUyA9IHRvVXNlclNldHRpbmdzVVM7XG4gICAgZnVuY3Rpb24gdG9Vc2VyU2V0dGluZ3NHZW5lcmFsKGtleUNvZGUpIHtcbiAgICAgICAgcmV0dXJuIHVzZXJTZXR0aW5nc0dlbmVyYWxNYXAua2V5Q29kZVRvU3RyKGtleUNvZGUpO1xuICAgIH1cbiAgICBLZXlDb2RlVXRpbHMudG9Vc2VyU2V0dGluZ3NHZW5lcmFsID0gdG9Vc2VyU2V0dGluZ3NHZW5lcmFsO1xuICAgIGZ1bmN0aW9uIGZyb21Vc2VyU2V0dGluZ3Moa2V5KSB7XG4gICAgICAgIHJldHVybiB1c2VyU2V0dGluZ3NVU01hcC5zdHJUb0tleUNvZGUoa2V5KSB8fCB1c2VyU2V0dGluZ3NHZW5lcmFsTWFwLnN0clRvS2V5Q29kZShrZXkpO1xuICAgIH1cbiAgICBLZXlDb2RlVXRpbHMuZnJvbVVzZXJTZXR0aW5ncyA9IGZyb21Vc2VyU2V0dGluZ3M7XG4gICAgZnVuY3Rpb24gdG9FbGVjdHJvbkFjY2VsZXJhdG9yKGtleUNvZGUpIHtcbiAgICAgICAgaWYgKGtleUNvZGUgPj0gOTggLyogS2V5Q29kZS5OdW1wYWQwICovICYmIGtleUNvZGUgPD0gMTEzIC8qIEtleUNvZGUuTnVtcGFkRGl2aWRlICovKSB7XG4gICAgICAgICAgICAvLyBbRWxlY3Ryb24gQWNjZWxlcmF0b3JzXSBFbGVjdHJvbiBpcyBhYmxlIHRvIHBhcnNlIG51bXBhZCBrZXlzLCBidXQgdW5mb3J0dW5hdGVseSBpdFxuICAgICAgICAgICAgLy8gcmVuZGVycyB0aGVtIGp1c3QgYXMgcmVndWxhciBrZXlzIGluIG1lbnVzLiBGb3IgZXhhbXBsZSwgbnVtMCBpcyByZW5kZXJlZCBhcyBcIjBcIixcbiAgICAgICAgICAgIC8vIG51bWRpdiBpcyByZW5kZXJlZCBhcyBcIi9cIiwgbnVtc3ViIGlzIHJlbmRlcmVkIGFzIFwiLVwiLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIGxlYWQgdG8gaW5jcmVkaWJsZSBjb25mdXNpb24sIGFzIGl0IG1ha2VzIG51bXBhZCBiYXNlZCBrZXliaW5kaW5ncyBpbmRpc3Rpbmd1aXNoYWJsZVxuICAgICAgICAgICAgLy8gZnJvbSBrZXliaW5kaW5ncyBiYXNlZCBvbiByZWd1bGFyIGtleXMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV2UgdGhlcmVmb3JlIG5lZWQgdG8gZmFsbCBiYWNrIHRvIGN1c3RvbSByZW5kZXJpbmcgZm9yIG51bXBhZCBrZXlzLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChrZXlDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDE2IC8qIEtleUNvZGUuVXBBcnJvdyAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1VwJztcbiAgICAgICAgICAgIGNhc2UgMTggLyogS2V5Q29kZS5Eb3duQXJyb3cgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICdEb3duJztcbiAgICAgICAgICAgIGNhc2UgMTUgLyogS2V5Q29kZS5MZWZ0QXJyb3cgKi86XG4gICAgICAgICAgICAgICAgcmV0dXJuICdMZWZ0JztcbiAgICAgICAgICAgIGNhc2UgMTcgLyogS2V5Q29kZS5SaWdodEFycm93ICovOlxuICAgICAgICAgICAgICAgIHJldHVybiAnUmlnaHQnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1aU1hcC5rZXlDb2RlVG9TdHIoa2V5Q29kZSk7XG4gICAgfVxuICAgIEtleUNvZGVVdGlscy50b0VsZWN0cm9uQWNjZWxlcmF0b3IgPSB0b0VsZWN0cm9uQWNjZWxlcmF0b3I7XG59KShLZXlDb2RlVXRpbHMgfHwgKEtleUNvZGVVdGlscyA9IHt9KSk7XG5leHBvcnQgZnVuY3Rpb24gS2V5Q2hvcmQoZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0KSB7XG4gICAgY29uc3QgY2hvcmRQYXJ0ID0gKChzZWNvbmRQYXJ0ICYgMHgwMDAwRkZGRikgPDwgMTYpID4+PiAwO1xuICAgIHJldHVybiAoZmlyc3RQYXJ0IHwgY2hvcmRQYXJ0KSA+Pj4gMDtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi9yYW5nZS5qcyc7XG4vKipcbiAqIEEgc2VsZWN0aW9uIGluIHRoZSBlZGl0b3IuXG4gKiBUaGUgc2VsZWN0aW9uIGlzIGEgcmFuZ2UgdGhhdCBoYXMgYW4gb3JpZW50YXRpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWxlY3Rpb24gZXh0ZW5kcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3Ioc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCBzZWxlY3Rpb25TdGFydENvbHVtbiwgcG9zaXRpb25MaW5lTnVtYmVyLCBwb3NpdGlvbkNvbHVtbikge1xuICAgICAgICBzdXBlcihzZWxlY3Rpb25TdGFydExpbmVOdW1iZXIsIHNlbGVjdGlvblN0YXJ0Q29sdW1uLCBwb3NpdGlvbkxpbmVOdW1iZXIsIHBvc2l0aW9uQ29sdW1uKTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgPSBzZWxlY3Rpb25TdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uU3RhcnRDb2x1bW4gPSBzZWxlY3Rpb25TdGFydENvbHVtbjtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkxpbmVOdW1iZXIgPSBwb3NpdGlvbkxpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMucG9zaXRpb25Db2x1bW4gPSBwb3NpdGlvbkNvbHVtbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtIHRvIGEgaHVtYW4tcmVhZGFibGUgcmVwcmVzZW50YXRpb24uXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnWycgKyB0aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciArICcsJyArIHRoaXMuc2VsZWN0aW9uU3RhcnRDb2x1bW4gKyAnIC0+ICcgKyB0aGlzLnBvc2l0aW9uTGluZU51bWJlciArICcsJyArIHRoaXMucG9zaXRpb25Db2x1bW4gKyAnXSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgZXF1YWxzIG90aGVyIHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBlcXVhbHNTZWxlY3Rpb24ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIChTZWxlY3Rpb24uc2VsZWN0aW9uc0VxdWFsKHRoaXMsIG90aGVyKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgdGhlIHR3byBzZWxlY3Rpb25zIGFyZSBlcXVhbC5cbiAgICAgKi9cbiAgICBzdGF0aWMgc2VsZWN0aW9uc0VxdWFsKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciA9PT0gYi5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgJiZcbiAgICAgICAgICAgIGEuc2VsZWN0aW9uU3RhcnRDb2x1bW4gPT09IGIuc2VsZWN0aW9uU3RhcnRDb2x1bW4gJiZcbiAgICAgICAgICAgIGEucG9zaXRpb25MaW5lTnVtYmVyID09PSBiLnBvc2l0aW9uTGluZU51bWJlciAmJlxuICAgICAgICAgICAgYS5wb3NpdGlvbkNvbHVtbiA9PT0gYi5wb3NpdGlvbkNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBkaXJlY3Rpb25zIChMVFIgb3IgUlRMKS5cbiAgICAgKi9cbiAgICBnZXREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGlvblN0YXJ0TGluZU51bWJlciA9PT0gdGhpcy5zdGFydExpbmVOdW1iZXIgJiYgdGhpcy5zZWxlY3Rpb25TdGFydENvbHVtbiA9PT0gdGhpcy5zdGFydENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIDAgLyogU2VsZWN0aW9uRGlyZWN0aW9uLkxUUiAqLztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMSAvKiBTZWxlY3Rpb25EaXJlY3Rpb24uUlRMICovO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgc2VsZWN0aW9uIHdpdGggYSBkaWZmZXJlbnQgYHBvc2l0aW9uTGluZU51bWJlcmAgYW5kIGBwb3NpdGlvbkNvbHVtbmAuXG4gICAgICovXG4gICAgc2V0RW5kUG9zaXRpb24oZW5kTGluZU51bWJlciwgZW5kQ29sdW1uKSB7XG4gICAgICAgIGlmICh0aGlzLmdldERpcmVjdGlvbigpID09PSAwIC8qIFNlbGVjdGlvbkRpcmVjdGlvbi5MVFIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHRoaXMuc3RhcnRMaW5lTnVtYmVyLCB0aGlzLnN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbiwgdGhpcy5zdGFydExpbmVOdW1iZXIsIHRoaXMuc3RhcnRDb2x1bW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHBvc2l0aW9uIGF0IGBwb3NpdGlvbkxpbmVOdW1iZXJgIGFuZCBgcG9zaXRpb25Db2x1bW5gLlxuICAgICAqL1xuICAgIGdldFBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMucG9zaXRpb25MaW5lTnVtYmVyLCB0aGlzLnBvc2l0aW9uQ29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIGdldFNlbGVjdGlvblN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFBvc2l0aW9uKHRoaXMuc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCB0aGlzLnNlbGVjdGlvblN0YXJ0Q29sdW1uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHNlbGVjdGlvbiB3aXRoIGEgZGlmZmVyZW50IGBzZWxlY3Rpb25TdGFydExpbmVOdW1iZXJgIGFuZCBgc2VsZWN0aW9uU3RhcnRDb2x1bW5gLlxuICAgICAqL1xuICAgIHNldFN0YXJ0UG9zaXRpb24oc3RhcnRMaW5lTnVtYmVyLCBzdGFydENvbHVtbikge1xuICAgICAgICBpZiAodGhpcy5nZXREaXJlY3Rpb24oKSA9PT0gMCAvKiBTZWxlY3Rpb25EaXJlY3Rpb24uTFRSICovKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCB0aGlzLmVuZExpbmVOdW1iZXIsIHRoaXMuZW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbih0aGlzLmVuZExpbmVOdW1iZXIsIHRoaXMuZW5kQ29sdW1uLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKTtcbiAgICB9XG4gICAgLy8gLS0tLVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGBTZWxlY3Rpb25gIGZyb20gb25lIG9yIHR3byBwb3NpdGlvbnNcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVBvc2l0aW9ucyhzdGFydCwgZW5kID0gc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oc3RhcnQubGluZU51bWJlciwgc3RhcnQuY29sdW1uLCBlbmQubGluZU51bWJlciwgZW5kLmNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgU2VsZWN0aW9uYCBmcm9tIGEgcmFuZ2UsIGdpdmVuIGEgZGlyZWN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUmFuZ2UocmFuZ2UsIGRpcmVjdGlvbikge1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAwIC8qIFNlbGVjdGlvbkRpcmVjdGlvbi5MVFIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4sIHJhbmdlLmVuZExpbmVOdW1iZXIsIHJhbmdlLmVuZENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZS5lbmRMaW5lTnVtYmVyLCByYW5nZS5lbmRDb2x1bW4sIHJhbmdlLnN0YXJ0TGluZU51bWJlciwgcmFuZ2Uuc3RhcnRDb2x1bW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGBTZWxlY3Rpb25gIGZyb20gYW4gYElTZWxlY3Rpb25gLlxuICAgICAqL1xuICAgIHN0YXRpYyBsaWZ0U2VsZWN0aW9uKHNlbCkge1xuICAgICAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihzZWwuc2VsZWN0aW9uU3RhcnRMaW5lTnVtYmVyLCBzZWwuc2VsZWN0aW9uU3RhcnRDb2x1bW4sIHNlbC5wb3NpdGlvbkxpbmVOdW1iZXIsIHNlbC5wb3NpdGlvbkNvbHVtbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGBhYCBlcXVhbHMgYGJgLlxuICAgICAqL1xuICAgIHN0YXRpYyBzZWxlY3Rpb25zQXJyRXF1YWwoYSwgYikge1xuICAgICAgICBpZiAoYSAmJiAhYiB8fCAhYSAmJiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25zRXF1YWwoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgYG9iamAgaXMgYW4gYElTZWxlY3Rpb25gLlxuICAgICAqL1xuICAgIHN0YXRpYyBpc0lTZWxlY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiAob2JqXG4gICAgICAgICAgICAmJiAodHlwZW9mIG9iai5zZWxlY3Rpb25TdGFydExpbmVOdW1iZXIgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmouc2VsZWN0aW9uU3RhcnRDb2x1bW4gPT09ICdudW1iZXInKVxuICAgICAgICAgICAgJiYgKHR5cGVvZiBvYmoucG9zaXRpb25MaW5lTnVtYmVyID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICYmICh0eXBlb2Ygb2JqLnBvc2l0aW9uQ29sdW1uID09PSAnbnVtYmVyJykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgd2l0aCBhIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlV2l0aERpcmVjdGlvbihzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uLCBlbmRMaW5lTnVtYmVyLCBlbmRDb2x1bW4sIGRpcmVjdGlvbikge1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAwIC8qIFNlbGVjdGlvbkRpcmVjdGlvbi5MVFIgKi8pIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2VsZWN0aW9uKHN0YXJ0TGluZU51bWJlciwgc3RhcnRDb2x1bW4sIGVuZExpbmVOdW1iZXIsIGVuZENvbHVtbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTZWxlY3Rpb24oZW5kTGluZU51bWJlciwgZW5kQ29sdW1uLCBzdGFydExpbmVOdW1iZXIsIHN0YXJ0Q29sdW1uKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGEgSmF2YVNjcmlwdCBTdHJpbmcgb3Igbm90LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XG4gICAgcmV0dXJuICh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyk7XG59XG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBvZiB0eXBlIGBvYmplY3RgIGJ1dCAqKm5vdCoqXG4gKlx0YG51bGxgLCBhbiBgYXJyYXlgLCBhIGByZWdleHBgLCBub3IgYSBgZGF0ZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgICAvLyBUaGUgbWV0aG9kIGNhbid0IGRvIGEgdHlwZSBjYXN0IHNpbmNlIHRoZXJlIGFyZSB0eXBlIChsaWtlIHN0cmluZ3MpIHdoaWNoXG4gICAgLy8gYXJlIHN1YmNsYXNzZXMgb2YgYW55IHB1dCBub3QgcG9zaXR2ZWx5IG1hdGNoZWQgYnkgdGhlIGZ1bmN0aW9uLiBIZW5jZSB0eXBlXG4gICAgLy8gbmFycm93aW5nIHJlc3VsdHMgaW4gd3JvbmcgcmVzdWx0cy5cbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbiAgICAgICAgJiYgb2JqICE9PSBudWxsXG4gICAgICAgICYmICFBcnJheS5pc0FycmF5KG9iailcbiAgICAgICAgJiYgIShvYmogaW5zdGFuY2VvZiBSZWdFeHApXG4gICAgICAgICYmICEob2JqIGluc3RhbmNlb2YgRGF0ZSk7XG59XG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBvZiB0eXBlIGBCdWZmZXJgIG9yIFVpbnQ4QXJyYXkgZGVydml2ZWQgdHlwZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlZEFycmF5KG9iaikge1xuICAgIGNvbnN0IFR5cGVkQXJyYXkgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVWludDhBcnJheSk7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG4gICAgICAgICYmIG9iaiBpbnN0YW5jZW9mIFR5cGVkQXJyYXk7XG59XG4vKipcbiAqIEluICoqY29udHJhc3QqKiB0byBqdXN0IGNoZWNraW5nIGB0eXBlb2ZgIHRoaXMgd2lsbCByZXR1cm4gYGZhbHNlYCBmb3IgYE5hTmAuXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgYSBKYXZhU2NyaXB0IE51bWJlciBvciBub3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc051bWJlcihvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICdudW1iZXInICYmICFpc05hTihvYmopKTtcbn1cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGFuIEl0ZXJhYmxlLCBjYXN0aW5nIHRvIHRoZSBnaXZlbiBnZW5lcmljXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0l0ZXJhYmxlKG9iaikge1xuICAgIHJldHVybiAhIW9iaiAmJiB0eXBlb2Ygb2JqW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyBhIEphdmFTY3JpcHQgQm9vbGVhbiBvciBub3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Jvb2xlYW4ob2JqKSB7XG4gICAgcmV0dXJuIChvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSk7XG59XG4vKipcbiAqIEByZXR1cm5zIHdoZXRoZXIgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZChvYmopIHtcbiAgICByZXR1cm4gKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKTtcbn1cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmluZWQoYXJnKSB7XG4gICAgcmV0dXJuICFpc1VuZGVmaW5lZE9yTnVsbChhcmcpO1xufVxuLyoqXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBwcm92aWRlZCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbChvYmopIHtcbiAgICByZXR1cm4gKGlzVW5kZWZpbmVkKG9iaikgfHwgb2JqID09PSBudWxsKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRUeXBlKGNvbmRpdGlvbiwgdHlwZSkge1xuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0eXBlID8gYFVuZXhwZWN0ZWQgdHlwZSwgZXhwZWN0ZWQgJyR7dHlwZX0nYCA6ICdVbmV4cGVjdGVkIHR5cGUnKTtcbiAgICB9XG59XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgYXJndW1lbnQgcGFzc2VkIGluIGlzIG5laXRoZXIgdW5kZWZpbmVkIG5vciBudWxsLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXNEZWZpbmVkKGFyZykge1xuICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhcmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXNzZXJ0aW9uIEZhaWxlZDogYXJndW1lbnQgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZztcbn1cbi8qKlxuICogQHJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgcGFyYW1ldGVyIGlzIGEgSmF2YVNjcmlwdCBGdW5jdGlvbiBvciBub3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0Z1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDb25zdHJhaW50cyhhcmdzLCBjb25zdHJhaW50cykge1xuICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKGFyZ3MubGVuZ3RoLCBjb25zdHJhaW50cy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFsaWRhdGVDb25zdHJhaW50KGFyZ3NbaV0sIGNvbnN0cmFpbnRzW2ldKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVDb25zdHJhaW50KGFyZywgY29uc3RyYWludCkge1xuICAgIGlmIChpc1N0cmluZyhjb25zdHJhaW50KSkge1xuICAgICAgICBpZiAodHlwZW9mIGFyZyAhPT0gY29uc3RyYWludCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudCBkb2VzIG5vdCBtYXRjaCBjb25zdHJhaW50OiB0eXBlb2YgJHtjb25zdHJhaW50fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24oY29uc3RyYWludCkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBjb25zdHJhaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZE9yTnVsbChhcmcpICYmIGFyZy5jb25zdHJ1Y3RvciA9PT0gY29uc3RyYWludCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJhaW50Lmxlbmd0aCA9PT0gMSAmJiBjb25zdHJhaW50LmNhbGwodW5kZWZpbmVkLCBhcmcpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhcmd1bWVudCBkb2VzIG5vdCBtYXRjaCBvbmUgb2YgdGhlc2UgY29uc3RyYWludHM6IGFyZyBpbnN0YW5jZW9mIGNvbnN0cmFpbnQsIGFyZy5jb25zdHJ1Y3RvciA9PT0gY29uc3RyYWludCwgbm9yIGNvbnN0cmFpbnQoYXJnKSA9PT0gdHJ1ZWApO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi90eXBlcy5qcyc7XG5jb25zdCBfY29kaWNvbkZvbnRDaGFyYWN0ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RlcihpZCwgZm9udENoYXJhY3Rlcikge1xuICAgIGlmIChpc1N0cmluZyhmb250Q2hhcmFjdGVyKSkge1xuICAgICAgICBjb25zdCB2YWwgPSBfY29kaWNvbkZvbnRDaGFyYWN0ZXJzW2ZvbnRDaGFyYWN0ZXJdO1xuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtpZH0gcmVmZXJlbmNlcyBhbiB1bmtub3duIGNvZGljb246ICR7Zm9udENoYXJhY3Rlcn1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb250Q2hhcmFjdGVyID0gdmFsO1xuICAgIH1cbiAgICBfY29kaWNvbkZvbnRDaGFyYWN0ZXJzW2lkXSA9IGZvbnRDaGFyYWN0ZXI7XG4gICAgcmV0dXJuIHsgaWQgfTtcbn1cbi8qKlxuICogT25seSB0byBiZSB1c2VkIGJ5IHRoZSBpY29uUmVnaXN0cnkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2RpY29uRm9udENoYXJhY3RlcnMoKSB7XG4gICAgcmV0dXJuIF9jb2RpY29uRm9udENoYXJhY3RlcnM7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IHJlZ2lzdGVyIH0gZnJvbSAnLi9jb2RpY29uc1V0aWwuanMnO1xuLy8gVGhpcyBmaWxlIGlzIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGJ5IChtaWNyb3NvZnQvdnNjb2RlLWNvZGljb25zKS9zY3JpcHRzL2V4cG9ydC10by10cy5qc1xuLy8gUGxlYXNlIGRvbid0IGVkaXQgaXQsIGFzIHlvdXIgY2hhbmdlcyB3aWxsIGJlIG92ZXJ3cml0dGVuLlxuLy8gSW5zdGVhZCwgYWRkIG1hcHBpbmdzIHRvIGNvZGljb25zRGVyaXZlZCBpbiBjb2RpY29ucy50cy5cbmV4cG9ydCBjb25zdCBjb2RpY29uc0xpYnJhcnkgPSB7XG4gICAgYWRkOiByZWdpc3RlcignYWRkJywgMHhlYTYwKSxcbiAgICBwbHVzOiByZWdpc3RlcigncGx1cycsIDB4ZWE2MCksXG4gICAgZ2lzdE5ldzogcmVnaXN0ZXIoJ2dpc3QtbmV3JywgMHhlYTYwKSxcbiAgICByZXBvQ3JlYXRlOiByZWdpc3RlcigncmVwby1jcmVhdGUnLCAweGVhNjApLFxuICAgIGxpZ2h0YnVsYjogcmVnaXN0ZXIoJ2xpZ2h0YnVsYicsIDB4ZWE2MSksXG4gICAgbGlnaHRCdWxiOiByZWdpc3RlcignbGlnaHQtYnVsYicsIDB4ZWE2MSksXG4gICAgcmVwbzogcmVnaXN0ZXIoJ3JlcG8nLCAweGVhNjIpLFxuICAgIHJlcG9EZWxldGU6IHJlZ2lzdGVyKCdyZXBvLWRlbGV0ZScsIDB4ZWE2MiksXG4gICAgZ2lzdEZvcms6IHJlZ2lzdGVyKCdnaXN0LWZvcmsnLCAweGVhNjMpLFxuICAgIHJlcG9Gb3JrZWQ6IHJlZ2lzdGVyKCdyZXBvLWZvcmtlZCcsIDB4ZWE2MyksXG4gICAgZ2l0UHVsbFJlcXVlc3Q6IHJlZ2lzdGVyKCdnaXQtcHVsbC1yZXF1ZXN0JywgMHhlYTY0KSxcbiAgICBnaXRQdWxsUmVxdWVzdEFiYW5kb25lZDogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtYWJhbmRvbmVkJywgMHhlYTY0KSxcbiAgICByZWNvcmRLZXlzOiByZWdpc3RlcigncmVjb3JkLWtleXMnLCAweGVhNjUpLFxuICAgIGtleWJvYXJkOiByZWdpc3Rlcigna2V5Ym9hcmQnLCAweGVhNjUpLFxuICAgIHRhZzogcmVnaXN0ZXIoJ3RhZycsIDB4ZWE2NiksXG4gICAgZ2l0UHVsbFJlcXVlc3RMYWJlbDogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtbGFiZWwnLCAweGVhNjYpLFxuICAgIHRhZ0FkZDogcmVnaXN0ZXIoJ3RhZy1hZGQnLCAweGVhNjYpLFxuICAgIHRhZ1JlbW92ZTogcmVnaXN0ZXIoJ3RhZy1yZW1vdmUnLCAweGVhNjYpLFxuICAgIHBlcnNvbjogcmVnaXN0ZXIoJ3BlcnNvbicsIDB4ZWE2NyksXG4gICAgcGVyc29uRm9sbG93OiByZWdpc3RlcigncGVyc29uLWZvbGxvdycsIDB4ZWE2NyksXG4gICAgcGVyc29uT3V0bGluZTogcmVnaXN0ZXIoJ3BlcnNvbi1vdXRsaW5lJywgMHhlYTY3KSxcbiAgICBwZXJzb25GaWxsZWQ6IHJlZ2lzdGVyKCdwZXJzb24tZmlsbGVkJywgMHhlYTY3KSxcbiAgICBnaXRCcmFuY2g6IHJlZ2lzdGVyKCdnaXQtYnJhbmNoJywgMHhlYTY4KSxcbiAgICBnaXRCcmFuY2hDcmVhdGU6IHJlZ2lzdGVyKCdnaXQtYnJhbmNoLWNyZWF0ZScsIDB4ZWE2OCksXG4gICAgZ2l0QnJhbmNoRGVsZXRlOiByZWdpc3RlcignZ2l0LWJyYW5jaC1kZWxldGUnLCAweGVhNjgpLFxuICAgIHNvdXJjZUNvbnRyb2w6IHJlZ2lzdGVyKCdzb3VyY2UtY29udHJvbCcsIDB4ZWE2OCksXG4gICAgbWlycm9yOiByZWdpc3RlcignbWlycm9yJywgMHhlYTY5KSxcbiAgICBtaXJyb3JQdWJsaWM6IHJlZ2lzdGVyKCdtaXJyb3ItcHVibGljJywgMHhlYTY5KSxcbiAgICBzdGFyOiByZWdpc3Rlcignc3RhcicsIDB4ZWE2YSksXG4gICAgc3RhckFkZDogcmVnaXN0ZXIoJ3N0YXItYWRkJywgMHhlYTZhKSxcbiAgICBzdGFyRGVsZXRlOiByZWdpc3Rlcignc3Rhci1kZWxldGUnLCAweGVhNmEpLFxuICAgIHN0YXJFbXB0eTogcmVnaXN0ZXIoJ3N0YXItZW1wdHknLCAweGVhNmEpLFxuICAgIGNvbW1lbnQ6IHJlZ2lzdGVyKCdjb21tZW50JywgMHhlYTZiKSxcbiAgICBjb21tZW50QWRkOiByZWdpc3RlcignY29tbWVudC1hZGQnLCAweGVhNmIpLFxuICAgIGFsZXJ0OiByZWdpc3RlcignYWxlcnQnLCAweGVhNmMpLFxuICAgIHdhcm5pbmc6IHJlZ2lzdGVyKCd3YXJuaW5nJywgMHhlYTZjKSxcbiAgICBzZWFyY2g6IHJlZ2lzdGVyKCdzZWFyY2gnLCAweGVhNmQpLFxuICAgIHNlYXJjaFNhdmU6IHJlZ2lzdGVyKCdzZWFyY2gtc2F2ZScsIDB4ZWE2ZCksXG4gICAgbG9nT3V0OiByZWdpc3RlcignbG9nLW91dCcsIDB4ZWE2ZSksXG4gICAgc2lnbk91dDogcmVnaXN0ZXIoJ3NpZ24tb3V0JywgMHhlYTZlKSxcbiAgICBsb2dJbjogcmVnaXN0ZXIoJ2xvZy1pbicsIDB4ZWE2ZiksXG4gICAgc2lnbkluOiByZWdpc3Rlcignc2lnbi1pbicsIDB4ZWE2ZiksXG4gICAgZXllOiByZWdpc3RlcignZXllJywgMHhlYTcwKSxcbiAgICBleWVVbndhdGNoOiByZWdpc3RlcignZXllLXVud2F0Y2gnLCAweGVhNzApLFxuICAgIGV5ZVdhdGNoOiByZWdpc3RlcignZXllLXdhdGNoJywgMHhlYTcwKSxcbiAgICBjaXJjbGVGaWxsZWQ6IHJlZ2lzdGVyKCdjaXJjbGUtZmlsbGVkJywgMHhlYTcxKSxcbiAgICBwcmltaXRpdmVEb3Q6IHJlZ2lzdGVyKCdwcmltaXRpdmUtZG90JywgMHhlYTcxKSxcbiAgICBjbG9zZURpcnR5OiByZWdpc3RlcignY2xvc2UtZGlydHknLCAweGVhNzEpLFxuICAgIGRlYnVnQnJlYWtwb2ludDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQnLCAweGVhNzEpLFxuICAgIGRlYnVnQnJlYWtwb2ludERpc2FibGVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1kaXNhYmxlZCcsIDB4ZWE3MSksXG4gICAgZGVidWdIaW50OiByZWdpc3RlcignZGVidWctaGludCcsIDB4ZWE3MSksXG4gICAgdGVybWluYWxEZWNvcmF0aW9uU3VjY2VzczogcmVnaXN0ZXIoJ3Rlcm1pbmFsLWRlY29yYXRpb24tc3VjY2VzcycsIDB4ZWE3MSksXG4gICAgcHJpbWl0aXZlU3F1YXJlOiByZWdpc3RlcigncHJpbWl0aXZlLXNxdWFyZScsIDB4ZWE3MiksXG4gICAgZWRpdDogcmVnaXN0ZXIoJ2VkaXQnLCAweGVhNzMpLFxuICAgIHBlbmNpbDogcmVnaXN0ZXIoJ3BlbmNpbCcsIDB4ZWE3MyksXG4gICAgaW5mbzogcmVnaXN0ZXIoJ2luZm8nLCAweGVhNzQpLFxuICAgIGlzc3VlT3BlbmVkOiByZWdpc3RlcignaXNzdWUtb3BlbmVkJywgMHhlYTc0KSxcbiAgICBnaXN0UHJpdmF0ZTogcmVnaXN0ZXIoJ2dpc3QtcHJpdmF0ZScsIDB4ZWE3NSksXG4gICAgZ2l0Rm9ya1ByaXZhdGU6IHJlZ2lzdGVyKCdnaXQtZm9yay1wcml2YXRlJywgMHhlYTc1KSxcbiAgICBsb2NrOiByZWdpc3RlcignbG9jaycsIDB4ZWE3NSksXG4gICAgbWlycm9yUHJpdmF0ZTogcmVnaXN0ZXIoJ21pcnJvci1wcml2YXRlJywgMHhlYTc1KSxcbiAgICBjbG9zZTogcmVnaXN0ZXIoJ2Nsb3NlJywgMHhlYTc2KSxcbiAgICByZW1vdmVDbG9zZTogcmVnaXN0ZXIoJ3JlbW92ZS1jbG9zZScsIDB4ZWE3NiksXG4gICAgeDogcmVnaXN0ZXIoJ3gnLCAweGVhNzYpLFxuICAgIHJlcG9TeW5jOiByZWdpc3RlcigncmVwby1zeW5jJywgMHhlYTc3KSxcbiAgICBzeW5jOiByZWdpc3Rlcignc3luYycsIDB4ZWE3NyksXG4gICAgY2xvbmU6IHJlZ2lzdGVyKCdjbG9uZScsIDB4ZWE3OCksXG4gICAgZGVza3RvcERvd25sb2FkOiByZWdpc3RlcignZGVza3RvcC1kb3dubG9hZCcsIDB4ZWE3OCksXG4gICAgYmVha2VyOiByZWdpc3RlcignYmVha2VyJywgMHhlYTc5KSxcbiAgICBtaWNyb3Njb3BlOiByZWdpc3RlcignbWljcm9zY29wZScsIDB4ZWE3OSksXG4gICAgdm06IHJlZ2lzdGVyKCd2bScsIDB4ZWE3YSksXG4gICAgZGV2aWNlRGVza3RvcDogcmVnaXN0ZXIoJ2RldmljZS1kZXNrdG9wJywgMHhlYTdhKSxcbiAgICBmaWxlOiByZWdpc3RlcignZmlsZScsIDB4ZWE3YiksXG4gICAgZmlsZVRleHQ6IHJlZ2lzdGVyKCdmaWxlLXRleHQnLCAweGVhN2IpLFxuICAgIG1vcmU6IHJlZ2lzdGVyKCdtb3JlJywgMHhlYTdjKSxcbiAgICBlbGxpcHNpczogcmVnaXN0ZXIoJ2VsbGlwc2lzJywgMHhlYTdjKSxcbiAgICBrZWJhYkhvcml6b250YWw6IHJlZ2lzdGVyKCdrZWJhYi1ob3Jpem9udGFsJywgMHhlYTdjKSxcbiAgICBtYWlsUmVwbHk6IHJlZ2lzdGVyKCdtYWlsLXJlcGx5JywgMHhlYTdkKSxcbiAgICByZXBseTogcmVnaXN0ZXIoJ3JlcGx5JywgMHhlYTdkKSxcbiAgICBvcmdhbml6YXRpb246IHJlZ2lzdGVyKCdvcmdhbml6YXRpb24nLCAweGVhN2UpLFxuICAgIG9yZ2FuaXphdGlvbkZpbGxlZDogcmVnaXN0ZXIoJ29yZ2FuaXphdGlvbi1maWxsZWQnLCAweGVhN2UpLFxuICAgIG9yZ2FuaXphdGlvbk91dGxpbmU6IHJlZ2lzdGVyKCdvcmdhbml6YXRpb24tb3V0bGluZScsIDB4ZWE3ZSksXG4gICAgbmV3RmlsZTogcmVnaXN0ZXIoJ25ldy1maWxlJywgMHhlYTdmKSxcbiAgICBmaWxlQWRkOiByZWdpc3RlcignZmlsZS1hZGQnLCAweGVhN2YpLFxuICAgIG5ld0ZvbGRlcjogcmVnaXN0ZXIoJ25ldy1mb2xkZXInLCAweGVhODApLFxuICAgIGZpbGVEaXJlY3RvcnlDcmVhdGU6IHJlZ2lzdGVyKCdmaWxlLWRpcmVjdG9yeS1jcmVhdGUnLCAweGVhODApLFxuICAgIHRyYXNoOiByZWdpc3RlcigndHJhc2gnLCAweGVhODEpLFxuICAgIHRyYXNoY2FuOiByZWdpc3RlcigndHJhc2hjYW4nLCAweGVhODEpLFxuICAgIGhpc3Rvcnk6IHJlZ2lzdGVyKCdoaXN0b3J5JywgMHhlYTgyKSxcbiAgICBjbG9jazogcmVnaXN0ZXIoJ2Nsb2NrJywgMHhlYTgyKSxcbiAgICBmb2xkZXI6IHJlZ2lzdGVyKCdmb2xkZXInLCAweGVhODMpLFxuICAgIGZpbGVEaXJlY3Rvcnk6IHJlZ2lzdGVyKCdmaWxlLWRpcmVjdG9yeScsIDB4ZWE4MyksXG4gICAgc3ltYm9sRm9sZGVyOiByZWdpc3Rlcignc3ltYm9sLWZvbGRlcicsIDB4ZWE4MyksXG4gICAgbG9nb0dpdGh1YjogcmVnaXN0ZXIoJ2xvZ28tZ2l0aHViJywgMHhlYTg0KSxcbiAgICBtYXJrR2l0aHViOiByZWdpc3RlcignbWFyay1naXRodWInLCAweGVhODQpLFxuICAgIGdpdGh1YjogcmVnaXN0ZXIoJ2dpdGh1YicsIDB4ZWE4NCksXG4gICAgdGVybWluYWw6IHJlZ2lzdGVyKCd0ZXJtaW5hbCcsIDB4ZWE4NSksXG4gICAgY29uc29sZTogcmVnaXN0ZXIoJ2NvbnNvbGUnLCAweGVhODUpLFxuICAgIHJlcGw6IHJlZ2lzdGVyKCdyZXBsJywgMHhlYTg1KSxcbiAgICB6YXA6IHJlZ2lzdGVyKCd6YXAnLCAweGVhODYpLFxuICAgIHN5bWJvbEV2ZW50OiByZWdpc3Rlcignc3ltYm9sLWV2ZW50JywgMHhlYTg2KSxcbiAgICBlcnJvcjogcmVnaXN0ZXIoJ2Vycm9yJywgMHhlYTg3KSxcbiAgICBzdG9wOiByZWdpc3Rlcignc3RvcCcsIDB4ZWE4NyksXG4gICAgdmFyaWFibGU6IHJlZ2lzdGVyKCd2YXJpYWJsZScsIDB4ZWE4OCksXG4gICAgc3ltYm9sVmFyaWFibGU6IHJlZ2lzdGVyKCdzeW1ib2wtdmFyaWFibGUnLCAweGVhODgpLFxuICAgIGFycmF5OiByZWdpc3RlcignYXJyYXknLCAweGVhOGEpLFxuICAgIHN5bWJvbEFycmF5OiByZWdpc3Rlcignc3ltYm9sLWFycmF5JywgMHhlYThhKSxcbiAgICBzeW1ib2xNb2R1bGU6IHJlZ2lzdGVyKCdzeW1ib2wtbW9kdWxlJywgMHhlYThiKSxcbiAgICBzeW1ib2xQYWNrYWdlOiByZWdpc3Rlcignc3ltYm9sLXBhY2thZ2UnLCAweGVhOGIpLFxuICAgIHN5bWJvbE5hbWVzcGFjZTogcmVnaXN0ZXIoJ3N5bWJvbC1uYW1lc3BhY2UnLCAweGVhOGIpLFxuICAgIHN5bWJvbE9iamVjdDogcmVnaXN0ZXIoJ3N5bWJvbC1vYmplY3QnLCAweGVhOGIpLFxuICAgIHN5bWJvbE1ldGhvZDogcmVnaXN0ZXIoJ3N5bWJvbC1tZXRob2QnLCAweGVhOGMpLFxuICAgIHN5bWJvbEZ1bmN0aW9uOiByZWdpc3Rlcignc3ltYm9sLWZ1bmN0aW9uJywgMHhlYThjKSxcbiAgICBzeW1ib2xDb25zdHJ1Y3RvcjogcmVnaXN0ZXIoJ3N5bWJvbC1jb25zdHJ1Y3RvcicsIDB4ZWE4YyksXG4gICAgc3ltYm9sQm9vbGVhbjogcmVnaXN0ZXIoJ3N5bWJvbC1ib29sZWFuJywgMHhlYThmKSxcbiAgICBzeW1ib2xOdWxsOiByZWdpc3Rlcignc3ltYm9sLW51bGwnLCAweGVhOGYpLFxuICAgIHN5bWJvbE51bWVyaWM6IHJlZ2lzdGVyKCdzeW1ib2wtbnVtZXJpYycsIDB4ZWE5MCksXG4gICAgc3ltYm9sTnVtYmVyOiByZWdpc3Rlcignc3ltYm9sLW51bWJlcicsIDB4ZWE5MCksXG4gICAgc3ltYm9sU3RydWN0dXJlOiByZWdpc3Rlcignc3ltYm9sLXN0cnVjdHVyZScsIDB4ZWE5MSksXG4gICAgc3ltYm9sU3RydWN0OiByZWdpc3Rlcignc3ltYm9sLXN0cnVjdCcsIDB4ZWE5MSksXG4gICAgc3ltYm9sUGFyYW1ldGVyOiByZWdpc3Rlcignc3ltYm9sLXBhcmFtZXRlcicsIDB4ZWE5MiksXG4gICAgc3ltYm9sVHlwZVBhcmFtZXRlcjogcmVnaXN0ZXIoJ3N5bWJvbC10eXBlLXBhcmFtZXRlcicsIDB4ZWE5MiksXG4gICAgc3ltYm9sS2V5OiByZWdpc3Rlcignc3ltYm9sLWtleScsIDB4ZWE5MyksXG4gICAgc3ltYm9sVGV4dDogcmVnaXN0ZXIoJ3N5bWJvbC10ZXh0JywgMHhlYTkzKSxcbiAgICBzeW1ib2xSZWZlcmVuY2U6IHJlZ2lzdGVyKCdzeW1ib2wtcmVmZXJlbmNlJywgMHhlYTk0KSxcbiAgICBnb1RvRmlsZTogcmVnaXN0ZXIoJ2dvLXRvLWZpbGUnLCAweGVhOTQpLFxuICAgIHN5bWJvbEVudW06IHJlZ2lzdGVyKCdzeW1ib2wtZW51bScsIDB4ZWE5NSksXG4gICAgc3ltYm9sVmFsdWU6IHJlZ2lzdGVyKCdzeW1ib2wtdmFsdWUnLCAweGVhOTUpLFxuICAgIHN5bWJvbFJ1bGVyOiByZWdpc3Rlcignc3ltYm9sLXJ1bGVyJywgMHhlYTk2KSxcbiAgICBzeW1ib2xVbml0OiByZWdpc3Rlcignc3ltYm9sLXVuaXQnLCAweGVhOTYpLFxuICAgIGFjdGl2YXRlQnJlYWtwb2ludHM6IHJlZ2lzdGVyKCdhY3RpdmF0ZS1icmVha3BvaW50cycsIDB4ZWE5NyksXG4gICAgYXJjaGl2ZTogcmVnaXN0ZXIoJ2FyY2hpdmUnLCAweGVhOTgpLFxuICAgIGFycm93Qm90aDogcmVnaXN0ZXIoJ2Fycm93LWJvdGgnLCAweGVhOTkpLFxuICAgIGFycm93RG93bjogcmVnaXN0ZXIoJ2Fycm93LWRvd24nLCAweGVhOWEpLFxuICAgIGFycm93TGVmdDogcmVnaXN0ZXIoJ2Fycm93LWxlZnQnLCAweGVhOWIpLFxuICAgIGFycm93UmlnaHQ6IHJlZ2lzdGVyKCdhcnJvdy1yaWdodCcsIDB4ZWE5YyksXG4gICAgYXJyb3dTbWFsbERvd246IHJlZ2lzdGVyKCdhcnJvdy1zbWFsbC1kb3duJywgMHhlYTlkKSxcbiAgICBhcnJvd1NtYWxsTGVmdDogcmVnaXN0ZXIoJ2Fycm93LXNtYWxsLWxlZnQnLCAweGVhOWUpLFxuICAgIGFycm93U21hbGxSaWdodDogcmVnaXN0ZXIoJ2Fycm93LXNtYWxsLXJpZ2h0JywgMHhlYTlmKSxcbiAgICBhcnJvd1NtYWxsVXA6IHJlZ2lzdGVyKCdhcnJvdy1zbWFsbC11cCcsIDB4ZWFhMCksXG4gICAgYXJyb3dVcDogcmVnaXN0ZXIoJ2Fycm93LXVwJywgMHhlYWExKSxcbiAgICBiZWxsOiByZWdpc3RlcignYmVsbCcsIDB4ZWFhMiksXG4gICAgYm9sZDogcmVnaXN0ZXIoJ2JvbGQnLCAweGVhYTMpLFxuICAgIGJvb2s6IHJlZ2lzdGVyKCdib29rJywgMHhlYWE0KSxcbiAgICBib29rbWFyazogcmVnaXN0ZXIoJ2Jvb2ttYXJrJywgMHhlYWE1KSxcbiAgICBkZWJ1Z0JyZWFrcG9pbnRDb25kaXRpb25hbFVudmVyaWZpZWQ6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWNvbmRpdGlvbmFsLXVudmVyaWZpZWQnLCAweGVhYTYpLFxuICAgIGRlYnVnQnJlYWtwb2ludENvbmRpdGlvbmFsOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1jb25kaXRpb25hbCcsIDB4ZWFhNyksXG4gICAgZGVidWdCcmVha3BvaW50Q29uZGl0aW9uYWxEaXNhYmxlZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtY29uZGl0aW9uYWwtZGlzYWJsZWQnLCAweGVhYTcpLFxuICAgIGRlYnVnQnJlYWtwb2ludERhdGFVbnZlcmlmaWVkOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1kYXRhLXVudmVyaWZpZWQnLCAweGVhYTgpLFxuICAgIGRlYnVnQnJlYWtwb2ludERhdGE6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWRhdGEnLCAweGVhYTkpLFxuICAgIGRlYnVnQnJlYWtwb2ludERhdGFEaXNhYmxlZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtZGF0YS1kaXNhYmxlZCcsIDB4ZWFhOSksXG4gICAgZGVidWdCcmVha3BvaW50TG9nVW52ZXJpZmllZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtbG9nLXVudmVyaWZpZWQnLCAweGVhYWEpLFxuICAgIGRlYnVnQnJlYWtwb2ludExvZzogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtbG9nJywgMHhlYWFiKSxcbiAgICBkZWJ1Z0JyZWFrcG9pbnRMb2dEaXNhYmxlZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtbG9nLWRpc2FibGVkJywgMHhlYWFiKSxcbiAgICBicmllZmNhc2U6IHJlZ2lzdGVyKCdicmllZmNhc2UnLCAweGVhYWMpLFxuICAgIGJyb2FkY2FzdDogcmVnaXN0ZXIoJ2Jyb2FkY2FzdCcsIDB4ZWFhZCksXG4gICAgYnJvd3NlcjogcmVnaXN0ZXIoJ2Jyb3dzZXInLCAweGVhYWUpLFxuICAgIGJ1ZzogcmVnaXN0ZXIoJ2J1ZycsIDB4ZWFhZiksXG4gICAgY2FsZW5kYXI6IHJlZ2lzdGVyKCdjYWxlbmRhcicsIDB4ZWFiMCksXG4gICAgY2FzZVNlbnNpdGl2ZTogcmVnaXN0ZXIoJ2Nhc2Utc2Vuc2l0aXZlJywgMHhlYWIxKSxcbiAgICBjaGVjazogcmVnaXN0ZXIoJ2NoZWNrJywgMHhlYWIyKSxcbiAgICBjaGVja2xpc3Q6IHJlZ2lzdGVyKCdjaGVja2xpc3QnLCAweGVhYjMpLFxuICAgIGNoZXZyb25Eb3duOiByZWdpc3RlcignY2hldnJvbi1kb3duJywgMHhlYWI0KSxcbiAgICBjaGV2cm9uTGVmdDogcmVnaXN0ZXIoJ2NoZXZyb24tbGVmdCcsIDB4ZWFiNSksXG4gICAgY2hldnJvblJpZ2h0OiByZWdpc3RlcignY2hldnJvbi1yaWdodCcsIDB4ZWFiNiksXG4gICAgY2hldnJvblVwOiByZWdpc3RlcignY2hldnJvbi11cCcsIDB4ZWFiNyksXG4gICAgY2hyb21lQ2xvc2U6IHJlZ2lzdGVyKCdjaHJvbWUtY2xvc2UnLCAweGVhYjgpLFxuICAgIGNocm9tZU1heGltaXplOiByZWdpc3RlcignY2hyb21lLW1heGltaXplJywgMHhlYWI5KSxcbiAgICBjaHJvbWVNaW5pbWl6ZTogcmVnaXN0ZXIoJ2Nocm9tZS1taW5pbWl6ZScsIDB4ZWFiYSksXG4gICAgY2hyb21lUmVzdG9yZTogcmVnaXN0ZXIoJ2Nocm9tZS1yZXN0b3JlJywgMHhlYWJiKSxcbiAgICBjaXJjbGVPdXRsaW5lOiByZWdpc3RlcignY2lyY2xlLW91dGxpbmUnLCAweGVhYmMpLFxuICAgIGNpcmNsZTogcmVnaXN0ZXIoJ2NpcmNsZScsIDB4ZWFiYyksXG4gICAgZGVidWdCcmVha3BvaW50VW52ZXJpZmllZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtdW52ZXJpZmllZCcsIDB4ZWFiYyksXG4gICAgdGVybWluYWxEZWNvcmF0aW9uSW5jb21wbGV0ZTogcmVnaXN0ZXIoJ3Rlcm1pbmFsLWRlY29yYXRpb24taW5jb21wbGV0ZScsIDB4ZWFiYyksXG4gICAgY2lyY2xlU2xhc2g6IHJlZ2lzdGVyKCdjaXJjbGUtc2xhc2gnLCAweGVhYmQpLFxuICAgIGNpcmN1aXRCb2FyZDogcmVnaXN0ZXIoJ2NpcmN1aXQtYm9hcmQnLCAweGVhYmUpLFxuICAgIGNsZWFyQWxsOiByZWdpc3RlcignY2xlYXItYWxsJywgMHhlYWJmKSxcbiAgICBjbGlwcHk6IHJlZ2lzdGVyKCdjbGlwcHknLCAweGVhYzApLFxuICAgIGNsb3NlQWxsOiByZWdpc3RlcignY2xvc2UtYWxsJywgMHhlYWMxKSxcbiAgICBjbG91ZERvd25sb2FkOiByZWdpc3RlcignY2xvdWQtZG93bmxvYWQnLCAweGVhYzIpLFxuICAgIGNsb3VkVXBsb2FkOiByZWdpc3RlcignY2xvdWQtdXBsb2FkJywgMHhlYWMzKSxcbiAgICBjb2RlOiByZWdpc3RlcignY29kZScsIDB4ZWFjNCksXG4gICAgY29sbGFwc2VBbGw6IHJlZ2lzdGVyKCdjb2xsYXBzZS1hbGwnLCAweGVhYzUpLFxuICAgIGNvbG9yTW9kZTogcmVnaXN0ZXIoJ2NvbG9yLW1vZGUnLCAweGVhYzYpLFxuICAgIGNvbW1lbnREaXNjdXNzaW9uOiByZWdpc3RlcignY29tbWVudC1kaXNjdXNzaW9uJywgMHhlYWM3KSxcbiAgICBjcmVkaXRDYXJkOiByZWdpc3RlcignY3JlZGl0LWNhcmQnLCAweGVhYzkpLFxuICAgIGRhc2g6IHJlZ2lzdGVyKCdkYXNoJywgMHhlYWNjKSxcbiAgICBkYXNoYm9hcmQ6IHJlZ2lzdGVyKCdkYXNoYm9hcmQnLCAweGVhY2QpLFxuICAgIGRhdGFiYXNlOiByZWdpc3RlcignZGF0YWJhc2UnLCAweGVhY2UpLFxuICAgIGRlYnVnQ29udGludWU6IHJlZ2lzdGVyKCdkZWJ1Zy1jb250aW51ZScsIDB4ZWFjZiksXG4gICAgZGVidWdEaXNjb25uZWN0OiByZWdpc3RlcignZGVidWctZGlzY29ubmVjdCcsIDB4ZWFkMCksXG4gICAgZGVidWdQYXVzZTogcmVnaXN0ZXIoJ2RlYnVnLXBhdXNlJywgMHhlYWQxKSxcbiAgICBkZWJ1Z1Jlc3RhcnQ6IHJlZ2lzdGVyKCdkZWJ1Zy1yZXN0YXJ0JywgMHhlYWQyKSxcbiAgICBkZWJ1Z1N0YXJ0OiByZWdpc3RlcignZGVidWctc3RhcnQnLCAweGVhZDMpLFxuICAgIGRlYnVnU3RlcEludG86IHJlZ2lzdGVyKCdkZWJ1Zy1zdGVwLWludG8nLCAweGVhZDQpLFxuICAgIGRlYnVnU3RlcE91dDogcmVnaXN0ZXIoJ2RlYnVnLXN0ZXAtb3V0JywgMHhlYWQ1KSxcbiAgICBkZWJ1Z1N0ZXBPdmVyOiByZWdpc3RlcignZGVidWctc3RlcC1vdmVyJywgMHhlYWQ2KSxcbiAgICBkZWJ1Z1N0b3A6IHJlZ2lzdGVyKCdkZWJ1Zy1zdG9wJywgMHhlYWQ3KSxcbiAgICBkZWJ1ZzogcmVnaXN0ZXIoJ2RlYnVnJywgMHhlYWQ4KSxcbiAgICBkZXZpY2VDYW1lcmFWaWRlbzogcmVnaXN0ZXIoJ2RldmljZS1jYW1lcmEtdmlkZW8nLCAweGVhZDkpLFxuICAgIGRldmljZUNhbWVyYTogcmVnaXN0ZXIoJ2RldmljZS1jYW1lcmEnLCAweGVhZGEpLFxuICAgIGRldmljZU1vYmlsZTogcmVnaXN0ZXIoJ2RldmljZS1tb2JpbGUnLCAweGVhZGIpLFxuICAgIGRpZmZBZGRlZDogcmVnaXN0ZXIoJ2RpZmYtYWRkZWQnLCAweGVhZGMpLFxuICAgIGRpZmZJZ25vcmVkOiByZWdpc3RlcignZGlmZi1pZ25vcmVkJywgMHhlYWRkKSxcbiAgICBkaWZmTW9kaWZpZWQ6IHJlZ2lzdGVyKCdkaWZmLW1vZGlmaWVkJywgMHhlYWRlKSxcbiAgICBkaWZmUmVtb3ZlZDogcmVnaXN0ZXIoJ2RpZmYtcmVtb3ZlZCcsIDB4ZWFkZiksXG4gICAgZGlmZlJlbmFtZWQ6IHJlZ2lzdGVyKCdkaWZmLXJlbmFtZWQnLCAweGVhZTApLFxuICAgIGRpZmY6IHJlZ2lzdGVyKCdkaWZmJywgMHhlYWUxKSxcbiAgICBkaWZmU2lkZWJ5c2lkZTogcmVnaXN0ZXIoJ2RpZmYtc2lkZWJ5c2lkZScsIDB4ZWFlMSksXG4gICAgZGlzY2FyZDogcmVnaXN0ZXIoJ2Rpc2NhcmQnLCAweGVhZTIpLFxuICAgIGVkaXRvckxheW91dDogcmVnaXN0ZXIoJ2VkaXRvci1sYXlvdXQnLCAweGVhZTMpLFxuICAgIGVtcHR5V2luZG93OiByZWdpc3RlcignZW1wdHktd2luZG93JywgMHhlYWU0KSxcbiAgICBleGNsdWRlOiByZWdpc3RlcignZXhjbHVkZScsIDB4ZWFlNSksXG4gICAgZXh0ZW5zaW9uczogcmVnaXN0ZXIoJ2V4dGVuc2lvbnMnLCAweGVhZTYpLFxuICAgIGV5ZUNsb3NlZDogcmVnaXN0ZXIoJ2V5ZS1jbG9zZWQnLCAweGVhZTcpLFxuICAgIGZpbGVCaW5hcnk6IHJlZ2lzdGVyKCdmaWxlLWJpbmFyeScsIDB4ZWFlOCksXG4gICAgZmlsZUNvZGU6IHJlZ2lzdGVyKCdmaWxlLWNvZGUnLCAweGVhZTkpLFxuICAgIGZpbGVNZWRpYTogcmVnaXN0ZXIoJ2ZpbGUtbWVkaWEnLCAweGVhZWEpLFxuICAgIGZpbGVQZGY6IHJlZ2lzdGVyKCdmaWxlLXBkZicsIDB4ZWFlYiksXG4gICAgZmlsZVN1Ym1vZHVsZTogcmVnaXN0ZXIoJ2ZpbGUtc3VibW9kdWxlJywgMHhlYWVjKSxcbiAgICBmaWxlU3ltbGlua0RpcmVjdG9yeTogcmVnaXN0ZXIoJ2ZpbGUtc3ltbGluay1kaXJlY3RvcnknLCAweGVhZWQpLFxuICAgIGZpbGVTeW1saW5rRmlsZTogcmVnaXN0ZXIoJ2ZpbGUtc3ltbGluay1maWxlJywgMHhlYWVlKSxcbiAgICBmaWxlWmlwOiByZWdpc3RlcignZmlsZS16aXAnLCAweGVhZWYpLFxuICAgIGZpbGVzOiByZWdpc3RlcignZmlsZXMnLCAweGVhZjApLFxuICAgIGZpbHRlcjogcmVnaXN0ZXIoJ2ZpbHRlcicsIDB4ZWFmMSksXG4gICAgZmxhbWU6IHJlZ2lzdGVyKCdmbGFtZScsIDB4ZWFmMiksXG4gICAgZm9sZERvd246IHJlZ2lzdGVyKCdmb2xkLWRvd24nLCAweGVhZjMpLFxuICAgIGZvbGRVcDogcmVnaXN0ZXIoJ2ZvbGQtdXAnLCAweGVhZjQpLFxuICAgIGZvbGQ6IHJlZ2lzdGVyKCdmb2xkJywgMHhlYWY1KSxcbiAgICBmb2xkZXJBY3RpdmU6IHJlZ2lzdGVyKCdmb2xkZXItYWN0aXZlJywgMHhlYWY2KSxcbiAgICBmb2xkZXJPcGVuZWQ6IHJlZ2lzdGVyKCdmb2xkZXItb3BlbmVkJywgMHhlYWY3KSxcbiAgICBnZWFyOiByZWdpc3RlcignZ2VhcicsIDB4ZWFmOCksXG4gICAgZ2lmdDogcmVnaXN0ZXIoJ2dpZnQnLCAweGVhZjkpLFxuICAgIGdpc3RTZWNyZXQ6IHJlZ2lzdGVyKCdnaXN0LXNlY3JldCcsIDB4ZWFmYSksXG4gICAgZ2lzdDogcmVnaXN0ZXIoJ2dpc3QnLCAweGVhZmIpLFxuICAgIGdpdENvbW1pdDogcmVnaXN0ZXIoJ2dpdC1jb21taXQnLCAweGVhZmMpLFxuICAgIGdpdENvbXBhcmU6IHJlZ2lzdGVyKCdnaXQtY29tcGFyZScsIDB4ZWFmZCksXG4gICAgY29tcGFyZUNoYW5nZXM6IHJlZ2lzdGVyKCdjb21wYXJlLWNoYW5nZXMnLCAweGVhZmQpLFxuICAgIGdpdE1lcmdlOiByZWdpc3RlcignZ2l0LW1lcmdlJywgMHhlYWZlKSxcbiAgICBnaXRodWJBY3Rpb246IHJlZ2lzdGVyKCdnaXRodWItYWN0aW9uJywgMHhlYWZmKSxcbiAgICBnaXRodWJBbHQ6IHJlZ2lzdGVyKCdnaXRodWItYWx0JywgMHhlYjAwKSxcbiAgICBnbG9iZTogcmVnaXN0ZXIoJ2dsb2JlJywgMHhlYjAxKSxcbiAgICBncmFiYmVyOiByZWdpc3RlcignZ3JhYmJlcicsIDB4ZWIwMiksXG4gICAgZ3JhcGg6IHJlZ2lzdGVyKCdncmFwaCcsIDB4ZWIwMyksXG4gICAgZ3JpcHBlcjogcmVnaXN0ZXIoJ2dyaXBwZXInLCAweGViMDQpLFxuICAgIGhlYXJ0OiByZWdpc3RlcignaGVhcnQnLCAweGViMDUpLFxuICAgIGhvbWU6IHJlZ2lzdGVyKCdob21lJywgMHhlYjA2KSxcbiAgICBob3Jpem9udGFsUnVsZTogcmVnaXN0ZXIoJ2hvcml6b250YWwtcnVsZScsIDB4ZWIwNyksXG4gICAgaHVib3Q6IHJlZ2lzdGVyKCdodWJvdCcsIDB4ZWIwOCksXG4gICAgaW5ib3g6IHJlZ2lzdGVyKCdpbmJveCcsIDB4ZWIwOSksXG4gICAgaXNzdWVSZW9wZW5lZDogcmVnaXN0ZXIoJ2lzc3VlLXJlb3BlbmVkJywgMHhlYjBiKSxcbiAgICBpc3N1ZXM6IHJlZ2lzdGVyKCdpc3N1ZXMnLCAweGViMGMpLFxuICAgIGl0YWxpYzogcmVnaXN0ZXIoJ2l0YWxpYycsIDB4ZWIwZCksXG4gICAgamVyc2V5OiByZWdpc3RlcignamVyc2V5JywgMHhlYjBlKSxcbiAgICBqc29uOiByZWdpc3RlcignanNvbicsIDB4ZWIwZiksXG4gICAga2ViYWJWZXJ0aWNhbDogcmVnaXN0ZXIoJ2tlYmFiLXZlcnRpY2FsJywgMHhlYjEwKSxcbiAgICBrZXk6IHJlZ2lzdGVyKCdrZXknLCAweGViMTEpLFxuICAgIGxhdzogcmVnaXN0ZXIoJ2xhdycsIDB4ZWIxMiksXG4gICAgbGlnaHRidWxiQXV0b2ZpeDogcmVnaXN0ZXIoJ2xpZ2h0YnVsYi1hdXRvZml4JywgMHhlYjEzKSxcbiAgICBsaW5rRXh0ZXJuYWw6IHJlZ2lzdGVyKCdsaW5rLWV4dGVybmFsJywgMHhlYjE0KSxcbiAgICBsaW5rOiByZWdpc3RlcignbGluaycsIDB4ZWIxNSksXG4gICAgbGlzdE9yZGVyZWQ6IHJlZ2lzdGVyKCdsaXN0LW9yZGVyZWQnLCAweGViMTYpLFxuICAgIGxpc3RVbm9yZGVyZWQ6IHJlZ2lzdGVyKCdsaXN0LXVub3JkZXJlZCcsIDB4ZWIxNyksXG4gICAgbGl2ZVNoYXJlOiByZWdpc3RlcignbGl2ZS1zaGFyZScsIDB4ZWIxOCksXG4gICAgbG9hZGluZzogcmVnaXN0ZXIoJ2xvYWRpbmcnLCAweGViMTkpLFxuICAgIGxvY2F0aW9uOiByZWdpc3RlcignbG9jYXRpb24nLCAweGViMWEpLFxuICAgIG1haWxSZWFkOiByZWdpc3RlcignbWFpbC1yZWFkJywgMHhlYjFiKSxcbiAgICBtYWlsOiByZWdpc3RlcignbWFpbCcsIDB4ZWIxYyksXG4gICAgbWFya2Rvd246IHJlZ2lzdGVyKCdtYXJrZG93bicsIDB4ZWIxZCksXG4gICAgbWVnYXBob25lOiByZWdpc3RlcignbWVnYXBob25lJywgMHhlYjFlKSxcbiAgICBtZW50aW9uOiByZWdpc3RlcignbWVudGlvbicsIDB4ZWIxZiksXG4gICAgbWlsZXN0b25lOiByZWdpc3RlcignbWlsZXN0b25lJywgMHhlYjIwKSxcbiAgICBnaXRQdWxsUmVxdWVzdE1pbGVzdG9uZTogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtbWlsZXN0b25lJywgMHhlYjIwKSxcbiAgICBtb3J0YXJCb2FyZDogcmVnaXN0ZXIoJ21vcnRhci1ib2FyZCcsIDB4ZWIyMSksXG4gICAgbW92ZTogcmVnaXN0ZXIoJ21vdmUnLCAweGViMjIpLFxuICAgIG11bHRpcGxlV2luZG93czogcmVnaXN0ZXIoJ211bHRpcGxlLXdpbmRvd3MnLCAweGViMjMpLFxuICAgIG11dGU6IHJlZ2lzdGVyKCdtdXRlJywgMHhlYjI0KSxcbiAgICBub05ld2xpbmU6IHJlZ2lzdGVyKCduby1uZXdsaW5lJywgMHhlYjI1KSxcbiAgICBub3RlOiByZWdpc3Rlcignbm90ZScsIDB4ZWIyNiksXG4gICAgb2N0b2ZhY2U6IHJlZ2lzdGVyKCdvY3RvZmFjZScsIDB4ZWIyNyksXG4gICAgb3BlblByZXZpZXc6IHJlZ2lzdGVyKCdvcGVuLXByZXZpZXcnLCAweGViMjgpLFxuICAgIHBhY2thZ2U6IHJlZ2lzdGVyKCdwYWNrYWdlJywgMHhlYjI5KSxcbiAgICBwYWludGNhbjogcmVnaXN0ZXIoJ3BhaW50Y2FuJywgMHhlYjJhKSxcbiAgICBwaW46IHJlZ2lzdGVyKCdwaW4nLCAweGViMmIpLFxuICAgIHBsYXk6IHJlZ2lzdGVyKCdwbGF5JywgMHhlYjJjKSxcbiAgICBydW46IHJlZ2lzdGVyKCdydW4nLCAweGViMmMpLFxuICAgIHBsdWc6IHJlZ2lzdGVyKCdwbHVnJywgMHhlYjJkKSxcbiAgICBwcmVzZXJ2ZUNhc2U6IHJlZ2lzdGVyKCdwcmVzZXJ2ZS1jYXNlJywgMHhlYjJlKSxcbiAgICBwcmV2aWV3OiByZWdpc3RlcigncHJldmlldycsIDB4ZWIyZiksXG4gICAgcHJvamVjdDogcmVnaXN0ZXIoJ3Byb2plY3QnLCAweGViMzApLFxuICAgIHB1bHNlOiByZWdpc3RlcigncHVsc2UnLCAweGViMzEpLFxuICAgIHF1ZXN0aW9uOiByZWdpc3RlcigncXVlc3Rpb24nLCAweGViMzIpLFxuICAgIHF1b3RlOiByZWdpc3RlcigncXVvdGUnLCAweGViMzMpLFxuICAgIHJhZGlvVG93ZXI6IHJlZ2lzdGVyKCdyYWRpby10b3dlcicsIDB4ZWIzNCksXG4gICAgcmVhY3Rpb25zOiByZWdpc3RlcigncmVhY3Rpb25zJywgMHhlYjM1KSxcbiAgICByZWZlcmVuY2VzOiByZWdpc3RlcigncmVmZXJlbmNlcycsIDB4ZWIzNiksXG4gICAgcmVmcmVzaDogcmVnaXN0ZXIoJ3JlZnJlc2gnLCAweGViMzcpLFxuICAgIHJlZ2V4OiByZWdpc3RlcigncmVnZXgnLCAweGViMzgpLFxuICAgIHJlbW90ZUV4cGxvcmVyOiByZWdpc3RlcigncmVtb3RlLWV4cGxvcmVyJywgMHhlYjM5KSxcbiAgICByZW1vdGU6IHJlZ2lzdGVyKCdyZW1vdGUnLCAweGViM2EpLFxuICAgIHJlbW92ZTogcmVnaXN0ZXIoJ3JlbW92ZScsIDB4ZWIzYiksXG4gICAgcmVwbGFjZUFsbDogcmVnaXN0ZXIoJ3JlcGxhY2UtYWxsJywgMHhlYjNjKSxcbiAgICByZXBsYWNlOiByZWdpc3RlcigncmVwbGFjZScsIDB4ZWIzZCksXG4gICAgcmVwb0Nsb25lOiByZWdpc3RlcigncmVwby1jbG9uZScsIDB4ZWIzZSksXG4gICAgcmVwb0ZvcmNlUHVzaDogcmVnaXN0ZXIoJ3JlcG8tZm9yY2UtcHVzaCcsIDB4ZWIzZiksXG4gICAgcmVwb1B1bGw6IHJlZ2lzdGVyKCdyZXBvLXB1bGwnLCAweGViNDApLFxuICAgIHJlcG9QdXNoOiByZWdpc3RlcigncmVwby1wdXNoJywgMHhlYjQxKSxcbiAgICByZXBvcnQ6IHJlZ2lzdGVyKCdyZXBvcnQnLCAweGViNDIpLFxuICAgIHJlcXVlc3RDaGFuZ2VzOiByZWdpc3RlcigncmVxdWVzdC1jaGFuZ2VzJywgMHhlYjQzKSxcbiAgICByb2NrZXQ6IHJlZ2lzdGVyKCdyb2NrZXQnLCAweGViNDQpLFxuICAgIHJvb3RGb2xkZXJPcGVuZWQ6IHJlZ2lzdGVyKCdyb290LWZvbGRlci1vcGVuZWQnLCAweGViNDUpLFxuICAgIHJvb3RGb2xkZXI6IHJlZ2lzdGVyKCdyb290LWZvbGRlcicsIDB4ZWI0NiksXG4gICAgcnNzOiByZWdpc3RlcigncnNzJywgMHhlYjQ3KSxcbiAgICBydWJ5OiByZWdpc3RlcigncnVieScsIDB4ZWI0OCksXG4gICAgc2F2ZUFsbDogcmVnaXN0ZXIoJ3NhdmUtYWxsJywgMHhlYjQ5KSxcbiAgICBzYXZlQXM6IHJlZ2lzdGVyKCdzYXZlLWFzJywgMHhlYjRhKSxcbiAgICBzYXZlOiByZWdpc3Rlcignc2F2ZScsIDB4ZWI0YiksXG4gICAgc2NyZWVuRnVsbDogcmVnaXN0ZXIoJ3NjcmVlbi1mdWxsJywgMHhlYjRjKSxcbiAgICBzY3JlZW5Ob3JtYWw6IHJlZ2lzdGVyKCdzY3JlZW4tbm9ybWFsJywgMHhlYjRkKSxcbiAgICBzZWFyY2hTdG9wOiByZWdpc3Rlcignc2VhcmNoLXN0b3AnLCAweGViNGUpLFxuICAgIHNlcnZlcjogcmVnaXN0ZXIoJ3NlcnZlcicsIDB4ZWI1MCksXG4gICAgc2V0dGluZ3NHZWFyOiByZWdpc3Rlcignc2V0dGluZ3MtZ2VhcicsIDB4ZWI1MSksXG4gICAgc2V0dGluZ3M6IHJlZ2lzdGVyKCdzZXR0aW5ncycsIDB4ZWI1MiksXG4gICAgc2hpZWxkOiByZWdpc3Rlcignc2hpZWxkJywgMHhlYjUzKSxcbiAgICBzbWlsZXk6IHJlZ2lzdGVyKCdzbWlsZXknLCAweGViNTQpLFxuICAgIHNvcnRQcmVjZWRlbmNlOiByZWdpc3Rlcignc29ydC1wcmVjZWRlbmNlJywgMHhlYjU1KSxcbiAgICBzcGxpdEhvcml6b250YWw6IHJlZ2lzdGVyKCdzcGxpdC1ob3Jpem9udGFsJywgMHhlYjU2KSxcbiAgICBzcGxpdFZlcnRpY2FsOiByZWdpc3Rlcignc3BsaXQtdmVydGljYWwnLCAweGViNTcpLFxuICAgIHNxdWlycmVsOiByZWdpc3Rlcignc3F1aXJyZWwnLCAweGViNTgpLFxuICAgIHN0YXJGdWxsOiByZWdpc3Rlcignc3Rhci1mdWxsJywgMHhlYjU5KSxcbiAgICBzdGFySGFsZjogcmVnaXN0ZXIoJ3N0YXItaGFsZicsIDB4ZWI1YSksXG4gICAgc3ltYm9sQ2xhc3M6IHJlZ2lzdGVyKCdzeW1ib2wtY2xhc3MnLCAweGViNWIpLFxuICAgIHN5bWJvbENvbG9yOiByZWdpc3Rlcignc3ltYm9sLWNvbG9yJywgMHhlYjVjKSxcbiAgICBzeW1ib2xDb25zdGFudDogcmVnaXN0ZXIoJ3N5bWJvbC1jb25zdGFudCcsIDB4ZWI1ZCksXG4gICAgc3ltYm9sRW51bU1lbWJlcjogcmVnaXN0ZXIoJ3N5bWJvbC1lbnVtLW1lbWJlcicsIDB4ZWI1ZSksXG4gICAgc3ltYm9sRmllbGQ6IHJlZ2lzdGVyKCdzeW1ib2wtZmllbGQnLCAweGViNWYpLFxuICAgIHN5bWJvbEZpbGU6IHJlZ2lzdGVyKCdzeW1ib2wtZmlsZScsIDB4ZWI2MCksXG4gICAgc3ltYm9sSW50ZXJmYWNlOiByZWdpc3Rlcignc3ltYm9sLWludGVyZmFjZScsIDB4ZWI2MSksXG4gICAgc3ltYm9sS2V5d29yZDogcmVnaXN0ZXIoJ3N5bWJvbC1rZXl3b3JkJywgMHhlYjYyKSxcbiAgICBzeW1ib2xNaXNjOiByZWdpc3Rlcignc3ltYm9sLW1pc2MnLCAweGViNjMpLFxuICAgIHN5bWJvbE9wZXJhdG9yOiByZWdpc3Rlcignc3ltYm9sLW9wZXJhdG9yJywgMHhlYjY0KSxcbiAgICBzeW1ib2xQcm9wZXJ0eTogcmVnaXN0ZXIoJ3N5bWJvbC1wcm9wZXJ0eScsIDB4ZWI2NSksXG4gICAgd3JlbmNoOiByZWdpc3Rlcignd3JlbmNoJywgMHhlYjY1KSxcbiAgICB3cmVuY2hTdWJhY3Rpb246IHJlZ2lzdGVyKCd3cmVuY2gtc3ViYWN0aW9uJywgMHhlYjY1KSxcbiAgICBzeW1ib2xTbmlwcGV0OiByZWdpc3Rlcignc3ltYm9sLXNuaXBwZXQnLCAweGViNjYpLFxuICAgIHRhc2tsaXN0OiByZWdpc3RlcigndGFza2xpc3QnLCAweGViNjcpLFxuICAgIHRlbGVzY29wZTogcmVnaXN0ZXIoJ3RlbGVzY29wZScsIDB4ZWI2OCksXG4gICAgdGV4dFNpemU6IHJlZ2lzdGVyKCd0ZXh0LXNpemUnLCAweGViNjkpLFxuICAgIHRocmVlQmFyczogcmVnaXN0ZXIoJ3RocmVlLWJhcnMnLCAweGViNmEpLFxuICAgIHRodW1ic2Rvd246IHJlZ2lzdGVyKCd0aHVtYnNkb3duJywgMHhlYjZiKSxcbiAgICB0aHVtYnN1cDogcmVnaXN0ZXIoJ3RodW1ic3VwJywgMHhlYjZjKSxcbiAgICB0b29sczogcmVnaXN0ZXIoJ3Rvb2xzJywgMHhlYjZkKSxcbiAgICB0cmlhbmdsZURvd246IHJlZ2lzdGVyKCd0cmlhbmdsZS1kb3duJywgMHhlYjZlKSxcbiAgICB0cmlhbmdsZUxlZnQ6IHJlZ2lzdGVyKCd0cmlhbmdsZS1sZWZ0JywgMHhlYjZmKSxcbiAgICB0cmlhbmdsZVJpZ2h0OiByZWdpc3RlcigndHJpYW5nbGUtcmlnaHQnLCAweGViNzApLFxuICAgIHRyaWFuZ2xlVXA6IHJlZ2lzdGVyKCd0cmlhbmdsZS11cCcsIDB4ZWI3MSksXG4gICAgdHdpdHRlcjogcmVnaXN0ZXIoJ3R3aXR0ZXInLCAweGViNzIpLFxuICAgIHVuZm9sZDogcmVnaXN0ZXIoJ3VuZm9sZCcsIDB4ZWI3MyksXG4gICAgdW5sb2NrOiByZWdpc3RlcigndW5sb2NrJywgMHhlYjc0KSxcbiAgICB1bm11dGU6IHJlZ2lzdGVyKCd1bm11dGUnLCAweGViNzUpLFxuICAgIHVudmVyaWZpZWQ6IHJlZ2lzdGVyKCd1bnZlcmlmaWVkJywgMHhlYjc2KSxcbiAgICB2ZXJpZmllZDogcmVnaXN0ZXIoJ3ZlcmlmaWVkJywgMHhlYjc3KSxcbiAgICB2ZXJzaW9uczogcmVnaXN0ZXIoJ3ZlcnNpb25zJywgMHhlYjc4KSxcbiAgICB2bUFjdGl2ZTogcmVnaXN0ZXIoJ3ZtLWFjdGl2ZScsIDB4ZWI3OSksXG4gICAgdm1PdXRsaW5lOiByZWdpc3Rlcigndm0tb3V0bGluZScsIDB4ZWI3YSksXG4gICAgdm1SdW5uaW5nOiByZWdpc3Rlcigndm0tcnVubmluZycsIDB4ZWI3YiksXG4gICAgd2F0Y2g6IHJlZ2lzdGVyKCd3YXRjaCcsIDB4ZWI3YyksXG4gICAgd2hpdGVzcGFjZTogcmVnaXN0ZXIoJ3doaXRlc3BhY2UnLCAweGViN2QpLFxuICAgIHdob2xlV29yZDogcmVnaXN0ZXIoJ3dob2xlLXdvcmQnLCAweGViN2UpLFxuICAgIHdpbmRvdzogcmVnaXN0ZXIoJ3dpbmRvdycsIDB4ZWI3ZiksXG4gICAgd29yZFdyYXA6IHJlZ2lzdGVyKCd3b3JkLXdyYXAnLCAweGViODApLFxuICAgIHpvb21JbjogcmVnaXN0ZXIoJ3pvb20taW4nLCAweGViODEpLFxuICAgIHpvb21PdXQ6IHJlZ2lzdGVyKCd6b29tLW91dCcsIDB4ZWI4MiksXG4gICAgbGlzdEZpbHRlcjogcmVnaXN0ZXIoJ2xpc3QtZmlsdGVyJywgMHhlYjgzKSxcbiAgICBsaXN0RmxhdDogcmVnaXN0ZXIoJ2xpc3QtZmxhdCcsIDB4ZWI4NCksXG4gICAgbGlzdFNlbGVjdGlvbjogcmVnaXN0ZXIoJ2xpc3Qtc2VsZWN0aW9uJywgMHhlYjg1KSxcbiAgICBzZWxlY3Rpb246IHJlZ2lzdGVyKCdzZWxlY3Rpb24nLCAweGViODUpLFxuICAgIGxpc3RUcmVlOiByZWdpc3RlcignbGlzdC10cmVlJywgMHhlYjg2KSxcbiAgICBkZWJ1Z0JyZWFrcG9pbnRGdW5jdGlvblVudmVyaWZpZWQ6IHJlZ2lzdGVyKCdkZWJ1Zy1icmVha3BvaW50LWZ1bmN0aW9uLXVudmVyaWZpZWQnLCAweGViODcpLFxuICAgIGRlYnVnQnJlYWtwb2ludEZ1bmN0aW9uOiByZWdpc3RlcignZGVidWctYnJlYWtwb2ludC1mdW5jdGlvbicsIDB4ZWI4OCksXG4gICAgZGVidWdCcmVha3BvaW50RnVuY3Rpb25EaXNhYmxlZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtZnVuY3Rpb24tZGlzYWJsZWQnLCAweGViODgpLFxuICAgIGRlYnVnU3RhY2tmcmFtZUFjdGl2ZTogcmVnaXN0ZXIoJ2RlYnVnLXN0YWNrZnJhbWUtYWN0aXZlJywgMHhlYjg5KSxcbiAgICBjaXJjbGVTbWFsbEZpbGxlZDogcmVnaXN0ZXIoJ2NpcmNsZS1zbWFsbC1maWxsZWQnLCAweGViOGEpLFxuICAgIGRlYnVnU3RhY2tmcmFtZURvdDogcmVnaXN0ZXIoJ2RlYnVnLXN0YWNrZnJhbWUtZG90JywgMHhlYjhhKSxcbiAgICB0ZXJtaW5hbERlY29yYXRpb25NYXJrOiByZWdpc3RlcigndGVybWluYWwtZGVjb3JhdGlvbi1tYXJrJywgMHhlYjhhKSxcbiAgICBkZWJ1Z1N0YWNrZnJhbWU6IHJlZ2lzdGVyKCdkZWJ1Zy1zdGFja2ZyYW1lJywgMHhlYjhiKSxcbiAgICBkZWJ1Z1N0YWNrZnJhbWVGb2N1c2VkOiByZWdpc3RlcignZGVidWctc3RhY2tmcmFtZS1mb2N1c2VkJywgMHhlYjhiKSxcbiAgICBkZWJ1Z0JyZWFrcG9pbnRVbnN1cHBvcnRlZDogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtdW5zdXBwb3J0ZWQnLCAweGViOGMpLFxuICAgIHN5bWJvbFN0cmluZzogcmVnaXN0ZXIoJ3N5bWJvbC1zdHJpbmcnLCAweGViOGQpLFxuICAgIGRlYnVnUmV2ZXJzZUNvbnRpbnVlOiByZWdpc3RlcignZGVidWctcmV2ZXJzZS1jb250aW51ZScsIDB4ZWI4ZSksXG4gICAgZGVidWdTdGVwQmFjazogcmVnaXN0ZXIoJ2RlYnVnLXN0ZXAtYmFjaycsIDB4ZWI4ZiksXG4gICAgZGVidWdSZXN0YXJ0RnJhbWU6IHJlZ2lzdGVyKCdkZWJ1Zy1yZXN0YXJ0LWZyYW1lJywgMHhlYjkwKSxcbiAgICBkZWJ1Z0FsdDogcmVnaXN0ZXIoJ2RlYnVnLWFsdCcsIDB4ZWI5MSksXG4gICAgY2FsbEluY29taW5nOiByZWdpc3RlcignY2FsbC1pbmNvbWluZycsIDB4ZWI5MiksXG4gICAgY2FsbE91dGdvaW5nOiByZWdpc3RlcignY2FsbC1vdXRnb2luZycsIDB4ZWI5MyksXG4gICAgbWVudTogcmVnaXN0ZXIoJ21lbnUnLCAweGViOTQpLFxuICAgIGV4cGFuZEFsbDogcmVnaXN0ZXIoJ2V4cGFuZC1hbGwnLCAweGViOTUpLFxuICAgIGZlZWRiYWNrOiByZWdpc3RlcignZmVlZGJhY2snLCAweGViOTYpLFxuICAgIGdpdFB1bGxSZXF1ZXN0UmV2aWV3ZXI6IHJlZ2lzdGVyKCdnaXQtcHVsbC1yZXF1ZXN0LXJldmlld2VyJywgMHhlYjk2KSxcbiAgICBncm91cEJ5UmVmVHlwZTogcmVnaXN0ZXIoJ2dyb3VwLWJ5LXJlZi10eXBlJywgMHhlYjk3KSxcbiAgICB1bmdyb3VwQnlSZWZUeXBlOiByZWdpc3RlcigndW5ncm91cC1ieS1yZWYtdHlwZScsIDB4ZWI5OCksXG4gICAgYWNjb3VudDogcmVnaXN0ZXIoJ2FjY291bnQnLCAweGViOTkpLFxuICAgIGdpdFB1bGxSZXF1ZXN0QXNzaWduZWU6IHJlZ2lzdGVyKCdnaXQtcHVsbC1yZXF1ZXN0LWFzc2lnbmVlJywgMHhlYjk5KSxcbiAgICBiZWxsRG90OiByZWdpc3RlcignYmVsbC1kb3QnLCAweGViOWEpLFxuICAgIGRlYnVnQ29uc29sZTogcmVnaXN0ZXIoJ2RlYnVnLWNvbnNvbGUnLCAweGViOWIpLFxuICAgIGxpYnJhcnk6IHJlZ2lzdGVyKCdsaWJyYXJ5JywgMHhlYjljKSxcbiAgICBvdXRwdXQ6IHJlZ2lzdGVyKCdvdXRwdXQnLCAweGViOWQpLFxuICAgIHJ1bkFsbDogcmVnaXN0ZXIoJ3J1bi1hbGwnLCAweGViOWUpLFxuICAgIHN5bmNJZ25vcmVkOiByZWdpc3Rlcignc3luYy1pZ25vcmVkJywgMHhlYjlmKSxcbiAgICBwaW5uZWQ6IHJlZ2lzdGVyKCdwaW5uZWQnLCAweGViYTApLFxuICAgIGdpdGh1YkludmVydGVkOiByZWdpc3RlcignZ2l0aHViLWludmVydGVkJywgMHhlYmExKSxcbiAgICBzZXJ2ZXJQcm9jZXNzOiByZWdpc3Rlcignc2VydmVyLXByb2Nlc3MnLCAweGViYTIpLFxuICAgIHNlcnZlckVudmlyb25tZW50OiByZWdpc3Rlcignc2VydmVyLWVudmlyb25tZW50JywgMHhlYmEzKSxcbiAgICBwYXNzOiByZWdpc3RlcigncGFzcycsIDB4ZWJhNCksXG4gICAgaXNzdWVDbG9zZWQ6IHJlZ2lzdGVyKCdpc3N1ZS1jbG9zZWQnLCAweGViYTQpLFxuICAgIHN0b3BDaXJjbGU6IHJlZ2lzdGVyKCdzdG9wLWNpcmNsZScsIDB4ZWJhNSksXG4gICAgcGxheUNpcmNsZTogcmVnaXN0ZXIoJ3BsYXktY2lyY2xlJywgMHhlYmE2KSxcbiAgICByZWNvcmQ6IHJlZ2lzdGVyKCdyZWNvcmQnLCAweGViYTcpLFxuICAgIGRlYnVnQWx0U21hbGw6IHJlZ2lzdGVyKCdkZWJ1Zy1hbHQtc21hbGwnLCAweGViYTgpLFxuICAgIHZtQ29ubmVjdDogcmVnaXN0ZXIoJ3ZtLWNvbm5lY3QnLCAweGViYTkpLFxuICAgIGNsb3VkOiByZWdpc3RlcignY2xvdWQnLCAweGViYWEpLFxuICAgIG1lcmdlOiByZWdpc3RlcignbWVyZ2UnLCAweGViYWIpLFxuICAgIGV4cG9ydDogcmVnaXN0ZXIoJ2V4cG9ydCcsIDB4ZWJhYyksXG4gICAgZ3JhcGhMZWZ0OiByZWdpc3RlcignZ3JhcGgtbGVmdCcsIDB4ZWJhZCksXG4gICAgbWFnbmV0OiByZWdpc3RlcignbWFnbmV0JywgMHhlYmFlKSxcbiAgICBub3RlYm9vazogcmVnaXN0ZXIoJ25vdGVib29rJywgMHhlYmFmKSxcbiAgICByZWRvOiByZWdpc3RlcigncmVkbycsIDB4ZWJiMCksXG4gICAgY2hlY2tBbGw6IHJlZ2lzdGVyKCdjaGVjay1hbGwnLCAweGViYjEpLFxuICAgIHBpbm5lZERpcnR5OiByZWdpc3RlcigncGlubmVkLWRpcnR5JywgMHhlYmIyKSxcbiAgICBwYXNzRmlsbGVkOiByZWdpc3RlcigncGFzcy1maWxsZWQnLCAweGViYjMpLFxuICAgIGNpcmNsZUxhcmdlRmlsbGVkOiByZWdpc3RlcignY2lyY2xlLWxhcmdlLWZpbGxlZCcsIDB4ZWJiNCksXG4gICAgY2lyY2xlTGFyZ2U6IHJlZ2lzdGVyKCdjaXJjbGUtbGFyZ2UnLCAweGViYjUpLFxuICAgIGNpcmNsZUxhcmdlT3V0bGluZTogcmVnaXN0ZXIoJ2NpcmNsZS1sYXJnZS1vdXRsaW5lJywgMHhlYmI1KSxcbiAgICBjb21iaW5lOiByZWdpc3RlcignY29tYmluZScsIDB4ZWJiNiksXG4gICAgZ2F0aGVyOiByZWdpc3RlcignZ2F0aGVyJywgMHhlYmI2KSxcbiAgICB0YWJsZTogcmVnaXN0ZXIoJ3RhYmxlJywgMHhlYmI3KSxcbiAgICB2YXJpYWJsZUdyb3VwOiByZWdpc3RlcigndmFyaWFibGUtZ3JvdXAnLCAweGViYjgpLFxuICAgIHR5cGVIaWVyYXJjaHk6IHJlZ2lzdGVyKCd0eXBlLWhpZXJhcmNoeScsIDB4ZWJiOSksXG4gICAgdHlwZUhpZXJhcmNoeVN1YjogcmVnaXN0ZXIoJ3R5cGUtaGllcmFyY2h5LXN1YicsIDB4ZWJiYSksXG4gICAgdHlwZUhpZXJhcmNoeVN1cGVyOiByZWdpc3RlcigndHlwZS1oaWVyYXJjaHktc3VwZXInLCAweGViYmIpLFxuICAgIGdpdFB1bGxSZXF1ZXN0Q3JlYXRlOiByZWdpc3RlcignZ2l0LXB1bGwtcmVxdWVzdC1jcmVhdGUnLCAweGViYmMpLFxuICAgIHJ1bkFib3ZlOiByZWdpc3RlcigncnVuLWFib3ZlJywgMHhlYmJkKSxcbiAgICBydW5CZWxvdzogcmVnaXN0ZXIoJ3J1bi1iZWxvdycsIDB4ZWJiZSksXG4gICAgbm90ZWJvb2tUZW1wbGF0ZTogcmVnaXN0ZXIoJ25vdGVib29rLXRlbXBsYXRlJywgMHhlYmJmKSxcbiAgICBkZWJ1Z1JlcnVuOiByZWdpc3RlcignZGVidWctcmVydW4nLCAweGViYzApLFxuICAgIHdvcmtzcGFjZVRydXN0ZWQ6IHJlZ2lzdGVyKCd3b3Jrc3BhY2UtdHJ1c3RlZCcsIDB4ZWJjMSksXG4gICAgd29ya3NwYWNlVW50cnVzdGVkOiByZWdpc3Rlcignd29ya3NwYWNlLXVudHJ1c3RlZCcsIDB4ZWJjMiksXG4gICAgd29ya3NwYWNlVW5rbm93bjogcmVnaXN0ZXIoJ3dvcmtzcGFjZS11bmtub3duJywgMHhlYmMzKSxcbiAgICB0ZXJtaW5hbENtZDogcmVnaXN0ZXIoJ3Rlcm1pbmFsLWNtZCcsIDB4ZWJjNCksXG4gICAgdGVybWluYWxEZWJpYW46IHJlZ2lzdGVyKCd0ZXJtaW5hbC1kZWJpYW4nLCAweGViYzUpLFxuICAgIHRlcm1pbmFsTGludXg6IHJlZ2lzdGVyKCd0ZXJtaW5hbC1saW51eCcsIDB4ZWJjNiksXG4gICAgdGVybWluYWxQb3dlcnNoZWxsOiByZWdpc3RlcigndGVybWluYWwtcG93ZXJzaGVsbCcsIDB4ZWJjNyksXG4gICAgdGVybWluYWxUbXV4OiByZWdpc3RlcigndGVybWluYWwtdG11eCcsIDB4ZWJjOCksXG4gICAgdGVybWluYWxVYnVudHU6IHJlZ2lzdGVyKCd0ZXJtaW5hbC11YnVudHUnLCAweGViYzkpLFxuICAgIHRlcm1pbmFsQmFzaDogcmVnaXN0ZXIoJ3Rlcm1pbmFsLWJhc2gnLCAweGViY2EpLFxuICAgIGFycm93U3dhcDogcmVnaXN0ZXIoJ2Fycm93LXN3YXAnLCAweGViY2IpLFxuICAgIGNvcHk6IHJlZ2lzdGVyKCdjb3B5JywgMHhlYmNjKSxcbiAgICBwZXJzb25BZGQ6IHJlZ2lzdGVyKCdwZXJzb24tYWRkJywgMHhlYmNkKSxcbiAgICBmaWx0ZXJGaWxsZWQ6IHJlZ2lzdGVyKCdmaWx0ZXItZmlsbGVkJywgMHhlYmNlKSxcbiAgICB3YW5kOiByZWdpc3Rlcignd2FuZCcsIDB4ZWJjZiksXG4gICAgZGVidWdMaW5lQnlMaW5lOiByZWdpc3RlcignZGVidWctbGluZS1ieS1saW5lJywgMHhlYmQwKSxcbiAgICBpbnNwZWN0OiByZWdpc3RlcignaW5zcGVjdCcsIDB4ZWJkMSksXG4gICAgbGF5ZXJzOiByZWdpc3RlcignbGF5ZXJzJywgMHhlYmQyKSxcbiAgICBsYXllcnNEb3Q6IHJlZ2lzdGVyKCdsYXllcnMtZG90JywgMHhlYmQzKSxcbiAgICBsYXllcnNBY3RpdmU6IHJlZ2lzdGVyKCdsYXllcnMtYWN0aXZlJywgMHhlYmQ0KSxcbiAgICBjb21wYXNzOiByZWdpc3RlcignY29tcGFzcycsIDB4ZWJkNSksXG4gICAgY29tcGFzc0RvdDogcmVnaXN0ZXIoJ2NvbXBhc3MtZG90JywgMHhlYmQ2KSxcbiAgICBjb21wYXNzQWN0aXZlOiByZWdpc3RlcignY29tcGFzcy1hY3RpdmUnLCAweGViZDcpLFxuICAgIGF6dXJlOiByZWdpc3RlcignYXp1cmUnLCAweGViZDgpLFxuICAgIGlzc3VlRHJhZnQ6IHJlZ2lzdGVyKCdpc3N1ZS1kcmFmdCcsIDB4ZWJkOSksXG4gICAgZ2l0UHVsbFJlcXVlc3RDbG9zZWQ6IHJlZ2lzdGVyKCdnaXQtcHVsbC1yZXF1ZXN0LWNsb3NlZCcsIDB4ZWJkYSksXG4gICAgZ2l0UHVsbFJlcXVlc3REcmFmdDogcmVnaXN0ZXIoJ2dpdC1wdWxsLXJlcXVlc3QtZHJhZnQnLCAweGViZGIpLFxuICAgIGRlYnVnQWxsOiByZWdpc3RlcignZGVidWctYWxsJywgMHhlYmRjKSxcbiAgICBkZWJ1Z0NvdmVyYWdlOiByZWdpc3RlcignZGVidWctY292ZXJhZ2UnLCAweGViZGQpLFxuICAgIHJ1bkVycm9yczogcmVnaXN0ZXIoJ3J1bi1lcnJvcnMnLCAweGViZGUpLFxuICAgIGZvbGRlckxpYnJhcnk6IHJlZ2lzdGVyKCdmb2xkZXItbGlicmFyeScsIDB4ZWJkZiksXG4gICAgZGVidWdDb250aW51ZVNtYWxsOiByZWdpc3RlcignZGVidWctY29udGludWUtc21hbGwnLCAweGViZTApLFxuICAgIGJlYWtlclN0b3A6IHJlZ2lzdGVyKCdiZWFrZXItc3RvcCcsIDB4ZWJlMSksXG4gICAgZ3JhcGhMaW5lOiByZWdpc3RlcignZ3JhcGgtbGluZScsIDB4ZWJlMiksXG4gICAgZ3JhcGhTY2F0dGVyOiByZWdpc3RlcignZ3JhcGgtc2NhdHRlcicsIDB4ZWJlMyksXG4gICAgcGllQ2hhcnQ6IHJlZ2lzdGVyKCdwaWUtY2hhcnQnLCAweGViZTQpLFxuICAgIGJyYWNrZXQ6IHJlZ2lzdGVyKCdicmFja2V0JywgMHhlYjBmKSxcbiAgICBicmFja2V0RG90OiByZWdpc3RlcignYnJhY2tldC1kb3QnLCAweGViZTUpLFxuICAgIGJyYWNrZXRFcnJvcjogcmVnaXN0ZXIoJ2JyYWNrZXQtZXJyb3InLCAweGViZTYpLFxuICAgIGxvY2tTbWFsbDogcmVnaXN0ZXIoJ2xvY2stc21hbGwnLCAweGViZTcpLFxuICAgIGF6dXJlRGV2b3BzOiByZWdpc3RlcignYXp1cmUtZGV2b3BzJywgMHhlYmU4KSxcbiAgICB2ZXJpZmllZEZpbGxlZDogcmVnaXN0ZXIoJ3ZlcmlmaWVkLWZpbGxlZCcsIDB4ZWJlOSksXG4gICAgbmV3bGluZTogcmVnaXN0ZXIoJ25ld2xpbmUnLCAweGViZWEpLFxuICAgIGxheW91dDogcmVnaXN0ZXIoJ2xheW91dCcsIDB4ZWJlYiksXG4gICAgbGF5b3V0QWN0aXZpdHliYXJMZWZ0OiByZWdpc3RlcignbGF5b3V0LWFjdGl2aXR5YmFyLWxlZnQnLCAweGViZWMpLFxuICAgIGxheW91dEFjdGl2aXR5YmFyUmlnaHQ6IHJlZ2lzdGVyKCdsYXlvdXQtYWN0aXZpdHliYXItcmlnaHQnLCAweGViZWQpLFxuICAgIGxheW91dFBhbmVsTGVmdDogcmVnaXN0ZXIoJ2xheW91dC1wYW5lbC1sZWZ0JywgMHhlYmVlKSxcbiAgICBsYXlvdXRQYW5lbENlbnRlcjogcmVnaXN0ZXIoJ2xheW91dC1wYW5lbC1jZW50ZXInLCAweGViZWYpLFxuICAgIGxheW91dFBhbmVsSnVzdGlmeTogcmVnaXN0ZXIoJ2xheW91dC1wYW5lbC1qdXN0aWZ5JywgMHhlYmYwKSxcbiAgICBsYXlvdXRQYW5lbFJpZ2h0OiByZWdpc3RlcignbGF5b3V0LXBhbmVsLXJpZ2h0JywgMHhlYmYxKSxcbiAgICBsYXlvdXRQYW5lbDogcmVnaXN0ZXIoJ2xheW91dC1wYW5lbCcsIDB4ZWJmMiksXG4gICAgbGF5b3V0U2lkZWJhckxlZnQ6IHJlZ2lzdGVyKCdsYXlvdXQtc2lkZWJhci1sZWZ0JywgMHhlYmYzKSxcbiAgICBsYXlvdXRTaWRlYmFyUmlnaHQ6IHJlZ2lzdGVyKCdsYXlvdXQtc2lkZWJhci1yaWdodCcsIDB4ZWJmNCksXG4gICAgbGF5b3V0U3RhdHVzYmFyOiByZWdpc3RlcignbGF5b3V0LXN0YXR1c2JhcicsIDB4ZWJmNSksXG4gICAgbGF5b3V0TWVudWJhcjogcmVnaXN0ZXIoJ2xheW91dC1tZW51YmFyJywgMHhlYmY2KSxcbiAgICBsYXlvdXRDZW50ZXJlZDogcmVnaXN0ZXIoJ2xheW91dC1jZW50ZXJlZCcsIDB4ZWJmNyksXG4gICAgdGFyZ2V0OiByZWdpc3RlcigndGFyZ2V0JywgMHhlYmY4KSxcbiAgICBpbmRlbnQ6IHJlZ2lzdGVyKCdpbmRlbnQnLCAweGViZjkpLFxuICAgIHJlY29yZFNtYWxsOiByZWdpc3RlcigncmVjb3JkLXNtYWxsJywgMHhlYmZhKSxcbiAgICBlcnJvclNtYWxsOiByZWdpc3RlcignZXJyb3Itc21hbGwnLCAweGViZmIpLFxuICAgIHRlcm1pbmFsRGVjb3JhdGlvbkVycm9yOiByZWdpc3RlcigndGVybWluYWwtZGVjb3JhdGlvbi1lcnJvcicsIDB4ZWJmYiksXG4gICAgYXJyb3dDaXJjbGVEb3duOiByZWdpc3RlcignYXJyb3ctY2lyY2xlLWRvd24nLCAweGViZmMpLFxuICAgIGFycm93Q2lyY2xlTGVmdDogcmVnaXN0ZXIoJ2Fycm93LWNpcmNsZS1sZWZ0JywgMHhlYmZkKSxcbiAgICBhcnJvd0NpcmNsZVJpZ2h0OiByZWdpc3RlcignYXJyb3ctY2lyY2xlLXJpZ2h0JywgMHhlYmZlKSxcbiAgICBhcnJvd0NpcmNsZVVwOiByZWdpc3RlcignYXJyb3ctY2lyY2xlLXVwJywgMHhlYmZmKSxcbiAgICBsYXlvdXRTaWRlYmFyUmlnaHRPZmY6IHJlZ2lzdGVyKCdsYXlvdXQtc2lkZWJhci1yaWdodC1vZmYnLCAweGVjMDApLFxuICAgIGxheW91dFBhbmVsT2ZmOiByZWdpc3RlcignbGF5b3V0LXBhbmVsLW9mZicsIDB4ZWMwMSksXG4gICAgbGF5b3V0U2lkZWJhckxlZnRPZmY6IHJlZ2lzdGVyKCdsYXlvdXQtc2lkZWJhci1sZWZ0LW9mZicsIDB4ZWMwMiksXG4gICAgYmxhbms6IHJlZ2lzdGVyKCdibGFuaycsIDB4ZWMwMyksXG4gICAgaGVhcnRGaWxsZWQ6IHJlZ2lzdGVyKCdoZWFydC1maWxsZWQnLCAweGVjMDQpLFxuICAgIG1hcDogcmVnaXN0ZXIoJ21hcCcsIDB4ZWMwNSksXG4gICAgbWFwSG9yaXpvbnRhbDogcmVnaXN0ZXIoJ21hcC1ob3Jpem9udGFsJywgMHhlYzA1KSxcbiAgICBmb2xkSG9yaXpvbnRhbDogcmVnaXN0ZXIoJ2ZvbGQtaG9yaXpvbnRhbCcsIDB4ZWMwNSksXG4gICAgbWFwRmlsbGVkOiByZWdpc3RlcignbWFwLWZpbGxlZCcsIDB4ZWMwNiksXG4gICAgbWFwSG9yaXpvbnRhbEZpbGxlZDogcmVnaXN0ZXIoJ21hcC1ob3Jpem9udGFsLWZpbGxlZCcsIDB4ZWMwNiksXG4gICAgZm9sZEhvcml6b250YWxGaWxsZWQ6IHJlZ2lzdGVyKCdmb2xkLWhvcml6b250YWwtZmlsbGVkJywgMHhlYzA2KSxcbiAgICBjaXJjbGVTbWFsbDogcmVnaXN0ZXIoJ2NpcmNsZS1zbWFsbCcsIDB4ZWMwNyksXG4gICAgYmVsbFNsYXNoOiByZWdpc3RlcignYmVsbC1zbGFzaCcsIDB4ZWMwOCksXG4gICAgYmVsbFNsYXNoRG90OiByZWdpc3RlcignYmVsbC1zbGFzaC1kb3QnLCAweGVjMDkpLFxuICAgIGNvbW1lbnRVbnJlc29sdmVkOiByZWdpc3RlcignY29tbWVudC11bnJlc29sdmVkJywgMHhlYzBhKSxcbiAgICBnaXRQdWxsUmVxdWVzdEdvVG9DaGFuZ2VzOiByZWdpc3RlcignZ2l0LXB1bGwtcmVxdWVzdC1nby10by1jaGFuZ2VzJywgMHhlYzBiKSxcbiAgICBnaXRQdWxsUmVxdWVzdE5ld0NoYW5nZXM6IHJlZ2lzdGVyKCdnaXQtcHVsbC1yZXF1ZXN0LW5ldy1jaGFuZ2VzJywgMHhlYzBjKSxcbiAgICBzZWFyY2hGdXp6eTogcmVnaXN0ZXIoJ3NlYXJjaC1mdXp6eScsIDB4ZWMwZCksXG4gICAgY29tbWVudERyYWZ0OiByZWdpc3RlcignY29tbWVudC1kcmFmdCcsIDB4ZWMwZSksXG4gICAgc2VuZDogcmVnaXN0ZXIoJ3NlbmQnLCAweGVjMGYpLFxuICAgIHNwYXJrbGU6IHJlZ2lzdGVyKCdzcGFya2xlJywgMHhlYzEwKSxcbiAgICBpbnNlcnQ6IHJlZ2lzdGVyKCdpbnNlcnQnLCAweGVjMTEpLFxuICAgIG1pYzogcmVnaXN0ZXIoJ21pYycsIDB4ZWMxMiksXG4gICAgdGh1bWJzZG93bkZpbGxlZDogcmVnaXN0ZXIoJ3RodW1ic2Rvd24tZmlsbGVkJywgMHhlYzEzKSxcbiAgICB0aHVtYnN1cEZpbGxlZDogcmVnaXN0ZXIoJ3RodW1ic3VwLWZpbGxlZCcsIDB4ZWMxNCksXG4gICAgY29mZmVlOiByZWdpc3RlcignY29mZmVlJywgMHhlYzE1KSxcbiAgICBzbmFrZTogcmVnaXN0ZXIoJ3NuYWtlJywgMHhlYzE2KSxcbiAgICBnYW1lOiByZWdpc3RlcignZ2FtZScsIDB4ZWMxNyksXG4gICAgdnI6IHJlZ2lzdGVyKCd2cicsIDB4ZWMxOCksXG4gICAgY2hpcDogcmVnaXN0ZXIoJ2NoaXAnLCAweGVjMTkpLFxuICAgIHBpYW5vOiByZWdpc3RlcigncGlhbm8nLCAweGVjMWEpLFxuICAgIG11c2ljOiByZWdpc3RlcignbXVzaWMnLCAweGVjMWIpLFxuICAgIG1pY0ZpbGxlZDogcmVnaXN0ZXIoJ21pYy1maWxsZWQnLCAweGVjMWMpLFxuICAgIHJlcG9GZXRjaDogcmVnaXN0ZXIoJ3JlcG8tZmV0Y2gnLCAweGVjMWQpLFxuICAgIGNvcGlsb3Q6IHJlZ2lzdGVyKCdjb3BpbG90JywgMHhlYzFlKSxcbiAgICBsaWdodGJ1bGJTcGFya2xlOiByZWdpc3RlcignbGlnaHRidWxiLXNwYXJrbGUnLCAweGVjMWYpLFxuICAgIHJvYm90OiByZWdpc3Rlcigncm9ib3QnLCAweGVjMjApLFxuICAgIHNwYXJrbGVGaWxsZWQ6IHJlZ2lzdGVyKCdzcGFya2xlLWZpbGxlZCcsIDB4ZWMyMSksXG4gICAgZGlmZlNpbmdsZTogcmVnaXN0ZXIoJ2RpZmYtc2luZ2xlJywgMHhlYzIyKSxcbiAgICBkaWZmTXVsdGlwbGU6IHJlZ2lzdGVyKCdkaWZmLW11bHRpcGxlJywgMHhlYzIzKSxcbiAgICBzdXJyb3VuZFdpdGg6IHJlZ2lzdGVyKCdzdXJyb3VuZC13aXRoJywgMHhlYzI0KSxcbiAgICBzaGFyZTogcmVnaXN0ZXIoJ3NoYXJlJywgMHhlYzI1KSxcbiAgICBnaXRTdGFzaDogcmVnaXN0ZXIoJ2dpdC1zdGFzaCcsIDB4ZWMyNiksXG4gICAgZ2l0U3Rhc2hBcHBseTogcmVnaXN0ZXIoJ2dpdC1zdGFzaC1hcHBseScsIDB4ZWMyNyksXG4gICAgZ2l0U3Rhc2hQb3A6IHJlZ2lzdGVyKCdnaXQtc3Rhc2gtcG9wJywgMHhlYzI4KSxcbiAgICB2c2NvZGU6IHJlZ2lzdGVyKCd2c2NvZGUnLCAweGVjMjkpLFxuICAgIHZzY29kZUluc2lkZXJzOiByZWdpc3RlcigndnNjb2RlLWluc2lkZXJzJywgMHhlYzJhKSxcbiAgICBjb2RlT3NzOiByZWdpc3RlcignY29kZS1vc3MnLCAweGVjMmIpLFxuICAgIHJ1bkNvdmVyYWdlOiByZWdpc3RlcigncnVuLWNvdmVyYWdlJywgMHhlYzJjKSxcbiAgICBydW5BbGxDb3ZlcmFnZTogcmVnaXN0ZXIoJ3J1bi1hbGwtY292ZXJhZ2UnLCAweGVjMmQpLFxuICAgIGNvdmVyYWdlOiByZWdpc3RlcignY292ZXJhZ2UnLCAweGVjMmUpLFxuICAgIGdpdGh1YlByb2plY3Q6IHJlZ2lzdGVyKCdnaXRodWItcHJvamVjdCcsIDB4ZWMyZiksXG4gICAgbWFwVmVydGljYWw6IHJlZ2lzdGVyKCdtYXAtdmVydGljYWwnLCAweGVjMzApLFxuICAgIGZvbGRWZXJ0aWNhbDogcmVnaXN0ZXIoJ2ZvbGQtdmVydGljYWwnLCAweGVjMzApLFxuICAgIG1hcFZlcnRpY2FsRmlsbGVkOiByZWdpc3RlcignbWFwLXZlcnRpY2FsLWZpbGxlZCcsIDB4ZWMzMSksXG4gICAgZm9sZFZlcnRpY2FsRmlsbGVkOiByZWdpc3RlcignZm9sZC12ZXJ0aWNhbC1maWxsZWQnLCAweGVjMzEpLFxuICAgIGdvVG9TZWFyY2g6IHJlZ2lzdGVyKCdnby10by1zZWFyY2gnLCAweGVjMzIpLFxuICAgIHBlcmNlbnRhZ2U6IHJlZ2lzdGVyKCdwZXJjZW50YWdlJywgMHhlYzMzKSxcbiAgICBzb3J0UGVyY2VudGFnZTogcmVnaXN0ZXIoJ3NvcnQtcGVyY2VudGFnZScsIDB4ZWMzMyksXG4gICAgYXR0YWNoOiByZWdpc3RlcignYXR0YWNoJywgMHhlYzM0KSxcbn07XG4iLCJpbXBvcnQgeyByZWdpc3RlciB9IGZyb20gJy4vY29kaWNvbnNVdGlsLmpzJztcbmltcG9ydCB7IGNvZGljb25zTGlicmFyeSB9IGZyb20gJy4vY29kaWNvbnNMaWJyYXJ5LmpzJztcbi8qKlxuICogRGVyaXZlZCBpY29ucywgdGhhdCBjb3VsZCBiZWNvbWUgc2VwYXJhdGUgaWNvbnMuXG4gKiBUaGVzZSBtYXBwaW5ncyBzaG91bGQgYmUgbW92ZWQgaW50byB0aGUgbWFwcGluZyBmaWxlIGluIHRoZSB2c2NvZGUtY29kaWNvbnMgcmVwbyBhdCBzb21lIHBvaW50LlxuICovXG5leHBvcnQgY29uc3QgY29kaWNvbnNEZXJpdmVkID0ge1xuICAgIGRpYWxvZ0Vycm9yOiByZWdpc3RlcignZGlhbG9nLWVycm9yJywgJ2Vycm9yJyksXG4gICAgZGlhbG9nV2FybmluZzogcmVnaXN0ZXIoJ2RpYWxvZy13YXJuaW5nJywgJ3dhcm5pbmcnKSxcbiAgICBkaWFsb2dJbmZvOiByZWdpc3RlcignZGlhbG9nLWluZm8nLCAnaW5mbycpLFxuICAgIGRpYWxvZ0Nsb3NlOiByZWdpc3RlcignZGlhbG9nLWNsb3NlJywgJ2Nsb3NlJyksXG4gICAgdHJlZUl0ZW1FeHBhbmRlZDogcmVnaXN0ZXIoJ3RyZWUtaXRlbS1leHBhbmRlZCcsICdjaGV2cm9uLWRvd24nKSwgLy8gY29sbGFwc2VkIGlzIGRvbmUgd2l0aCByb3RhdGlvblxuICAgIHRyZWVGaWx0ZXJPblR5cGVPbjogcmVnaXN0ZXIoJ3RyZWUtZmlsdGVyLW9uLXR5cGUtb24nLCAnbGlzdC1maWx0ZXInKSxcbiAgICB0cmVlRmlsdGVyT25UeXBlT2ZmOiByZWdpc3RlcigndHJlZS1maWx0ZXItb24tdHlwZS1vZmYnLCAnbGlzdC1zZWxlY3Rpb24nKSxcbiAgICB0cmVlRmlsdGVyQ2xlYXI6IHJlZ2lzdGVyKCd0cmVlLWZpbHRlci1jbGVhcicsICdjbG9zZScpLFxuICAgIHRyZWVJdGVtTG9hZGluZzogcmVnaXN0ZXIoJ3RyZWUtaXRlbS1sb2FkaW5nJywgJ2xvYWRpbmcnKSxcbiAgICBtZW51U2VsZWN0aW9uOiByZWdpc3RlcignbWVudS1zZWxlY3Rpb24nLCAnY2hlY2snKSxcbiAgICBtZW51U3VibWVudTogcmVnaXN0ZXIoJ21lbnUtc3VibWVudScsICdjaGV2cm9uLXJpZ2h0JyksXG4gICAgbWVudUJhck1vcmU6IHJlZ2lzdGVyKCdtZW51YmFyLW1vcmUnLCAnbW9yZScpLFxuICAgIHNjcm9sbGJhckJ1dHRvbkxlZnQ6IHJlZ2lzdGVyKCdzY3JvbGxiYXItYnV0dG9uLWxlZnQnLCAndHJpYW5nbGUtbGVmdCcpLFxuICAgIHNjcm9sbGJhckJ1dHRvblJpZ2h0OiByZWdpc3Rlcignc2Nyb2xsYmFyLWJ1dHRvbi1yaWdodCcsICd0cmlhbmdsZS1yaWdodCcpLFxuICAgIHNjcm9sbGJhckJ1dHRvblVwOiByZWdpc3Rlcignc2Nyb2xsYmFyLWJ1dHRvbi11cCcsICd0cmlhbmdsZS11cCcpLFxuICAgIHNjcm9sbGJhckJ1dHRvbkRvd246IHJlZ2lzdGVyKCdzY3JvbGxiYXItYnV0dG9uLWRvd24nLCAndHJpYW5nbGUtZG93bicpLFxuICAgIHRvb2xCYXJNb3JlOiByZWdpc3RlcigndG9vbGJhci1tb3JlJywgJ21vcmUnKSxcbiAgICBxdWlja0lucHV0QmFjazogcmVnaXN0ZXIoJ3F1aWNrLWlucHV0LWJhY2snLCAnYXJyb3ctbGVmdCcpLFxuICAgIGRyb3BEb3duQnV0dG9uOiByZWdpc3RlcignZHJvcC1kb3duLWJ1dHRvbicsIDB4ZWFiNCksXG4gICAgc3ltYm9sQ3VzdG9tQ29sb3I6IHJlZ2lzdGVyKCdzeW1ib2wtY3VzdG9tY29sb3InLCAweGViNWMpLFxuICAgIGV4cG9ydEljb246IHJlZ2lzdGVyKCdleHBvcnQnLCAweGViYWMpLFxuICAgIHdvcmtzcGFjZVVuc3BlY2lmaWVkOiByZWdpc3Rlcignd29ya3NwYWNlLXVuc3BlY2lmaWVkJywgMHhlYmMzKSxcbiAgICBuZXdMaW5lOiByZWdpc3RlcignbmV3bGluZScsIDB4ZWJlYSksXG4gICAgdGh1bWJzRG93bkZpbGxlZDogcmVnaXN0ZXIoJ3RodW1ic2Rvd24tZmlsbGVkJywgMHhlYzEzKSxcbiAgICB0aHVtYnNVcEZpbGxlZDogcmVnaXN0ZXIoJ3RodW1ic3VwLWZpbGxlZCcsIDB4ZWMxNCksXG4gICAgZ2l0RmV0Y2g6IHJlZ2lzdGVyKCdnaXQtZmV0Y2gnLCAweGVjMWQpLFxuICAgIGxpZ2h0YnVsYlNwYXJrbGVBdXRvZml4OiByZWdpc3RlcignbGlnaHRidWxiLXNwYXJrbGUtYXV0b2ZpeCcsIDB4ZWMxZiksXG4gICAgZGVidWdCcmVha3BvaW50UGVuZGluZzogcmVnaXN0ZXIoJ2RlYnVnLWJyZWFrcG9pbnQtcGVuZGluZycsIDB4ZWJkOSksXG59O1xuLyoqXG4gKiBUaGUgQ29kaWNvbiBsaWJyYXJ5IGlzIGEgc2V0IG9mIGRlZmF1bHQgaWNvbnMgdGhhdCBhcmUgYnVpbHQtaW4gaW4gVlMgQ29kZS5cbiAqXG4gKiBJbiB0aGUgcHJvZHVjdCAob3V0c2lkZSBvZiBiYXNlKSBDb2RpY29ucyBzaG91bGQgb25seSBiZSB1c2VkIGFzIGRlZmF1bHRzLiBJbiBvcmRlciB0byBoYXZlIGFsbCBpY29ucyBpbiBWUyBDb2RlXG4gKiB0aGVtZWFibGUsIGNvbXBvbmVudCBzaG91bGQgZGVmaW5lIG5ldywgVUkgY29tcG9uZW50IHNwZWNpZmljIGljb25zIHVzaW5nIGBpY29uUmVnaXN0cnkucmVnaXN0ZXJJY29uYC5cbiAqIEluIHRoYXQgY2FsbCBhIENvZGljb24gY2FuIGJlIG5hbWVkIGFzIGRlZmF1bHQuXG4gKi9cbmV4cG9ydCBjb25zdCBDb2RpY29uID0ge1xuICAgIC4uLmNvZGljb25zTGlicmFyeSxcbiAgICAuLi5jb2RpY29uc0Rlcml2ZWRcbn07XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEVtaXR0ZXIgfSBmcm9tICcuLi8uLi9iYXNlL2NvbW1vbi9ldmVudC5qcyc7XG5pbXBvcnQgeyBEaXNwb3NhYmxlLCB0b0Rpc3Bvc2FibGUgfSBmcm9tICcuLi8uLi9iYXNlL2NvbW1vbi9saWZlY3ljbGUuanMnO1xuZXhwb3J0IGNsYXNzIFRva2VuaXphdGlvblJlZ2lzdHJ5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX2ZhY3RvcmllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fb25EaWRDaGFuZ2UgPSBuZXcgRW1pdHRlcigpO1xuICAgICAgICB0aGlzLm9uRGlkQ2hhbmdlID0gdGhpcy5fb25EaWRDaGFuZ2UuZXZlbnQ7XG4gICAgICAgIHRoaXMuX2NvbG9yTWFwID0gbnVsbDtcbiAgICB9XG4gICAgaGFuZGxlQ2hhbmdlKGxhbmd1YWdlSWRzKSB7XG4gICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlLmZpcmUoe1xuICAgICAgICAgICAgY2hhbmdlZExhbmd1YWdlczogbGFuZ3VhZ2VJZHMsXG4gICAgICAgICAgICBjaGFuZ2VkQ29sb3JNYXA6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWdpc3RlcihsYW5ndWFnZUlkLCBzdXBwb3J0KSB7XG4gICAgICAgIHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnRzLnNldChsYW5ndWFnZUlkLCBzdXBwb3J0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoW2xhbmd1YWdlSWRdKTtcbiAgICAgICAgcmV0dXJuIHRvRGlzcG9zYWJsZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydHMuZ2V0KGxhbmd1YWdlSWQpICE9PSBzdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydHMuZGVsZXRlKGxhbmd1YWdlSWQpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaGFuZ2UoW2xhbmd1YWdlSWRdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldChsYW5ndWFnZUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0cy5nZXQobGFuZ3VhZ2VJZCkgfHwgbnVsbDtcbiAgICB9XG4gICAgcmVnaXN0ZXJGYWN0b3J5KGxhbmd1YWdlSWQsIGZhY3RvcnkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLl9mYWN0b3JpZXMuZ2V0KGxhbmd1YWdlSWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgICAgICBjb25zdCBteURhdGEgPSBuZXcgVG9rZW5pemF0aW9uU3VwcG9ydEZhY3RvcnlEYXRhKHRoaXMsIGxhbmd1YWdlSWQsIGZhY3RvcnkpO1xuICAgICAgICB0aGlzLl9mYWN0b3JpZXMuc2V0KGxhbmd1YWdlSWQsIG15RGF0YSk7XG4gICAgICAgIHJldHVybiB0b0Rpc3Bvc2FibGUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuX2ZhY3Rvcmllcy5nZXQobGFuZ3VhZ2VJZCk7XG4gICAgICAgICAgICBpZiAoIXYgfHwgdiAhPT0gbXlEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fZmFjdG9yaWVzLmRlbGV0ZShsYW5ndWFnZUlkKTtcbiAgICAgICAgICAgIHYuZGlzcG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0T3JDcmVhdGUobGFuZ3VhZ2VJZCkge1xuICAgICAgICAvLyBjaGVjayBmaXJzdCBpZiB0aGUgc3VwcG9ydCBpcyBhbHJlYWR5IHNldFxuICAgICAgICBjb25zdCB0b2tlbml6YXRpb25TdXBwb3J0ID0gdGhpcy5nZXQobGFuZ3VhZ2VJZCk7XG4gICAgICAgIGlmICh0b2tlbml6YXRpb25TdXBwb3J0KSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW5pemF0aW9uU3VwcG9ydDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmYWN0b3J5ID0gdGhpcy5fZmFjdG9yaWVzLmdldChsYW5ndWFnZUlkKTtcbiAgICAgICAgaWYgKCFmYWN0b3J5IHx8IGZhY3RvcnkuaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgLy8gbm8gZmFjdG9yeSBvciBmYWN0b3J5LnJlc29sdmUgYWxyZWFkeSBmaW5pc2hlZFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgZmFjdG9yeS5yZXNvbHZlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldChsYW5ndWFnZUlkKTtcbiAgICB9XG4gICAgaXNSZXNvbHZlZChsYW5ndWFnZUlkKSB7XG4gICAgICAgIGNvbnN0IHRva2VuaXphdGlvblN1cHBvcnQgPSB0aGlzLmdldChsYW5ndWFnZUlkKTtcbiAgICAgICAgaWYgKHRva2VuaXphdGlvblN1cHBvcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLl9mYWN0b3JpZXMuZ2V0KGxhbmd1YWdlSWQpO1xuICAgICAgICBpZiAoIWZhY3RvcnkgfHwgZmFjdG9yeS5pc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHNldENvbG9yTWFwKGNvbG9yTWFwKSB7XG4gICAgICAgIHRoaXMuX2NvbG9yTWFwID0gY29sb3JNYXA7XG4gICAgICAgIHRoaXMuX29uRGlkQ2hhbmdlLmZpcmUoe1xuICAgICAgICAgICAgY2hhbmdlZExhbmd1YWdlczogQXJyYXkuZnJvbSh0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0cy5rZXlzKCkpLFxuICAgICAgICAgICAgY2hhbmdlZENvbG9yTWFwOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb2xvck1hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yTWFwO1xuICAgIH1cbiAgICBnZXREZWZhdWx0QmFja2dyb3VuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbG9yTWFwICYmIHRoaXMuX2NvbG9yTWFwLmxlbmd0aCA+IDIgLyogQ29sb3JJZC5EZWZhdWx0QmFja2dyb3VuZCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yTWFwWzIgLyogQ29sb3JJZC5EZWZhdWx0QmFja2dyb3VuZCAqL107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuY2xhc3MgVG9rZW5pemF0aW9uU3VwcG9ydEZhY3RvcnlEYXRhIGV4dGVuZHMgRGlzcG9zYWJsZSB7XG4gICAgZ2V0IGlzUmVzb2x2ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1Jlc29sdmVkO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihfcmVnaXN0cnksIF9sYW5ndWFnZUlkLCBfZmFjdG9yeSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9yZWdpc3RyeSA9IF9yZWdpc3RyeTtcbiAgICAgICAgdGhpcy5fbGFuZ3VhZ2VJZCA9IF9sYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl9mYWN0b3J5ID0gX2ZhY3Rvcnk7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZVByb21pc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc1Jlc29sdmVkID0gZmFsc2U7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmUoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZVByb21pc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVQcm9taXNlID0gdGhpcy5fY3JlYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQcm9taXNlO1xuICAgIH1cbiAgICBhc3luYyBfY3JlYXRlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHRoaXMuX2ZhY3RvcnkudG9rZW5pemF0aW9uU3VwcG9ydDtcbiAgICAgICAgdGhpcy5faXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5faXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVnaXN0ZXIodGhpcy5fcmVnaXN0cnkucmVnaXN0ZXIodGhpcy5fbGFuZ3VhZ2VJZCwgdmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCB7IENvZGljb24gfSBmcm9tICcuLi8uLi9iYXNlL2NvbW1vbi9jb2RpY29ucy5qcyc7XG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgVG9rZW5pemF0aW9uUmVnaXN0cnkgYXMgVG9rZW5pemF0aW9uUmVnaXN0cnlJbXBsIH0gZnJvbSAnLi90b2tlbml6YXRpb25SZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBsb2NhbGl6ZSB9IGZyb20gJy4uLy4uL25scy5qcyc7XG5leHBvcnQgY2xhc3MgVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKG9mZnNldCwgdHlwZSwgbGFuZ3VhZ2UpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgdGhpcy5fdG9rZW5CcmFuZCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAnKCcgKyB0aGlzLm9mZnNldCArICcsICcgKyB0aGlzLnR5cGUgKyAnKSc7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFRva2VuaXphdGlvblJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IodG9rZW5zLCBlbmRTdGF0ZSkge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5lbmRTdGF0ZSA9IGVuZFN0YXRlO1xuICAgICAgICB0aGlzLl90b2tlbml6YXRpb25SZXN1bHRCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgRW5jb2RlZFRva2VuaXphdGlvblJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgICogVGhlIHRva2VucyBpbiBiaW5hcnkgZm9ybWF0LiBFYWNoIHRva2VuIG9jY3VwaWVzIHR3byBhcnJheSBpbmRpY2VzLiBGb3IgdG9rZW4gaTpcbiAgICAgKiAgLSBhdCBvZmZzZXQgMippID0+IHN0YXJ0SW5kZXhcbiAgICAgKiAgLSBhdCBvZmZzZXQgMippICsgMSA9PiBtZXRhZGF0YVxuICAgICAqXG4gICAgICovXG4gICAgdG9rZW5zLCBlbmRTdGF0ZSkge1xuICAgICAgICB0aGlzLnRva2VucyA9IHRva2VucztcbiAgICAgICAgdGhpcy5lbmRTdGF0ZSA9IGVuZFN0YXRlO1xuICAgICAgICB0aGlzLl9lbmNvZGVkVG9rZW5pemF0aW9uUmVzdWx0QnJhbmQgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IHZhciBIb3ZlclZlcmJvc2l0eUFjdGlvbjtcbihmdW5jdGlvbiAoSG92ZXJWZXJib3NpdHlBY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBJbmNyZWFzZSB0aGUgdmVyYm9zaXR5IG9mIHRoZSBob3ZlclxuICAgICAqL1xuICAgIEhvdmVyVmVyYm9zaXR5QWN0aW9uW0hvdmVyVmVyYm9zaXR5QWN0aW9uW1wiSW5jcmVhc2VcIl0gPSAwXSA9IFwiSW5jcmVhc2VcIjtcbiAgICAvKipcbiAgICAgKiBEZWNyZWFzZSB0aGUgdmVyYm9zaXR5IG9mIHRoZSBob3ZlclxuICAgICAqL1xuICAgIEhvdmVyVmVyYm9zaXR5QWN0aW9uW0hvdmVyVmVyYm9zaXR5QWN0aW9uW1wiRGVjcmVhc2VcIl0gPSAxXSA9IFwiRGVjcmVhc2VcIjtcbn0pKEhvdmVyVmVyYm9zaXR5QWN0aW9uIHx8IChIb3ZlclZlcmJvc2l0eUFjdGlvbiA9IHt9KSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtS2luZHM7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZHMpIHtcbiAgICBjb25zdCBieUtpbmQgPSBuZXcgTWFwKCk7XG4gICAgYnlLaW5kLnNldCgwIC8qIENvbXBsZXRpb25JdGVtS2luZC5NZXRob2QgKi8sIENvZGljb24uc3ltYm9sTWV0aG9kKTtcbiAgICBieUtpbmQuc2V0KDEgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uICovLCBDb2RpY29uLnN5bWJvbEZ1bmN0aW9uKTtcbiAgICBieUtpbmQuc2V0KDIgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkNvbnN0cnVjdG9yICovLCBDb2RpY29uLnN5bWJvbENvbnN0cnVjdG9yKTtcbiAgICBieUtpbmQuc2V0KDMgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkICovLCBDb2RpY29uLnN5bWJvbEZpZWxkKTtcbiAgICBieUtpbmQuc2V0KDQgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlICovLCBDb2RpY29uLnN5bWJvbFZhcmlhYmxlKTtcbiAgICBieUtpbmQuc2V0KDUgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkNsYXNzICovLCBDb2RpY29uLnN5bWJvbENsYXNzKTtcbiAgICBieUtpbmQuc2V0KDYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCAqLywgQ29kaWNvbi5zeW1ib2xTdHJ1Y3QpO1xuICAgIGJ5S2luZC5zZXQoNyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuSW50ZXJmYWNlICovLCBDb2RpY29uLnN5bWJvbEludGVyZmFjZSk7XG4gICAgYnlLaW5kLnNldCg4IC8qIENvbXBsZXRpb25JdGVtS2luZC5Nb2R1bGUgKi8sIENvZGljb24uc3ltYm9sTW9kdWxlKTtcbiAgICBieUtpbmQuc2V0KDkgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ICovLCBDb2RpY29uLnN5bWJvbFByb3BlcnR5KTtcbiAgICBieUtpbmQuc2V0KDEwIC8qIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCAqLywgQ29kaWNvbi5zeW1ib2xFdmVudCk7XG4gICAgYnlLaW5kLnNldCgxMSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuT3BlcmF0b3IgKi8sIENvZGljb24uc3ltYm9sT3BlcmF0b3IpO1xuICAgIGJ5S2luZC5zZXQoMTIgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQgKi8sIENvZGljb24uc3ltYm9sVW5pdCk7XG4gICAgYnlLaW5kLnNldCgxMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgKi8sIENvZGljb24uc3ltYm9sVmFsdWUpO1xuICAgIGJ5S2luZC5zZXQoMTUgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gKi8sIENvZGljb24uc3ltYm9sRW51bSk7XG4gICAgYnlLaW5kLnNldCgxNCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgKi8sIENvZGljb24uc3ltYm9sQ29uc3RhbnQpO1xuICAgIGJ5S2luZC5zZXQoMTUgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW0gKi8sIENvZGljb24uc3ltYm9sRW51bSk7XG4gICAgYnlLaW5kLnNldCgxNiAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRW51bU1lbWJlciAqLywgQ29kaWNvbi5zeW1ib2xFbnVtTWVtYmVyKTtcbiAgICBieUtpbmQuc2V0KDE3IC8qIENvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkICovLCBDb2RpY29uLnN5bWJvbEtleXdvcmQpO1xuICAgIGJ5S2luZC5zZXQoMjcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgKi8sIENvZGljb24uc3ltYm9sU25pcHBldCk7XG4gICAgYnlLaW5kLnNldCgxOCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVGV4dCAqLywgQ29kaWNvbi5zeW1ib2xUZXh0KTtcbiAgICBieUtpbmQuc2V0KDE5IC8qIENvbXBsZXRpb25JdGVtS2luZC5Db2xvciAqLywgQ29kaWNvbi5zeW1ib2xDb2xvcik7XG4gICAgYnlLaW5kLnNldCgyMCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSAqLywgQ29kaWNvbi5zeW1ib2xGaWxlKTtcbiAgICBieUtpbmQuc2V0KDIxIC8qIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgKi8sIENvZGljb24uc3ltYm9sUmVmZXJlbmNlKTtcbiAgICBieUtpbmQuc2V0KDIyIC8qIENvbXBsZXRpb25JdGVtS2luZC5DdXN0b21jb2xvciAqLywgQ29kaWNvbi5zeW1ib2xDdXN0b21Db2xvcik7XG4gICAgYnlLaW5kLnNldCgyMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyICovLCBDb2RpY29uLnN5bWJvbEZvbGRlcik7XG4gICAgYnlLaW5kLnNldCgyNCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVHlwZVBhcmFtZXRlciAqLywgQ29kaWNvbi5zeW1ib2xUeXBlUGFyYW1ldGVyKTtcbiAgICBieUtpbmQuc2V0KDI1IC8qIENvbXBsZXRpb25JdGVtS2luZC5Vc2VyICovLCBDb2RpY29uLmFjY291bnQpO1xuICAgIGJ5S2luZC5zZXQoMjYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLklzc3VlICovLCBDb2RpY29uLmlzc3Vlcyk7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9JY29uKGtpbmQpIHtcbiAgICAgICAgbGV0IGNvZGljb24gPSBieUtpbmQuZ2V0KGtpbmQpO1xuICAgICAgICBpZiAoIWNvZGljb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnTm8gY29kaWNvbiBmb3VuZCBmb3IgQ29tcGxldGlvbkl0ZW1LaW5kICcgKyBraW5kKTtcbiAgICAgICAgICAgIGNvZGljb24gPSBDb2RpY29uLnN5bWJvbFByb3BlcnR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2RpY29uO1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbUtpbmRzLnRvSWNvbiA9IHRvSWNvbjtcbiAgICBjb25zdCBkYXRhID0gbmV3IE1hcCgpO1xuICAgIGRhdGEuc2V0KCdtZXRob2QnLCAwIC8qIENvbXBsZXRpb25JdGVtS2luZC5NZXRob2QgKi8pO1xuICAgIGRhdGEuc2V0KCdmdW5jdGlvbicsIDEgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkZ1bmN0aW9uICovKTtcbiAgICBkYXRhLnNldCgnY29uc3RydWN0b3InLCAyIC8qIENvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvciAqLyk7XG4gICAgZGF0YS5zZXQoJ2ZpZWxkJywgMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRmllbGQgKi8pO1xuICAgIGRhdGEuc2V0KCd2YXJpYWJsZScsIDQgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlZhcmlhYmxlICovKTtcbiAgICBkYXRhLnNldCgnY2xhc3MnLCA1IC8qIENvbXBsZXRpb25JdGVtS2luZC5DbGFzcyAqLyk7XG4gICAgZGF0YS5zZXQoJ3N0cnVjdCcsIDYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlN0cnVjdCAqLyk7XG4gICAgZGF0YS5zZXQoJ2ludGVyZmFjZScsIDcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZSAqLyk7XG4gICAgZGF0YS5zZXQoJ21vZHVsZScsIDggLyogQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSAqLyk7XG4gICAgZGF0YS5zZXQoJ3Byb3BlcnR5JywgOSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHkgKi8pO1xuICAgIGRhdGEuc2V0KCdldmVudCcsIDEwIC8qIENvbXBsZXRpb25JdGVtS2luZC5FdmVudCAqLyk7XG4gICAgZGF0YS5zZXQoJ29wZXJhdG9yJywgMTEgLyogQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yICovKTtcbiAgICBkYXRhLnNldCgndW5pdCcsIDEyIC8qIENvbXBsZXRpb25JdGVtS2luZC5Vbml0ICovKTtcbiAgICBkYXRhLnNldCgndmFsdWUnLCAxMyAvKiBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgKi8pO1xuICAgIGRhdGEuc2V0KCdjb25zdGFudCcsIDE0IC8qIENvbXBsZXRpb25JdGVtS2luZC5Db25zdGFudCAqLyk7XG4gICAgZGF0YS5zZXQoJ2VudW0nLCAxNSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRW51bSAqLyk7XG4gICAgZGF0YS5zZXQoJ2VudW0tbWVtYmVyJywgMTYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgKi8pO1xuICAgIGRhdGEuc2V0KCdlbnVtTWVtYmVyJywgMTYgLyogQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgKi8pO1xuICAgIGRhdGEuc2V0KCdrZXl3b3JkJywgMTcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLktleXdvcmQgKi8pO1xuICAgIGRhdGEuc2V0KCdzbmlwcGV0JywgMjcgLyogQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgKi8pO1xuICAgIGRhdGEuc2V0KCd0ZXh0JywgMTggLyogQ29tcGxldGlvbkl0ZW1LaW5kLlRleHQgKi8pO1xuICAgIGRhdGEuc2V0KCdjb2xvcicsIDE5IC8qIENvbXBsZXRpb25JdGVtS2luZC5Db2xvciAqLyk7XG4gICAgZGF0YS5zZXQoJ2ZpbGUnLCAyMCAvKiBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSAqLyk7XG4gICAgZGF0YS5zZXQoJ3JlZmVyZW5jZScsIDIxIC8qIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgKi8pO1xuICAgIGRhdGEuc2V0KCdjdXN0b21jb2xvcicsIDIyIC8qIENvbXBsZXRpb25JdGVtS2luZC5DdXN0b21jb2xvciAqLyk7XG4gICAgZGF0YS5zZXQoJ2ZvbGRlcicsIDIzIC8qIENvbXBsZXRpb25JdGVtS2luZC5Gb2xkZXIgKi8pO1xuICAgIGRhdGEuc2V0KCd0eXBlLXBhcmFtZXRlcicsIDI0IC8qIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyICovKTtcbiAgICBkYXRhLnNldCgndHlwZVBhcmFtZXRlcicsIDI0IC8qIENvbXBsZXRpb25JdGVtS2luZC5UeXBlUGFyYW1ldGVyICovKTtcbiAgICBkYXRhLnNldCgnYWNjb3VudCcsIDI1IC8qIENvbXBsZXRpb25JdGVtS2luZC5Vc2VyICovKTtcbiAgICBkYXRhLnNldCgnaXNzdWUnLCAyNiAvKiBDb21wbGV0aW9uSXRlbUtpbmQuSXNzdWUgKi8pO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUsIHN0cmljdCkge1xuICAgICAgICBsZXQgcmVzID0gZGF0YS5nZXQodmFsdWUpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ3VuZGVmaW5lZCcgJiYgIXN0cmljdCkge1xuICAgICAgICAgICAgcmVzID0gOSAvKiBDb21wbGV0aW9uSXRlbUtpbmQuUHJvcGVydHkgKi87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kcy5mcm9tU3RyaW5nID0gZnJvbVN0cmluZztcbn0pKENvbXBsZXRpb25JdGVtS2luZHMgfHwgKENvbXBsZXRpb25JdGVtS2luZHMgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYW4ge0BsaW5rIElubGluZUNvbXBsZXRpb25zUHJvdmlkZXIgaW5saW5lIGNvbXBsZXRpb24gcHJvdmlkZXJ9IHdhcyB0cmlnZ2VyZWQuXG4gKi9cbmV4cG9ydCB2YXIgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSB3aGlsZSBlZGl0aW5nLlxuICAgICAqIEl0IGlzIHN1ZmZpY2llbnQgdG8gcmV0dXJuIGEgc2luZ2xlIGNvbXBsZXRpb24gaXRlbSBpbiB0aGlzIGNhc2UuXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW0lubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkF1dG9tYXRpY1wiXSA9IDBdID0gXCJBdXRvbWF0aWNcIjtcbiAgICAvKipcbiAgICAgKiBDb21wbGV0aW9uIHdhcyB0cmlnZ2VyZWQgZXhwbGljaXRseSBieSBhIHVzZXIgZ2VzdHVyZS5cbiAgICAgKiBSZXR1cm4gbXVsdGlwbGUgY29tcGxldGlvbiBpdGVtcyB0byBlbmFibGUgY3ljbGluZyB0aHJvdWdoIHRoZW0uXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW0lubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZFtcIkV4cGxpY2l0XCJdID0gMV0gPSBcIkV4cGxpY2l0XCI7XG59KShJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IHt9KSk7XG5leHBvcnQgY2xhc3MgU2VsZWN0ZWRTdWdnZXN0aW9uSW5mbyB7XG4gICAgY29uc3RydWN0b3IocmFuZ2UsIHRleHQsIGNvbXBsZXRpb25LaW5kLCBpc1NuaXBwZXRUZXh0KSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5jb21wbGV0aW9uS2luZCA9IGNvbXBsZXRpb25LaW5kO1xuICAgICAgICB0aGlzLmlzU25pcHBldFRleHQgPSBpc1NuaXBwZXRUZXh0O1xuICAgIH1cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmxpZnQodGhpcy5yYW5nZSkuZXF1YWxzUmFuZ2Uob3RoZXIucmFuZ2UpXG4gICAgICAgICAgICAmJiB0aGlzLnRleHQgPT09IG90aGVyLnRleHRcbiAgICAgICAgICAgICYmIHRoaXMuY29tcGxldGlvbktpbmQgPT09IG90aGVyLmNvbXBsZXRpb25LaW5kXG4gICAgICAgICAgICAmJiB0aGlzLmlzU25pcHBldFRleHQgPT09IG90aGVyLmlzU25pcHBldFRleHQ7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudFBhc3RlVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50UGFzdGVUcmlnZ2VyS2luZCkge1xuICAgIERvY3VtZW50UGFzdGVUcmlnZ2VyS2luZFtEb2N1bWVudFBhc3RlVHJpZ2dlcktpbmRbXCJBdXRvbWF0aWNcIl0gPSAwXSA9IFwiQXV0b21hdGljXCI7XG4gICAgRG9jdW1lbnRQYXN0ZVRyaWdnZXJLaW5kW0RvY3VtZW50UGFzdGVUcmlnZ2VyS2luZFtcIlBhc3RlQXNcIl0gPSAxXSA9IFwiUGFzdGVBc1wiO1xufSkoRG9jdW1lbnRQYXN0ZVRyaWdnZXJLaW5kIHx8IChEb2N1bWVudFBhc3RlVHJpZ2dlcktpbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCkge1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJJbnZva2VcIl0gPSAxXSA9IFwiSW52b2tlXCI7XG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1NpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtcIlRyaWdnZXJDaGFyYWN0ZXJcIl0gPSAyXSA9IFwiVHJpZ2dlckNoYXJhY3RlclwiO1xuICAgIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbXCJDb250ZW50Q2hhbmdlXCJdID0gM10gPSBcIkNvbnRlbnRDaGFuZ2VcIjtcbn0pKFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZCB8fCAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kID0ge30pKTtcbi8qKlxuICogQSBkb2N1bWVudCBoaWdobGlnaHQga2luZC5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudEhpZ2hsaWdodEtpbmQ7XG4oZnVuY3Rpb24gKERvY3VtZW50SGlnaGxpZ2h0S2luZCkge1xuICAgIC8qKlxuICAgICAqIEEgdGV4dHVhbCBvY2N1cnJlbmNlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZFtEb2N1bWVudEhpZ2hsaWdodEtpbmRbXCJUZXh0XCJdID0gMF0gPSBcIlRleHRcIjtcbiAgICAvKipcbiAgICAgKiBSZWFkLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSByZWFkaW5nIGEgdmFyaWFibGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kW0RvY3VtZW50SGlnaGxpZ2h0S2luZFtcIlJlYWRcIl0gPSAxXSA9IFwiUmVhZFwiO1xuICAgIC8qKlxuICAgICAqIFdyaXRlLWFjY2VzcyBvZiBhIHN5bWJvbCwgbGlrZSB3cml0aW5nIHRvIGEgdmFyaWFibGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kW0RvY3VtZW50SGlnaGxpZ2h0S2luZFtcIldyaXRlXCJdID0gMl0gPSBcIldyaXRlXCI7XG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMb2NhdGlvbkxpbmsodGhpbmcpIHtcbiAgICByZXR1cm4gdGhpbmdcbiAgICAgICAgJiYgVVJJLmlzVXJpKHRoaW5nLnVyaSlcbiAgICAgICAgJiYgUmFuZ2UuaXNJUmFuZ2UodGhpbmcucmFuZ2UpXG4gICAgICAgICYmIChSYW5nZS5pc0lSYW5nZSh0aGluZy5vcmlnaW5TZWxlY3Rpb25SYW5nZSkgfHwgUmFuZ2UuaXNJUmFuZ2UodGhpbmcudGFyZ2V0U2VsZWN0aW9uUmFuZ2UpKTtcbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjb25zdCBzeW1ib2xLaW5kTmFtZXMgPSB7XG4gICAgWzE3IC8qIFN5bWJvbEtpbmQuQXJyYXkgKi9dOiBsb2NhbGl6ZSgnQXJyYXknLCBcImFycmF5XCIpLFxuICAgIFsxNiAvKiBTeW1ib2xLaW5kLkJvb2xlYW4gKi9dOiBsb2NhbGl6ZSgnQm9vbGVhbicsIFwiYm9vbGVhblwiKSxcbiAgICBbNCAvKiBTeW1ib2xLaW5kLkNsYXNzICovXTogbG9jYWxpemUoJ0NsYXNzJywgXCJjbGFzc1wiKSxcbiAgICBbMTMgLyogU3ltYm9sS2luZC5Db25zdGFudCAqL106IGxvY2FsaXplKCdDb25zdGFudCcsIFwiY29uc3RhbnRcIiksXG4gICAgWzggLyogU3ltYm9sS2luZC5Db25zdHJ1Y3RvciAqL106IGxvY2FsaXplKCdDb25zdHJ1Y3RvcicsIFwiY29uc3RydWN0b3JcIiksXG4gICAgWzkgLyogU3ltYm9sS2luZC5FbnVtICovXTogbG9jYWxpemUoJ0VudW0nLCBcImVudW1lcmF0aW9uXCIpLFxuICAgIFsyMSAvKiBTeW1ib2xLaW5kLkVudW1NZW1iZXIgKi9dOiBsb2NhbGl6ZSgnRW51bU1lbWJlcicsIFwiZW51bWVyYXRpb24gbWVtYmVyXCIpLFxuICAgIFsyMyAvKiBTeW1ib2xLaW5kLkV2ZW50ICovXTogbG9jYWxpemUoJ0V2ZW50JywgXCJldmVudFwiKSxcbiAgICBbNyAvKiBTeW1ib2xLaW5kLkZpZWxkICovXTogbG9jYWxpemUoJ0ZpZWxkJywgXCJmaWVsZFwiKSxcbiAgICBbMCAvKiBTeW1ib2xLaW5kLkZpbGUgKi9dOiBsb2NhbGl6ZSgnRmlsZScsIFwiZmlsZVwiKSxcbiAgICBbMTEgLyogU3ltYm9sS2luZC5GdW5jdGlvbiAqL106IGxvY2FsaXplKCdGdW5jdGlvbicsIFwiZnVuY3Rpb25cIiksXG4gICAgWzEwIC8qIFN5bWJvbEtpbmQuSW50ZXJmYWNlICovXTogbG9jYWxpemUoJ0ludGVyZmFjZScsIFwiaW50ZXJmYWNlXCIpLFxuICAgIFsxOSAvKiBTeW1ib2xLaW5kLktleSAqL106IGxvY2FsaXplKCdLZXknLCBcImtleVwiKSxcbiAgICBbNSAvKiBTeW1ib2xLaW5kLk1ldGhvZCAqL106IGxvY2FsaXplKCdNZXRob2QnLCBcIm1ldGhvZFwiKSxcbiAgICBbMSAvKiBTeW1ib2xLaW5kLk1vZHVsZSAqL106IGxvY2FsaXplKCdNb2R1bGUnLCBcIm1vZHVsZVwiKSxcbiAgICBbMiAvKiBTeW1ib2xLaW5kLk5hbWVzcGFjZSAqL106IGxvY2FsaXplKCdOYW1lc3BhY2UnLCBcIm5hbWVzcGFjZVwiKSxcbiAgICBbMjAgLyogU3ltYm9sS2luZC5OdWxsICovXTogbG9jYWxpemUoJ051bGwnLCBcIm51bGxcIiksXG4gICAgWzE1IC8qIFN5bWJvbEtpbmQuTnVtYmVyICovXTogbG9jYWxpemUoJ051bWJlcicsIFwibnVtYmVyXCIpLFxuICAgIFsxOCAvKiBTeW1ib2xLaW5kLk9iamVjdCAqL106IGxvY2FsaXplKCdPYmplY3QnLCBcIm9iamVjdFwiKSxcbiAgICBbMjQgLyogU3ltYm9sS2luZC5PcGVyYXRvciAqL106IGxvY2FsaXplKCdPcGVyYXRvcicsIFwib3BlcmF0b3JcIiksXG4gICAgWzMgLyogU3ltYm9sS2luZC5QYWNrYWdlICovXTogbG9jYWxpemUoJ1BhY2thZ2UnLCBcInBhY2thZ2VcIiksXG4gICAgWzYgLyogU3ltYm9sS2luZC5Qcm9wZXJ0eSAqL106IGxvY2FsaXplKCdQcm9wZXJ0eScsIFwicHJvcGVydHlcIiksXG4gICAgWzE0IC8qIFN5bWJvbEtpbmQuU3RyaW5nICovXTogbG9jYWxpemUoJ1N0cmluZycsIFwic3RyaW5nXCIpLFxuICAgIFsyMiAvKiBTeW1ib2xLaW5kLlN0cnVjdCAqL106IGxvY2FsaXplKCdTdHJ1Y3QnLCBcInN0cnVjdFwiKSxcbiAgICBbMjUgLyogU3ltYm9sS2luZC5UeXBlUGFyYW1ldGVyICovXTogbG9jYWxpemUoJ1R5cGVQYXJhbWV0ZXInLCBcInR5cGUgcGFyYW1ldGVyXCIpLFxuICAgIFsxMiAvKiBTeW1ib2xLaW5kLlZhcmlhYmxlICovXTogbG9jYWxpemUoJ1ZhcmlhYmxlJywgXCJ2YXJpYWJsZVwiKSxcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJpYUxhYmVsRm9yU3ltYm9sKHN5bWJvbE5hbWUsIGtpbmQpIHtcbiAgICByZXR1cm4gbG9jYWxpemUoJ3N5bWJvbEFyaWFMYWJlbCcsICd7MH0gKHsxfSknLCBzeW1ib2xOYW1lLCBzeW1ib2xLaW5kTmFtZXNba2luZF0pO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHZhciBTeW1ib2xLaW5kcztcbihmdW5jdGlvbiAoU3ltYm9sS2luZHMpIHtcbiAgICBjb25zdCBieUtpbmQgPSBuZXcgTWFwKCk7XG4gICAgYnlLaW5kLnNldCgwIC8qIFN5bWJvbEtpbmQuRmlsZSAqLywgQ29kaWNvbi5zeW1ib2xGaWxlKTtcbiAgICBieUtpbmQuc2V0KDEgLyogU3ltYm9sS2luZC5Nb2R1bGUgKi8sIENvZGljb24uc3ltYm9sTW9kdWxlKTtcbiAgICBieUtpbmQuc2V0KDIgLyogU3ltYm9sS2luZC5OYW1lc3BhY2UgKi8sIENvZGljb24uc3ltYm9sTmFtZXNwYWNlKTtcbiAgICBieUtpbmQuc2V0KDMgLyogU3ltYm9sS2luZC5QYWNrYWdlICovLCBDb2RpY29uLnN5bWJvbFBhY2thZ2UpO1xuICAgIGJ5S2luZC5zZXQoNCAvKiBTeW1ib2xLaW5kLkNsYXNzICovLCBDb2RpY29uLnN5bWJvbENsYXNzKTtcbiAgICBieUtpbmQuc2V0KDUgLyogU3ltYm9sS2luZC5NZXRob2QgKi8sIENvZGljb24uc3ltYm9sTWV0aG9kKTtcbiAgICBieUtpbmQuc2V0KDYgLyogU3ltYm9sS2luZC5Qcm9wZXJ0eSAqLywgQ29kaWNvbi5zeW1ib2xQcm9wZXJ0eSk7XG4gICAgYnlLaW5kLnNldCg3IC8qIFN5bWJvbEtpbmQuRmllbGQgKi8sIENvZGljb24uc3ltYm9sRmllbGQpO1xuICAgIGJ5S2luZC5zZXQoOCAvKiBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yICovLCBDb2RpY29uLnN5bWJvbENvbnN0cnVjdG9yKTtcbiAgICBieUtpbmQuc2V0KDkgLyogU3ltYm9sS2luZC5FbnVtICovLCBDb2RpY29uLnN5bWJvbEVudW0pO1xuICAgIGJ5S2luZC5zZXQoMTAgLyogU3ltYm9sS2luZC5JbnRlcmZhY2UgKi8sIENvZGljb24uc3ltYm9sSW50ZXJmYWNlKTtcbiAgICBieUtpbmQuc2V0KDExIC8qIFN5bWJvbEtpbmQuRnVuY3Rpb24gKi8sIENvZGljb24uc3ltYm9sRnVuY3Rpb24pO1xuICAgIGJ5S2luZC5zZXQoMTIgLyogU3ltYm9sS2luZC5WYXJpYWJsZSAqLywgQ29kaWNvbi5zeW1ib2xWYXJpYWJsZSk7XG4gICAgYnlLaW5kLnNldCgxMyAvKiBTeW1ib2xLaW5kLkNvbnN0YW50ICovLCBDb2RpY29uLnN5bWJvbENvbnN0YW50KTtcbiAgICBieUtpbmQuc2V0KDE0IC8qIFN5bWJvbEtpbmQuU3RyaW5nICovLCBDb2RpY29uLnN5bWJvbFN0cmluZyk7XG4gICAgYnlLaW5kLnNldCgxNSAvKiBTeW1ib2xLaW5kLk51bWJlciAqLywgQ29kaWNvbi5zeW1ib2xOdW1iZXIpO1xuICAgIGJ5S2luZC5zZXQoMTYgLyogU3ltYm9sS2luZC5Cb29sZWFuICovLCBDb2RpY29uLnN5bWJvbEJvb2xlYW4pO1xuICAgIGJ5S2luZC5zZXQoMTcgLyogU3ltYm9sS2luZC5BcnJheSAqLywgQ29kaWNvbi5zeW1ib2xBcnJheSk7XG4gICAgYnlLaW5kLnNldCgxOCAvKiBTeW1ib2xLaW5kLk9iamVjdCAqLywgQ29kaWNvbi5zeW1ib2xPYmplY3QpO1xuICAgIGJ5S2luZC5zZXQoMTkgLyogU3ltYm9sS2luZC5LZXkgKi8sIENvZGljb24uc3ltYm9sS2V5KTtcbiAgICBieUtpbmQuc2V0KDIwIC8qIFN5bWJvbEtpbmQuTnVsbCAqLywgQ29kaWNvbi5zeW1ib2xOdWxsKTtcbiAgICBieUtpbmQuc2V0KDIxIC8qIFN5bWJvbEtpbmQuRW51bU1lbWJlciAqLywgQ29kaWNvbi5zeW1ib2xFbnVtTWVtYmVyKTtcbiAgICBieUtpbmQuc2V0KDIyIC8qIFN5bWJvbEtpbmQuU3RydWN0ICovLCBDb2RpY29uLnN5bWJvbFN0cnVjdCk7XG4gICAgYnlLaW5kLnNldCgyMyAvKiBTeW1ib2xLaW5kLkV2ZW50ICovLCBDb2RpY29uLnN5bWJvbEV2ZW50KTtcbiAgICBieUtpbmQuc2V0KDI0IC8qIFN5bWJvbEtpbmQuT3BlcmF0b3IgKi8sIENvZGljb24uc3ltYm9sT3BlcmF0b3IpO1xuICAgIGJ5S2luZC5zZXQoMjUgLyogU3ltYm9sS2luZC5UeXBlUGFyYW1ldGVyICovLCBDb2RpY29uLnN5bWJvbFR5cGVQYXJhbWV0ZXIpO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvSWNvbihraW5kKSB7XG4gICAgICAgIGxldCBpY29uID0gYnlLaW5kLmdldChraW5kKTtcbiAgICAgICAgaWYgKCFpY29uKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ05vIGNvZGljb24gZm91bmQgZm9yIFN5bWJvbEtpbmQgJyArIGtpbmQpO1xuICAgICAgICAgICAgaWNvbiA9IENvZGljb24uc3ltYm9sUHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGljb247XG4gICAgfVxuICAgIFN5bWJvbEtpbmRzLnRvSWNvbiA9IHRvSWNvbjtcbn0pKFN5bWJvbEtpbmRzIHx8IChTeW1ib2xLaW5kcyA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY2xhc3MgVGV4dEVkaXQge1xufVxuZXhwb3J0IGNsYXNzIEZvbGRpbmdSYW5nZUtpbmQge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgRm9sZGluZ1JhbmdlS2luZH0gZm9yIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBvZiB0aGUga2luZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NvbW1lbnQnOiByZXR1cm4gRm9sZGluZ1JhbmdlS2luZC5Db21tZW50O1xuICAgICAgICAgICAgY2FzZSAnaW1wb3J0cyc6IHJldHVybiBGb2xkaW5nUmFuZ2VLaW5kLkltcG9ydHM7XG4gICAgICAgICAgICBjYXNlICdyZWdpb24nOiByZXR1cm4gRm9sZGluZ1JhbmdlS2luZC5SZWdpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGb2xkaW5nUmFuZ2VLaW5kKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB7QGxpbmsgRm9sZGluZ1JhbmdlS2luZH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgb2YgdGhlIGtpbmQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbn1cbi8qKlxuICogS2luZCBmb3IgZm9sZGluZyByYW5nZSByZXByZXNlbnRpbmcgYSBjb21tZW50LiBUaGUgdmFsdWUgb2YgdGhlIGtpbmQgaXMgJ2NvbW1lbnQnLlxuICovXG5Gb2xkaW5nUmFuZ2VLaW5kLkNvbW1lbnQgPSBuZXcgRm9sZGluZ1JhbmdlS2luZCgnY29tbWVudCcpO1xuLyoqXG4gKiBLaW5kIGZvciBmb2xkaW5nIHJhbmdlIHJlcHJlc2VudGluZyBhIGltcG9ydC4gVGhlIHZhbHVlIG9mIHRoZSBraW5kIGlzICdpbXBvcnRzJy5cbiAqL1xuRm9sZGluZ1JhbmdlS2luZC5JbXBvcnRzID0gbmV3IEZvbGRpbmdSYW5nZUtpbmQoJ2ltcG9ydHMnKTtcbi8qKlxuICogS2luZCBmb3IgZm9sZGluZyByYW5nZSByZXByZXNlbnRpbmcgcmVnaW9ucyAoZm9yIGV4YW1wbGUgbWFya2VkIGJ5IGAjcmVnaW9uYCwgYCNlbmRyZWdpb25gKS5cbiAqIFRoZSB2YWx1ZSBvZiB0aGUga2luZCBpcyAncmVnaW9uJy5cbiAqL1xuRm9sZGluZ1JhbmdlS2luZC5SZWdpb24gPSBuZXcgRm9sZGluZ1JhbmdlS2luZCgncmVnaW9uJyk7XG5leHBvcnQgdmFyIE5ld1N5bWJvbE5hbWVUYWc7XG4oZnVuY3Rpb24gKE5ld1N5bWJvbE5hbWVUYWcpIHtcbiAgICBOZXdTeW1ib2xOYW1lVGFnW05ld1N5bWJvbE5hbWVUYWdbXCJBSUdlbmVyYXRlZFwiXSA9IDFdID0gXCJBSUdlbmVyYXRlZFwiO1xufSkoTmV3U3ltYm9sTmFtZVRhZyB8fCAoTmV3U3ltYm9sTmFtZVRhZyA9IHt9KSk7XG5leHBvcnQgdmFyIE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kKSB7XG4gICAgTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kW05ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDBdID0gXCJJbnZva2VcIjtcbiAgICBOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmRbTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kW1wiQXV0b21hdGljXCJdID0gMV0gPSBcIkF1dG9tYXRpY1wiO1xufSkoTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kIHx8IChOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IHZhciBDb21tYW5kO1xuKGZ1bmN0aW9uIChDb21tYW5kKSB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXMob2JqKSB7XG4gICAgICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmouaWQgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICB0eXBlb2Ygb2JqLnRpdGxlID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgQ29tbWFuZC5pcyA9IGlzO1xufSkoQ29tbWFuZCB8fCAoQ29tbWFuZCA9IHt9KSk7XG5leHBvcnQgdmFyIElubGF5SGludEtpbmQ7XG4oZnVuY3Rpb24gKElubGF5SGludEtpbmQpIHtcbiAgICBJbmxheUhpbnRLaW5kW0lubGF5SGludEtpbmRbXCJUeXBlXCJdID0gMV0gPSBcIlR5cGVcIjtcbiAgICBJbmxheUhpbnRLaW5kW0lubGF5SGludEtpbmRbXCJQYXJhbWV0ZXJcIl0gPSAyXSA9IFwiUGFyYW1ldGVyXCI7XG59KShJbmxheUhpbnRLaW5kIHx8IChJbmxheUhpbnRLaW5kID0ge30pKTtcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXp5VG9rZW5pemF0aW9uU3VwcG9ydCB7XG4gICAgY29uc3RydWN0b3IoY3JlYXRlU3VwcG9ydCkge1xuICAgICAgICB0aGlzLmNyZWF0ZVN1cHBvcnQgPSBjcmVhdGVTdXBwb3J0O1xuICAgICAgICB0aGlzLl90b2tlbml6YXRpb25TdXBwb3J0ID0gbnVsbDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnQudGhlbigoc3VwcG9ydCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCB0b2tlbml6YXRpb25TdXBwb3J0KCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuaXphdGlvblN1cHBvcnQgPSB0aGlzLmNyZWF0ZVN1cHBvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdG9rZW5pemF0aW9uU3VwcG9ydDtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY29uc3QgVG9rZW5pemF0aW9uUmVnaXN0cnkgPSBuZXcgVG9rZW5pemF0aW9uUmVnaXN0cnlJbXBsKCk7XG5leHBvcnQgdmFyIElubGluZUVkaXRUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoSW5saW5lRWRpdFRyaWdnZXJLaW5kKSB7XG4gICAgSW5saW5lRWRpdFRyaWdnZXJLaW5kW0lubGluZUVkaXRUcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDBdID0gXCJJbnZva2VcIjtcbiAgICBJbmxpbmVFZGl0VHJpZ2dlcktpbmRbSW5saW5lRWRpdFRyaWdnZXJLaW5kW1wiQXV0b21hdGljXCJdID0gMV0gPSBcIkF1dG9tYXRpY1wiO1xufSkoSW5saW5lRWRpdFRyaWdnZXJLaW5kIHx8IChJbmxpbmVFZGl0VHJpZ2dlcktpbmQgPSB7fSkpO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBUSElTIElTIEEgR0VORVJBVEVEIEZJTEUuIERPIE5PVCBFRElUIERJUkVDVExZLlxuZXhwb3J0IHZhciBBY2Nlc3NpYmlsaXR5U3VwcG9ydDtcbihmdW5jdGlvbiAoQWNjZXNzaWJpbGl0eVN1cHBvcnQpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHNob3VsZCBiZSB0aGUgYnJvd3NlciBjYXNlIHdoZXJlIGl0IGlzIG5vdCBrbm93biBpZiBhIHNjcmVlbiByZWFkZXIgaXMgYXR0YWNoZWQgb3Igbm8uXG4gICAgICovXG4gICAgQWNjZXNzaWJpbGl0eVN1cHBvcnRbQWNjZXNzaWJpbGl0eVN1cHBvcnRbXCJVbmtub3duXCJdID0gMF0gPSBcIlVua25vd25cIjtcbiAgICBBY2Nlc3NpYmlsaXR5U3VwcG9ydFtBY2Nlc3NpYmlsaXR5U3VwcG9ydFtcIkRpc2FibGVkXCJdID0gMV0gPSBcIkRpc2FibGVkXCI7XG4gICAgQWNjZXNzaWJpbGl0eVN1cHBvcnRbQWNjZXNzaWJpbGl0eVN1cHBvcnRbXCJFbmFibGVkXCJdID0gMl0gPSBcIkVuYWJsZWRcIjtcbn0pKEFjY2Vzc2liaWxpdHlTdXBwb3J0IHx8IChBY2Nlc3NpYmlsaXR5U3VwcG9ydCA9IHt9KSk7XG5leHBvcnQgdmFyIENvZGVBY3Rpb25UcmlnZ2VyVHlwZTtcbihmdW5jdGlvbiAoQ29kZUFjdGlvblRyaWdnZXJUeXBlKSB7XG4gICAgQ29kZUFjdGlvblRyaWdnZXJUeXBlW0NvZGVBY3Rpb25UcmlnZ2VyVHlwZVtcIkludm9rZVwiXSA9IDFdID0gXCJJbnZva2VcIjtcbiAgICBDb2RlQWN0aW9uVHJpZ2dlclR5cGVbQ29kZUFjdGlvblRyaWdnZXJUeXBlW1wiQXV0b1wiXSA9IDJdID0gXCJBdXRvXCI7XG59KShDb2RlQWN0aW9uVHJpZ2dlclR5cGUgfHwgKENvZGVBY3Rpb25UcmlnZ2VyVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGU7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGUpIHtcbiAgICBDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlW0NvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBBZGp1c3Qgd2hpdGVzcGFjZS9pbmRlbnRhdGlvbiBvZiBtdWx0aWxpbmUgaW5zZXJ0IHRleHRzIHRvXG4gICAgICogbWF0Y2ggdGhlIGN1cnJlbnQgbGluZSBpbmRlbnRhdGlvbi5cbiAgICAgKi9cbiAgICBDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlW0NvbXBsZXRpb25JdGVtSW5zZXJ0VGV4dFJ1bGVbXCJLZWVwV2hpdGVzcGFjZVwiXSA9IDFdID0gXCJLZWVwV2hpdGVzcGFjZVwiO1xuICAgIC8qKlxuICAgICAqIGBpbnNlcnRUZXh0YCBpcyBhIHNuaXBwZXQuXG4gICAgICovXG4gICAgQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZVtDb21wbGV0aW9uSXRlbUluc2VydFRleHRSdWxlW1wiSW5zZXJ0QXNTbmlwcGV0XCJdID0gNF0gPSBcIkluc2VydEFzU25pcHBldFwiO1xufSkoQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZSB8fCAoQ29tcGxldGlvbkl0ZW1JbnNlcnRUZXh0UnVsZSA9IHt9KSk7XG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtS2luZDtcbihmdW5jdGlvbiAoQ29tcGxldGlvbkl0ZW1LaW5kKSB7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIk1ldGhvZFwiXSA9IDBdID0gXCJNZXRob2RcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRnVuY3Rpb25cIl0gPSAxXSA9IFwiRnVuY3Rpb25cIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiQ29uc3RydWN0b3JcIl0gPSAyXSA9IFwiQ29uc3RydWN0b3JcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRmllbGRcIl0gPSAzXSA9IFwiRmllbGRcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVmFyaWFibGVcIl0gPSA0XSA9IFwiVmFyaWFibGVcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiQ2xhc3NcIl0gPSA1XSA9IFwiQ2xhc3NcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiU3RydWN0XCJdID0gNl0gPSBcIlN0cnVjdFwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJJbnRlcmZhY2VcIl0gPSA3XSA9IFwiSW50ZXJmYWNlXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIk1vZHVsZVwiXSA9IDhdID0gXCJNb2R1bGVcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiUHJvcGVydHlcIl0gPSA5XSA9IFwiUHJvcGVydHlcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRXZlbnRcIl0gPSAxMF0gPSBcIkV2ZW50XCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIk9wZXJhdG9yXCJdID0gMTFdID0gXCJPcGVyYXRvclwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJVbml0XCJdID0gMTJdID0gXCJVbml0XCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIlZhbHVlXCJdID0gMTNdID0gXCJWYWx1ZVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDb25zdGFudFwiXSA9IDE0XSA9IFwiQ29uc3RhbnRcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRW51bVwiXSA9IDE1XSA9IFwiRW51bVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJFbnVtTWVtYmVyXCJdID0gMTZdID0gXCJFbnVtTWVtYmVyXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIktleXdvcmRcIl0gPSAxN10gPSBcIktleXdvcmRcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVGV4dFwiXSA9IDE4XSA9IFwiVGV4dFwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDb2xvclwiXSA9IDE5XSA9IFwiQ29sb3JcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRmlsZVwiXSA9IDIwXSA9IFwiRmlsZVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJSZWZlcmVuY2VcIl0gPSAyMV0gPSBcIlJlZmVyZW5jZVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJDdXN0b21jb2xvclwiXSA9IDIyXSA9IFwiQ3VzdG9tY29sb3JcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiRm9sZGVyXCJdID0gMjNdID0gXCJGb2xkZXJcIjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmRbQ29tcGxldGlvbkl0ZW1LaW5kW1wiVHlwZVBhcmFtZXRlclwiXSA9IDI0XSA9IFwiVHlwZVBhcmFtZXRlclwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJVc2VyXCJdID0gMjVdID0gXCJVc2VyXCI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kW0NvbXBsZXRpb25JdGVtS2luZFtcIklzc3VlXCJdID0gMjZdID0gXCJJc3N1ZVwiO1xuICAgIENvbXBsZXRpb25JdGVtS2luZFtDb21wbGV0aW9uSXRlbUtpbmRbXCJTbmlwcGV0XCJdID0gMjddID0gXCJTbmlwcGV0XCI7XG59KShDb21wbGV0aW9uSXRlbUtpbmQgfHwgKENvbXBsZXRpb25JdGVtS2luZCA9IHt9KSk7XG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtVGFnO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbVRhZykge1xuICAgIENvbXBsZXRpb25JdGVtVGFnW0NvbXBsZXRpb25JdGVtVGFnW1wiRGVwcmVjYXRlZFwiXSA9IDFdID0gXCJEZXByZWNhdGVkXCI7XG59KShDb21wbGV0aW9uSXRlbVRhZyB8fCAoQ29tcGxldGlvbkl0ZW1UYWcgPSB7fSkpO1xuLyoqXG4gKiBIb3cgYSBzdWdnZXN0IHByb3ZpZGVyIHdhcyB0cmlnZ2VyZWQuXG4gKi9cbmV4cG9ydCB2YXIgQ29tcGxldGlvblRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uVHJpZ2dlcktpbmQpIHtcbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmRbQ29tcGxldGlvblRyaWdnZXJLaW5kW1wiSW52b2tlXCJdID0gMF0gPSBcIkludm9rZVwiO1xuICAgIENvbXBsZXRpb25UcmlnZ2VyS2luZFtDb21wbGV0aW9uVHJpZ2dlcktpbmRbXCJUcmlnZ2VyQ2hhcmFjdGVyXCJdID0gMV0gPSBcIlRyaWdnZXJDaGFyYWN0ZXJcIjtcbiAgICBDb21wbGV0aW9uVHJpZ2dlcktpbmRbQ29tcGxldGlvblRyaWdnZXJLaW5kW1wiVHJpZ2dlckZvckluY29tcGxldGVDb21wbGV0aW9uc1wiXSA9IDJdID0gXCJUcmlnZ2VyRm9ySW5jb21wbGV0ZUNvbXBsZXRpb25zXCI7XG59KShDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKENvbXBsZXRpb25UcmlnZ2VyS2luZCA9IHt9KSk7XG4vKipcbiAqIEEgcG9zaXRpb25pbmcgcHJlZmVyZW5jZSBmb3IgcmVuZGVyaW5nIGNvbnRlbnQgd2lkZ2V0cy5cbiAqL1xuZXhwb3J0IHZhciBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlO1xuKGZ1bmN0aW9uIChDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlKSB7XG4gICAgLyoqXG4gICAgICogUGxhY2UgdGhlIGNvbnRlbnQgd2lkZ2V0IGV4YWN0bHkgYXQgYSBwb3NpdGlvblxuICAgICAqL1xuICAgIENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtcIkVYQUNUXCJdID0gMF0gPSBcIkVYQUNUXCI7XG4gICAgLyoqXG4gICAgICogUGxhY2UgdGhlIGNvbnRlbnQgd2lkZ2V0IGFib3ZlIGEgcG9zaXRpb25cbiAgICAgKi9cbiAgICBDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW0NvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbXCJBQk9WRVwiXSA9IDFdID0gXCJBQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIFBsYWNlIHRoZSBjb250ZW50IHdpZGdldCBiZWxvdyBhIHBvc2l0aW9uXG4gICAgICovXG4gICAgQ29udGVudFdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtDb250ZW50V2lkZ2V0UG9zaXRpb25QcmVmZXJlbmNlW1wiQkVMT1dcIl0gPSAyXSA9IFwiQkVMT1dcIjtcbn0pKENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UgfHwgKENvbnRlbnRXaWRnZXRQb3NpdGlvblByZWZlcmVuY2UgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgdGhlIHJlYXNvbiB0aGUgY3Vyc29yIGhhcyBjaGFuZ2VkIGl0cyBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IHZhciBDdXJzb3JDaGFuZ2VSZWFzb247XG4oZnVuY3Rpb24gKEN1cnNvckNoYW5nZVJlYXNvbikge1xuICAgIC8qKlxuICAgICAqIFVua25vd24gb3Igbm90IHNldC5cbiAgICAgKi9cbiAgICBDdXJzb3JDaGFuZ2VSZWFzb25bQ3Vyc29yQ2hhbmdlUmVhc29uW1wiTm90U2V0XCJdID0gMF0gPSBcIk5vdFNldFwiO1xuICAgIC8qKlxuICAgICAqIEEgYG1vZGVsLnNldFZhbHVlKClgIHdhcyBjYWxsZWQuXG4gICAgICovXG4gICAgQ3Vyc29yQ2hhbmdlUmVhc29uW0N1cnNvckNoYW5nZVJlYXNvbltcIkNvbnRlbnRGbHVzaFwiXSA9IDFdID0gXCJDb250ZW50Rmx1c2hcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgYG1vZGVsYCBoYXMgYmVlbiBjaGFuZ2VkIG91dHNpZGUgb2YgdGhpcyBjdXJzb3IgYW5kIHRoZSBjdXJzb3IgcmVjb3ZlcnMgaXRzIHBvc2l0aW9uIGZyb20gYXNzb2NpYXRlZCBtYXJrZXJzLlxuICAgICAqL1xuICAgIEN1cnNvckNoYW5nZVJlYXNvbltDdXJzb3JDaGFuZ2VSZWFzb25bXCJSZWNvdmVyRnJvbU1hcmtlcnNcIl0gPSAyXSA9IFwiUmVjb3ZlckZyb21NYXJrZXJzXCI7XG4gICAgLyoqXG4gICAgICogVGhlcmUgd2FzIGFuIGV4cGxpY2l0IHVzZXIgZ2VzdHVyZS5cbiAgICAgKi9cbiAgICBDdXJzb3JDaGFuZ2VSZWFzb25bQ3Vyc29yQ2hhbmdlUmVhc29uW1wiRXhwbGljaXRcIl0gPSAzXSA9IFwiRXhwbGljaXRcIjtcbiAgICAvKipcbiAgICAgKiBUaGVyZSB3YXMgYSBQYXN0ZS5cbiAgICAgKi9cbiAgICBDdXJzb3JDaGFuZ2VSZWFzb25bQ3Vyc29yQ2hhbmdlUmVhc29uW1wiUGFzdGVcIl0gPSA0XSA9IFwiUGFzdGVcIjtcbiAgICAvKipcbiAgICAgKiBUaGVyZSB3YXMgYW4gVW5kby5cbiAgICAgKi9cbiAgICBDdXJzb3JDaGFuZ2VSZWFzb25bQ3Vyc29yQ2hhbmdlUmVhc29uW1wiVW5kb1wiXSA9IDVdID0gXCJVbmRvXCI7XG4gICAgLyoqXG4gICAgICogVGhlcmUgd2FzIGEgUmVkby5cbiAgICAgKi9cbiAgICBDdXJzb3JDaGFuZ2VSZWFzb25bQ3Vyc29yQ2hhbmdlUmVhc29uW1wiUmVkb1wiXSA9IDZdID0gXCJSZWRvXCI7XG59KShDdXJzb3JDaGFuZ2VSZWFzb24gfHwgKEN1cnNvckNoYW5nZVJlYXNvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBkZWZhdWx0IGVuZCBvZiBsaW5lIHRvIHVzZSB3aGVuIGluc3RhbnRpYXRpbmcgbW9kZWxzLlxuICovXG5leHBvcnQgdmFyIERlZmF1bHRFbmRPZkxpbmU7XG4oZnVuY3Rpb24gKERlZmF1bHRFbmRPZkxpbmUpIHtcbiAgICAvKipcbiAgICAgKiBVc2UgbGluZSBmZWVkIChcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgRGVmYXVsdEVuZE9mTGluZVtEZWZhdWx0RW5kT2ZMaW5lW1wiTEZcIl0gPSAxXSA9IFwiTEZcIjtcbiAgICAvKipcbiAgICAgKiBVc2UgY2FycmlhZ2UgcmV0dXJuIGFuZCBsaW5lIGZlZWQgKFxcclxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBEZWZhdWx0RW5kT2ZMaW5lW0RlZmF1bHRFbmRPZkxpbmVbXCJDUkxGXCJdID0gMl0gPSBcIkNSTEZcIjtcbn0pKERlZmF1bHRFbmRPZkxpbmUgfHwgKERlZmF1bHRFbmRPZkxpbmUgPSB7fSkpO1xuLyoqXG4gKiBBIGRvY3VtZW50IGhpZ2hsaWdodCBraW5kLlxuICovXG5leHBvcnQgdmFyIERvY3VtZW50SGlnaGxpZ2h0S2luZDtcbihmdW5jdGlvbiAoRG9jdW1lbnRIaWdobGlnaHRLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQSB0ZXh0dWFsIG9jY3VycmVuY2UuXG4gICAgICovXG4gICAgRG9jdW1lbnRIaWdobGlnaHRLaW5kW0RvY3VtZW50SGlnaGxpZ2h0S2luZFtcIlRleHRcIl0gPSAwXSA9IFwiVGV4dFwiO1xuICAgIC8qKlxuICAgICAqIFJlYWQtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHJlYWRpbmcgYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiUmVhZFwiXSA9IDFdID0gXCJSZWFkXCI7XG4gICAgLyoqXG4gICAgICogV3JpdGUtYWNjZXNzIG9mIGEgc3ltYm9sLCBsaWtlIHdyaXRpbmcgdG8gYSB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmRbRG9jdW1lbnRIaWdobGlnaHRLaW5kW1wiV3JpdGVcIl0gPSAyXSA9IFwiV3JpdGVcIjtcbn0pKERvY3VtZW50SGlnaGxpZ2h0S2luZCB8fCAoRG9jdW1lbnRIaWdobGlnaHRLaW5kID0ge30pKTtcbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBhdXRvIGluZGVudGF0aW9uIGluIHRoZSBlZGl0b3JcbiAqL1xuZXhwb3J0IHZhciBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3k7XG4oZnVuY3Rpb24gKEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneSkge1xuICAgIEVkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3lbRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W1wiS2VlcFwiXSA9IDFdID0gXCJLZWVwXCI7XG4gICAgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W0VkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtcIkJyYWNrZXRzXCJdID0gMl0gPSBcIkJyYWNrZXRzXCI7XG4gICAgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W0VkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtcIkFkdmFuY2VkXCJdID0gM10gPSBcIkFkdmFuY2VkXCI7XG4gICAgRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5W0VkaXRvckF1dG9JbmRlbnRTdHJhdGVneVtcIkZ1bGxcIl0gPSA0XSA9IFwiRnVsbFwiO1xufSkoRWRpdG9yQXV0b0luZGVudFN0cmF0ZWd5IHx8IChFZGl0b3JBdXRvSW5kZW50U3RyYXRlZ3kgPSB7fSkpO1xuZXhwb3J0IHZhciBFZGl0b3JPcHRpb247XG4oZnVuY3Rpb24gKEVkaXRvck9wdGlvbikge1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhY2NlcHRTdWdnZXN0aW9uT25Db21taXRDaGFyYWN0ZXJcIl0gPSAwXSA9IFwiYWNjZXB0U3VnZ2VzdGlvbk9uQ29tbWl0Q2hhcmFjdGVyXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFjY2VwdFN1Z2dlc3Rpb25PbkVudGVyXCJdID0gMV0gPSBcImFjY2VwdFN1Z2dlc3Rpb25PbkVudGVyXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFjY2Vzc2liaWxpdHlTdXBwb3J0XCJdID0gMl0gPSBcImFjY2Vzc2liaWxpdHlTdXBwb3J0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImFjY2Vzc2liaWxpdHlQYWdlU2l6ZVwiXSA9IDNdID0gXCJhY2Nlc3NpYmlsaXR5UGFnZVNpemVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiYXJpYUxhYmVsXCJdID0gNF0gPSBcImFyaWFMYWJlbFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhcmlhUmVxdWlyZWRcIl0gPSA1XSA9IFwiYXJpYVJlcXVpcmVkXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nQnJhY2tldHNcIl0gPSA2XSA9IFwiYXV0b0Nsb3NpbmdCcmFja2V0c1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ0NvbW1lbnRzXCJdID0gN10gPSBcImF1dG9DbG9zaW5nQ29tbWVudHNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2NyZWVuUmVhZGVyQW5ub3VuY2VJbmxpbmVTdWdnZXN0aW9uXCJdID0gOF0gPSBcInNjcmVlblJlYWRlckFubm91bmNlSW5saW5lU3VnZ2VzdGlvblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ0RlbGV0ZVwiXSA9IDldID0gXCJhdXRvQ2xvc2luZ0RlbGV0ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvQ2xvc2luZ092ZXJ0eXBlXCJdID0gMTBdID0gXCJhdXRvQ2xvc2luZ092ZXJ0eXBlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9DbG9zaW5nUXVvdGVzXCJdID0gMTFdID0gXCJhdXRvQ2xvc2luZ1F1b3Rlc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJhdXRvSW5kZW50XCJdID0gMTJdID0gXCJhdXRvSW5kZW50XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9tYXRpY0xheW91dFwiXSA9IDEzXSA9IFwiYXV0b21hdGljTGF5b3V0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImF1dG9TdXJyb3VuZFwiXSA9IDE0XSA9IFwiYXV0b1N1cnJvdW5kXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImJyYWNrZXRQYWlyQ29sb3JpemF0aW9uXCJdID0gMTVdID0gXCJicmFja2V0UGFpckNvbG9yaXphdGlvblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJndWlkZXNcIl0gPSAxNl0gPSBcImd1aWRlc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2RlTGVuc1wiXSA9IDE3XSA9IFwiY29kZUxlbnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29kZUxlbnNGb250RmFtaWx5XCJdID0gMThdID0gXCJjb2RlTGVuc0ZvbnRGYW1pbHlcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29kZUxlbnNGb250U2l6ZVwiXSA9IDE5XSA9IFwiY29kZUxlbnNGb250U2l6ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2xvckRlY29yYXRvcnNcIl0gPSAyMF0gPSBcImNvbG9yRGVjb3JhdG9yc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2xvckRlY29yYXRvcnNMaW1pdFwiXSA9IDIxXSA9IFwiY29sb3JEZWNvcmF0b3JzTGltaXRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29sdW1uU2VsZWN0aW9uXCJdID0gMjJdID0gXCJjb2x1bW5TZWxlY3Rpb25cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY29tbWVudHNcIl0gPSAyM10gPSBcImNvbW1lbnRzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImNvbnRleHRtZW51XCJdID0gMjRdID0gXCJjb250ZXh0bWVudVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb3B5V2l0aFN5bnRheEhpZ2hsaWdodGluZ1wiXSA9IDI1XSA9IFwiY29weVdpdGhTeW50YXhIaWdobGlnaHRpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY3Vyc29yQmxpbmtpbmdcIl0gPSAyNl0gPSBcImN1cnNvckJsaW5raW5nXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImN1cnNvclNtb290aENhcmV0QW5pbWF0aW9uXCJdID0gMjddID0gXCJjdXJzb3JTbW9vdGhDYXJldEFuaW1hdGlvblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTdHlsZVwiXSA9IDI4XSA9IFwiY3Vyc29yU3R5bGVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiY3Vyc29yU3Vycm91bmRpbmdMaW5lc1wiXSA9IDI5XSA9IFwiY3Vyc29yU3Vycm91bmRpbmdMaW5lc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JTdXJyb3VuZGluZ0xpbmVzU3R5bGVcIl0gPSAzMF0gPSBcImN1cnNvclN1cnJvdW5kaW5nTGluZXNTdHlsZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjdXJzb3JXaWR0aFwiXSA9IDMxXSA9IFwiY3Vyc29yV2lkdGhcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZGlzYWJsZUxheWVySGludGluZ1wiXSA9IDMyXSA9IFwiZGlzYWJsZUxheWVySGludGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkaXNhYmxlTW9ub3NwYWNlT3B0aW1pemF0aW9uc1wiXSA9IDMzXSA9IFwiZGlzYWJsZU1vbm9zcGFjZU9wdGltaXphdGlvbnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZG9tUmVhZE9ubHlcIl0gPSAzNF0gPSBcImRvbVJlYWRPbmx5XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImRyYWdBbmREcm9wXCJdID0gMzVdID0gXCJkcmFnQW5kRHJvcFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkcm9wSW50b0VkaXRvclwiXSA9IDM2XSA9IFwiZHJvcEludG9FZGl0b3JcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZW1wdHlTZWxlY3Rpb25DbGlwYm9hcmRcIl0gPSAzN10gPSBcImVtcHR5U2VsZWN0aW9uQ2xpcGJvYXJkXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImV4cGVyaW1lbnRhbFdoaXRlc3BhY2VSZW5kZXJpbmdcIl0gPSAzOF0gPSBcImV4cGVyaW1lbnRhbFdoaXRlc3BhY2VSZW5kZXJpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZXh0cmFFZGl0b3JDbGFzc05hbWVcIl0gPSAzOV0gPSBcImV4dHJhRWRpdG9yQ2xhc3NOYW1lXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZhc3RTY3JvbGxTZW5zaXRpdml0eVwiXSA9IDQwXSA9IFwiZmFzdFNjcm9sbFNlbnNpdGl2aXR5XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZpbmRcIl0gPSA0MV0gPSBcImZpbmRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZml4ZWRPdmVyZmxvd1dpZGdldHNcIl0gPSA0Ml0gPSBcImZpeGVkT3ZlcmZsb3dXaWRnZXRzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImZvbGRpbmdcIl0gPSA0M10gPSBcImZvbGRpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ1N0cmF0ZWd5XCJdID0gNDRdID0gXCJmb2xkaW5nU3RyYXRlZ3lcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ0hpZ2hsaWdodFwiXSA9IDQ1XSA9IFwiZm9sZGluZ0hpZ2hsaWdodFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb2xkaW5nSW1wb3J0c0J5RGVmYXVsdFwiXSA9IDQ2XSA9IFwiZm9sZGluZ0ltcG9ydHNCeURlZmF1bHRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9sZGluZ01heGltdW1SZWdpb25zXCJdID0gNDddID0gXCJmb2xkaW5nTWF4aW11bVJlZ2lvbnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widW5mb2xkT25DbGlja0FmdGVyRW5kT2ZMaW5lXCJdID0gNDhdID0gXCJ1bmZvbGRPbkNsaWNrQWZ0ZXJFbmRPZkxpbmVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9udEZhbWlseVwiXSA9IDQ5XSA9IFwiZm9udEZhbWlseVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250SW5mb1wiXSA9IDUwXSA9IFwiZm9udEluZm9cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9udExpZ2F0dXJlc1wiXSA9IDUxXSA9IFwiZm9udExpZ2F0dXJlc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250U2l6ZVwiXSA9IDUyXSA9IFwiZm9udFNpemVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9udFdlaWdodFwiXSA9IDUzXSA9IFwiZm9udFdlaWdodFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb250VmFyaWF0aW9uc1wiXSA9IDU0XSA9IFwiZm9udFZhcmlhdGlvbnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZm9ybWF0T25QYXN0ZVwiXSA9IDU1XSA9IFwiZm9ybWF0T25QYXN0ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJmb3JtYXRPblR5cGVcIl0gPSA1Nl0gPSBcImZvcm1hdE9uVHlwZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJnbHlwaE1hcmdpblwiXSA9IDU3XSA9IFwiZ2x5cGhNYXJnaW5cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiZ290b0xvY2F0aW9uXCJdID0gNThdID0gXCJnb3RvTG9jYXRpb25cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaGlkZUN1cnNvckluT3ZlcnZpZXdSdWxlclwiXSA9IDU5XSA9IFwiaGlkZUN1cnNvckluT3ZlcnZpZXdSdWxlclwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJob3ZlclwiXSA9IDYwXSA9IFwiaG92ZXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaW5EaWZmRWRpdG9yXCJdID0gNjFdID0gXCJpbkRpZmZFZGl0b3JcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wiaW5saW5lU3VnZ2VzdFwiXSA9IDYyXSA9IFwiaW5saW5lU3VnZ2VzdFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJpbmxpbmVFZGl0XCJdID0gNjNdID0gXCJpbmxpbmVFZGl0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxldHRlclNwYWNpbmdcIl0gPSA2NF0gPSBcImxldHRlclNwYWNpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGlnaHRidWxiXCJdID0gNjVdID0gXCJsaWdodGJ1bGJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZURlY29yYXRpb25zV2lkdGhcIl0gPSA2Nl0gPSBcImxpbmVEZWNvcmF0aW9uc1dpZHRoXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpbmVIZWlnaHRcIl0gPSA2N10gPSBcImxpbmVIZWlnaHRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGluZU51bWJlcnNcIl0gPSA2OF0gPSBcImxpbmVOdW1iZXJzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxpbmVOdW1iZXJzTWluQ2hhcnNcIl0gPSA2OV0gPSBcImxpbmVOdW1iZXJzTWluQ2hhcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibGlua2VkRWRpdGluZ1wiXSA9IDcwXSA9IFwibGlua2VkRWRpdGluZ1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJsaW5rc1wiXSA9IDcxXSA9IFwibGlua3NcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibWF0Y2hCcmFja2V0c1wiXSA9IDcyXSA9IFwibWF0Y2hCcmFja2V0c1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtaW5pbWFwXCJdID0gNzNdID0gXCJtaW5pbWFwXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm1vdXNlU3R5bGVcIl0gPSA3NF0gPSBcIm1vdXNlU3R5bGVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibW91c2VXaGVlbFNjcm9sbFNlbnNpdGl2aXR5XCJdID0gNzVdID0gXCJtb3VzZVdoZWVsU2Nyb2xsU2Vuc2l0aXZpdHlcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibW91c2VXaGVlbFpvb21cIl0gPSA3Nl0gPSBcIm1vdXNlV2hlZWxab29tXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm11bHRpQ3Vyc29yTWVyZ2VPdmVybGFwcGluZ1wiXSA9IDc3XSA9IFwibXVsdGlDdXJzb3JNZXJnZU92ZXJsYXBwaW5nXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm11bHRpQ3Vyc29yTW9kaWZpZXJcIl0gPSA3OF0gPSBcIm11bHRpQ3Vyc29yTW9kaWZpZXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wibXVsdGlDdXJzb3JQYXN0ZVwiXSA9IDc5XSA9IFwibXVsdGlDdXJzb3JQYXN0ZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJtdWx0aUN1cnNvckxpbWl0XCJdID0gODBdID0gXCJtdWx0aUN1cnNvckxpbWl0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm9jY3VycmVuY2VzSGlnaGxpZ2h0XCJdID0gODFdID0gXCJvY2N1cnJlbmNlc0hpZ2hsaWdodFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJvdmVydmlld1J1bGVyQm9yZGVyXCJdID0gODJdID0gXCJvdmVydmlld1J1bGVyQm9yZGVyXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIm92ZXJ2aWV3UnVsZXJMYW5lc1wiXSA9IDgzXSA9IFwib3ZlcnZpZXdSdWxlckxhbmVzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInBhZGRpbmdcIl0gPSA4NF0gPSBcInBhZGRpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicGFzdGVBc1wiXSA9IDg1XSA9IFwicGFzdGVBc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJwYXJhbWV0ZXJIaW50c1wiXSA9IDg2XSA9IFwicGFyYW1ldGVySGludHNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicGVla1dpZGdldERlZmF1bHRGb2N1c1wiXSA9IDg3XSA9IFwicGVla1dpZGdldERlZmF1bHRGb2N1c1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkZWZpbml0aW9uTGlua09wZW5zSW5QZWVrXCJdID0gODhdID0gXCJkZWZpbml0aW9uTGlua09wZW5zSW5QZWVrXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInF1aWNrU3VnZ2VzdGlvbnNcIl0gPSA4OV0gPSBcInF1aWNrU3VnZ2VzdGlvbnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicXVpY2tTdWdnZXN0aW9uc0RlbGF5XCJdID0gOTBdID0gXCJxdWlja1N1Z2dlc3Rpb25zRGVsYXlcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicmVhZE9ubHlcIl0gPSA5MV0gPSBcInJlYWRPbmx5XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlYWRPbmx5TWVzc2FnZVwiXSA9IDkyXSA9IFwicmVhZE9ubHlNZXNzYWdlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmFtZU9uVHlwZVwiXSA9IDkzXSA9IFwicmVuYW1lT25UeXBlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmRlckNvbnRyb2xDaGFyYWN0ZXJzXCJdID0gOTRdID0gXCJyZW5kZXJDb250cm9sQ2hhcmFjdGVyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJGaW5hbE5ld2xpbmVcIl0gPSA5NV0gPSBcInJlbmRlckZpbmFsTmV3bGluZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJMaW5lSGlnaGxpZ2h0XCJdID0gOTZdID0gXCJyZW5kZXJMaW5lSGlnaGxpZ2h0XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJlbmRlckxpbmVIaWdobGlnaHRPbmx5V2hlbkZvY3VzXCJdID0gOTddID0gXCJyZW5kZXJMaW5lSGlnaGxpZ2h0T25seVdoZW5Gb2N1c1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJWYWxpZGF0aW9uRGVjb3JhdGlvbnNcIl0gPSA5OF0gPSBcInJlbmRlclZhbGlkYXRpb25EZWNvcmF0aW9uc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJyZW5kZXJXaGl0ZXNwYWNlXCJdID0gOTldID0gXCJyZW5kZXJXaGl0ZXNwYWNlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJldmVhbEhvcml6b250YWxSaWdodFBhZGRpbmdcIl0gPSAxMDBdID0gXCJyZXZlYWxIb3Jpem9udGFsUmlnaHRQYWRkaW5nXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJvdW5kZWRTZWxlY3Rpb25cIl0gPSAxMDFdID0gXCJyb3VuZGVkU2VsZWN0aW9uXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInJ1bGVyc1wiXSA9IDEwMl0gPSBcInJ1bGVyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzY3JvbGxiYXJcIl0gPSAxMDNdID0gXCJzY3JvbGxiYXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsQmV5b25kTGFzdENvbHVtblwiXSA9IDEwNF0gPSBcInNjcm9sbEJleW9uZExhc3RDb2x1bW5cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2Nyb2xsQmV5b25kTGFzdExpbmVcIl0gPSAxMDVdID0gXCJzY3JvbGxCZXlvbmRMYXN0TGluZVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzY3JvbGxQcmVkb21pbmFudEF4aXNcIl0gPSAxMDZdID0gXCJzY3JvbGxQcmVkb21pbmFudEF4aXNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2VsZWN0aW9uQ2xpcGJvYXJkXCJdID0gMTA3XSA9IFwic2VsZWN0aW9uQ2xpcGJvYXJkXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInNlbGVjdGlvbkhpZ2hsaWdodFwiXSA9IDEwOF0gPSBcInNlbGVjdGlvbkhpZ2hsaWdodFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzZWxlY3RPbkxpbmVOdW1iZXJzXCJdID0gMTA5XSA9IFwic2VsZWN0T25MaW5lTnVtYmVyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzaG93Rm9sZGluZ0NvbnRyb2xzXCJdID0gMTEwXSA9IFwic2hvd0ZvbGRpbmdDb250cm9sc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzaG93VW51c2VkXCJdID0gMTExXSA9IFwic2hvd1VudXNlZFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzbmlwcGV0U3VnZ2VzdGlvbnNcIl0gPSAxMTJdID0gXCJzbmlwcGV0U3VnZ2VzdGlvbnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic21hcnRTZWxlY3RcIl0gPSAxMTNdID0gXCJzbWFydFNlbGVjdFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzbW9vdGhTY3JvbGxpbmdcIl0gPSAxMTRdID0gXCJzbW9vdGhTY3JvbGxpbmdcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3RpY2t5U2Nyb2xsXCJdID0gMTE1XSA9IFwic3RpY2t5U2Nyb2xsXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN0aWNreVRhYlN0b3BzXCJdID0gMTE2XSA9IFwic3RpY2t5VGFiU3RvcHNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3RvcFJlbmRlcmluZ0xpbmVBZnRlclwiXSA9IDExN10gPSBcInN0b3BSZW5kZXJpbmdMaW5lQWZ0ZXJcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3VnZ2VzdFwiXSA9IDExOF0gPSBcInN1Z2dlc3RcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3VnZ2VzdEZvbnRTaXplXCJdID0gMTE5XSA9IFwic3VnZ2VzdEZvbnRTaXplXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInN1Z2dlc3RMaW5lSGVpZ2h0XCJdID0gMTIwXSA9IFwic3VnZ2VzdExpbmVIZWlnaHRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic3VnZ2VzdE9uVHJpZ2dlckNoYXJhY3RlcnNcIl0gPSAxMjFdID0gXCJzdWdnZXN0T25UcmlnZ2VyQ2hhcmFjdGVyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJzdWdnZXN0U2VsZWN0aW9uXCJdID0gMTIyXSA9IFwic3VnZ2VzdFNlbGVjdGlvblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ0YWJDb21wbGV0aW9uXCJdID0gMTIzXSA9IFwidGFiQ29tcGxldGlvblwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ0YWJJbmRleFwiXSA9IDEyNF0gPSBcInRhYkluZGV4XCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInVuaWNvZGVIaWdobGlnaHRpbmdcIl0gPSAxMjVdID0gXCJ1bmljb2RlSGlnaGxpZ2h0aW5nXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInVudXN1YWxMaW5lVGVybWluYXRvcnNcIl0gPSAxMjZdID0gXCJ1bnVzdWFsTGluZVRlcm1pbmF0b3JzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcInVzZVNoYWRvd0RPTVwiXSA9IDEyN10gPSBcInVzZVNoYWRvd0RPTVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ1c2VUYWJTdG9wc1wiXSA9IDEyOF0gPSBcInVzZVRhYlN0b3BzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRCcmVha1wiXSA9IDEyOV0gPSBcIndvcmRCcmVha1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkU2VnbWVudGVyTG9jYWxlc1wiXSA9IDEzMF0gPSBcIndvcmRTZWdtZW50ZXJMb2NhbGVzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRTZXBhcmF0b3JzXCJdID0gMTMxXSA9IFwid29yZFNlcGFyYXRvcnNcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBcIl0gPSAxMzJdID0gXCJ3b3JkV3JhcFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkV3JhcEJyZWFrQWZ0ZXJDaGFyYWN0ZXJzXCJdID0gMTMzXSA9IFwid29yZFdyYXBCcmVha0FmdGVyQ2hhcmFjdGVyc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkV3JhcEJyZWFrQmVmb3JlQ2hhcmFjdGVyc1wiXSA9IDEzNF0gPSBcIndvcmRXcmFwQnJlYWtCZWZvcmVDaGFyYWN0ZXJzXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndvcmRXcmFwQ29sdW1uXCJdID0gMTM1XSA9IFwid29yZFdyYXBDb2x1bW5cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid29yZFdyYXBPdmVycmlkZTFcIl0gPSAxMzZdID0gXCJ3b3JkV3JhcE92ZXJyaWRlMVwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJ3b3JkV3JhcE92ZXJyaWRlMlwiXSA9IDEzN10gPSBcIndvcmRXcmFwT3ZlcnJpZGUyXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndyYXBwaW5nSW5kZW50XCJdID0gMTM4XSA9IFwid3JhcHBpbmdJbmRlbnRcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wid3JhcHBpbmdTdHJhdGVneVwiXSA9IDEzOV0gPSBcIndyYXBwaW5nU3RyYXRlZ3lcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wic2hvd0RlcHJlY2F0ZWRcIl0gPSAxNDBdID0gXCJzaG93RGVwcmVjYXRlZFwiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJpbmxheUhpbnRzXCJdID0gMTQxXSA9IFwiaW5sYXlIaW50c1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJlZGl0b3JDbGFzc05hbWVcIl0gPSAxNDJdID0gXCJlZGl0b3JDbGFzc05hbWVcIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1wicGl4ZWxSYXRpb1wiXSA9IDE0M10gPSBcInBpeGVsUmF0aW9cIjtcbiAgICBFZGl0b3JPcHRpb25bRWRpdG9yT3B0aW9uW1widGFiRm9jdXNNb2RlXCJdID0gMTQ0XSA9IFwidGFiRm9jdXNNb2RlXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImxheW91dEluZm9cIl0gPSAxNDVdID0gXCJsYXlvdXRJbmZvXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcIndyYXBwaW5nSW5mb1wiXSA9IDE0Nl0gPSBcIndyYXBwaW5nSW5mb1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJkZWZhdWx0Q29sb3JEZWNvcmF0b3JzXCJdID0gMTQ3XSA9IFwiZGVmYXVsdENvbG9yRGVjb3JhdG9yc1wiO1xuICAgIEVkaXRvck9wdGlvbltFZGl0b3JPcHRpb25bXCJjb2xvckRlY29yYXRvcnNBY3RpdmF0ZWRPblwiXSA9IDE0OF0gPSBcImNvbG9yRGVjb3JhdG9yc0FjdGl2YXRlZE9uXCI7XG4gICAgRWRpdG9yT3B0aW9uW0VkaXRvck9wdGlvbltcImlubGluZUNvbXBsZXRpb25zQWNjZXNzaWJpbGl0eVZlcmJvc2VcIl0gPSAxNDldID0gXCJpbmxpbmVDb21wbGV0aW9uc0FjY2Vzc2liaWxpdHlWZXJib3NlXCI7XG59KShFZGl0b3JPcHRpb24gfHwgKEVkaXRvck9wdGlvbiA9IHt9KSk7XG4vKipcbiAqIEVuZCBvZiBsaW5lIGNoYXJhY3RlciBwcmVmZXJlbmNlLlxuICovXG5leHBvcnQgdmFyIEVuZE9mTGluZVByZWZlcmVuY2U7XG4oZnVuY3Rpb24gKEVuZE9mTGluZVByZWZlcmVuY2UpIHtcbiAgICAvKipcbiAgICAgKiBVc2UgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3RlciBpZGVudGlmaWVkIGluIHRoZSB0ZXh0IGJ1ZmZlci5cbiAgICAgKi9cbiAgICBFbmRPZkxpbmVQcmVmZXJlbmNlW0VuZE9mTGluZVByZWZlcmVuY2VbXCJUZXh0RGVmaW5lZFwiXSA9IDBdID0gXCJUZXh0RGVmaW5lZFwiO1xuICAgIC8qKlxuICAgICAqIFVzZSBsaW5lIGZlZWQgKFxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBFbmRPZkxpbmVQcmVmZXJlbmNlW0VuZE9mTGluZVByZWZlcmVuY2VbXCJMRlwiXSA9IDFdID0gXCJMRlwiO1xuICAgIC8qKlxuICAgICAqIFVzZSBjYXJyaWFnZSByZXR1cm4gYW5kIGxpbmUgZmVlZCAoXFxyXFxuKSBhcyB0aGUgZW5kIG9mIGxpbmUgY2hhcmFjdGVyLlxuICAgICAqL1xuICAgIEVuZE9mTGluZVByZWZlcmVuY2VbRW5kT2ZMaW5lUHJlZmVyZW5jZVtcIkNSTEZcIl0gPSAyXSA9IFwiQ1JMRlwiO1xufSkoRW5kT2ZMaW5lUHJlZmVyZW5jZSB8fCAoRW5kT2ZMaW5lUHJlZmVyZW5jZSA9IHt9KSk7XG4vKipcbiAqIEVuZCBvZiBsaW5lIGNoYXJhY3RlciBwcmVmZXJlbmNlLlxuICovXG5leHBvcnQgdmFyIEVuZE9mTGluZVNlcXVlbmNlO1xuKGZ1bmN0aW9uIChFbmRPZkxpbmVTZXF1ZW5jZSkge1xuICAgIC8qKlxuICAgICAqIFVzZSBsaW5lIGZlZWQgKFxcbikgYXMgdGhlIGVuZCBvZiBsaW5lIGNoYXJhY3Rlci5cbiAgICAgKi9cbiAgICBFbmRPZkxpbmVTZXF1ZW5jZVtFbmRPZkxpbmVTZXF1ZW5jZVtcIkxGXCJdID0gMF0gPSBcIkxGXCI7XG4gICAgLyoqXG4gICAgICogVXNlIGNhcnJpYWdlIHJldHVybiBhbmQgbGluZSBmZWVkIChcXHJcXG4pIGFzIHRoZSBlbmQgb2YgbGluZSBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgRW5kT2ZMaW5lU2VxdWVuY2VbRW5kT2ZMaW5lU2VxdWVuY2VbXCJDUkxGXCJdID0gMV0gPSBcIkNSTEZcIjtcbn0pKEVuZE9mTGluZVNlcXVlbmNlIHx8IChFbmRPZkxpbmVTZXF1ZW5jZSA9IHt9KSk7XG4vKipcbiAqIFZlcnRpY2FsIExhbmUgaW4gdGhlIGdseXBoIG1hcmdpbiBvZiB0aGUgZWRpdG9yLlxuICovXG5leHBvcnQgdmFyIEdseXBoTWFyZ2luTGFuZTtcbihmdW5jdGlvbiAoR2x5cGhNYXJnaW5MYW5lKSB7XG4gICAgR2x5cGhNYXJnaW5MYW5lW0dseXBoTWFyZ2luTGFuZVtcIkxlZnRcIl0gPSAxXSA9IFwiTGVmdFwiO1xuICAgIEdseXBoTWFyZ2luTGFuZVtHbHlwaE1hcmdpbkxhbmVbXCJDZW50ZXJcIl0gPSAyXSA9IFwiQ2VudGVyXCI7XG4gICAgR2x5cGhNYXJnaW5MYW5lW0dseXBoTWFyZ2luTGFuZVtcIlJpZ2h0XCJdID0gM10gPSBcIlJpZ2h0XCI7XG59KShHbHlwaE1hcmdpbkxhbmUgfHwgKEdseXBoTWFyZ2luTGFuZSA9IHt9KSk7XG5leHBvcnQgdmFyIEhvdmVyVmVyYm9zaXR5QWN0aW9uO1xuKGZ1bmN0aW9uIChIb3ZlclZlcmJvc2l0eUFjdGlvbikge1xuICAgIC8qKlxuICAgICAqIEluY3JlYXNlIHRoZSB2ZXJib3NpdHkgb2YgdGhlIGhvdmVyXG4gICAgICovXG4gICAgSG92ZXJWZXJib3NpdHlBY3Rpb25bSG92ZXJWZXJib3NpdHlBY3Rpb25bXCJJbmNyZWFzZVwiXSA9IDBdID0gXCJJbmNyZWFzZVwiO1xuICAgIC8qKlxuICAgICAqIERlY3JlYXNlIHRoZSB2ZXJib3NpdHkgb2YgdGhlIGhvdmVyXG4gICAgICovXG4gICAgSG92ZXJWZXJib3NpdHlBY3Rpb25bSG92ZXJWZXJib3NpdHlBY3Rpb25bXCJEZWNyZWFzZVwiXSA9IDFdID0gXCJEZWNyZWFzZVwiO1xufSkoSG92ZXJWZXJib3NpdHlBY3Rpb24gfHwgKEhvdmVyVmVyYm9zaXR5QWN0aW9uID0ge30pKTtcbi8qKlxuICogRGVzY3JpYmVzIHdoYXQgdG8gZG8gd2l0aCB0aGUgaW5kZW50YXRpb24gd2hlbiBwcmVzc2luZyBFbnRlci5cbiAqL1xuZXhwb3J0IHZhciBJbmRlbnRBY3Rpb247XG4oZnVuY3Rpb24gKEluZGVudEFjdGlvbikge1xuICAgIC8qKlxuICAgICAqIEluc2VydCBuZXcgbGluZSBhbmQgY29weSB0aGUgcHJldmlvdXMgbGluZSdzIGluZGVudGF0aW9uLlxuICAgICAqL1xuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgbmV3IGxpbmUgYW5kIGluZGVudCBvbmNlIChyZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgbGluZSdzIGluZGVudGF0aW9uKS5cbiAgICAgKi9cbiAgICBJbmRlbnRBY3Rpb25bSW5kZW50QWN0aW9uW1wiSW5kZW50XCJdID0gMV0gPSBcIkluZGVudFwiO1xuICAgIC8qKlxuICAgICAqIEluc2VydCB0d28gbmV3IGxpbmVzOlxuICAgICAqICAtIHRoZSBmaXJzdCBvbmUgaW5kZW50ZWQgd2hpY2ggd2lsbCBob2xkIHRoZSBjdXJzb3JcbiAgICAgKiAgLSB0aGUgc2Vjb25kIG9uZSBhdCB0aGUgc2FtZSBpbmRlbnRhdGlvbiBsZXZlbFxuICAgICAqL1xuICAgIEluZGVudEFjdGlvbltJbmRlbnRBY3Rpb25bXCJJbmRlbnRPdXRkZW50XCJdID0gMl0gPSBcIkluZGVudE91dGRlbnRcIjtcbiAgICAvKipcbiAgICAgKiBJbnNlcnQgbmV3IGxpbmUgYW5kIG91dGRlbnQgb25jZSAocmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIGxpbmUncyBpbmRlbnRhdGlvbikuXG4gICAgICovXG4gICAgSW5kZW50QWN0aW9uW0luZGVudEFjdGlvbltcIk91dGRlbnRcIl0gPSAzXSA9IFwiT3V0ZGVudFwiO1xufSkoSW5kZW50QWN0aW9uIHx8IChJbmRlbnRBY3Rpb24gPSB7fSkpO1xuZXhwb3J0IHZhciBJbmplY3RlZFRleHRDdXJzb3JTdG9wcztcbihmdW5jdGlvbiAoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMpIHtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIkJvdGhcIl0gPSAwXSA9IFwiQm90aFwiO1xuICAgIEluamVjdGVkVGV4dEN1cnNvclN0b3BzW0luamVjdGVkVGV4dEN1cnNvclN0b3BzW1wiUmlnaHRcIl0gPSAxXSA9IFwiUmlnaHRcIjtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIkxlZnRcIl0gPSAyXSA9IFwiTGVmdFwiO1xuICAgIEluamVjdGVkVGV4dEN1cnNvclN0b3BzW0luamVjdGVkVGV4dEN1cnNvclN0b3BzW1wiTm9uZVwiXSA9IDNdID0gXCJOb25lXCI7XG59KShJbmplY3RlZFRleHRDdXJzb3JTdG9wcyB8fCAoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMgPSB7fSkpO1xuZXhwb3J0IHZhciBJbmxheUhpbnRLaW5kO1xuKGZ1bmN0aW9uIChJbmxheUhpbnRLaW5kKSB7XG4gICAgSW5sYXlIaW50S2luZFtJbmxheUhpbnRLaW5kW1wiVHlwZVwiXSA9IDFdID0gXCJUeXBlXCI7XG4gICAgSW5sYXlIaW50S2luZFtJbmxheUhpbnRLaW5kW1wiUGFyYW1ldGVyXCJdID0gMl0gPSBcIlBhcmFtZXRlclwiO1xufSkoSW5sYXlIaW50S2luZCB8fCAoSW5sYXlIaW50S2luZCA9IHt9KSk7XG4vKipcbiAqIEhvdyBhbiB7QGxpbmsgSW5saW5lQ29tcGxldGlvbnNQcm92aWRlciBpbmxpbmUgY29tcGxldGlvbiBwcm92aWRlcn0gd2FzIHRyaWdnZXJlZC5cbiAqL1xuZXhwb3J0IHZhciBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBhdXRvbWF0aWNhbGx5IHdoaWxlIGVkaXRpbmcuXG4gICAgICogSXQgaXMgc3VmZmljaWVudCB0byByZXR1cm4gYSBzaW5nbGUgY29tcGxldGlvbiBpdGVtIGluIHRoaXMgY2FzZS5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmRbSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW1wiQXV0b21hdGljXCJdID0gMF0gPSBcIkF1dG9tYXRpY1wiO1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBleHBsaWNpdGx5IGJ5IGEgdXNlciBnZXN0dXJlLlxuICAgICAqIFJldHVybiBtdWx0aXBsZSBjb21wbGV0aW9uIGl0ZW1zIHRvIGVuYWJsZSBjeWNsaW5nIHRocm91Z2ggdGhlbS5cbiAgICAgKi9cbiAgICBJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmRbSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kW1wiRXhwbGljaXRcIl0gPSAxXSA9IFwiRXhwbGljaXRcIjtcbn0pKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCB8fCAoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kID0ge30pKTtcbmV4cG9ydCB2YXIgSW5saW5lRWRpdFRyaWdnZXJLaW5kO1xuKGZ1bmN0aW9uIChJbmxpbmVFZGl0VHJpZ2dlcktpbmQpIHtcbiAgICBJbmxpbmVFZGl0VHJpZ2dlcktpbmRbSW5saW5lRWRpdFRyaWdnZXJLaW5kW1wiSW52b2tlXCJdID0gMF0gPSBcIkludm9rZVwiO1xuICAgIElubGluZUVkaXRUcmlnZ2VyS2luZFtJbmxpbmVFZGl0VHJpZ2dlcktpbmRbXCJBdXRvbWF0aWNcIl0gPSAxXSA9IFwiQXV0b21hdGljXCI7XG59KShJbmxpbmVFZGl0VHJpZ2dlcktpbmQgfHwgKElubGluZUVkaXRUcmlnZ2VyS2luZCA9IHt9KSk7XG4vKipcbiAqIFZpcnR1YWwgS2V5IENvZGVzLCB0aGUgdmFsdWUgZG9lcyBub3QgaG9sZCBhbnkgaW5oZXJlbnQgbWVhbmluZy5cbiAqIEluc3BpcmVkIHNvbWV3aGF0IGZyb20gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvZGQzNzU3MzEodj12cy44NSkuYXNweFxuICogQnV0IHRoZXNlIGFyZSBcIm1vcmUgZ2VuZXJhbFwiLCBhcyB0aGV5IHNob3VsZCB3b3JrIGFjcm9zcyBicm93c2VycyAmIE9TYHMuXG4gKi9cbmV4cG9ydCB2YXIgS2V5Q29kZTtcbihmdW5jdGlvbiAoS2V5Q29kZSkge1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRlcGVuZHNPbktiTGF5b3V0XCJdID0gLTFdID0gXCJEZXBlbmRzT25LYkxheW91dFwiO1xuICAgIC8qKlxuICAgICAqIFBsYWNlZCBmaXJzdCB0byBjb3ZlciB0aGUgMCB2YWx1ZSBvZiB0aGUgZW51bS5cbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJVbmtub3duXCJdID0gMF0gPSBcIlVua25vd25cIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCYWNrc3BhY2VcIl0gPSAxXSA9IFwiQmFja3NwYWNlXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiVGFiXCJdID0gMl0gPSBcIlRhYlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkVudGVyXCJdID0gM10gPSBcIkVudGVyXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU2hpZnRcIl0gPSA0XSA9IFwiU2hpZnRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJDdHJsXCJdID0gNV0gPSBcIkN0cmxcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBbHRcIl0gPSA2XSA9IFwiQWx0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUGF1c2VCcmVha1wiXSA9IDddID0gXCJQYXVzZUJyZWFrXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQ2Fwc0xvY2tcIl0gPSA4XSA9IFwiQ2Fwc0xvY2tcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJFc2NhcGVcIl0gPSA5XSA9IFwiRXNjYXBlXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU3BhY2VcIl0gPSAxMF0gPSBcIlNwYWNlXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiUGFnZVVwXCJdID0gMTFdID0gXCJQYWdlVXBcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJQYWdlRG93blwiXSA9IDEyXSA9IFwiUGFnZURvd25cIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJFbmRcIl0gPSAxM10gPSBcIkVuZFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkhvbWVcIl0gPSAxNF0gPSBcIkhvbWVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJMZWZ0QXJyb3dcIl0gPSAxNV0gPSBcIkxlZnRBcnJvd1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlVwQXJyb3dcIl0gPSAxNl0gPSBcIlVwQXJyb3dcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJSaWdodEFycm93XCJdID0gMTddID0gXCJSaWdodEFycm93XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRG93bkFycm93XCJdID0gMThdID0gXCJEb3duQXJyb3dcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJJbnNlcnRcIl0gPSAxOV0gPSBcIkluc2VydFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRlbGV0ZVwiXSA9IDIwXSA9IFwiRGVsZXRlXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQwXCJdID0gMjFdID0gXCJEaWdpdDBcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDFcIl0gPSAyMl0gPSBcIkRpZ2l0MVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0MlwiXSA9IDIzXSA9IFwiRGlnaXQyXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQzXCJdID0gMjRdID0gXCJEaWdpdDNcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDRcIl0gPSAyNV0gPSBcIkRpZ2l0NFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0NVwiXSA9IDI2XSA9IFwiRGlnaXQ1XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQ2XCJdID0gMjddID0gXCJEaWdpdDZcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJEaWdpdDdcIl0gPSAyOF0gPSBcIkRpZ2l0N1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkRpZ2l0OFwiXSA9IDI5XSA9IFwiRGlnaXQ4XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRGlnaXQ5XCJdID0gMzBdID0gXCJEaWdpdDlcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlBXCJdID0gMzFdID0gXCJLZXlBXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5QlwiXSA9IDMyXSA9IFwiS2V5QlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUNcIl0gPSAzM10gPSBcIktleUNcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlEXCJdID0gMzRdID0gXCJLZXlEXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5RVwiXSA9IDM1XSA9IFwiS2V5RVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUZcIl0gPSAzNl0gPSBcIktleUZcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlHXCJdID0gMzddID0gXCJLZXlHXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5SFwiXSA9IDM4XSA9IFwiS2V5SFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUlcIl0gPSAzOV0gPSBcIktleUlcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlKXCJdID0gNDBdID0gXCJLZXlKXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5S1wiXSA9IDQxXSA9IFwiS2V5S1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleUxcIl0gPSA0Ml0gPSBcIktleUxcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlNXCJdID0gNDNdID0gXCJLZXlNXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5TlwiXSA9IDQ0XSA9IFwiS2V5TlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleU9cIl0gPSA0NV0gPSBcIktleU9cIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlQXCJdID0gNDZdID0gXCJLZXlQXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5UVwiXSA9IDQ3XSA9IFwiS2V5UVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVJcIl0gPSA0OF0gPSBcIktleVJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlTXCJdID0gNDldID0gXCJLZXlTXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5VFwiXSA9IDUwXSA9IFwiS2V5VFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVVcIl0gPSA1MV0gPSBcIktleVVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlWXCJdID0gNTJdID0gXCJLZXlWXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5V1wiXSA9IDUzXSA9IFwiS2V5V1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIktleVhcIl0gPSA1NF0gPSBcIktleVhcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLZXlZXCJdID0gNTVdID0gXCJLZXlZXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiS2V5WlwiXSA9IDU2XSA9IFwiS2V5WlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk1ldGFcIl0gPSA1N10gPSBcIk1ldGFcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJDb250ZXh0TWVudVwiXSA9IDU4XSA9IFwiQ29udGV4dE1lbnVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMVwiXSA9IDU5XSA9IFwiRjFcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMlwiXSA9IDYwXSA9IFwiRjJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGM1wiXSA9IDYxXSA9IFwiRjNcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGNFwiXSA9IDYyXSA9IFwiRjRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGNVwiXSA9IDYzXSA9IFwiRjVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGNlwiXSA9IDY0XSA9IFwiRjZcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGN1wiXSA9IDY1XSA9IFwiRjdcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGOFwiXSA9IDY2XSA9IFwiRjhcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGOVwiXSA9IDY3XSA9IFwiRjlcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTBcIl0gPSA2OF0gPSBcIkYxMFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxMVwiXSA9IDY5XSA9IFwiRjExXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjEyXCJdID0gNzBdID0gXCJGMTJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTNcIl0gPSA3MV0gPSBcIkYxM1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxNFwiXSA9IDcyXSA9IFwiRjE0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE1XCJdID0gNzNdID0gXCJGMTVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTZcIl0gPSA3NF0gPSBcIkYxNlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYxN1wiXSA9IDc1XSA9IFwiRjE3XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjE4XCJdID0gNzZdID0gXCJGMThcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMTlcIl0gPSA3N10gPSBcIkYxOVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYyMFwiXSA9IDc4XSA9IFwiRjIwXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjIxXCJdID0gNzldID0gXCJGMjFcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJGMjJcIl0gPSA4MF0gPSBcIkYyMlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkYyM1wiXSA9IDgxXSA9IFwiRjIzXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiRjI0XCJdID0gODJdID0gXCJGMjRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1Mb2NrXCJdID0gODNdID0gXCJOdW1Mb2NrXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU2Nyb2xsTG9ja1wiXSA9IDg0XSA9IFwiU2Nyb2xsTG9ja1wiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICc7Oicga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiU2VtaWNvbG9uXCJdID0gODVdID0gXCJTZW1pY29sb25cIjtcbiAgICAvKipcbiAgICAgKiBGb3IgYW55IGNvdW50cnkvcmVnaW9uLCB0aGUgJysnIGtleVxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnPSsnIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkVxdWFsXCJdID0gODZdID0gXCJFcXVhbFwiO1xuICAgIC8qKlxuICAgICAqIEZvciBhbnkgY291bnRyeS9yZWdpb24sIHRoZSAnLCcga2V5XG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICcsPCcga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQ29tbWFcIl0gPSA4N10gPSBcIkNvbW1hXCI7XG4gICAgLyoqXG4gICAgICogRm9yIGFueSBjb3VudHJ5L3JlZ2lvbiwgdGhlICctJyBrZXlcbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJy1fJyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJNaW51c1wiXSA9IDg4XSA9IFwiTWludXNcIjtcbiAgICAvKipcbiAgICAgKiBGb3IgYW55IGNvdW50cnkvcmVnaW9uLCB0aGUgJy4nIGtleVxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnLj4nIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIlBlcmlvZFwiXSA9IDg5XSA9IFwiUGVyaW9kXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJy8/JyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJTbGFzaFwiXSA9IDkwXSA9IFwiU2xhc2hcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnYH4nIGtleVxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkJhY2txdW90ZVwiXSA9IDkxXSA9IFwiQmFja3F1b3RlXCI7XG4gICAgLyoqXG4gICAgICogVXNlZCBmb3IgbWlzY2VsbGFuZW91cyBjaGFyYWN0ZXJzOyBpdCBjYW4gdmFyeSBieSBrZXlib2FyZC5cbiAgICAgKiBGb3IgdGhlIFVTIHN0YW5kYXJkIGtleWJvYXJkLCB0aGUgJ1t7JyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCcmFja2V0TGVmdFwiXSA9IDkyXSA9IFwiQnJhY2tldExlZnRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnXFx8JyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCYWNrc2xhc2hcIl0gPSA5M10gPSBcIkJhY2tzbGFzaFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIG1pc2NlbGxhbmVvdXMgY2hhcmFjdGVyczsgaXQgY2FuIHZhcnkgYnkga2V5Ym9hcmQuXG4gICAgICogRm9yIHRoZSBVUyBzdGFuZGFyZCBrZXlib2FyZCwgdGhlICddfScga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJhY2tldFJpZ2h0XCJdID0gOTRdID0gXCJCcmFja2V0UmlnaHRcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqIEZvciB0aGUgVVMgc3RhbmRhcmQga2V5Ym9hcmQsIHRoZSAnJ1wiJyBrZXlcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJRdW90ZVwiXSA9IDk1XSA9IFwiUXVvdGVcIjtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBtaXNjZWxsYW5lb3VzIGNoYXJhY3RlcnM7IGl0IGNhbiB2YXJ5IGJ5IGtleWJvYXJkLlxuICAgICAqL1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk9FTV84XCJdID0gOTZdID0gXCJPRU1fOFwiO1xuICAgIC8qKlxuICAgICAqIEVpdGhlciB0aGUgYW5nbGUgYnJhY2tldCBrZXkgb3IgdGhlIGJhY2tzbGFzaCBrZXkgb24gdGhlIFJUIDEwMi1rZXkga2V5Ym9hcmQuXG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiSW50bEJhY2tzbGFzaFwiXSA9IDk3XSA9IFwiSW50bEJhY2tzbGFzaFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDBcIl0gPSA5OF0gPSBcIk51bXBhZDBcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQxXCJdID0gOTldID0gXCJOdW1wYWQxXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkMlwiXSA9IDEwMF0gPSBcIk51bXBhZDJcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQzXCJdID0gMTAxXSA9IFwiTnVtcGFkM1wiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDRcIl0gPSAxMDJdID0gXCJOdW1wYWQ0XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkNVwiXSA9IDEwM10gPSBcIk51bXBhZDVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQ2XCJdID0gMTA0XSA9IFwiTnVtcGFkNlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZDdcIl0gPSAxMDVdID0gXCJOdW1wYWQ3XCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTnVtcGFkOFwiXSA9IDEwNl0gPSBcIk51bXBhZDhcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWQ5XCJdID0gMTA3XSA9IFwiTnVtcGFkOVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZE11bHRpcGx5XCJdID0gMTA4XSA9IFwiTnVtcGFkTXVsdGlwbHlcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWRBZGRcIl0gPSAxMDldID0gXCJOdW1wYWRBZGRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOVU1QQURfU0VQQVJBVE9SXCJdID0gMTEwXSA9IFwiTlVNUEFEX1NFUEFSQVRPUlwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZFN1YnRyYWN0XCJdID0gMTExXSA9IFwiTnVtcGFkU3VidHJhY3RcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJOdW1wYWREZWNpbWFsXCJdID0gMTEyXSA9IFwiTnVtcGFkRGVjaW1hbFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk51bXBhZERpdmlkZVwiXSA9IDExM10gPSBcIk51bXBhZERpdmlkZVwiO1xuICAgIC8qKlxuICAgICAqIENvdmVyIGFsbCBrZXkgY29kZXMgd2hlbiBJTUUgaXMgcHJvY2Vzc2luZyBpbnB1dC5cbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJLRVlfSU5fQ09NUE9TSVRJT05cIl0gPSAxMTRdID0gXCJLRVlfSU5fQ09NUE9TSVRJT05cIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBQk5UX0MxXCJdID0gMTE1XSA9IFwiQUJOVF9DMVwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkFCTlRfQzJcIl0gPSAxMTZdID0gXCJBQk5UX0MyXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQXVkaW9Wb2x1bWVNdXRlXCJdID0gMTE3XSA9IFwiQXVkaW9Wb2x1bWVNdXRlXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQXVkaW9Wb2x1bWVVcFwiXSA9IDExOF0gPSBcIkF1ZGlvVm9sdW1lVXBcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJBdWRpb1ZvbHVtZURvd25cIl0gPSAxMTldID0gXCJBdWRpb1ZvbHVtZURvd25cIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCcm93c2VyU2VhcmNoXCJdID0gMTIwXSA9IFwiQnJvd3NlclNlYXJjaFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkJyb3dzZXJIb21lXCJdID0gMTIxXSA9IFwiQnJvd3NlckhvbWVcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJCcm93c2VyQmFja1wiXSA9IDEyMl0gPSBcIkJyb3dzZXJCYWNrXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQnJvd3NlckZvcndhcmRcIl0gPSAxMjNdID0gXCJCcm93c2VyRm9yd2FyZFwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIk1lZGlhVHJhY2tOZXh0XCJdID0gMTI0XSA9IFwiTWVkaWFUcmFja05leHRcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJNZWRpYVRyYWNrUHJldmlvdXNcIl0gPSAxMjVdID0gXCJNZWRpYVRyYWNrUHJldmlvdXNcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJNZWRpYVN0b3BcIl0gPSAxMjZdID0gXCJNZWRpYVN0b3BcIjtcbiAgICBLZXlDb2RlW0tleUNvZGVbXCJNZWRpYVBsYXlQYXVzZVwiXSA9IDEyN10gPSBcIk1lZGlhUGxheVBhdXNlXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTGF1bmNoTWVkaWFQbGF5ZXJcIl0gPSAxMjhdID0gXCJMYXVuY2hNZWRpYVBsYXllclwiO1xuICAgIEtleUNvZGVbS2V5Q29kZVtcIkxhdW5jaE1haWxcIl0gPSAxMjldID0gXCJMYXVuY2hNYWlsXCI7XG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiTGF1bmNoQXBwMlwiXSA9IDEzMF0gPSBcIkxhdW5jaEFwcDJcIjtcbiAgICAvKipcbiAgICAgKiBWS19DTEVBUiwgMHgwQywgQ0xFQVIga2V5XG4gICAgICovXG4gICAgS2V5Q29kZVtLZXlDb2RlW1wiQ2xlYXJcIl0gPSAxMzFdID0gXCJDbGVhclwiO1xuICAgIC8qKlxuICAgICAqIFBsYWNlZCBsYXN0IHRvIGNvdmVyIHRoZSBsZW5ndGggb2YgdGhlIGVudW0uXG4gICAgICogUGxlYXNlIGRvIG5vdCBkZXBlbmQgb24gdGhpcyB2YWx1ZSFcbiAgICAgKi9cbiAgICBLZXlDb2RlW0tleUNvZGVbXCJNQVhfVkFMVUVcIl0gPSAxMzJdID0gXCJNQVhfVkFMVUVcIjtcbn0pKEtleUNvZGUgfHwgKEtleUNvZGUgPSB7fSkpO1xuZXhwb3J0IHZhciBNYXJrZXJTZXZlcml0eTtcbihmdW5jdGlvbiAoTWFya2VyU2V2ZXJpdHkpIHtcbiAgICBNYXJrZXJTZXZlcml0eVtNYXJrZXJTZXZlcml0eVtcIkhpbnRcIl0gPSAxXSA9IFwiSGludFwiO1xuICAgIE1hcmtlclNldmVyaXR5W01hcmtlclNldmVyaXR5W1wiSW5mb1wiXSA9IDJdID0gXCJJbmZvXCI7XG4gICAgTWFya2VyU2V2ZXJpdHlbTWFya2VyU2V2ZXJpdHlbXCJXYXJuaW5nXCJdID0gNF0gPSBcIldhcm5pbmdcIjtcbiAgICBNYXJrZXJTZXZlcml0eVtNYXJrZXJTZXZlcml0eVtcIkVycm9yXCJdID0gOF0gPSBcIkVycm9yXCI7XG59KShNYXJrZXJTZXZlcml0eSB8fCAoTWFya2VyU2V2ZXJpdHkgPSB7fSkpO1xuZXhwb3J0IHZhciBNYXJrZXJUYWc7XG4oZnVuY3Rpb24gKE1hcmtlclRhZykge1xuICAgIE1hcmtlclRhZ1tNYXJrZXJUYWdbXCJVbm5lY2Vzc2FyeVwiXSA9IDFdID0gXCJVbm5lY2Vzc2FyeVwiO1xuICAgIE1hcmtlclRhZ1tNYXJrZXJUYWdbXCJEZXByZWNhdGVkXCJdID0gMl0gPSBcIkRlcHJlY2F0ZWRcIjtcbn0pKE1hcmtlclRhZyB8fCAoTWFya2VyVGFnID0ge30pKTtcbi8qKlxuICogUG9zaXRpb24gaW4gdGhlIG1pbmltYXAgdG8gcmVuZGVyIHRoZSBkZWNvcmF0aW9uLlxuICovXG5leHBvcnQgdmFyIE1pbmltYXBQb3NpdGlvbjtcbihmdW5jdGlvbiAoTWluaW1hcFBvc2l0aW9uKSB7XG4gICAgTWluaW1hcFBvc2l0aW9uW01pbmltYXBQb3NpdGlvbltcIklubGluZVwiXSA9IDFdID0gXCJJbmxpbmVcIjtcbiAgICBNaW5pbWFwUG9zaXRpb25bTWluaW1hcFBvc2l0aW9uW1wiR3V0dGVyXCJdID0gMl0gPSBcIkd1dHRlclwiO1xufSkoTWluaW1hcFBvc2l0aW9uIHx8IChNaW5pbWFwUG9zaXRpb24gPSB7fSkpO1xuLyoqXG4gKiBTZWN0aW9uIGhlYWRlciBzdHlsZS5cbiAqL1xuZXhwb3J0IHZhciBNaW5pbWFwU2VjdGlvbkhlYWRlclN0eWxlO1xuKGZ1bmN0aW9uIChNaW5pbWFwU2VjdGlvbkhlYWRlclN0eWxlKSB7XG4gICAgTWluaW1hcFNlY3Rpb25IZWFkZXJTdHlsZVtNaW5pbWFwU2VjdGlvbkhlYWRlclN0eWxlW1wiTm9ybWFsXCJdID0gMV0gPSBcIk5vcm1hbFwiO1xuICAgIE1pbmltYXBTZWN0aW9uSGVhZGVyU3R5bGVbTWluaW1hcFNlY3Rpb25IZWFkZXJTdHlsZVtcIlVuZGVybGluZWRcIl0gPSAyXSA9IFwiVW5kZXJsaW5lZFwiO1xufSkoTWluaW1hcFNlY3Rpb25IZWFkZXJTdHlsZSB8fCAoTWluaW1hcFNlY3Rpb25IZWFkZXJTdHlsZSA9IHt9KSk7XG4vKipcbiAqIFR5cGUgb2YgaGl0IGVsZW1lbnQgd2l0aCB0aGUgbW91c2UgaW4gdGhlIGVkaXRvci5cbiAqL1xuZXhwb3J0IHZhciBNb3VzZVRhcmdldFR5cGU7XG4oZnVuY3Rpb24gKE1vdXNlVGFyZ2V0VHlwZSkge1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIlVOS05PV05cIl0gPSAwXSA9IFwiVU5LTk9XTlwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgdGV4dGFyZWEgdXNlZCBmb3IgaW5wdXQuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIlRFWFRBUkVBXCJdID0gMV0gPSBcIlRFWFRBUkVBXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSBnbHlwaCBtYXJnaW5cbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX0dMWVBIX01BUkdJTlwiXSA9IDJdID0gXCJHVVRURVJfR0xZUEhfTUFSR0lOXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSBsaW5lIG51bWJlcnNcbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX0xJTkVfTlVNQkVSU1wiXSA9IDNdID0gXCJHVVRURVJfTElORV9OVU1CRVJTXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSBsaW5lIGRlY29yYXRpb25zXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkdVVFRFUl9MSU5FX0RFQ09SQVRJT05TXCJdID0gNF0gPSBcIkdVVFRFUl9MSU5FX0RFQ09SQVRJT05TXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRoZSB3aGl0ZXNwYWNlIGxlZnQgaW4gdGhlIGd1dHRlciBieSBhIHZpZXcgem9uZS5cbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiR1VUVEVSX1ZJRVdfWk9ORVwiXSA9IDVdID0gXCJHVVRURVJfVklFV19aT05FXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIHRleHQgaW4gdGhlIGNvbnRlbnQuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIkNPTlRFTlRfVEVYVFwiXSA9IDZdID0gXCJDT05URU5UX1RFWFRcIjtcbiAgICAvKipcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgZW1wdHkgc3BhY2UgaW4gdGhlIGNvbnRlbnQgKGUuZy4gYWZ0ZXIgbGluZSB0ZXh0IG9yIGJlbG93IGxhc3QgbGluZSlcbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiQ09OVEVOVF9FTVBUWVwiXSA9IDddID0gXCJDT05URU5UX0VNUFRZXCI7XG4gICAgLyoqXG4gICAgICogTW91c2UgaXMgb24gdG9wIG9mIGEgdmlldyB6b25lIGluIHRoZSBjb250ZW50LlxuICAgICAqL1xuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJDT05URU5UX1ZJRVdfWk9ORVwiXSA9IDhdID0gXCJDT05URU5UX1ZJRVdfWk9ORVwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhIGNvbnRlbnQgd2lkZ2V0LlxuICAgICAqL1xuICAgIE1vdXNlVGFyZ2V0VHlwZVtNb3VzZVRhcmdldFR5cGVbXCJDT05URU5UX1dJREdFVFwiXSA9IDldID0gXCJDT05URU5UX1dJREdFVFwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiB0aGUgZGVjb3JhdGlvbnMgb3ZlcnZpZXcgcnVsZXIuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIk9WRVJWSUVXX1JVTEVSXCJdID0gMTBdID0gXCJPVkVSVklFV19SVUxFUlwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG9uIHRvcCBvZiBhIHNjcm9sbGJhci5cbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiU0NST0xMQkFSXCJdID0gMTFdID0gXCJTQ1JPTExCQVJcIjtcbiAgICAvKipcbiAgICAgKiBNb3VzZSBpcyBvbiB0b3Agb2YgYW4gb3ZlcmxheSB3aWRnZXQuXG4gICAgICovXG4gICAgTW91c2VUYXJnZXRUeXBlW01vdXNlVGFyZ2V0VHlwZVtcIk9WRVJMQVlfV0lER0VUXCJdID0gMTJdID0gXCJPVkVSTEFZX1dJREdFVFwiO1xuICAgIC8qKlxuICAgICAqIE1vdXNlIGlzIG91dHNpZGUgb2YgdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICBNb3VzZVRhcmdldFR5cGVbTW91c2VUYXJnZXRUeXBlW1wiT1VUU0lERV9FRElUT1JcIl0gPSAxM10gPSBcIk9VVFNJREVfRURJVE9SXCI7XG59KShNb3VzZVRhcmdldFR5cGUgfHwgKE1vdXNlVGFyZ2V0VHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIE5ld1N5bWJvbE5hbWVUYWc7XG4oZnVuY3Rpb24gKE5ld1N5bWJvbE5hbWVUYWcpIHtcbiAgICBOZXdTeW1ib2xOYW1lVGFnW05ld1N5bWJvbE5hbWVUYWdbXCJBSUdlbmVyYXRlZFwiXSA9IDFdID0gXCJBSUdlbmVyYXRlZFwiO1xufSkoTmV3U3ltYm9sTmFtZVRhZyB8fCAoTmV3U3ltYm9sTmFtZVRhZyA9IHt9KSk7XG5leHBvcnQgdmFyIE5ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kKSB7XG4gICAgTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kW05ld1N5bWJvbE5hbWVUcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDBdID0gXCJJbnZva2VcIjtcbiAgICBOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmRbTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kW1wiQXV0b21hdGljXCJdID0gMV0gPSBcIkF1dG9tYXRpY1wiO1xufSkoTmV3U3ltYm9sTmFtZVRyaWdnZXJLaW5kIHx8IChOZXdTeW1ib2xOYW1lVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBBIHBvc2l0aW9uaW5nIHByZWZlcmVuY2UgZm9yIHJlbmRlcmluZyBvdmVybGF5IHdpZGdldHMuXG4gKi9cbmV4cG9ydCB2YXIgT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZTtcbihmdW5jdGlvbiAoT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSkge1xuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBvdmVybGF5IHdpZGdldCBpbiB0aGUgdG9wIHJpZ2h0IGNvcm5lclxuICAgICAqL1xuICAgIE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtcIlRPUF9SSUdIVF9DT1JORVJcIl0gPSAwXSA9IFwiVE9QX1JJR0hUX0NPUk5FUlwiO1xuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBvdmVybGF5IHdpZGdldCBpbiB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lclxuICAgICAqL1xuICAgIE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtcIkJPVFRPTV9SSUdIVF9DT1JORVJcIl0gPSAxXSA9IFwiQk9UVE9NX1JJR0hUX0NPUk5FUlwiO1xuICAgIC8qKlxuICAgICAqIFBvc2l0aW9uIHRoZSBvdmVybGF5IHdpZGdldCBpbiB0aGUgdG9wIGNlbnRlclxuICAgICAqL1xuICAgIE92ZXJsYXlXaWRnZXRQb3NpdGlvblByZWZlcmVuY2VbT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZVtcIlRPUF9DRU5URVJcIl0gPSAyXSA9IFwiVE9QX0NFTlRFUlwiO1xufSkoT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSB8fCAoT3ZlcmxheVdpZGdldFBvc2l0aW9uUHJlZmVyZW5jZSA9IHt9KSk7XG4vKipcbiAqIFZlcnRpY2FsIExhbmUgaW4gdGhlIG92ZXJ2aWV3IHJ1bGVyIG9mIHRoZSBlZGl0b3IuXG4gKi9cbmV4cG9ydCB2YXIgT3ZlcnZpZXdSdWxlckxhbmU7XG4oZnVuY3Rpb24gKE92ZXJ2aWV3UnVsZXJMYW5lKSB7XG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJMZWZ0XCJdID0gMV0gPSBcIkxlZnRcIjtcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkNlbnRlclwiXSA9IDJdID0gXCJDZW50ZXJcIjtcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIlJpZ2h0XCJdID0gNF0gPSBcIlJpZ2h0XCI7XG4gICAgT3ZlcnZpZXdSdWxlckxhbmVbT3ZlcnZpZXdSdWxlckxhbmVbXCJGdWxsXCJdID0gN10gPSBcIkZ1bGxcIjtcbn0pKE92ZXJ2aWV3UnVsZXJMYW5lIHx8IChPdmVydmlld1J1bGVyTGFuZSA9IHt9KSk7XG4vKipcbiAqIEhvdyBhIHBhcnRpYWwgYWNjZXB0YW5jZSB3YXMgdHJpZ2dlcmVkLlxuICovXG5leHBvcnQgdmFyIFBhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoUGFydGlhbEFjY2VwdFRyaWdnZXJLaW5kKSB7XG4gICAgUGFydGlhbEFjY2VwdFRyaWdnZXJLaW5kW1BhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZFtcIldvcmRcIl0gPSAwXSA9IFwiV29yZFwiO1xuICAgIFBhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZFtQYXJ0aWFsQWNjZXB0VHJpZ2dlcktpbmRbXCJMaW5lXCJdID0gMV0gPSBcIkxpbmVcIjtcbiAgICBQYXJ0aWFsQWNjZXB0VHJpZ2dlcktpbmRbUGFydGlhbEFjY2VwdFRyaWdnZXJLaW5kW1wiU3VnZ2VzdFwiXSA9IDJdID0gXCJTdWdnZXN0XCI7XG59KShQYXJ0aWFsQWNjZXB0VHJpZ2dlcktpbmQgfHwgKFBhcnRpYWxBY2NlcHRUcmlnZ2VyS2luZCA9IHt9KSk7XG5leHBvcnQgdmFyIFBvc2l0aW9uQWZmaW5pdHk7XG4oZnVuY3Rpb24gKFBvc2l0aW9uQWZmaW5pdHkpIHtcbiAgICAvKipcbiAgICAgKiBQcmVmZXJzIHRoZSBsZWZ0IG1vc3QgcG9zaXRpb24uXG4gICAgKi9cbiAgICBQb3NpdGlvbkFmZmluaXR5W1Bvc2l0aW9uQWZmaW5pdHlbXCJMZWZ0XCJdID0gMF0gPSBcIkxlZnRcIjtcbiAgICAvKipcbiAgICAgKiBQcmVmZXJzIHRoZSByaWdodCBtb3N0IHBvc2l0aW9uLlxuICAgICovXG4gICAgUG9zaXRpb25BZmZpbml0eVtQb3NpdGlvbkFmZmluaXR5W1wiUmlnaHRcIl0gPSAxXSA9IFwiUmlnaHRcIjtcbiAgICAvKipcbiAgICAgKiBObyBwcmVmZXJlbmNlLlxuICAgICovXG4gICAgUG9zaXRpb25BZmZpbml0eVtQb3NpdGlvbkFmZmluaXR5W1wiTm9uZVwiXSA9IDJdID0gXCJOb25lXCI7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIG9uIGluamVjdGVkIHRleHQsIHByZWZlcnMgdGhlIHBvc2l0aW9uIGxlZnQgb2YgaXQuXG4gICAgKi9cbiAgICBQb3NpdGlvbkFmZmluaXR5W1Bvc2l0aW9uQWZmaW5pdHlbXCJMZWZ0T2ZJbmplY3RlZFRleHRcIl0gPSAzXSA9IFwiTGVmdE9mSW5qZWN0ZWRUZXh0XCI7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGdpdmVuIHBvc2l0aW9uIGlzIG9uIGluamVjdGVkIHRleHQsIHByZWZlcnMgdGhlIHBvc2l0aW9uIHJpZ2h0IG9mIGl0LlxuICAgICovXG4gICAgUG9zaXRpb25BZmZpbml0eVtQb3NpdGlvbkFmZmluaXR5W1wiUmlnaHRPZkluamVjdGVkVGV4dFwiXSA9IDRdID0gXCJSaWdodE9mSW5qZWN0ZWRUZXh0XCI7XG59KShQb3NpdGlvbkFmZmluaXR5IHx8IChQb3NpdGlvbkFmZmluaXR5ID0ge30pKTtcbmV4cG9ydCB2YXIgUmVuZGVyTGluZU51bWJlcnNUeXBlO1xuKGZ1bmN0aW9uIChSZW5kZXJMaW5lTnVtYmVyc1R5cGUpIHtcbiAgICBSZW5kZXJMaW5lTnVtYmVyc1R5cGVbUmVuZGVyTGluZU51bWJlcnNUeXBlW1wiT2ZmXCJdID0gMF0gPSBcIk9mZlwiO1xuICAgIFJlbmRlckxpbmVOdW1iZXJzVHlwZVtSZW5kZXJMaW5lTnVtYmVyc1R5cGVbXCJPblwiXSA9IDFdID0gXCJPblwiO1xuICAgIFJlbmRlckxpbmVOdW1iZXJzVHlwZVtSZW5kZXJMaW5lTnVtYmVyc1R5cGVbXCJSZWxhdGl2ZVwiXSA9IDJdID0gXCJSZWxhdGl2ZVwiO1xuICAgIFJlbmRlckxpbmVOdW1iZXJzVHlwZVtSZW5kZXJMaW5lTnVtYmVyc1R5cGVbXCJJbnRlcnZhbFwiXSA9IDNdID0gXCJJbnRlcnZhbFwiO1xuICAgIFJlbmRlckxpbmVOdW1iZXJzVHlwZVtSZW5kZXJMaW5lTnVtYmVyc1R5cGVbXCJDdXN0b21cIl0gPSA0XSA9IFwiQ3VzdG9tXCI7XG59KShSZW5kZXJMaW5lTnVtYmVyc1R5cGUgfHwgKFJlbmRlckxpbmVOdW1iZXJzVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIFJlbmRlck1pbmltYXA7XG4oZnVuY3Rpb24gKFJlbmRlck1pbmltYXApIHtcbiAgICBSZW5kZXJNaW5pbWFwW1JlbmRlck1pbmltYXBbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgICBSZW5kZXJNaW5pbWFwW1JlbmRlck1pbmltYXBbXCJUZXh0XCJdID0gMV0gPSBcIlRleHRcIjtcbiAgICBSZW5kZXJNaW5pbWFwW1JlbmRlck1pbmltYXBbXCJCbG9ja3NcIl0gPSAyXSA9IFwiQmxvY2tzXCI7XG59KShSZW5kZXJNaW5pbWFwIHx8IChSZW5kZXJNaW5pbWFwID0ge30pKTtcbmV4cG9ydCB2YXIgU2Nyb2xsVHlwZTtcbihmdW5jdGlvbiAoU2Nyb2xsVHlwZSkge1xuICAgIFNjcm9sbFR5cGVbU2Nyb2xsVHlwZVtcIlNtb290aFwiXSA9IDBdID0gXCJTbW9vdGhcIjtcbiAgICBTY3JvbGxUeXBlW1Njcm9sbFR5cGVbXCJJbW1lZGlhdGVcIl0gPSAxXSA9IFwiSW1tZWRpYXRlXCI7XG59KShTY3JvbGxUeXBlIHx8IChTY3JvbGxUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgU2Nyb2xsYmFyVmlzaWJpbGl0eTtcbihmdW5jdGlvbiAoU2Nyb2xsYmFyVmlzaWJpbGl0eSkge1xuICAgIFNjcm9sbGJhclZpc2liaWxpdHlbU2Nyb2xsYmFyVmlzaWJpbGl0eVtcIkF1dG9cIl0gPSAxXSA9IFwiQXV0b1wiO1xuICAgIFNjcm9sbGJhclZpc2liaWxpdHlbU2Nyb2xsYmFyVmlzaWJpbGl0eVtcIkhpZGRlblwiXSA9IDJdID0gXCJIaWRkZW5cIjtcbiAgICBTY3JvbGxiYXJWaXNpYmlsaXR5W1Njcm9sbGJhclZpc2liaWxpdHlbXCJWaXNpYmxlXCJdID0gM10gPSBcIlZpc2libGVcIjtcbn0pKFNjcm9sbGJhclZpc2liaWxpdHkgfHwgKFNjcm9sbGJhclZpc2liaWxpdHkgPSB7fSkpO1xuLyoqXG4gKiBUaGUgZGlyZWN0aW9uIG9mIGEgc2VsZWN0aW9uLlxuICovXG5leHBvcnQgdmFyIFNlbGVjdGlvbkRpcmVjdGlvbjtcbihmdW5jdGlvbiAoU2VsZWN0aW9uRGlyZWN0aW9uKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGlvbiBzdGFydHMgYWJvdmUgd2hlcmUgaXQgZW5kcy5cbiAgICAgKi9cbiAgICBTZWxlY3Rpb25EaXJlY3Rpb25bU2VsZWN0aW9uRGlyZWN0aW9uW1wiTFRSXCJdID0gMF0gPSBcIkxUUlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3Rpb24gc3RhcnRzIGJlbG93IHdoZXJlIGl0IGVuZHMuXG4gICAgICovXG4gICAgU2VsZWN0aW9uRGlyZWN0aW9uW1NlbGVjdGlvbkRpcmVjdGlvbltcIlJUTFwiXSA9IDFdID0gXCJSVExcIjtcbn0pKFNlbGVjdGlvbkRpcmVjdGlvbiB8fCAoU2VsZWN0aW9uRGlyZWN0aW9uID0ge30pKTtcbmV4cG9ydCB2YXIgU2hvd0xpZ2h0YnVsYkljb25Nb2RlO1xuKGZ1bmN0aW9uIChTaG93TGlnaHRidWxiSWNvbk1vZGUpIHtcbiAgICBTaG93TGlnaHRidWxiSWNvbk1vZGVbXCJPZmZcIl0gPSBcIm9mZlwiO1xuICAgIFNob3dMaWdodGJ1bGJJY29uTW9kZVtcIk9uQ29kZVwiXSA9IFwib25Db2RlXCI7XG4gICAgU2hvd0xpZ2h0YnVsYkljb25Nb2RlW1wiT25cIl0gPSBcIm9uXCI7XG59KShTaG93TGlnaHRidWxiSWNvbk1vZGUgfHwgKFNob3dMaWdodGJ1bGJJY29uTW9kZSA9IHt9KSk7XG5leHBvcnQgdmFyIFNpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kKSB7XG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1NpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtcIkludm9rZVwiXSA9IDFdID0gXCJJbnZva2VcIjtcbiAgICBTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmRbU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1wiVHJpZ2dlckNoYXJhY3RlclwiXSA9IDJdID0gXCJUcmlnZ2VyQ2hhcmFjdGVyXCI7XG4gICAgU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kW1NpZ25hdHVyZUhlbHBUcmlnZ2VyS2luZFtcIkNvbnRlbnRDaGFuZ2VcIl0gPSAzXSA9IFwiQ29udGVudENoYW5nZVwiO1xufSkoU2lnbmF0dXJlSGVscFRyaWdnZXJLaW5kIHx8IChTaWduYXR1cmVIZWxwVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBBIHN5bWJvbCBraW5kLlxuICovXG5leHBvcnQgdmFyIFN5bWJvbEtpbmQ7XG4oZnVuY3Rpb24gKFN5bWJvbEtpbmQpIHtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJGaWxlXCJdID0gMF0gPSBcIkZpbGVcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJNb2R1bGVcIl0gPSAxXSA9IFwiTW9kdWxlXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTmFtZXNwYWNlXCJdID0gMl0gPSBcIk5hbWVzcGFjZVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlBhY2thZ2VcIl0gPSAzXSA9IFwiUGFja2FnZVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkNsYXNzXCJdID0gNF0gPSBcIkNsYXNzXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTWV0aG9kXCJdID0gNV0gPSBcIk1ldGhvZFwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlByb3BlcnR5XCJdID0gNl0gPSBcIlByb3BlcnR5XCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRmllbGRcIl0gPSA3XSA9IFwiRmllbGRcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJDb25zdHJ1Y3RvclwiXSA9IDhdID0gXCJDb25zdHJ1Y3RvclwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkVudW1cIl0gPSA5XSA9IFwiRW51bVwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkludGVyZmFjZVwiXSA9IDEwXSA9IFwiSW50ZXJmYWNlXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiRnVuY3Rpb25cIl0gPSAxMV0gPSBcIkZ1bmN0aW9uXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiVmFyaWFibGVcIl0gPSAxMl0gPSBcIlZhcmlhYmxlXCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiQ29uc3RhbnRcIl0gPSAxM10gPSBcIkNvbnN0YW50XCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiU3RyaW5nXCJdID0gMTRdID0gXCJTdHJpbmdcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJOdW1iZXJcIl0gPSAxNV0gPSBcIk51bWJlclwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkJvb2xlYW5cIl0gPSAxNl0gPSBcIkJvb2xlYW5cIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJBcnJheVwiXSA9IDE3XSA9IFwiQXJyYXlcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJPYmplY3RcIl0gPSAxOF0gPSBcIk9iamVjdFwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIktleVwiXSA9IDE5XSA9IFwiS2V5XCI7XG4gICAgU3ltYm9sS2luZFtTeW1ib2xLaW5kW1wiTnVsbFwiXSA9IDIwXSA9IFwiTnVsbFwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkVudW1NZW1iZXJcIl0gPSAyMV0gPSBcIkVudW1NZW1iZXJcIjtcbiAgICBTeW1ib2xLaW5kW1N5bWJvbEtpbmRbXCJTdHJ1Y3RcIl0gPSAyMl0gPSBcIlN0cnVjdFwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIkV2ZW50XCJdID0gMjNdID0gXCJFdmVudFwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIk9wZXJhdG9yXCJdID0gMjRdID0gXCJPcGVyYXRvclwiO1xuICAgIFN5bWJvbEtpbmRbU3ltYm9sS2luZFtcIlR5cGVQYXJhbWV0ZXJcIl0gPSAyNV0gPSBcIlR5cGVQYXJhbWV0ZXJcIjtcbn0pKFN5bWJvbEtpbmQgfHwgKFN5bWJvbEtpbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBTeW1ib2xUYWc7XG4oZnVuY3Rpb24gKFN5bWJvbFRhZykge1xuICAgIFN5bWJvbFRhZ1tTeW1ib2xUYWdbXCJEZXByZWNhdGVkXCJdID0gMV0gPSBcIkRlcHJlY2F0ZWRcIjtcbn0pKFN5bWJvbFRhZyB8fCAoU3ltYm9sVGFnID0ge30pKTtcbi8qKlxuICogVGhlIGtpbmQgb2YgYW5pbWF0aW9uIGluIHdoaWNoIHRoZSBlZGl0b3IncyBjdXJzb3Igc2hvdWxkIGJlIHJlbmRlcmVkLlxuICovXG5leHBvcnQgdmFyIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlO1xuKGZ1bmN0aW9uIChUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZSkge1xuICAgIC8qKlxuICAgICAqIEhpZGRlblxuICAgICAqL1xuICAgIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1RleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1wiSGlkZGVuXCJdID0gMF0gPSBcIkhpZGRlblwiO1xuICAgIC8qKlxuICAgICAqIEJsaW5raW5nXG4gICAgICovXG4gICAgVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbVGV4dEVkaXRvckN1cnNvckJsaW5raW5nU3R5bGVbXCJCbGlua1wiXSA9IDFdID0gXCJCbGlua1wiO1xuICAgIC8qKlxuICAgICAqIEJsaW5raW5nIHdpdGggc21vb3RoIGZhZGluZ1xuICAgICAqL1xuICAgIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1RleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1wiU21vb3RoXCJdID0gMl0gPSBcIlNtb290aFwiO1xuICAgIC8qKlxuICAgICAqIEJsaW5raW5nIHdpdGggcHJvbG9uZ2VkIGZpbGxlZCBzdGF0ZSBhbmQgc21vb3RoIGZhZGluZ1xuICAgICAqL1xuICAgIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1RleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1wiUGhhc2VcIl0gPSAzXSA9IFwiUGhhc2VcIjtcbiAgICAvKipcbiAgICAgKiBFeHBhbmQgY29sbGFwc2UgYW5pbWF0aW9uIG9uIHRoZSB5IGF4aXNcbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZVtcIkV4cGFuZFwiXSA9IDRdID0gXCJFeHBhbmRcIjtcbiAgICAvKipcbiAgICAgKiBOby1CbGlua2luZ1xuICAgICAqL1xuICAgIFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1RleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlW1wiU29saWRcIl0gPSA1XSA9IFwiU29saWRcIjtcbn0pKFRleHRFZGl0b3JDdXJzb3JCbGlua2luZ1N0eWxlIHx8IChUZXh0RWRpdG9yQ3Vyc29yQmxpbmtpbmdTdHlsZSA9IHt9KSk7XG4vKipcbiAqIFRoZSBzdHlsZSBpbiB3aGljaCB0aGUgZWRpdG9yJ3MgY3Vyc29yIHNob3VsZCBiZSByZW5kZXJlZC5cbiAqL1xuZXhwb3J0IHZhciBUZXh0RWRpdG9yQ3Vyc29yU3R5bGU7XG4oZnVuY3Rpb24gKFRleHRFZGl0b3JDdXJzb3JTdHlsZSkge1xuICAgIC8qKlxuICAgICAqIEFzIGEgdmVydGljYWwgbGluZSAoc2l0dGluZyBiZXR3ZWVuIHR3byBjaGFyYWN0ZXJzKS5cbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiTGluZVwiXSA9IDFdID0gXCJMaW5lXCI7XG4gICAgLyoqXG4gICAgICogQXMgYSBibG9jayAoc2l0dGluZyBvbiB0b3Agb2YgYSBjaGFyYWN0ZXIpLlxuICAgICAqL1xuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJCbG9ja1wiXSA9IDJdID0gXCJCbG9ja1wiO1xuICAgIC8qKlxuICAgICAqIEFzIGEgaG9yaXpvbnRhbCBsaW5lIChzaXR0aW5nIHVuZGVyIGEgY2hhcmFjdGVyKS5cbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiVW5kZXJsaW5lXCJdID0gM10gPSBcIlVuZGVybGluZVwiO1xuICAgIC8qKlxuICAgICAqIEFzIGEgdGhpbiB2ZXJ0aWNhbCBsaW5lIChzaXR0aW5nIGJldHdlZW4gdHdvIGNoYXJhY3RlcnMpLlxuICAgICAqL1xuICAgIFRleHRFZGl0b3JDdXJzb3JTdHlsZVtUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbXCJMaW5lVGhpblwiXSA9IDRdID0gXCJMaW5lVGhpblwiO1xuICAgIC8qKlxuICAgICAqIEFzIGFuIG91dGxpbmVkIGJsb2NrIChzaXR0aW5nIG9uIHRvcCBvZiBhIGNoYXJhY3RlcikuXG4gICAgICovXG4gICAgVGV4dEVkaXRvckN1cnNvclN0eWxlW1RleHRFZGl0b3JDdXJzb3JTdHlsZVtcIkJsb2NrT3V0bGluZVwiXSA9IDVdID0gXCJCbG9ja091dGxpbmVcIjtcbiAgICAvKipcbiAgICAgKiBBcyBhIHRoaW4gaG9yaXpvbnRhbCBsaW5lIChzaXR0aW5nIHVuZGVyIGEgY2hhcmFjdGVyKS5cbiAgICAgKi9cbiAgICBUZXh0RWRpdG9yQ3Vyc29yU3R5bGVbVGV4dEVkaXRvckN1cnNvclN0eWxlW1wiVW5kZXJsaW5lVGhpblwiXSA9IDZdID0gXCJVbmRlcmxpbmVUaGluXCI7XG59KShUZXh0RWRpdG9yQ3Vyc29yU3R5bGUgfHwgKFRleHRFZGl0b3JDdXJzb3JTdHlsZSA9IHt9KSk7XG4vKipcbiAqIERlc2NyaWJlcyB0aGUgYmVoYXZpb3Igb2YgZGVjb3JhdGlvbnMgd2hlbiB0eXBpbmcvZWRpdGluZyBuZWFyIHRoZWlyIGVkZ2VzLlxuICogTm90ZTogUGxlYXNlIGRvIG5vdCBlZGl0IHRoZSB2YWx1ZXMsIGFzIHRoZXkgdmVyeSBjYXJlZnVsbHkgbWF0Y2ggYERlY29yYXRpb25SYW5nZUJlaGF2aW9yYFxuICovXG5leHBvcnQgdmFyIFRyYWNrZWRSYW5nZVN0aWNraW5lc3M7XG4oZnVuY3Rpb24gKFRyYWNrZWRSYW5nZVN0aWNraW5lc3MpIHtcbiAgICBUcmFja2VkUmFuZ2VTdGlja2luZXNzW1RyYWNrZWRSYW5nZVN0aWNraW5lc3NbXCJBbHdheXNHcm93c1doZW5UeXBpbmdBdEVkZ2VzXCJdID0gMF0gPSBcIkFsd2F5c0dyb3dzV2hlblR5cGluZ0F0RWRnZXNcIjtcbiAgICBUcmFja2VkUmFuZ2VTdGlja2luZXNzW1RyYWNrZWRSYW5nZVN0aWNraW5lc3NbXCJOZXZlckdyb3dzV2hlblR5cGluZ0F0RWRnZXNcIl0gPSAxXSA9IFwiTmV2ZXJHcm93c1doZW5UeXBpbmdBdEVkZ2VzXCI7XG4gICAgVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tUcmFja2VkUmFuZ2VTdGlja2luZXNzW1wiR3Jvd3NPbmx5V2hlblR5cGluZ0JlZm9yZVwiXSA9IDJdID0gXCJHcm93c09ubHlXaGVuVHlwaW5nQmVmb3JlXCI7XG4gICAgVHJhY2tlZFJhbmdlU3RpY2tpbmVzc1tUcmFja2VkUmFuZ2VTdGlja2luZXNzW1wiR3Jvd3NPbmx5V2hlblR5cGluZ0FmdGVyXCJdID0gM10gPSBcIkdyb3dzT25seVdoZW5UeXBpbmdBZnRlclwiO1xufSkoVHJhY2tlZFJhbmdlU3RpY2tpbmVzcyB8fCAoVHJhY2tlZFJhbmdlU3RpY2tpbmVzcyA9IHt9KSk7XG4vKipcbiAqIERlc2NyaWJlcyBob3cgdG8gaW5kZW50IHdyYXBwZWQgbGluZXMuXG4gKi9cbmV4cG9ydCB2YXIgV3JhcHBpbmdJbmRlbnQ7XG4oZnVuY3Rpb24gKFdyYXBwaW5nSW5kZW50KSB7XG4gICAgLyoqXG4gICAgICogTm8gaW5kZW50YXRpb24gPT4gd3JhcHBlZCBsaW5lcyBiZWdpbiBhdCBjb2x1bW4gMS5cbiAgICAgKi9cbiAgICBXcmFwcGluZ0luZGVudFtXcmFwcGluZ0luZGVudFtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xuICAgIC8qKlxuICAgICAqIFNhbWUgPT4gd3JhcHBlZCBsaW5lcyBnZXQgdGhlIHNhbWUgaW5kZW50YXRpb24gYXMgdGhlIHBhcmVudC5cbiAgICAgKi9cbiAgICBXcmFwcGluZ0luZGVudFtXcmFwcGluZ0luZGVudFtcIlNhbWVcIl0gPSAxXSA9IFwiU2FtZVwiO1xuICAgIC8qKlxuICAgICAqIEluZGVudCA9PiB3cmFwcGVkIGxpbmVzIGdldCArMSBpbmRlbnRhdGlvbiB0b3dhcmQgdGhlIHBhcmVudC5cbiAgICAgKi9cbiAgICBXcmFwcGluZ0luZGVudFtXcmFwcGluZ0luZGVudFtcIkluZGVudFwiXSA9IDJdID0gXCJJbmRlbnRcIjtcbiAgICAvKipcbiAgICAgKiBEZWVwSW5kZW50ID0+IHdyYXBwZWQgbGluZXMgZ2V0ICsyIGluZGVudGF0aW9uIHRvd2FyZCB0aGUgcGFyZW50LlxuICAgICAqL1xuICAgIFdyYXBwaW5nSW5kZW50W1dyYXBwaW5nSW5kZW50W1wiRGVlcEluZGVudFwiXSA9IDNdID0gXCJEZWVwSW5kZW50XCI7XG59KShXcmFwcGluZ0luZGVudCB8fCAoV3JhcHBpbmdJbmRlbnQgPSB7fSkpO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXZlbnQuanMnO1xuaW1wb3J0IHsgS2V5Q2hvcmQgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9rZXlDb2Rlcy5qcyc7XG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi91cmkuanMnO1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi9jb3JlL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBTZWxlY3Rpb24gfSBmcm9tICcuLi9jb3JlL3NlbGVjdGlvbi5qcyc7XG5pbXBvcnQgeyBUb2tlbiB9IGZyb20gJy4uL2xhbmd1YWdlcy5qcyc7XG5pbXBvcnQgKiBhcyBzdGFuZGFsb25lRW51bXMgZnJvbSAnLi4vc3RhbmRhbG9uZS9zdGFuZGFsb25lRW51bXMuanMnO1xuZXhwb3J0IGNsYXNzIEtleU1vZCB7XG4gICAgc3RhdGljIGNob3JkKGZpcnN0UGFydCwgc2Vjb25kUGFydCkge1xuICAgICAgICByZXR1cm4gS2V5Q2hvcmQoZmlyc3RQYXJ0LCBzZWNvbmRQYXJ0KTtcbiAgICB9XG59XG5LZXlNb2QuQ3RybENtZCA9IDIwNDggLyogQ29uc3RLZXlNb2QuQ3RybENtZCAqLztcbktleU1vZC5TaGlmdCA9IDEwMjQgLyogQ29uc3RLZXlNb2QuU2hpZnQgKi87XG5LZXlNb2QuQWx0ID0gNTEyIC8qIENvbnN0S2V5TW9kLkFsdCAqLztcbktleU1vZC5XaW5DdHJsID0gMjU2IC8qIENvbnN0S2V5TW9kLldpbkN0cmwgKi87XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTW9uYWNvQmFzZUFQSSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlZGl0b3I6IHVuZGVmaW5lZCwgLy8gdW5kZWZpbmVkIG92ZXJyaWRlIGV4cGVjdGVkIGhlcmVcbiAgICAgICAgbGFuZ3VhZ2VzOiB1bmRlZmluZWQsIC8vIHVuZGVmaW5lZCBvdmVycmlkZSBleHBlY3RlZCBoZXJlXG4gICAgICAgIENhbmNlbGxhdGlvblRva2VuU291cmNlOiBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSxcbiAgICAgICAgRW1pdHRlcjogRW1pdHRlcixcbiAgICAgICAgS2V5Q29kZTogc3RhbmRhbG9uZUVudW1zLktleUNvZGUsXG4gICAgICAgIEtleU1vZDogS2V5TW9kLFxuICAgICAgICBQb3NpdGlvbjogUG9zaXRpb24sXG4gICAgICAgIFJhbmdlOiBSYW5nZSxcbiAgICAgICAgU2VsZWN0aW9uOiBTZWxlY3Rpb24sXG4gICAgICAgIFNlbGVjdGlvbkRpcmVjdGlvbjogc3RhbmRhbG9uZUVudW1zLlNlbGVjdGlvbkRpcmVjdGlvbixcbiAgICAgICAgTWFya2VyU2V2ZXJpdHk6IHN0YW5kYWxvbmVFbnVtcy5NYXJrZXJTZXZlcml0eSxcbiAgICAgICAgTWFya2VyVGFnOiBzdGFuZGFsb25lRW51bXMuTWFya2VyVGFnLFxuICAgICAgICBVcmk6IFVSSSxcbiAgICAgICAgVG9rZW46IFRva2VuXG4gICAgfTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xudmFyIF9hLCBfYjtcbmNsYXNzIFJlc291cmNlTWFwRW50cnkge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy51cmkgPSB1cmk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0VudHJpZXMoYXJnKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbn1cbmV4cG9ydCBjbGFzcyBSZXNvdXJjZU1hcCB7XG4gICAgY29uc3RydWN0b3IoYXJnLCB0b0tleSkge1xuICAgICAgICB0aGlzW19hXSA9ICdSZXNvdXJjZU1hcCc7XG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBSZXNvdXJjZU1hcCkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKGFyZy5tYXApO1xuICAgICAgICAgICAgdGhpcy50b0tleSA9IHRvS2V5ICE9PSBudWxsICYmIHRvS2V5ICE9PSB2b2lkIDAgPyB0b0tleSA6IFJlc291cmNlTWFwLmRlZmF1bHRUb0tleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0VudHJpZXMoYXJnKSkge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnRvS2V5ID0gdG9LZXkgIT09IG51bGwgJiYgdG9LZXkgIT09IHZvaWQgMCA/IHRvS2V5IDogUmVzb3VyY2VNYXAuZGVmYXVsdFRvS2V5O1xuICAgICAgICAgICAgZm9yIChjb25zdCBbcmVzb3VyY2UsIHZhbHVlXSBvZiBhcmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChyZXNvdXJjZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnRvS2V5ID0gYXJnICE9PSBudWxsICYmIGFyZyAhPT0gdm9pZCAwID8gYXJnIDogUmVzb3VyY2VNYXAuZGVmYXVsdFRvS2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChyZXNvdXJjZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXAuc2V0KHRoaXMudG9LZXkocmVzb3VyY2UpLCBuZXcgUmVzb3VyY2VNYXBFbnRyeShyZXNvdXJjZSwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldChyZXNvdXJjZSkge1xuICAgICAgICB2YXIgX2M7XG4gICAgICAgIHJldHVybiAoX2MgPSB0aGlzLm1hcC5nZXQodGhpcy50b0tleShyZXNvdXJjZSkpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmFsdWU7XG4gICAgfVxuICAgIGhhcyhyZXNvdXJjZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzKHRoaXMudG9LZXkocmVzb3VyY2UpKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5zaXplO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5tYXAuY2xlYXIoKTtcbiAgICB9XG4gICAgZGVsZXRlKHJlc291cmNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5kZWxldGUodGhpcy50b0tleShyZXNvdXJjZSkpO1xuICAgIH1cbiAgICBmb3JFYWNoKGNsYiwgdGhpc0FyZykge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXNBcmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjbGIgPSBjbGIuYmluZCh0aGlzQXJnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtfLCBlbnRyeV0gb2YgdGhpcy5tYXApIHtcbiAgICAgICAgICAgIGNsYihlbnRyeS52YWx1ZSwgZW50cnkudXJpLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqdmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB5aWVsZCBlbnRyeS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqa2V5cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLm1hcC52YWx1ZXMoKSkge1xuICAgICAgICAgICAgeWllbGQgZW50cnkudXJpO1xuICAgICAgICB9XG4gICAgfVxuICAgICplbnRyaWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHRoaXMubWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICB5aWVsZCBbZW50cnkudXJpLCBlbnRyeS52YWx1ZV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgKlsoX2EgPSBTeW1ib2wudG9TdHJpbmdUYWcsIFN5bWJvbC5pdGVyYXRvcildKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFssIGVudHJ5XSBvZiB0aGlzLm1hcCkge1xuICAgICAgICAgICAgeWllbGQgW2VudHJ5LnVyaSwgZW50cnkudmFsdWVdO1xuICAgICAgICB9XG4gICAgfVxufVxuUmVzb3VyY2VNYXAuZGVmYXVsdFRvS2V5ID0gKHJlc291cmNlKSA9PiByZXNvdXJjZS50b1N0cmluZygpO1xuZXhwb3J0IGNsYXNzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXNbX2JdID0gJ0xpbmtlZE1hcCc7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5faGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdGFpbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gMDtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX21hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLl9oZWFkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gMDtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxuICAgIGdldCBmaXJzdCgpIHtcbiAgICAgICAgdmFyIF9jO1xuICAgICAgICByZXR1cm4gKF9jID0gdGhpcy5faGVhZCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZhbHVlO1xuICAgIH1cbiAgICBnZXQgbGFzdCgpIHtcbiAgICAgICAgdmFyIF9jO1xuICAgICAgICByZXR1cm4gKF9jID0gdGhpcy5fdGFpbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZhbHVlO1xuICAgIH1cbiAgICBoYXMoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKGtleSk7XG4gICAgfVxuICAgIGdldChrZXksIHRvdWNoID0gMCAvKiBUb3VjaC5Ob25lICovKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG91Y2ggIT09IDAgLyogVG91Y2guTm9uZSAqLykge1xuICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlLCB0b3VjaCA9IDAgLyogVG91Y2guTm9uZSAqLykge1xuICAgICAgICBsZXQgaXRlbSA9IHRoaXMuX21hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKGl0ZW0pIHtcbiAgICAgICAgICAgIGl0ZW0udmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0b3VjaCAhPT0gMCAvKiBUb3VjaC5Ob25lICovKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b3VjaChpdGVtLCB0b3VjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtID0geyBrZXksIHZhbHVlLCBuZXh0OiB1bmRlZmluZWQsIHByZXZpb3VzOiB1bmRlZmluZWQgfTtcbiAgICAgICAgICAgIHN3aXRjaCAodG91Y2gpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDAgLyogVG91Y2guTm9uZSAqLzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRJdGVtTGFzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxIC8qIFRvdWNoLkFzT2xkICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1GaXJzdChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyIC8qIFRvdWNoLkFzTmV3ICovOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEl0ZW1MYXN0KGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21hcC5zZXQoa2V5LCBpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuX3NpemUrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGVsZXRlKGtleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnJlbW92ZShrZXkpO1xuICAgIH1cbiAgICByZW1vdmUoa2V5KSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIHRoaXMucmVtb3ZlSXRlbShpdGVtKTtcbiAgICAgICAgdGhpcy5fc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaXRlbS52YWx1ZTtcbiAgICB9XG4gICAgc2hpZnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2hlYWQgfHwgIXRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoaXRlbS5rZXkpO1xuICAgICAgICB0aGlzLnJlbW92ZUl0ZW0oaXRlbSk7XG4gICAgICAgIHRoaXMuX3NpemUtLTtcbiAgICAgICAgcmV0dXJuIGl0ZW0udmFsdWU7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpc0FyZykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrZm4uYmluZCh0aGlzQXJnKShjdXJyZW50LnZhbHVlLCBjdXJyZW50LmtleSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja2ZuKGN1cnJlbnQudmFsdWUsIGN1cnJlbnQua2V5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAga2V5cygpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXAuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC5rZXksIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXAuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogY3VycmVudC52YWx1ZSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgZW50cmllcygpIHtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHtcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXh0KCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXAuX3N0YXRlICE9PSBzdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpbmtlZE1hcCBnb3QgbW9kaWZpZWQgZHVyaW5nIGl0ZXJhdGlvbi5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyB2YWx1ZTogW2N1cnJlbnQua2V5LCBjdXJyZW50LnZhbHVlXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgWyhfYiA9IFN5bWJvbC50b1N0cmluZ1RhZywgU3ltYm9sLml0ZXJhdG9yKV0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXMoKTtcbiAgICB9XG4gICAgdHJpbU9sZChuZXdTaXplKSB7XG4gICAgICAgIGlmIChuZXdTaXplID49IHRoaXMuc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLl9oZWFkO1xuICAgICAgICBsZXQgY3VycmVudFNpemUgPSB0aGlzLnNpemU7XG4gICAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnRTaXplID4gbmV3U2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShjdXJyZW50LmtleSk7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICAgICAgICAgICAgY3VycmVudFNpemUtLTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oZWFkID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IGN1cnJlbnRTaXplO1xuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgY3VycmVudC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGF0ZSsrO1xuICAgIH1cbiAgICB0cmltTmV3KG5ld1NpemUpIHtcbiAgICAgICAgaWYgKG5ld1NpemUgPj0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1NpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuX3RhaWw7XG4gICAgICAgIGxldCBjdXJyZW50U2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudFNpemUgPiBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKGN1cnJlbnQua2V5KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnByZXZpb3VzO1xuICAgICAgICAgICAgY3VycmVudFNpemUtLTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWlsID0gY3VycmVudDtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IGN1cnJlbnRTaXplO1xuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgY3VycmVudC5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1GaXJzdChpdGVtKSB7XG4gICAgICAgIC8vIEZpcnN0IHRpbWUgSW5zZXJ0XG4gICAgICAgIGlmICghdGhpcy5faGVhZCAmJiAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLl9oZWFkO1xuICAgICAgICAgICAgdGhpcy5faGVhZC5wcmV2aW91cyA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGVhZCA9IGl0ZW07XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIGFkZEl0ZW1MYXN0KGl0ZW0pIHtcbiAgICAgICAgLy8gRmlyc3QgdGltZSBJbnNlcnRcbiAgICAgICAgaWYgKCF0aGlzLl9oZWFkICYmICF0aGlzLl90YWlsKSB7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YWlsID0gaXRlbTtcbiAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICB9XG4gICAgcmVtb3ZlSXRlbShpdGVtKSB7XG4gICAgICAgIGlmIChpdGVtID09PSB0aGlzLl9oZWFkICYmIGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl90YWlsID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlZFxuICAgICAgICAgICAgLy8gYnkgdGhlIGNhc2UgYWJvdmUuXG4gICAgICAgICAgICBpZiAoIWl0ZW0ubmV4dCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtLm5leHQucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9oZWFkID0gaXRlbS5uZXh0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2FuIG9ubHkgaGFwcGVuIGlmIHNpemUgPT09IDEgd2hpY2ggaXMgaGFuZGxlZFxuICAgICAgICAgICAgLy8gYnkgdGhlIGNhc2UgYWJvdmUuXG4gICAgICAgICAgICBpZiAoIWl0ZW0ucHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbGlzdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5wcmV2aW91cy5uZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fdGFpbCA9IGl0ZW0ucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgaWYgKCFuZXh0IHx8ICFwcmV2aW91cykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBsaXN0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGl0ZW0ucHJldmlvdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3N0YXRlKys7XG4gICAgfVxuICAgIHRvdWNoKGl0ZW0sIHRvdWNoKSB7XG4gICAgICAgIGlmICghdGhpcy5faGVhZCB8fCAhdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGxpc3QnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRvdWNoICE9PSAxIC8qIFRvdWNoLkFzT2xkICovICYmIHRvdWNoICE9PSAyIC8qIFRvdWNoLkFzTmV3ICovKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3VjaCA9PT0gMSAvKiBUb3VjaC5Bc09sZCAqLykge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgLy8gVW5saW5rIHRoZSBpdGVtXG4gICAgICAgICAgICBpZiAoaXRlbSA9PT0gdGhpcy5fdGFpbCkge1xuICAgICAgICAgICAgICAgIC8vIHByZXZpb3VzIG11c3QgYmUgZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBub3QgaGVhZCBidXQgaXMgdGFpbFxuICAgICAgICAgICAgICAgIC8vIFNvIHRoZXJlIGFyZSBtb3JlIHRoYW4gb24gaXRlbSBpbiB0aGUgbWFwXG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl90YWlsID0gcHJldmlvdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3RoIG5leHQgYW5kIHByZXZpb3VzIGFyZSBub3QgdW5kZWZpbmVkIHNpbmNlIGl0ZW0gd2FzIG5laXRoZXIgaGVhZCBub3IgdGFpbC5cbiAgICAgICAgICAgICAgICBuZXh0LnByZXZpb3VzID0gcHJldmlvdXM7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMubmV4dCA9IG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIG5vZGUgYXQgaGVhZFxuICAgICAgICAgICAgaXRlbS5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHRoaXMuX2hlYWQ7XG4gICAgICAgICAgICB0aGlzLl9oZWFkLnByZXZpb3VzID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX2hlYWQgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0b3VjaCA9PT0gMiAvKiBUb3VjaC5Bc05ldyAqLykge1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX3RhaWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlbS5uZXh0O1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBpdGVtLnByZXZpb3VzO1xuICAgICAgICAgICAgLy8gVW5saW5rIHRoZSBpdGVtLlxuICAgICAgICAgICAgaWYgKGl0ZW0gPT09IHRoaXMuX2hlYWQpIHtcbiAgICAgICAgICAgICAgICAvLyBuZXh0IG11c3QgYmUgZGVmaW5lZCBzaW5jZSBpdGVtIHdhcyBub3QgdGFpbCBidXQgaXMgaGVhZFxuICAgICAgICAgICAgICAgIC8vIFNvIHRoZXJlIGFyZSBtb3JlIHRoYW4gb24gaXRlbSBpbiB0aGUgbWFwXG4gICAgICAgICAgICAgICAgbmV4dC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0aGlzLl9oZWFkID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdGggbmV4dCBhbmQgcHJldmlvdXMgYXJlIG5vdCB1bmRlZmluZWQgc2luY2UgaXRlbSB3YXMgbmVpdGhlciBoZWFkIG5vciB0YWlsLlxuICAgICAgICAgICAgICAgIG5leHQucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgICAgICAgICBwcmV2aW91cy5uZXh0ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0ubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGl0ZW0ucHJldmlvdXMgPSB0aGlzLl90YWlsO1xuICAgICAgICAgICAgdGhpcy5fdGFpbC5uZXh0ID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX3RhaWwgPSBpdGVtO1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgdGhpcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBmcm9tSlNPTihkYXRhKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZGF0YSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBDYWNoZSBleHRlbmRzIExpbmtlZE1hcCB7XG4gICAgY29uc3RydWN0b3IobGltaXQsIHJhdGlvID0gMSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9saW1pdCA9IGxpbWl0O1xuICAgICAgICB0aGlzLl9yYXRpbyA9IE1hdGgubWluKE1hdGgubWF4KDAsIHJhdGlvKSwgMSk7XG4gICAgfVxuICAgIGdldCBsaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbWl0O1xuICAgIH1cbiAgICBzZXQgbGltaXQobGltaXQpIHtcbiAgICAgICAgdGhpcy5fbGltaXQgPSBsaW1pdDtcbiAgICAgICAgdGhpcy5jaGVja1RyaW0oKTtcbiAgICB9XG4gICAgZ2V0KGtleSwgdG91Y2ggPSAyIC8qIFRvdWNoLkFzTmV3ICovKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5LCB0b3VjaCk7XG4gICAgfVxuICAgIHBlZWsoa2V5KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5nZXQoa2V5LCAwIC8qIFRvdWNoLk5vbmUgKi8pO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBzdXBlci5zZXQoa2V5LCB2YWx1ZSwgMiAvKiBUb3VjaC5Bc05ldyAqLyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjaGVja1RyaW0oKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUgPiB0aGlzLl9saW1pdCkge1xuICAgICAgICAgICAgdGhpcy50cmltKE1hdGgucm91bmQodGhpcy5fbGltaXQgKiB0aGlzLl9yYXRpbykpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIExSVUNhY2hlIGV4dGVuZHMgQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGxpbWl0LCByYXRpbyA9IDEpIHtcbiAgICAgICAgc3VwZXIobGltaXQsIHJhdGlvKTtcbiAgICB9XG4gICAgdHJpbShuZXdTaXplKSB7XG4gICAgICAgIHRoaXMudHJpbU9sZChuZXdTaXplKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmNoZWNrVHJpbSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG4vKipcbiAqIEEgbWFwIHRoYXQgYWxsb3dzIGFjY2VzcyBib3RoIGJ5IGtleXMgYW5kIHZhbHVlcy5cbiAqICoqTk9URSoqOiB2YWx1ZXMgbmVlZCB0byBiZSB1bmlxdWUuXG4gKi9cbmV4cG9ydCBjbGFzcyBCaWRpcmVjdGlvbmFsTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyaWVzKSB7XG4gICAgICAgIHRoaXMuX20xID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9tMiA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbTEuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5fbTIuY2xlYXIoKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fbTEuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLl9tMi5zZXQodmFsdWUsIGtleSk7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX20xLmdldChrZXkpO1xuICAgIH1cbiAgICBnZXRLZXkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX20yLmdldCh2YWx1ZSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9tMS5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tMS5kZWxldGUoa2V5KTtcbiAgICAgICAgdGhpcy5fbTIuZGVsZXRlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGtleXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tMS5rZXlzKCk7XG4gICAgfVxuICAgIHZhbHVlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX20xLnZhbHVlcygpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTZXRNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYWRkKGtleSwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHZhbHVlcyA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIXZhbHVlcykge1xuICAgICAgICAgICAgdmFsdWVzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMuYWRkKHZhbHVlKTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghdmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWVzLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yRWFjaChrZXksIGZuKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHRoaXMubWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoIXZhbHVlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKGZuKTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IExSVUNhY2hlIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vbWFwLmpzJztcbmltcG9ydCB7IENoYXJhY3RlckNsYXNzaWZpZXIgfSBmcm9tICcuL2NoYXJhY3RlckNsYXNzaWZpZXIuanMnO1xuZXhwb3J0IGNsYXNzIFdvcmRDaGFyYWN0ZXJDbGFzc2lmaWVyIGV4dGVuZHMgQ2hhcmFjdGVyQ2xhc3NpZmllciB7XG4gICAgY29uc3RydWN0b3Iod29yZFNlcGFyYXRvcnMsIGludGxTZWdtZW50ZXJMb2NhbGVzKSB7XG4gICAgICAgIHN1cGVyKDAgLyogV29yZENoYXJhY3RlckNsYXNzLlJlZ3VsYXIgKi8pO1xuICAgICAgICB0aGlzLl9zZWdtZW50ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZWRMaW5lID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2FjaGVkU2VnbWVudHMgPSBbXTtcbiAgICAgICAgdGhpcy5pbnRsU2VnbWVudGVyTG9jYWxlcyA9IGludGxTZWdtZW50ZXJMb2NhbGVzO1xuICAgICAgICBpZiAodGhpcy5pbnRsU2VnbWVudGVyTG9jYWxlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9zZWdtZW50ZXIgPSBuZXcgSW50bC5TZWdtZW50ZXIodGhpcy5pbnRsU2VnbWVudGVyTG9jYWxlcywgeyBncmFudWxhcml0eTogJ3dvcmQnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2VnbWVudGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gd29yZFNlcGFyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KHdvcmRTZXBhcmF0b3JzLmNoYXJDb2RlQXQoaSksIDIgLyogV29yZENoYXJhY3RlckNsYXNzLldvcmRTZXBhcmF0b3IgKi8pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KDMyIC8qIENoYXJDb2RlLlNwYWNlICovLCAxIC8qIFdvcmRDaGFyYWN0ZXJDbGFzcy5XaGl0ZXNwYWNlICovKTtcbiAgICAgICAgdGhpcy5zZXQoOSAvKiBDaGFyQ29kZS5UYWIgKi8sIDEgLyogV29yZENoYXJhY3RlckNsYXNzLldoaXRlc3BhY2UgKi8pO1xuICAgIH1cbiAgICBmaW5kUHJldkludGxXb3JkQmVmb3JlT3JBdE9mZnNldChsaW5lLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiB0aGlzLl9nZXRJbnRsU2VnbWVudGVyV29yZHNPbkxpbmUobGluZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWdtZW50LmluZGV4ID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBzZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGU7XG4gICAgfVxuICAgIGZpbmROZXh0SW50bFdvcmRBdE9yQWZ0ZXJPZmZzZXQobGluZUNvbnRlbnQsIG9mZnNldCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2YgdGhpcy5fZ2V0SW50bFNlZ21lbnRlcldvcmRzT25MaW5lKGxpbmVDb250ZW50KSkge1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQuaW5kZXggPCBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBfZ2V0SW50bFNlZ21lbnRlcldvcmRzT25MaW5lKGxpbmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zZWdtZW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgbGluZSBoYXMgY2hhbmdlZCBmcm9tIHRoZSBwcmV2aW91cyBjYWxsXG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWRMaW5lID09PSBsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2VnbWVudHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjYWNoZSB3aXRoIHRoZSBuZXcgbGluZVxuICAgICAgICB0aGlzLl9jYWNoZWRMaW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5fY2FjaGVkU2VnbWVudHMgPSB0aGlzLl9maWx0ZXJXb3JkU2VnbWVudHModGhpcy5fc2VnbWVudGVyLnNlZ21lbnQobGluZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkU2VnbWVudHM7XG4gICAgfVxuICAgIF9maWx0ZXJXb3JkU2VnbWVudHMoc2VnbWVudHMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2lzV29yZExpa2Uoc2VnbWVudCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfaXNXb3JkTGlrZShzZWdtZW50KSB7XG4gICAgICAgIGlmIChzZWdtZW50LmlzV29yZExpa2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCB3b3JkQ2xhc3NpZmllckNhY2hlID0gbmV3IExSVUNhY2hlKDEwKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXBGb3JXb3JkU2VwYXJhdG9ycyh3b3JkU2VwYXJhdG9ycywgaW50bFNlZ21lbnRlckxvY2FsZXMpIHtcbiAgICBjb25zdCBrZXkgPSBgJHt3b3JkU2VwYXJhdG9yc30vJHtpbnRsU2VnbWVudGVyTG9jYWxlcy5qb2luKCcsJyl9YDtcbiAgICBsZXQgcmVzdWx0ID0gd29yZENsYXNzaWZpZXJDYWNoZS5nZXQoa2V5KTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXN1bHQgPSBuZXcgV29yZENoYXJhY3RlckNsYXNzaWZpZXIod29yZFNlcGFyYXRvcnMsIGludGxTZWdtZW50ZXJMb2NhbGVzKTtcbiAgICAgICAgd29yZENsYXNzaWZpZXJDYWNoZS5zZXQoa2V5LCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBlcXVhbHMgfSBmcm9tICcuLi8uLi9iYXNlL2NvbW1vbi9vYmplY3RzLmpzJztcbi8qKlxuICogVmVydGljYWwgTGFuZSBpbiB0aGUgb3ZlcnZpZXcgcnVsZXIgb2YgdGhlIGVkaXRvci5cbiAqL1xuZXhwb3J0IHZhciBPdmVydmlld1J1bGVyTGFuZTtcbihmdW5jdGlvbiAoT3ZlcnZpZXdSdWxlckxhbmUpIHtcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkxlZnRcIl0gPSAxXSA9IFwiTGVmdFwiO1xuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiQ2VudGVyXCJdID0gMl0gPSBcIkNlbnRlclwiO1xuICAgIE92ZXJ2aWV3UnVsZXJMYW5lW092ZXJ2aWV3UnVsZXJMYW5lW1wiUmlnaHRcIl0gPSA0XSA9IFwiUmlnaHRcIjtcbiAgICBPdmVydmlld1J1bGVyTGFuZVtPdmVydmlld1J1bGVyTGFuZVtcIkZ1bGxcIl0gPSA3XSA9IFwiRnVsbFwiO1xufSkoT3ZlcnZpZXdSdWxlckxhbmUgfHwgKE92ZXJ2aWV3UnVsZXJMYW5lID0ge30pKTtcbi8qKlxuICogVmVydGljYWwgTGFuZSBpbiB0aGUgZ2x5cGggbWFyZ2luIG9mIHRoZSBlZGl0b3IuXG4gKi9cbmV4cG9ydCB2YXIgR2x5cGhNYXJnaW5MYW5lO1xuKGZ1bmN0aW9uIChHbHlwaE1hcmdpbkxhbmUpIHtcbiAgICBHbHlwaE1hcmdpbkxhbmVbR2x5cGhNYXJnaW5MYW5lW1wiTGVmdFwiXSA9IDFdID0gXCJMZWZ0XCI7XG4gICAgR2x5cGhNYXJnaW5MYW5lW0dseXBoTWFyZ2luTGFuZVtcIkNlbnRlclwiXSA9IDJdID0gXCJDZW50ZXJcIjtcbiAgICBHbHlwaE1hcmdpbkxhbmVbR2x5cGhNYXJnaW5MYW5lW1wiUmlnaHRcIl0gPSAzXSA9IFwiUmlnaHRcIjtcbn0pKEdseXBoTWFyZ2luTGFuZSB8fCAoR2x5cGhNYXJnaW5MYW5lID0ge30pKTtcbmV4cG9ydCB2YXIgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHM7XG4oZnVuY3Rpb24gKEluamVjdGVkVGV4dEN1cnNvclN0b3BzKSB7XG4gICAgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbXCJCb3RoXCJdID0gMF0gPSBcIkJvdGhcIjtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIlJpZ2h0XCJdID0gMV0gPSBcIlJpZ2h0XCI7XG4gICAgSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHNbXCJMZWZ0XCJdID0gMl0gPSBcIkxlZnRcIjtcbiAgICBJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tJbmplY3RlZFRleHRDdXJzb3JTdG9wc1tcIk5vbmVcIl0gPSAzXSA9IFwiTm9uZVwiO1xufSkoSW5qZWN0ZWRUZXh0Q3Vyc29yU3RvcHMgfHwgKEluamVjdGVkVGV4dEN1cnNvclN0b3BzID0ge30pKTtcbmV4cG9ydCBjbGFzcyBUZXh0TW9kZWxSZXNvbHZlZE9wdGlvbnMge1xuICAgIGdldCBvcmlnaW5hbEluZGVudFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRlbnRTaXplSXNUYWJTaXplID8gJ3RhYlNpemUnIDogdGhpcy5pbmRlbnRTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcmMpIHtcbiAgICAgICAgdGhpcy5fdGV4dE1vZGVsUmVzb2x2ZWRPcHRpb25zQnJhbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMudGFiU2l6ZSA9IE1hdGgubWF4KDEsIHNyYy50YWJTaXplIHwgMCk7XG4gICAgICAgIGlmIChzcmMuaW5kZW50U2l6ZSA9PT0gJ3RhYlNpemUnKSB7XG4gICAgICAgICAgICB0aGlzLmluZGVudFNpemUgPSB0aGlzLnRhYlNpemU7XG4gICAgICAgICAgICB0aGlzLl9pbmRlbnRTaXplSXNUYWJTaXplID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZW50U2l6ZSA9IE1hdGgubWF4KDEsIHNyYy5pbmRlbnRTaXplIHwgMCk7XG4gICAgICAgICAgICB0aGlzLl9pbmRlbnRTaXplSXNUYWJTaXplID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnNlcnRTcGFjZXMgPSBCb29sZWFuKHNyYy5pbnNlcnRTcGFjZXMpO1xuICAgICAgICB0aGlzLmRlZmF1bHRFT0wgPSBzcmMuZGVmYXVsdEVPTCB8IDA7XG4gICAgICAgIHRoaXMudHJpbUF1dG9XaGl0ZXNwYWNlID0gQm9vbGVhbihzcmMudHJpbUF1dG9XaGl0ZXNwYWNlKTtcbiAgICAgICAgdGhpcy5icmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnMgPSBzcmMuYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnRhYlNpemUgPT09IG90aGVyLnRhYlNpemVcbiAgICAgICAgICAgICYmIHRoaXMuX2luZGVudFNpemVJc1RhYlNpemUgPT09IG90aGVyLl9pbmRlbnRTaXplSXNUYWJTaXplXG4gICAgICAgICAgICAmJiB0aGlzLmluZGVudFNpemUgPT09IG90aGVyLmluZGVudFNpemVcbiAgICAgICAgICAgICYmIHRoaXMuaW5zZXJ0U3BhY2VzID09PSBvdGhlci5pbnNlcnRTcGFjZXNcbiAgICAgICAgICAgICYmIHRoaXMuZGVmYXVsdEVPTCA9PT0gb3RoZXIuZGVmYXVsdEVPTFxuICAgICAgICAgICAgJiYgdGhpcy50cmltQXV0b1doaXRlc3BhY2UgPT09IG90aGVyLnRyaW1BdXRvV2hpdGVzcGFjZVxuICAgICAgICAgICAgJiYgZXF1YWxzKHRoaXMuYnJhY2tldFBhaXJDb2xvcml6YXRpb25PcHRpb25zLCBvdGhlci5icmFja2V0UGFpckNvbG9yaXphdGlvbk9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY3JlYXRlQ2hhbmdlRXZlbnQobmV3T3B0cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGFiU2l6ZTogdGhpcy50YWJTaXplICE9PSBuZXdPcHRzLnRhYlNpemUsXG4gICAgICAgICAgICBpbmRlbnRTaXplOiB0aGlzLmluZGVudFNpemUgIT09IG5ld09wdHMuaW5kZW50U2l6ZSxcbiAgICAgICAgICAgIGluc2VydFNwYWNlczogdGhpcy5pbnNlcnRTcGFjZXMgIT09IG5ld09wdHMuaW5zZXJ0U3BhY2VzLFxuICAgICAgICAgICAgdHJpbUF1dG9XaGl0ZXNwYWNlOiB0aGlzLnRyaW1BdXRvV2hpdGVzcGFjZSAhPT0gbmV3T3B0cy50cmltQXV0b1doaXRlc3BhY2UsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEZpbmRNYXRjaCB7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmFuZ2UsIG1hdGNoZXMpIHtcbiAgICAgICAgdGhpcy5fZmluZE1hdGNoQnJhbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJVGV4dFNuYXBzaG90KG9iaikge1xuICAgIHJldHVybiAob2JqICYmIHR5cGVvZiBvYmoucmVhZCA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgVmFsaWRBbm5vdGF0ZWRFZGl0T3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihpZGVudGlmaWVyLCByYW5nZSwgdGV4dCwgZm9yY2VNb3ZlTWFya2VycywgaXNBdXRvV2hpdGVzcGFjZUVkaXQsIF9pc1RyYWNrZWQpIHtcbiAgICAgICAgdGhpcy5pZGVudGlmaWVyID0gaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmZvcmNlTW92ZU1hcmtlcnMgPSBmb3JjZU1vdmVNYXJrZXJzO1xuICAgICAgICB0aGlzLmlzQXV0b1doaXRlc3BhY2VFZGl0ID0gaXNBdXRvV2hpdGVzcGFjZUVkaXQ7XG4gICAgICAgIHRoaXMuX2lzVHJhY2tlZCA9IF9pc1RyYWNrZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGNsYXNzIFNlYXJjaERhdGEge1xuICAgIGNvbnN0cnVjdG9yKHJlZ2V4LCB3b3JkU2VwYXJhdG9ycywgc2ltcGxlU2VhcmNoKSB7XG4gICAgICAgIHRoaXMucmVnZXggPSByZWdleDtcbiAgICAgICAgdGhpcy53b3JkU2VwYXJhdG9ycyA9IHdvcmRTZXBhcmF0b3JzO1xuICAgICAgICB0aGlzLnNpbXBsZVNlYXJjaCA9IHNpbXBsZVNlYXJjaDtcbiAgICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgY2xhc3MgQXBwbHlFZGl0c1Jlc3VsdCB7XG4gICAgY29uc3RydWN0b3IocmV2ZXJzZUVkaXRzLCBjaGFuZ2VzLCB0cmltQXV0b1doaXRlc3BhY2VMaW5lTnVtYmVycykge1xuICAgICAgICB0aGlzLnJldmVyc2VFZGl0cyA9IHJldmVyc2VFZGl0cztcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy50cmltQXV0b1doaXRlc3BhY2VMaW5lTnVtYmVycyA9IHRyaW1BdXRvV2hpdGVzcGFjZUxpbmVOdW1iZXJzO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRTeW5jaHJvbml6ZU1vZGVsKG1vZGVsKSB7XG4gICAgcmV0dXJuICghbW9kZWwuaXNUb29MYXJnZUZvclN5bmNpbmcoKSAmJiAhbW9kZWwuaXNGb3JTaW1wbGVXaWRnZXQpO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgKiBhcyBzdHJpbmdzIGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL3N0cmluZ3MuanMnO1xuaW1wb3J0IHsgZ2V0TWFwRm9yV29yZFNlcGFyYXRvcnMgfSBmcm9tICcuLi9jb3JlL3dvcmRDaGFyYWN0ZXJDbGFzc2lmaWVyLmpzJztcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgRmluZE1hdGNoLCBTZWFyY2hEYXRhIH0gZnJvbSAnLi4vbW9kZWwuanMnO1xuY29uc3QgTElNSVRfRklORF9DT1VOVCA9IDk5OTtcbmV4cG9ydCBjbGFzcyBTZWFyY2hQYXJhbXMge1xuICAgIGNvbnN0cnVjdG9yKHNlYXJjaFN0cmluZywgaXNSZWdleCwgbWF0Y2hDYXNlLCB3b3JkU2VwYXJhdG9ycykge1xuICAgICAgICB0aGlzLnNlYXJjaFN0cmluZyA9IHNlYXJjaFN0cmluZztcbiAgICAgICAgdGhpcy5pc1JlZ2V4ID0gaXNSZWdleDtcbiAgICAgICAgdGhpcy5tYXRjaENhc2UgPSBtYXRjaENhc2U7XG4gICAgICAgIHRoaXMud29yZFNlcGFyYXRvcnMgPSB3b3JkU2VwYXJhdG9ycztcbiAgICB9XG4gICAgcGFyc2VTZWFyY2hSZXF1ZXN0KCkge1xuICAgICAgICBpZiAodGhpcy5zZWFyY2hTdHJpbmcgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gY3JlYXRlIGEgUmVnRXhwIG91dCBvZiB0aGUgcGFyYW1zXG4gICAgICAgIGxldCBtdWx0aWxpbmU7XG4gICAgICAgIGlmICh0aGlzLmlzUmVnZXgpIHtcbiAgICAgICAgICAgIG11bHRpbGluZSA9IGlzTXVsdGlsaW5lUmVnZXhTb3VyY2UodGhpcy5zZWFyY2hTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbXVsdGlsaW5lID0gKHRoaXMuc2VhcmNoU3RyaW5nLmluZGV4T2YoJ1xcbicpID49IDApO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZWdleCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZWdleCA9IHN0cmluZ3MuY3JlYXRlUmVnRXhwKHRoaXMuc2VhcmNoU3RyaW5nLCB0aGlzLmlzUmVnZXgsIHtcbiAgICAgICAgICAgICAgICBtYXRjaENhc2U6IHRoaXMubWF0Y2hDYXNlLFxuICAgICAgICAgICAgICAgIHdob2xlV29yZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbXVsdGlsaW5lOiBtdWx0aWxpbmUsXG4gICAgICAgICAgICAgICAgZ2xvYmFsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVuaWNvZGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVnZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjYW5Vc2VTaW1wbGVTZWFyY2ggPSAoIXRoaXMuaXNSZWdleCAmJiAhbXVsdGlsaW5lKTtcbiAgICAgICAgaWYgKGNhblVzZVNpbXBsZVNlYXJjaCAmJiB0aGlzLnNlYXJjaFN0cmluZy50b0xvd2VyQ2FzZSgpICE9PSB0aGlzLnNlYXJjaFN0cmluZy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICAvLyBjYXNpbmcgbWlnaHQgbWFrZSBhIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIGNhblVzZVNpbXBsZVNlYXJjaCA9IHRoaXMubWF0Y2hDYXNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VhcmNoRGF0YShyZWdleCwgdGhpcy53b3JkU2VwYXJhdG9ycyA/IGdldE1hcEZvcldvcmRTZXBhcmF0b3JzKHRoaXMud29yZFNlcGFyYXRvcnMsIFtdKSA6IG51bGwsIGNhblVzZVNpbXBsZVNlYXJjaCA/IHRoaXMuc2VhcmNoU3RyaW5nIDogbnVsbCk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTXVsdGlsaW5lUmVnZXhTb3VyY2Uoc2VhcmNoU3RyaW5nKSB7XG4gICAgaWYgKCFzZWFyY2hTdHJpbmcgfHwgc2VhcmNoU3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzZWFyY2hTdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgY2hDb2RlID0gc2VhcmNoU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjaENvZGUgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hDb2RlID09PSA5MiAvKiBDaGFyQ29kZS5CYWNrc2xhc2ggKi8pIHtcbiAgICAgICAgICAgIC8vIG1vdmUgdG8gbmV4dCBjaGFyXG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoaSA+PSBsZW4pIHtcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcgZW5kcyB3aXRoIGEgXFxcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5leHRDaENvZGUgPSBzZWFyY2hTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChuZXh0Q2hDb2RlID09PSAxMTAgLyogQ2hhckNvZGUubiAqLyB8fCBuZXh0Q2hDb2RlID09PSAxMTQgLyogQ2hhckNvZGUuciAqLyB8fCBuZXh0Q2hDb2RlID09PSA4NyAvKiBDaGFyQ29kZS5XICovKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUZpbmRNYXRjaChyYW5nZSwgcmF3TWF0Y2hlcywgY2FwdHVyZU1hdGNoZXMpIHtcbiAgICBpZiAoIWNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmluZE1hdGNoKHJhbmdlLCBudWxsKTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSByYXdNYXRjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIG1hdGNoZXNbaV0gPSByYXdNYXRjaGVzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZpbmRNYXRjaChyYW5nZSwgbWF0Y2hlcyk7XG59XG5jbGFzcyBMaW5lRmVlZENvdW50ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRleHQpIHtcbiAgICAgICAgY29uc3QgbGluZUZlZWRzT2Zmc2V0cyA9IFtdO1xuICAgICAgICBsZXQgbGluZUZlZWRzT2Zmc2V0c0xlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCB0ZXh0TGVuID0gdGV4dC5sZW5ndGg7IGkgPCB0ZXh0TGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJDb2RlQXQoaSkgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XG4gICAgICAgICAgICAgICAgbGluZUZlZWRzT2Zmc2V0c1tsaW5lRmVlZHNPZmZzZXRzTGVuKytdID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saW5lRmVlZHNPZmZzZXRzID0gbGluZUZlZWRzT2Zmc2V0cztcbiAgICB9XG4gICAgZmluZExpbmVGZWVkQ291bnRCZWZvcmVPZmZzZXQob2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGxpbmVGZWVkc09mZnNldHMgPSB0aGlzLl9saW5lRmVlZHNPZmZzZXRzO1xuICAgICAgICBsZXQgbWluID0gMDtcbiAgICAgICAgbGV0IG1heCA9IGxpbmVGZWVkc09mZnNldHMubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG1heCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIG5vIGxpbmUgZmVlZHNcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgPD0gbGluZUZlZWRzT2Zmc2V0c1swXSkge1xuICAgICAgICAgICAgLy8gYmVmb3JlIGZpcnN0IGxpbmUgZmVlZFxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG1pbiA8IG1heCkge1xuICAgICAgICAgICAgY29uc3QgbWlkID0gbWluICsgKChtYXggLSBtaW4pIC8gMiA+PiAwKTtcbiAgICAgICAgICAgIGlmIChsaW5lRmVlZHNPZmZzZXRzW21pZF0gPj0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChsaW5lRmVlZHNPZmZzZXRzW21pZCArIDFdID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBiaW5nbyFcbiAgICAgICAgICAgICAgICAgICAgbWluID0gbWlkO1xuICAgICAgICAgICAgICAgICAgICBtYXggPSBtaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSBtaWQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluICsgMTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVGV4dE1vZGVsU2VhcmNoIHtcbiAgICBzdGF0aWMgZmluZE1hdGNoZXMobW9kZWwsIHNlYXJjaFBhcmFtcywgc2VhcmNoUmFuZ2UsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaERhdGEgPSBzZWFyY2hQYXJhbXMucGFyc2VTZWFyY2hSZXF1ZXN0KCk7XG4gICAgICAgIGlmICghc2VhcmNoRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWFyY2hEYXRhLnJlZ2V4Lm11bHRpbGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZE1hdGNoZXNNdWx0aWxpbmUobW9kZWwsIHNlYXJjaFJhbmdlLCBuZXcgU2VhcmNoZXIoc2VhcmNoRGF0YS53b3JkU2VwYXJhdG9ycywgc2VhcmNoRGF0YS5yZWdleCksIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZG9GaW5kTWF0Y2hlc0xpbmVCeUxpbmUobW9kZWwsIHNlYXJjaFJhbmdlLCBzZWFyY2hEYXRhLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE11bHRpbGluZSBzZWFyY2ggYWx3YXlzIGV4ZWN1dGVzIG9uIHRoZSBsaW5lcyBjb25jYXRlbmF0ZWQgd2l0aCBcXG4uXG4gICAgICogV2UgbXVzdCB0aGVyZWZvcmUgY29tcGVuc2F0ZSBmb3IgdGhlIGNvdW50IG9mIFxcbiBpbiBjYXNlIHRoZSBtb2RlbCBpcyBDUkxGXG4gICAgICovXG4gICAgc3RhdGljIF9nZXRNdWx0aWxpbmVNYXRjaFJhbmdlKG1vZGVsLCBkZWx0YU9mZnNldCwgdGV4dCwgbGZDb3VudGVyLCBtYXRjaEluZGV4LCBtYXRjaDApIHtcbiAgICAgICAgbGV0IHN0YXJ0T2Zmc2V0O1xuICAgICAgICBsZXQgbGluZUZlZWRDb3VudEJlZm9yZU1hdGNoID0gMDtcbiAgICAgICAgaWYgKGxmQ291bnRlcikge1xuICAgICAgICAgICAgbGluZUZlZWRDb3VudEJlZm9yZU1hdGNoID0gbGZDb3VudGVyLmZpbmRMaW5lRmVlZENvdW50QmVmb3JlT2Zmc2V0KG1hdGNoSW5kZXgpO1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBkZWx0YU9mZnNldCArIG1hdGNoSW5kZXggKyBsaW5lRmVlZENvdW50QmVmb3JlTWF0Y2ggLyogYWRkIGFzIG1hbnkgXFxyIGFzIHRoZXJlIHdlcmUgXFxuICovO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQgPSBkZWx0YU9mZnNldCArIG1hdGNoSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVuZE9mZnNldDtcbiAgICAgICAgaWYgKGxmQ291bnRlcikge1xuICAgICAgICAgICAgY29uc3QgbGluZUZlZWRDb3VudEJlZm9yZUVuZE9mTWF0Y2ggPSBsZkNvdW50ZXIuZmluZExpbmVGZWVkQ291bnRCZWZvcmVPZmZzZXQobWF0Y2hJbmRleCArIG1hdGNoMC5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgbGluZUZlZWRDb3VudEluTWF0Y2ggPSBsaW5lRmVlZENvdW50QmVmb3JlRW5kT2ZNYXRjaCAtIGxpbmVGZWVkQ291bnRCZWZvcmVNYXRjaDtcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgbWF0Y2gwLmxlbmd0aCArIGxpbmVGZWVkQ291bnRJbk1hdGNoIC8qIGFkZCBhcyBtYW55IFxcciBhcyB0aGVyZSB3ZXJlIFxcbiAqLztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZE9mZnNldCA9IHN0YXJ0T2Zmc2V0ICsgbWF0Y2gwLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gbW9kZWwuZ2V0UG9zaXRpb25BdChzdGFydE9mZnNldCk7XG4gICAgICAgIGNvbnN0IGVuZFBvc2l0aW9uID0gbW9kZWwuZ2V0UG9zaXRpb25BdChlbmRPZmZzZXQpO1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0UG9zaXRpb24ubGluZU51bWJlciwgc3RhcnRQb3NpdGlvbi5jb2x1bW4sIGVuZFBvc2l0aW9uLmxpbmVOdW1iZXIsIGVuZFBvc2l0aW9uLmNvbHVtbik7XG4gICAgfVxuICAgIHN0YXRpYyBfZG9GaW5kTWF0Y2hlc011bHRpbGluZShtb2RlbCwgc2VhcmNoUmFuZ2UsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICBjb25zdCBkZWx0YU9mZnNldCA9IG1vZGVsLmdldE9mZnNldEF0KHNlYXJjaFJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKSk7XG4gICAgICAgIC8vIFdlIGFsd2F5cyBleGVjdXRlIG11bHRpbGluZSBzZWFyY2ggb3ZlciB0aGUgbGluZXMgam9pbmVkIHdpdGggXFxuXG4gICAgICAgIC8vIFRoaXMgbWFrZXMgaXQgdGhhdCBcXG4gd2lsbCBtYXRjaCB0aGUgRU9MIGZvciBib3RoIENSTEYgYW5kIExGIG1vZGVsc1xuICAgICAgICAvLyBXZSBjb21wZW5zYXRlIGZvciBvZmZzZXQgZXJyb3JzIGluIGBfZ2V0TXVsdGlsaW5lTWF0Y2hSYW5nZWBcbiAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldFZhbHVlSW5SYW5nZShzZWFyY2hSYW5nZSwgMSAvKiBFbmRPZkxpbmVQcmVmZXJlbmNlLkxGICovKTtcbiAgICAgICAgY29uc3QgbGZDb3VudGVyID0gKG1vZGVsLmdldEVPTCgpID09PSAnXFxyXFxuJyA/IG5ldyBMaW5lRmVlZENvdW50ZXIodGV4dCkgOiBudWxsKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgbGV0IG07XG4gICAgICAgIHNlYXJjaGVyLnJlc2V0KDApO1xuICAgICAgICB3aGlsZSAoKG0gPSBzZWFyY2hlci5uZXh0KHRleHQpKSkge1xuICAgICAgICAgICAgcmVzdWx0W2NvdW50ZXIrK10gPSBjcmVhdGVGaW5kTWF0Y2godGhpcy5fZ2V0TXVsdGlsaW5lTWF0Y2hSYW5nZShtb2RlbCwgZGVsdGFPZmZzZXQsIHRleHQsIGxmQ291bnRlciwgbS5pbmRleCwgbVswXSksIG0sIGNhcHR1cmVNYXRjaGVzKTtcbiAgICAgICAgICAgIGlmIChjb3VudGVyID49IGxpbWl0UmVzdWx0Q291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBfZG9GaW5kTWF0Y2hlc0xpbmVCeUxpbmUobW9kZWwsIHNlYXJjaFJhbmdlLCBzZWFyY2hEYXRhLCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IHJlc3VsdExlbiA9IDA7XG4gICAgICAgIC8vIEVhcmx5IGNhc2UgZm9yIGEgc2VhcmNoIHJhbmdlIHRoYXQgc3RhcnRzICYgc3RvcHMgb24gdGhlIHNhbWUgbGluZSBudW1iZXJcbiAgICAgICAgaWYgKHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gc2VhcmNoUmFuZ2UuZW5kTGluZU51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldExpbmVDb250ZW50KHNlYXJjaFJhbmdlLnN0YXJ0TGluZU51bWJlcikuc3Vic3RyaW5nKHNlYXJjaFJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgc2VhcmNoUmFuZ2UuZW5kQ29sdW1uIC0gMSk7XG4gICAgICAgICAgICByZXN1bHRMZW4gPSB0aGlzLl9maW5kTWF0Y2hlc0luTGluZShzZWFyY2hEYXRhLCB0ZXh0LCBzZWFyY2hSYW5nZS5zdGFydExpbmVOdW1iZXIsIHNlYXJjaFJhbmdlLnN0YXJ0Q29sdW1uIC0gMSwgcmVzdWx0TGVuLCByZXN1bHQsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29sbGVjdCByZXN1bHRzIGZyb20gZmlyc3QgbGluZVxuICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQoc2VhcmNoUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyKS5zdWJzdHJpbmcoc2VhcmNoUmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKTtcbiAgICAgICAgcmVzdWx0TGVuID0gdGhpcy5fZmluZE1hdGNoZXNJbkxpbmUoc2VhcmNoRGF0YSwgdGV4dCwgc2VhcmNoUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCBzZWFyY2hSYW5nZS5zdGFydENvbHVtbiAtIDEsIHJlc3VsdExlbiwgcmVzdWx0LCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCk7XG4gICAgICAgIC8vIENvbGxlY3QgcmVzdWx0cyBmcm9tIG1pZGRsZSBsaW5lc1xuICAgICAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gc2VhcmNoUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICsgMTsgbGluZU51bWJlciA8IHNlYXJjaFJhbmdlLmVuZExpbmVOdW1iZXIgJiYgcmVzdWx0TGVuIDwgbGltaXRSZXN1bHRDb3VudDsgbGluZU51bWJlcisrKSB7XG4gICAgICAgICAgICByZXN1bHRMZW4gPSB0aGlzLl9maW5kTWF0Y2hlc0luTGluZShzZWFyY2hEYXRhLCBtb2RlbC5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKSwgbGluZU51bWJlciwgMCwgcmVzdWx0TGVuLCByZXN1bHQsIGNhcHR1cmVNYXRjaGVzLCBsaW1pdFJlc3VsdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb2xsZWN0IHJlc3VsdHMgZnJvbSBsYXN0IGxpbmVcbiAgICAgICAgaWYgKHJlc3VsdExlbiA8IGxpbWl0UmVzdWx0Q291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChzZWFyY2hSYW5nZS5lbmRMaW5lTnVtYmVyKS5zdWJzdHJpbmcoMCwgc2VhcmNoUmFuZ2UuZW5kQ29sdW1uIC0gMSk7XG4gICAgICAgICAgICByZXN1bHRMZW4gPSB0aGlzLl9maW5kTWF0Y2hlc0luTGluZShzZWFyY2hEYXRhLCB0ZXh0LCBzZWFyY2hSYW5nZS5lbmRMaW5lTnVtYmVyLCAwLCByZXN1bHRMZW4sIHJlc3VsdCwgY2FwdHVyZU1hdGNoZXMsIGxpbWl0UmVzdWx0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBfZmluZE1hdGNoZXNJbkxpbmUoc2VhcmNoRGF0YSwgdGV4dCwgbGluZU51bWJlciwgZGVsdGFPZmZzZXQsIHJlc3VsdExlbiwgcmVzdWx0LCBjYXB0dXJlTWF0Y2hlcywgbGltaXRSZXN1bHRDb3VudCkge1xuICAgICAgICBjb25zdCB3b3JkU2VwYXJhdG9ycyA9IHNlYXJjaERhdGEud29yZFNlcGFyYXRvcnM7XG4gICAgICAgIGlmICghY2FwdHVyZU1hdGNoZXMgJiYgc2VhcmNoRGF0YS5zaW1wbGVTZWFyY2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFN0cmluZyA9IHNlYXJjaERhdGEuc2ltcGxlU2VhcmNoO1xuICAgICAgICAgICAgY29uc3Qgc2VhcmNoU3RyaW5nTGVuID0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHRleHRMZW5ndGggPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBsYXN0TWF0Y2hJbmRleCA9IC1zZWFyY2hTdHJpbmdMZW47XG4gICAgICAgICAgICB3aGlsZSAoKGxhc3RNYXRjaEluZGV4ID0gdGV4dC5pbmRleE9mKHNlYXJjaFN0cmluZywgbGFzdE1hdGNoSW5kZXggKyBzZWFyY2hTdHJpbmdMZW4pKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdvcmRTZXBhcmF0b3JzIHx8IGlzVmFsaWRNYXRjaCh3b3JkU2VwYXJhdG9ycywgdGV4dCwgdGV4dExlbmd0aCwgbGFzdE1hdGNoSW5kZXgsIHNlYXJjaFN0cmluZ0xlbikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdExlbisrXSA9IG5ldyBGaW5kTWF0Y2gobmV3IFJhbmdlKGxpbmVOdW1iZXIsIGxhc3RNYXRjaEluZGV4ICsgMSArIGRlbHRhT2Zmc2V0LCBsaW5lTnVtYmVyLCBsYXN0TWF0Y2hJbmRleCArIDEgKyBzZWFyY2hTdHJpbmdMZW4gKyBkZWx0YU9mZnNldCksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0TGVuID49IGxpbWl0UmVzdWx0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRMZW47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0TGVuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlYXJjaGVyID0gbmV3IFNlYXJjaGVyKHNlYXJjaERhdGEud29yZFNlcGFyYXRvcnMsIHNlYXJjaERhdGEucmVnZXgpO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgLy8gUmVzZXQgcmVnZXggdG8gc2VhcmNoIGZyb20gdGhlIGJlZ2lubmluZ1xuICAgICAgICBzZWFyY2hlci5yZXNldCgwKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgbSA9IHNlYXJjaGVyLm5leHQodGV4dCk7XG4gICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHRMZW4rK10gPSBjcmVhdGVGaW5kTWF0Y2gobmV3IFJhbmdlKGxpbmVOdW1iZXIsIG0uaW5kZXggKyAxICsgZGVsdGFPZmZzZXQsIGxpbmVOdW1iZXIsIG0uaW5kZXggKyAxICsgbVswXS5sZW5ndGggKyBkZWx0YU9mZnNldCksIG0sIGNhcHR1cmVNYXRjaGVzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0TGVuID49IGxpbWl0UmVzdWx0Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdExlbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0TGVuO1xuICAgIH1cbiAgICBzdGF0aWMgZmluZE5leHRNYXRjaChtb2RlbCwgc2VhcmNoUGFyYW1zLCBzZWFyY2hTdGFydCwgY2FwdHVyZU1hdGNoZXMpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoRGF0YSA9IHNlYXJjaFBhcmFtcy5wYXJzZVNlYXJjaFJlcXVlc3QoKTtcbiAgICAgICAgaWYgKCFzZWFyY2hEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWFyY2hlciA9IG5ldyBTZWFyY2hlcihzZWFyY2hEYXRhLndvcmRTZXBhcmF0b3JzLCBzZWFyY2hEYXRhLnJlZ2V4KTtcbiAgICAgICAgaWYgKHNlYXJjaERhdGEucmVnZXgubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9GaW5kTmV4dE1hdGNoTXVsdGlsaW5lKG1vZGVsLCBzZWFyY2hTdGFydCwgc2VhcmNoZXIsIGNhcHR1cmVNYXRjaGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZG9GaW5kTmV4dE1hdGNoTGluZUJ5TGluZShtb2RlbCwgc2VhcmNoU3RhcnQsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgfVxuICAgIHN0YXRpYyBfZG9GaW5kTmV4dE1hdGNoTXVsdGlsaW5lKG1vZGVsLCBzZWFyY2hTdGFydCwgc2VhcmNoZXIsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFRleHRTdGFydCA9IG5ldyBQb3NpdGlvbihzZWFyY2hTdGFydC5saW5lTnVtYmVyLCAxKTtcbiAgICAgICAgY29uc3QgZGVsdGFPZmZzZXQgPSBtb2RlbC5nZXRPZmZzZXRBdChzZWFyY2hUZXh0U3RhcnQpO1xuICAgICAgICBjb25zdCBsaW5lQ291bnQgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgLy8gV2UgYWx3YXlzIGV4ZWN1dGUgbXVsdGlsaW5lIHNlYXJjaCBvdmVyIHRoZSBsaW5lcyBqb2luZWQgd2l0aCBcXG5cbiAgICAgICAgLy8gVGhpcyBtYWtlcyBpdCB0aGF0IFxcbiB3aWxsIG1hdGNoIHRoZSBFT0wgZm9yIGJvdGggQ1JMRiBhbmQgTEYgbW9kZWxzXG4gICAgICAgIC8vIFdlIGNvbXBlbnNhdGUgZm9yIG9mZnNldCBlcnJvcnMgaW4gYF9nZXRNdWx0aWxpbmVNYXRjaFJhbmdlYFxuICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwuZ2V0VmFsdWVJblJhbmdlKG5ldyBSYW5nZShzZWFyY2hUZXh0U3RhcnQubGluZU51bWJlciwgc2VhcmNoVGV4dFN0YXJ0LmNvbHVtbiwgbGluZUNvdW50LCBtb2RlbC5nZXRMaW5lTWF4Q29sdW1uKGxpbmVDb3VudCkpLCAxIC8qIEVuZE9mTGluZVByZWZlcmVuY2UuTEYgKi8pO1xuICAgICAgICBjb25zdCBsZkNvdW50ZXIgPSAobW9kZWwuZ2V0RU9MKCkgPT09ICdcXHJcXG4nID8gbmV3IExpbmVGZWVkQ291bnRlcih0ZXh0KSA6IG51bGwpO1xuICAgICAgICBzZWFyY2hlci5yZXNldChzZWFyY2hTdGFydC5jb2x1bW4gLSAxKTtcbiAgICAgICAgY29uc3QgbSA9IHNlYXJjaGVyLm5leHQodGV4dCk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRmluZE1hdGNoKHRoaXMuX2dldE11bHRpbGluZU1hdGNoUmFuZ2UobW9kZWwsIGRlbHRhT2Zmc2V0LCB0ZXh0LCBsZkNvdW50ZXIsIG0uaW5kZXgsIG1bMF0pLCBtLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXIgIT09IDEgfHwgc2VhcmNoU3RhcnQuY29sdW1uICE9PSAxKSB7XG4gICAgICAgICAgICAvLyBUcnkgYWdhaW4gZnJvbSB0aGUgdG9wXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9GaW5kTmV4dE1hdGNoTXVsdGlsaW5lKG1vZGVsLCBuZXcgUG9zaXRpb24oMSwgMSksIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBfZG9GaW5kTmV4dE1hdGNoTGluZUJ5TGluZShtb2RlbCwgc2VhcmNoU3RhcnQsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcykge1xuICAgICAgICBjb25zdCBsaW5lQ291bnQgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lTnVtYmVyID0gc2VhcmNoU3RhcnQubGluZU51bWJlcjtcbiAgICAgICAgLy8gTG9vayBpbiBmaXJzdCBsaW5lXG4gICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChzdGFydExpbmVOdW1iZXIpO1xuICAgICAgICBjb25zdCByID0gdGhpcy5fZmluZEZpcnN0TWF0Y2hJbkxpbmUoc2VhcmNoZXIsIHRleHQsIHN0YXJ0TGluZU51bWJlciwgc2VhcmNoU3RhcnQuY29sdW1uLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBsaW5lQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZUluZGV4ID0gKHN0YXJ0TGluZU51bWJlciArIGkgLSAxKSAlIGxpbmVDb3VudDtcbiAgICAgICAgICAgIGNvbnN0IHRleHQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChsaW5lSW5kZXggKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9maW5kRmlyc3RNYXRjaEluTGluZShzZWFyY2hlciwgdGV4dCwgbGluZUluZGV4ICsgMSwgMSwgY2FwdHVyZU1hdGNoZXMpO1xuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RhdGljIF9maW5kRmlyc3RNYXRjaEluTGluZShzZWFyY2hlciwgdGV4dCwgbGluZU51bWJlciwgZnJvbUNvbHVtbiwgY2FwdHVyZU1hdGNoZXMpIHtcbiAgICAgICAgLy8gU2V0IHJlZ2V4IHRvIHNlYXJjaCBmcm9tIGNvbHVtblxuICAgICAgICBzZWFyY2hlci5yZXNldChmcm9tQ29sdW1uIC0gMSk7XG4gICAgICAgIGNvbnN0IG0gPSBzZWFyY2hlci5uZXh0KHRleHQpO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUZpbmRNYXRjaChuZXcgUmFuZ2UobGluZU51bWJlciwgbS5pbmRleCArIDEsIGxpbmVOdW1iZXIsIG0uaW5kZXggKyAxICsgbVswXS5sZW5ndGgpLCBtLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBmaW5kUHJldmlvdXNNYXRjaChtb2RlbCwgc2VhcmNoUGFyYW1zLCBzZWFyY2hTdGFydCwgY2FwdHVyZU1hdGNoZXMpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoRGF0YSA9IHNlYXJjaFBhcmFtcy5wYXJzZVNlYXJjaFJlcXVlc3QoKTtcbiAgICAgICAgaWYgKCFzZWFyY2hEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWFyY2hlciA9IG5ldyBTZWFyY2hlcihzZWFyY2hEYXRhLndvcmRTZXBhcmF0b3JzLCBzZWFyY2hEYXRhLnJlZ2V4KTtcbiAgICAgICAgaWYgKHNlYXJjaERhdGEucmVnZXgubXVsdGlsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZG9GaW5kUHJldmlvdXNNYXRjaE11bHRpbGluZShtb2RlbCwgc2VhcmNoU3RhcnQsIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZFByZXZpb3VzTWF0Y2hMaW5lQnlMaW5lKG1vZGVsLCBzZWFyY2hTdGFydCwgc2VhcmNoZXIsIGNhcHR1cmVNYXRjaGVzKTtcbiAgICB9XG4gICAgc3RhdGljIF9kb0ZpbmRQcmV2aW91c01hdGNoTXVsdGlsaW5lKG1vZGVsLCBzZWFyY2hTdGFydCwgc2VhcmNoZXIsIGNhcHR1cmVNYXRjaGVzKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLl9kb0ZpbmRNYXRjaGVzTXVsdGlsaW5lKG1vZGVsLCBuZXcgUmFuZ2UoMSwgMSwgc2VhcmNoU3RhcnQubGluZU51bWJlciwgc2VhcmNoU3RhcnQuY29sdW1uKSwgc2VhcmNoZXIsIGNhcHR1cmVNYXRjaGVzLCAxMCAqIExJTUlUX0ZJTkRfQ09VTlQpO1xuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IG1vZGVsLmdldExpbmVDb3VudCgpO1xuICAgICAgICBpZiAoc2VhcmNoU3RhcnQubGluZU51bWJlciAhPT0gbGluZUNvdW50IHx8IHNlYXJjaFN0YXJ0LmNvbHVtbiAhPT0gbW9kZWwuZ2V0TGluZU1heENvbHVtbihsaW5lQ291bnQpKSB7XG4gICAgICAgICAgICAvLyBUcnkgYWdhaW4gd2l0aCBhbGwgY29udGVudFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RvRmluZFByZXZpb3VzTWF0Y2hNdWx0aWxpbmUobW9kZWwsIG5ldyBQb3NpdGlvbihsaW5lQ291bnQsIG1vZGVsLmdldExpbmVNYXhDb2x1bW4obGluZUNvdW50KSksIHNlYXJjaGVyLCBjYXB0dXJlTWF0Y2hlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBfZG9GaW5kUHJldmlvdXNNYXRjaExpbmVCeUxpbmUobW9kZWwsIHNlYXJjaFN0YXJ0LCBzZWFyY2hlciwgY2FwdHVyZU1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgbGluZUNvdW50ID0gbW9kZWwuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0TGluZU51bWJlciA9IHNlYXJjaFN0YXJ0LmxpbmVOdW1iZXI7XG4gICAgICAgIC8vIExvb2sgaW4gZmlyc3QgbGluZVxuICAgICAgICBjb25zdCB0ZXh0ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQoc3RhcnRMaW5lTnVtYmVyKS5zdWJzdHJpbmcoMCwgc2VhcmNoU3RhcnQuY29sdW1uIC0gMSk7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLl9maW5kTGFzdE1hdGNoSW5MaW5lKHNlYXJjaGVyLCB0ZXh0LCBzdGFydExpbmVOdW1iZXIsIGNhcHR1cmVNYXRjaGVzKTtcbiAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGxpbmVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5lSW5kZXggPSAobGluZUNvdW50ICsgc3RhcnRMaW5lTnVtYmVyIC0gaSAtIDEpICUgbGluZUNvdW50O1xuICAgICAgICAgICAgY29uc3QgdGV4dCA9IG1vZGVsLmdldExpbmVDb250ZW50KGxpbmVJbmRleCArIDEpO1xuICAgICAgICAgICAgY29uc3QgciA9IHRoaXMuX2ZpbmRMYXN0TWF0Y2hJbkxpbmUoc2VhcmNoZXIsIHRleHQsIGxpbmVJbmRleCArIDEsIGNhcHR1cmVNYXRjaGVzKTtcbiAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHN0YXRpYyBfZmluZExhc3RNYXRjaEluTGluZShzZWFyY2hlciwgdGV4dCwgbGluZU51bWJlciwgY2FwdHVyZU1hdGNoZXMpIHtcbiAgICAgICAgbGV0IGJlc3RSZXN1bHQgPSBudWxsO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgc2VhcmNoZXIucmVzZXQoMCk7XG4gICAgICAgIHdoaWxlICgobSA9IHNlYXJjaGVyLm5leHQodGV4dCkpKSB7XG4gICAgICAgICAgICBiZXN0UmVzdWx0ID0gY3JlYXRlRmluZE1hdGNoKG5ldyBSYW5nZShsaW5lTnVtYmVyLCBtLmluZGV4ICsgMSwgbGluZU51bWJlciwgbS5pbmRleCArIDEgKyBtWzBdLmxlbmd0aCksIG0sIGNhcHR1cmVNYXRjaGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmVzdFJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiBsZWZ0SXNXb3JkQm91bmRheSh3b3JkU2VwYXJhdG9ycywgdGV4dCwgdGV4dExlbmd0aCwgbWF0Y2hTdGFydEluZGV4LCBtYXRjaExlbmd0aCkge1xuICAgIGlmIChtYXRjaFN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgICAgLy8gTWF0Y2ggc3RhcnRzIGF0IHN0YXJ0IG9mIHN0cmluZ1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY2hhckJlZm9yZSA9IHRleHQuY2hhckNvZGVBdChtYXRjaFN0YXJ0SW5kZXggLSAxKTtcbiAgICBpZiAod29yZFNlcGFyYXRvcnMuZ2V0KGNoYXJCZWZvcmUpICE9PSAwIC8qIFdvcmRDaGFyYWN0ZXJDbGFzcy5SZWd1bGFyICovKSB7XG4gICAgICAgIC8vIFRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBtYXRjaCBpcyBhIHdvcmQgc2VwYXJhdG9yXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2hhckJlZm9yZSA9PT0gMTMgLyogQ2hhckNvZGUuQ2FycmlhZ2VSZXR1cm4gKi8gfHwgY2hhckJlZm9yZSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgLy8gVGhlIGNoYXJhY3RlciBiZWZvcmUgdGhlIG1hdGNoIGlzIGxpbmUgYnJlYWsgb3IgY2FycmlhZ2UgcmV0dXJuLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoTGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBmaXJzdENoYXJJbk1hdGNoID0gdGV4dC5jaGFyQ29kZUF0KG1hdGNoU3RhcnRJbmRleCk7XG4gICAgICAgIGlmICh3b3JkU2VwYXJhdG9ycy5nZXQoZmlyc3RDaGFySW5NYXRjaCkgIT09IDAgLyogV29yZENoYXJhY3RlckNsYXNzLlJlZ3VsYXIgKi8pIHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBjaGFyYWN0ZXIgaW5zaWRlIHRoZSBtYXRjaCBpcyBhIHdvcmQgc2VwYXJhdG9yXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByaWdodElzV29yZEJvdW5kYXkod29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpIHtcbiAgICBpZiAobWF0Y2hTdGFydEluZGV4ICsgbWF0Y2hMZW5ndGggPT09IHRleHRMZW5ndGgpIHtcbiAgICAgICAgLy8gTWF0Y2ggZW5kcyBhdCBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBjaGFyQWZ0ZXIgPSB0ZXh0LmNoYXJDb2RlQXQobWF0Y2hTdGFydEluZGV4ICsgbWF0Y2hMZW5ndGgpO1xuICAgIGlmICh3b3JkU2VwYXJhdG9ycy5nZXQoY2hhckFmdGVyKSAhPT0gMCAvKiBXb3JkQ2hhcmFjdGVyQ2xhc3MuUmVndWxhciAqLykge1xuICAgICAgICAvLyBUaGUgY2hhcmFjdGVyIGFmdGVyIHRoZSBtYXRjaCBpcyBhIHdvcmQgc2VwYXJhdG9yXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY2hhckFmdGVyID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLyB8fCBjaGFyQWZ0ZXIgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XG4gICAgICAgIC8vIFRoZSBjaGFyYWN0ZXIgYWZ0ZXIgdGhlIG1hdGNoIGlzIGxpbmUgYnJlYWsgb3IgY2FycmlhZ2UgcmV0dXJuLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG1hdGNoTGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBsYXN0Q2hhckluTWF0Y2ggPSB0ZXh0LmNoYXJDb2RlQXQobWF0Y2hTdGFydEluZGV4ICsgbWF0Y2hMZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKHdvcmRTZXBhcmF0b3JzLmdldChsYXN0Q2hhckluTWF0Y2gpICE9PSAwIC8qIFdvcmRDaGFyYWN0ZXJDbGFzcy5SZWd1bGFyICovKSB7XG4gICAgICAgICAgICAvLyBUaGUgbGFzdCBjaGFyYWN0ZXIgaW4gdGhlIG1hdGNoIGlzIGEgd29yZCBzZXBhcmF0b3JcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTWF0Y2god29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpIHtcbiAgICByZXR1cm4gKGxlZnRJc1dvcmRCb3VuZGF5KHdvcmRTZXBhcmF0b3JzLCB0ZXh0LCB0ZXh0TGVuZ3RoLCBtYXRjaFN0YXJ0SW5kZXgsIG1hdGNoTGVuZ3RoKVxuICAgICAgICAmJiByaWdodElzV29yZEJvdW5kYXkod29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpKTtcbn1cbmV4cG9ydCBjbGFzcyBTZWFyY2hlciB7XG4gICAgY29uc3RydWN0b3Iod29yZFNlcGFyYXRvcnMsIHNlYXJjaFJlZ2V4KSB7XG4gICAgICAgIHRoaXMuX3dvcmRTZXBhcmF0b3JzID0gd29yZFNlcGFyYXRvcnM7XG4gICAgICAgIHRoaXMuX3NlYXJjaFJlZ2V4ID0gc2VhcmNoUmVnZXg7XG4gICAgICAgIHRoaXMuX3ByZXZNYXRjaFN0YXJ0SW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5fcHJldk1hdGNoTGVuZ3RoID0gMDtcbiAgICB9XG4gICAgcmVzZXQobGFzdEluZGV4KSB7XG4gICAgICAgIHRoaXMuX3NlYXJjaFJlZ2V4Lmxhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgdGhpcy5fcHJldk1hdGNoU3RhcnRJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9wcmV2TWF0Y2hMZW5ndGggPSAwO1xuICAgIH1cbiAgICBuZXh0KHRleHQpIHtcbiAgICAgICAgY29uc3QgdGV4dExlbmd0aCA9IHRleHQubGVuZ3RoO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZNYXRjaFN0YXJ0SW5kZXggKyB0aGlzLl9wcmV2TWF0Y2hMZW5ndGggPT09IHRleHRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWFjaGVkIHRoZSBlbmQgb2YgdGhlIGxpbmVcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG0gPSB0aGlzLl9zZWFyY2hSZWdleC5leGVjKHRleHQpO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtYXRjaFN0YXJ0SW5kZXggPSBtLmluZGV4O1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hMZW5ndGggPSBtWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChtYXRjaFN0YXJ0SW5kZXggPT09IHRoaXMuX3ByZXZNYXRjaFN0YXJ0SW5kZXggJiYgbWF0Y2hMZW5ndGggPT09IHRoaXMuX3ByZXZNYXRjaExlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc2VhcmNoIHJlc3VsdCBpcyBhbiBlbXB0eSBzdHJpbmcgYW5kIHdvbid0IGFkdmFuY2UgYHJlZ2V4Lmxhc3RJbmRleGAsIHNvIGByZWdleC5leGVjYCB3aWxsIHN0dWNrIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gdGhhdCBieSBhZHZhbmNpbmcgYnkgdHdvIGlmIHN1cnJvZ2F0ZSBwYWlyIGZvdW5kIGFuZCBieSBvbmUgb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdzLmdldE5leHRDb2RlUG9pbnQodGV4dCwgdGV4dExlbmd0aCwgdGhpcy5fc2VhcmNoUmVnZXgubGFzdEluZGV4KSA+IDB4RkZGRikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VhcmNoUmVnZXgubGFzdEluZGV4ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWFyY2hSZWdleC5sYXN0SW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB0aGUgcmVnZXggbWF0Y2hlcyB0aGUgc2FtZSByYW5nZSB0d2ljZVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcHJldk1hdGNoU3RhcnRJbmRleCA9IG1hdGNoU3RhcnRJbmRleDtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZNYXRjaExlbmd0aCA9IG1hdGNoTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl93b3JkU2VwYXJhdG9ycyB8fCBpc1ZhbGlkTWF0Y2godGhpcy5fd29yZFNlcGFyYXRvcnMsIHRleHQsIHRleHRMZW5ndGgsIG1hdGNoU3RhcnRJbmRleCwgbWF0Y2hMZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKG0pO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEJ1Z0luZGljYXRpbmdFcnJvciwgb25VbmV4cGVjdGVkRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG4vKipcbiAqIFRocm93cyBhbiBlcnJvciB3aXRoIHRoZSBwcm92aWRlZCBtZXNzYWdlIGlmIHRoZSBwcm92aWRlZCB2YWx1ZSBkb2VzIG5vdCBldmFsdWF0ZSB0byBhIHRydWUgSmF2YXNjcmlwdCB2YWx1ZS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGFzc2VydCguLi4pYCBpbnN0ZWFkLlxuICogVGhpcyBtZXRob2QgaXMgdXN1YWxseSB1c2VkIGxpa2UgdGhpczpcbiAqIGBgYHRzXG4gKiBpbXBvcnQgKiBhcyBhc3NlcnQgZnJvbSAndnMvYmFzZS9jb21tb24vYXNzZXJ0JztcbiAqIGFzc2VydC5vayguLi4pO1xuICogYGBgXG4gKlxuICogSG93ZXZlciwgYGFzc2VydGAgaW4gdGhhdCBleGFtcGxlIGlzIGEgdXNlciBjaG9zZW4gbmFtZS5cbiAqIFRoZXJlIGlzIG5vIHRvb2xpbmcgZm9yIGdlbmVyYXRpbmcgc3VjaCBhbiBpbXBvcnQgc3RhdGVtZW50LlxuICogVGh1cywgdGhlIGBhc3NlcnQoLi4uKWAgZnVuY3Rpb24gc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSA/IGBBc3NlcnRpb24gZmFpbGVkICgke21lc3NhZ2V9KWAgOiAnQXNzZXJ0aW9uIEZhaWxlZCcpO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcih2YWx1ZSwgbWVzc2FnZSA9ICdVbnJlYWNoYWJsZScpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG4vKipcbiAqIExpa2UgYXNzZXJ0LCBidXQgZG9lc24ndCB0aHJvdy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvZnRBc3NlcnQoY29uZGl0aW9uKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgb25VbmV4cGVjdGVkRXJyb3IobmV3IEJ1Z0luZGljYXRpbmdFcnJvcignU29mdCBBc3NlcnRpb24gRmFpbGVkJykpO1xuICAgIH1cbn1cbi8qKlxuICogY29uZGl0aW9uIG11c3QgYmUgc2lkZS1lZmZlY3QgZnJlZSFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEZuKGNvbmRpdGlvbikge1xuICAgIGlmICghY29uZGl0aW9uKCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAvLyBSZWV2YWx1YXRlIGBjb25kaXRpb25gIGFnYWluIHRvIG1ha2UgZGVidWdnaW5nIGVhc2llclxuICAgICAgICBjb25kaXRpb24oKTtcbiAgICAgICAgb25VbmV4cGVjdGVkRXJyb3IobmV3IEJ1Z0luZGljYXRpbmdFcnJvcignQXNzZXJ0aW9uIEZhaWxlZCcpKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tBZGphY2VudEl0ZW1zKGl0ZW1zLCBwcmVkaWNhdGUpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBpdGVtcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIGNvbnN0IGEgPSBpdGVtc1tpXTtcbiAgICAgICAgY29uc3QgYiA9IGl0ZW1zW2kgKyAxXTtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGUoYSwgYikpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgU2VhcmNoZXIgfSBmcm9tICcuLi9tb2RlbC90ZXh0TW9kZWxTZWFyY2guanMnO1xuaW1wb3J0ICogYXMgc3RyaW5ncyBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdHJpbmdzLmpzJztcbmltcG9ydCB7IGFzc2VydE5ldmVyIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vYXNzZXJ0LmpzJztcbmltcG9ydCB7IERFRkFVTFRfV09SRF9SRUdFWFAsIGdldFdvcmRBdFRleHQgfSBmcm9tICcuLi9jb3JlL3dvcmRIZWxwZXIuanMnO1xuZXhwb3J0IGNsYXNzIFVuaWNvZGVUZXh0TW9kZWxIaWdobGlnaHRlciB7XG4gICAgc3RhdGljIGNvbXB1dGVVbmljb2RlSGlnaGxpZ2h0cyhtb2RlbCwgb3B0aW9ucywgcmFuZ2UpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lID0gcmFuZ2UgPyByYW5nZS5zdGFydExpbmVOdW1iZXIgOiAxO1xuICAgICAgICBjb25zdCBlbmRMaW5lID0gcmFuZ2UgPyByYW5nZS5lbmRMaW5lTnVtYmVyIDogbW9kZWwuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGNvbnN0IGNvZGVQb2ludEhpZ2hsaWdodGVyID0gbmV3IENvZGVQb2ludEhpZ2hsaWdodGVyKG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBjYW5kaWRhdGVzID0gY29kZVBvaW50SGlnaGxpZ2h0ZXIuZ2V0Q2FuZGlkYXRlQ29kZVBvaW50cygpO1xuICAgICAgICBsZXQgcmVnZXg7XG4gICAgICAgIGlmIChjYW5kaWRhdGVzID09PSAnYWxsTm9uQmFzaWNBc2NpaScpIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnW15cXFxcdFxcXFxuXFxcXHJcXFxceDIwLVxcXFx4N0VdJywgJ2cnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlZ2V4ID0gbmV3IFJlZ0V4cChgJHtidWlsZFJlZ0V4cENoYXJDbGFzc0V4cHIoQXJyYXkuZnJvbShjYW5kaWRhdGVzKSl9YCwgJ2cnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWFyY2hlciA9IG5ldyBTZWFyY2hlcihudWxsLCByZWdleCk7XG4gICAgICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgICAgICBsZXQgaGFzTW9yZSA9IGZhbHNlO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgbGV0IGFtYmlndW91c0NoYXJhY3RlckNvdW50ID0gMDtcbiAgICAgICAgbGV0IGludmlzaWJsZUNoYXJhY3RlckNvdW50ID0gMDtcbiAgICAgICAgbGV0IG5vbkJhc2ljQXNjaWlDaGFyYWN0ZXJDb3VudCA9IDA7XG4gICAgICAgIGZvckxvb3A6IGZvciAobGV0IGxpbmVOdW1iZXIgPSBzdGFydExpbmUsIGxpbmVDb3VudCA9IGVuZExpbmU7IGxpbmVOdW1iZXIgPD0gbGluZUNvdW50OyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVDb250ZW50ID0gbW9kZWwuZ2V0TGluZUNvbnRlbnQobGluZU51bWJlcik7XG4gICAgICAgICAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZUNvbnRlbnQubGVuZ3RoO1xuICAgICAgICAgICAgLy8gUmVzZXQgcmVnZXggdG8gc2VhcmNoIGZyb20gdGhlIGJlZ2lubmluZ1xuICAgICAgICAgICAgc2VhcmNoZXIucmVzZXQoMCk7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgbSA9IHNlYXJjaGVyLm5leHQobGluZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gbS5pbmRleDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZEluZGV4ID0gbS5pbmRleCArIG1bMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAvLyBFeHRlbmQgcmFuZ2UgdG8gZW50aXJlIGNvZGUgcG9pbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyQ29kZUJlZm9yZSA9IGxpbmVDb250ZW50LmNoYXJDb2RlQXQoc3RhcnRJbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3MuaXNIaWdoU3Vycm9nYXRlKGNoYXJDb2RlQmVmb3JlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZW5kSW5kZXggKyAxIDwgbGluZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhckNvZGVCZWZvcmUgPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KGVuZEluZGV4IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyaW5ncy5pc0hpZ2hTdXJyb2dhdGUoY2hhckNvZGVCZWZvcmUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHIgPSBsaW5lQ29udGVudC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgd29yZCA9IGdldFdvcmRBdFRleHQoc3RhcnRJbmRleCArIDEsIERFRkFVTFRfV09SRF9SRUdFWFAsIGxpbmVDb250ZW50LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmQgJiYgd29yZC5lbmRDb2x1bW4gPD0gc3RhcnRJbmRleCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JkIGRvZXMgbm90IGluY2x1ZGUgdGhlIHByb2JsZW1hdGljIGNoYXJhY3RlciwgaWdub3JlIHRoZSB3b3JkXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoaWdobGlnaHRSZWFzb24gPSBjb2RlUG9pbnRIaWdobGlnaHRlci5zaG91bGRIaWdobGlnaHROb25CYXNpY0FTQ0lJKHN0ciwgd29yZCA/IHdvcmQud29yZCA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0UmVhc29uICE9PSAwIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25lICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0UmVhc29uID09PSAzIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5BbWJpZ3VvdXMgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbWJpZ3VvdXNDaGFyYWN0ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGlnaGxpZ2h0UmVhc29uID09PSAyIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5JbnZpc2libGUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZpc2libGVDaGFyYWN0ZXJDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaGlnaGxpZ2h0UmVhc29uID09PSAxIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25CYXNpY0FTQ0lJICovKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9uQmFzaWNBc2NpaUNoYXJhY3RlckNvdW50Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnROZXZlcihoaWdobGlnaHRSZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgTUFYX1JFU1VMVF9MRU5HVEggPSAxMDAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggPj0gTUFYX1JFU1VMVF9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNNb3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhayBmb3JMb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKGxpbmVOdW1iZXIsIHN0YXJ0SW5kZXggKyAxLCBsaW5lTnVtYmVyLCBlbmRJbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYW5nZXMsXG4gICAgICAgICAgICBoYXNNb3JlLFxuICAgICAgICAgICAgYW1iaWd1b3VzQ2hhcmFjdGVyQ291bnQsXG4gICAgICAgICAgICBpbnZpc2libGVDaGFyYWN0ZXJDb3VudCxcbiAgICAgICAgICAgIG5vbkJhc2ljQXNjaWlDaGFyYWN0ZXJDb3VudFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgY29tcHV0ZVVuaWNvZGVIaWdobGlnaHRSZWFzb24oY2hhciwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb2RlUG9pbnRIaWdobGlnaHRlciA9IG5ldyBDb2RlUG9pbnRIaWdobGlnaHRlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVhc29uID0gY29kZVBvaW50SGlnaGxpZ2h0ZXIuc2hvdWxkSGlnaGxpZ2h0Tm9uQmFzaWNBU0NJSShjaGFyLCBudWxsKTtcbiAgICAgICAgc3dpdGNoIChyZWFzb24pIHtcbiAgICAgICAgICAgIGNhc2UgMCAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uTm9uZSAqLzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNhc2UgMiAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uSW52aXNpYmxlICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6IDEgLyogVW5pY29kZUhpZ2hsaWdodGVyUmVhc29uS2luZC5JbnZpc2libGUgKi8gfTtcbiAgICAgICAgICAgIGNhc2UgMyAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uQW1iaWd1b3VzICovOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZVBvaW50ID0gY2hhci5jb2RlUG9pbnRBdCgwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmltYXJ5Q29uZnVzYWJsZSA9IGNvZGVQb2ludEhpZ2hsaWdodGVyLmFtYmlndW91c0NoYXJhY3RlcnMuZ2V0UHJpbWFyeUNvbmZ1c2FibGUoY29kZVBvaW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RBbWJpZ3VvdXNJbkxvY2FsZXMgPSBzdHJpbmdzLkFtYmlndW91c0NoYXJhY3RlcnMuZ2V0TG9jYWxlcygpLmZpbHRlcigobCkgPT4gIXN0cmluZ3MuQW1iaWd1b3VzQ2hhcmFjdGVycy5nZXRJbnN0YW5jZShuZXcgU2V0KFsuLi5vcHRpb25zLmFsbG93ZWRMb2NhbGVzLCBsXSkpLmlzQW1iaWd1b3VzKGNvZGVQb2ludCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6IDAgLyogVW5pY29kZUhpZ2hsaWdodGVyUmVhc29uS2luZC5BbWJpZ3VvdXMgKi8sIGNvbmZ1c2FibGVXaXRoOiBTdHJpbmcuZnJvbUNvZGVQb2ludChwcmltYXJ5Q29uZnVzYWJsZSksIG5vdEFtYmlndW91c0luTG9jYWxlcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAxIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25CYXNpY0FTQ0lJICovOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IGtpbmQ6IDIgLyogVW5pY29kZUhpZ2hsaWdodGVyUmVhc29uS2luZC5Ob25CYXNpY0FzY2lpICovIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFJlZ0V4cENoYXJDbGFzc0V4cHIoY29kZVBvaW50cywgZmxhZ3MpIHtcbiAgICBjb25zdCBzcmMgPSBgWyR7c3RyaW5ncy5lc2NhcGVSZWdFeHBDaGFyYWN0ZXJzKGNvZGVQb2ludHMubWFwKChpKSA9PiBTdHJpbmcuZnJvbUNvZGVQb2ludChpKSkuam9pbignJykpfV1gO1xuICAgIHJldHVybiBzcmM7XG59XG5jbGFzcyBDb2RlUG9pbnRIaWdobGlnaHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmFsbG93ZWRDb2RlUG9pbnRzID0gbmV3IFNldChvcHRpb25zLmFsbG93ZWRDb2RlUG9pbnRzKTtcbiAgICAgICAgdGhpcy5hbWJpZ3VvdXNDaGFyYWN0ZXJzID0gc3RyaW5ncy5BbWJpZ3VvdXNDaGFyYWN0ZXJzLmdldEluc3RhbmNlKG5ldyBTZXQob3B0aW9ucy5hbGxvd2VkTG9jYWxlcykpO1xuICAgIH1cbiAgICBnZXRDYW5kaWRhdGVDb2RlUG9pbnRzKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vbkJhc2ljQVNDSUkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYWxsTm9uQmFzaWNBc2NpaSc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmludmlzaWJsZUNoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3Agb2Ygc3RyaW5ncy5JbnZpc2libGVDaGFyYWN0ZXJzLmNvZGVQb2ludHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsb3dlZEludmlzaWJsZUNoYXJhY3RlcihTdHJpbmcuZnJvbUNvZGVQb2ludChjcCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldC5hZGQoY3ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFtYmlndW91c0NoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3Agb2YgdGhpcy5hbWJpZ3VvdXNDaGFyYWN0ZXJzLmdldENvbmZ1c2FibGVDb2RlUG9pbnRzKCkpIHtcbiAgICAgICAgICAgICAgICBzZXQuYWRkKGNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNwIG9mIHRoaXMuYWxsb3dlZENvZGVQb2ludHMpIHtcbiAgICAgICAgICAgIHNldC5kZWxldGUoY3ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIHNob3VsZEhpZ2hsaWdodE5vbkJhc2ljQVNDSUkoY2hhcmFjdGVyLCB3b3JkQ29udGV4dCkge1xuICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjaGFyYWN0ZXIuY29kZVBvaW50QXQoMCk7XG4gICAgICAgIGlmICh0aGlzLmFsbG93ZWRDb2RlUG9pbnRzLmhhcyhjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gMCAvKiBTaW1wbGVIaWdobGlnaHRSZWFzb24uTm9uZSAqLztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5vbkJhc2ljQVNDSUkpIHtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25CYXNpY0FTQ0lJICovO1xuICAgICAgICB9XG4gICAgICAgIGxldCBoYXNCYXNpY0FTQ0lJQ2hhcmFjdGVycyA9IGZhbHNlO1xuICAgICAgICBsZXQgaGFzTm9uQ29uZnVzYWJsZU5vbkJhc2ljQXNjaWlDaGFyYWN0ZXIgPSBmYWxzZTtcbiAgICAgICAgaWYgKHdvcmRDb250ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoYXIgb2Ygd29yZENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSBjaGFyLmNvZGVQb2ludEF0KDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmFzaWNBU0NJSSA9IHN0cmluZ3MuaXNCYXNpY0FTQ0lJKGNoYXIpO1xuICAgICAgICAgICAgICAgIGhhc0Jhc2ljQVNDSUlDaGFyYWN0ZXJzID0gaGFzQmFzaWNBU0NJSUNoYXJhY3RlcnMgfHwgaXNCYXNpY0FTQ0lJO1xuICAgICAgICAgICAgICAgIGlmICghaXNCYXNpY0FTQ0lJICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmFtYmlndW91c0NoYXJhY3RlcnMuaXNBbWJpZ3VvdXMoY29kZVBvaW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAhc3RyaW5ncy5JbnZpc2libGVDaGFyYWN0ZXJzLmlzSW52aXNpYmxlQ2hhcmFjdGVyKGNvZGVQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzTm9uQ29uZnVzYWJsZU5vbkJhc2ljQXNjaWlDaGFyYWN0ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgIC8qIERvbid0IGFsbG93IG1peGluZyB3ZWlyZCBsb29raW5nIGNoYXJhY3RlcnMgd2l0aCBBU0NJSSAqLyAhaGFzQmFzaWNBU0NJSUNoYXJhY3RlcnMgJiZcbiAgICAgICAgICAgIC8qIElzIHRoZXJlIGFuIG9idmlvdXNseSB3ZWlyZCBsb29raW5nIGNoYXJhY3Rlcj8gKi8gaGFzTm9uQ29uZnVzYWJsZU5vbkJhc2ljQXNjaWlDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5Ob25lICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW52aXNpYmxlQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgLy8gVE9ETyBjaGVjayBmb3IgZW1vamlzXG4gICAgICAgICAgICBpZiAoIWlzQWxsb3dlZEludmlzaWJsZUNoYXJhY3RlcihjaGFyYWN0ZXIpICYmIHN0cmluZ3MuSW52aXNpYmxlQ2hhcmFjdGVycy5pc0ludmlzaWJsZUNoYXJhY3Rlcihjb2RlUG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogU2ltcGxlSGlnaGxpZ2h0UmVhc29uLkludmlzaWJsZSAqLztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFtYmlndW91c0NoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFtYmlndW91c0NoYXJhY3RlcnMuaXNBbWJpZ3VvdXMoY29kZVBvaW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAzIC8qIFNpbXBsZUhpZ2hsaWdodFJlYXNvbi5BbWJpZ3VvdXMgKi87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAgLyogU2ltcGxlSGlnaGxpZ2h0UmVhc29uLk5vbmUgKi87XG4gICAgfVxufVxuZnVuY3Rpb24gaXNBbGxvd2VkSW52aXNpYmxlQ2hhcmFjdGVyKGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIgPT09ICcgJyB8fCBjaGFyYWN0ZXIgPT09ICdcXG4nIHx8IGNoYXJhY3RlciA9PT0gJ1xcdCc7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBjbGFzcyBMaW5lc0RpZmYge1xuICAgIGNvbnN0cnVjdG9yKGNoYW5nZXMsIFxuICAgIC8qKlxuICAgICAqIFNvcnRlZCBieSBvcmlnaW5hbCBsaW5lIHJhbmdlcy5cbiAgICAgKiBUaGUgb3JpZ2luYWwgbGluZSByYW5nZXMgYW5kIHRoZSBtb2RpZmllZCBsaW5lIHJhbmdlcyBtdXN0IGJlIGRpc2pvaW50IChidXQgY2FuIGJlIHRvdWNoaW5nKS5cbiAgICAgKi9cbiAgICBtb3ZlcywgXG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoZSB0aW1lIG91dCB3YXMgcmVhY2hlZC5cbiAgICAgKiBJbiB0aGF0IGNhc2UsIHRoZSBkaWZmcyBtaWdodCBiZSBhbiBhcHByb3hpbWF0aW9uIGFuZCB0aGUgdXNlciBzaG91bGQgYmUgYXNrZWQgdG8gcmVydW4gdGhlIGRpZmYgd2l0aCBtb3JlIHRpbWUuXG4gICAgICovXG4gICAgaGl0VGltZW91dCkge1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgICAgICB0aGlzLm1vdmVzID0gbW92ZXM7XG4gICAgICAgIHRoaXMuaGl0VGltZW91dCA9IGhpdFRpbWVvdXQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1vdmVkVGV4dCB7XG4gICAgY29uc3RydWN0b3IobGluZVJhbmdlTWFwcGluZywgY2hhbmdlcykge1xuICAgICAgICB0aGlzLmxpbmVSYW5nZU1hcHBpbmcgPSBsaW5lUmFuZ2VNYXBwaW5nO1xuICAgICAgICB0aGlzLmNoYW5nZXMgPSBjaGFuZ2VzO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgQnVnSW5kaWNhdGluZ0Vycm9yIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXJyb3JzLmpzJztcbi8qKlxuICogQSByYW5nZSBvZiBvZmZzZXRzICgwLWJhc2VkKS5cbiovXG5leHBvcnQgY2xhc3MgT2Zmc2V0UmFuZ2Uge1xuICAgIHN0YXRpYyBhZGRSYW5nZShyYW5nZSwgc29ydGVkUmFuZ2VzKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBzb3J0ZWRSYW5nZXMubGVuZ3RoICYmIHNvcnRlZFJhbmdlc1tpXS5lbmRFeGNsdXNpdmUgPCByYW5nZS5zdGFydCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBqID0gaTtcbiAgICAgICAgd2hpbGUgKGogPCBzb3J0ZWRSYW5nZXMubGVuZ3RoICYmIHNvcnRlZFJhbmdlc1tqXS5zdGFydCA8PSByYW5nZS5lbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgc29ydGVkUmFuZ2VzLnNwbGljZShpLCAwLCByYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKHJhbmdlLnN0YXJ0LCBzb3J0ZWRSYW5nZXNbaV0uc3RhcnQpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gTWF0aC5tYXgocmFuZ2UuZW5kRXhjbHVzaXZlLCBzb3J0ZWRSYW5nZXNbaiAtIDFdLmVuZEV4Y2x1c2l2ZSk7XG4gICAgICAgICAgICBzb3J0ZWRSYW5nZXMuc3BsaWNlKGksIGogLSBpLCBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyB0cnlDcmVhdGUoc3RhcnQsIGVuZEV4Y2x1c2l2ZSkge1xuICAgICAgICBpZiAoc3RhcnQgPiBlbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRSYW5nZShzdGFydCwgZW5kRXhjbHVzaXZlKTtcbiAgICB9XG4gICAgc3RhdGljIG9mTGVuZ3RoKGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIHN0YXRpYyBvZlN0YXJ0QW5kTGVuZ3RoKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRSYW5nZShzdGFydCwgc3RhcnQgKyBsZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kRXhjbHVzaXZlKSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5lbmRFeGNsdXNpdmUgPSBlbmRFeGNsdXNpdmU7XG4gICAgICAgIGlmIChzdGFydCA+IGVuZEV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcihgSW52YWxpZCByYW5nZTogJHt0aGlzLnRvU3RyaW5nKCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ID09PSB0aGlzLmVuZEV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgZGVsdGEob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2UodGhpcy5zdGFydCArIG9mZnNldCwgdGhpcy5lbmRFeGNsdXNpdmUgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBkZWx0YVN0YXJ0KG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKHRoaXMuc3RhcnQgKyBvZmZzZXQsIHRoaXMuZW5kRXhjbHVzaXZlKTtcbiAgICB9XG4gICAgZGVsdGFFbmQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2UodGhpcy5zdGFydCwgdGhpcy5lbmRFeGNsdXNpdmUgKyBvZmZzZXQpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbmRFeGNsdXNpdmUgLSB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YXJ0fSwgJHt0aGlzLmVuZEV4Y2x1c2l2ZX0pYDtcbiAgICB9XG4gICAgY29udGFpbnMob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0IDw9IG9mZnNldCAmJiBvZmZzZXQgPCB0aGlzLmVuZEV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogZm9yIGFsbCBudW1iZXJzIG46IHJhbmdlMS5jb250YWlucyhuKSBvciByYW5nZTIuY29udGFpbnMobikgPT4gcmFuZ2UxLmpvaW4ocmFuZ2UyKS5jb250YWlucyhuKVxuICAgICAqIFRoZSBqb2luZWQgcmFuZ2UgaXMgdGhlIHNtYWxsZXN0IHJhbmdlIHRoYXQgY29udGFpbnMgYm90aCByYW5nZXMuXG4gICAgICovXG4gICAgam9pbihvdGhlcikge1xuICAgICAgICByZXR1cm4gbmV3IE9mZnNldFJhbmdlKE1hdGgubWluKHRoaXMuc3RhcnQsIG90aGVyLnN0YXJ0KSwgTWF0aC5tYXgodGhpcy5lbmRFeGNsdXNpdmUsIG90aGVyLmVuZEV4Y2x1c2l2ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBmb3IgYWxsIG51bWJlcnMgbjogcmFuZ2UxLmNvbnRhaW5zKG4pIGFuZCByYW5nZTIuY29udGFpbnMobikgPD0+IHJhbmdlMS5pbnRlcnNlY3QocmFuZ2UyKS5jb250YWlucyhuKVxuICAgICAqXG4gICAgICogVGhlIHJlc3VsdGluZyByYW5nZSBpcyBlbXB0eSBpZiB0aGUgcmFuZ2VzIGRvIG5vdCBpbnRlcnNlY3QsIGJ1dCB0b3VjaC5cbiAgICAgKiBJZiB0aGUgcmFuZ2VzIGRvbid0IGV2ZW4gdG91Y2gsIHRoZSByZXN1bHQgaXMgdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGludGVyc2VjdChvdGhlcikge1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHRoaXMuc3RhcnQsIG90aGVyLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4odGhpcy5lbmRFeGNsdXNpdmUsIG90aGVyLmVuZEV4Y2x1c2l2ZSk7XG4gICAgICAgIGlmIChzdGFydCA8PSBlbmQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaW50ZXJzZWN0cyhvdGhlcikge1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KHRoaXMuc3RhcnQsIG90aGVyLnN0YXJ0KTtcbiAgICAgICAgY29uc3QgZW5kID0gTWF0aC5taW4odGhpcy5lbmRFeGNsdXNpdmUsIG90aGVyLmVuZEV4Y2x1c2l2ZSk7XG4gICAgICAgIHJldHVybiBzdGFydCA8IGVuZDtcbiAgICB9XG4gICAgaXNCZWZvcmUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kRXhjbHVzaXZlIDw9IG90aGVyLnN0YXJ0O1xuICAgIH1cbiAgICBpc0FmdGVyKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ID49IG90aGVyLmVuZEV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgc2xpY2UoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnIuc2xpY2UodGhpcy5zdGFydCwgdGhpcy5lbmRFeGNsdXNpdmUpO1xuICAgIH1cbiAgICBzdWJzdHJpbmcoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyaW5nKHRoaXMuc3RhcnQsIHRoaXMuZW5kRXhjbHVzaXZlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZ2l2ZW4gdmFsdWUgaWYgaXQgaXMgY29udGFpbmVkIGluIHRoaXMgaW5zdGFuY2UsIG90aGVyd2lzZSB0aGUgY2xvc2VzdCB2YWx1ZSB0aGF0IGlzIGNvbnRhaW5lZC5cbiAgICAgKiBUaGUgcmFuZ2UgbXVzdCBub3QgYmUgZW1wdHkuXG4gICAgICovXG4gICAgY2xpcCh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKGBJbnZhbGlkIGNsaXBwaW5nIHJhbmdlOiAke3RoaXMudG9TdHJpbmcoKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5zdGFydCwgTWF0aC5taW4odGhpcy5lbmRFeGNsdXNpdmUgLSAxLCB2YWx1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGByIDo9IHZhbHVlICsgayAqIGxlbmd0aGAgc3VjaCB0aGF0IGByYCBpcyBjb250YWluZWQgaW4gdGhpcyByYW5nZS5cbiAgICAgKiBUaGUgcmFuZ2UgbXVzdCBub3QgYmUgZW1wdHkuXG4gICAgICpcbiAgICAgKiBFLmcuIGBbNSwgMTApLmNsaXBDeWNsaWMoMTApID09PSA1YCwgYFs1LCAxMCkuY2xpcEN5Y2xpYygxMSkgPT09IDZgIGFuZCBgWzUsIDEwKS5jbGlwQ3ljbGljKDQpID09PSA5YC5cbiAgICAgKi9cbiAgICBjbGlwQ3ljbGljKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoYEludmFsaWQgY2xpcHBpbmcgcmFuZ2U6ICR7dGhpcy50b1N0cmluZygpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA8IHRoaXMuc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZEV4Y2x1c2l2ZSAtICgodGhpcy5zdGFydCAtIHZhbHVlKSAlIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5lbmRFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ICsgKCh2YWx1ZSAtIHRoaXMuc3RhcnQpICUgdGhpcy5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXJ0OyBpIDwgdGhpcy5lbmRFeGNsdXNpdmU7IGkrKykge1xuICAgICAgICAgICAgZihpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPZmZzZXRSYW5nZVNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3NvcnRlZFJhbmdlcyA9IFtdO1xuICAgIH1cbiAgICBhZGRSYW5nZShyYW5nZSkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgdGhpcy5fc29ydGVkUmFuZ2VzLmxlbmd0aCAmJiB0aGlzLl9zb3J0ZWRSYW5nZXNbaV0uZW5kRXhjbHVzaXZlIDwgcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgaiA9IGk7XG4gICAgICAgIHdoaWxlIChqIDwgdGhpcy5fc29ydGVkUmFuZ2VzLmxlbmd0aCAmJiB0aGlzLl9zb3J0ZWRSYW5nZXNbal0uc3RhcnQgPD0gcmFuZ2UuZW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPT09IGopIHtcbiAgICAgICAgICAgIHRoaXMuX3NvcnRlZFJhbmdlcy5zcGxpY2UoaSwgMCwgcmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1pbihyYW5nZS5zdGFydCwgdGhpcy5fc29ydGVkUmFuZ2VzW2ldLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWF4KHJhbmdlLmVuZEV4Y2x1c2l2ZSwgdGhpcy5fc29ydGVkUmFuZ2VzW2ogLSAxXS5lbmRFeGNsdXNpdmUpO1xuICAgICAgICAgICAgdGhpcy5fc29ydGVkUmFuZ2VzLnNwbGljZShpLCBqIC0gaSwgbmV3IE9mZnNldFJhbmdlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnRlZFJhbmdlcy5tYXAociA9PiByLnRvU3RyaW5nKCkpLmpvaW4oJywgJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgb2YgdGhlcmUgaXMgYSB2YWx1ZSB0aGF0IGlzIGNvbnRhaW5lZCBpbiB0aGlzIGluc3RhbmNlIGFuZCB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICAgICovXG4gICAgaW50ZXJzZWN0c1N0cmljdChvdGhlcikge1xuICAgICAgICAvLyBUT0RPIHVzZSBiaW5hcnkgc2VhcmNoXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCB0aGlzLl9zb3J0ZWRSYW5nZXMubGVuZ3RoICYmIHRoaXMuX3NvcnRlZFJhbmdlc1tpXS5lbmRFeGNsdXNpdmUgPD0gb3RoZXIuc3RhcnQpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaSA8IHRoaXMuX3NvcnRlZFJhbmdlcy5sZW5ndGggJiYgdGhpcy5fc29ydGVkUmFuZ2VzW2ldLnN0YXJ0IDwgb3RoZXIuZW5kRXhjbHVzaXZlO1xuICAgIH1cbiAgICBpbnRlcnNlY3RXaXRoUmFuZ2Uob3RoZXIpIHtcbiAgICAgICAgLy8gVE9ETyB1c2UgYmluYXJ5IHNlYXJjaCArIHNsaWNlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBPZmZzZXRSYW5nZVNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHJhbmdlIG9mIHRoaXMuX3NvcnRlZFJhbmdlcykge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uID0gcmFuZ2UuaW50ZXJzZWN0KG90aGVyKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuYWRkUmFuZ2UoaW50ZXJzZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpbnRlcnNlY3RXaXRoUmFuZ2VMZW5ndGgob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0V2l0aFJhbmdlKG90aGVyKS5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zb3J0ZWRSYW5nZXMucmVkdWNlKChwcmV2LCBjdXIpID0+IHByZXYgKyBjdXIubGVuZ3RoLCAwKTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGFzdChhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgY29uc3QgaWR4ID0gZmluZExhc3RJZHgoYXJyYXksIHByZWRpY2F0ZSk7XG4gICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5W2lkeF07XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZExhc3RJZHgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IGkgPSBmcm9tSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBhcnJheVtpXTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgbGFzdCBpdGVtIHdoZXJlIHByZWRpY2F0ZSBpcyB0cnVlIHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gKiBgcHJlZGljYXRlYCBtdXN0IGJlIG1vbm90b25vdXMsIGkuZS4gYGFyci5tYXAocHJlZGljYXRlKWAgbXVzdCBiZSBsaWtlIGBbdHJ1ZSwgLi4uLCB0cnVlLCBmYWxzZSwgLi4uLCBmYWxzZV1gIVxuICpcbiAqIEByZXR1cm5zIGB1bmRlZmluZWRgIGlmIG5vIGl0ZW0gbWF0Y2hlcywgb3RoZXJ3aXNlIHRoZSBsYXN0IGl0ZW0gdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGFzdE1vbm90b25vdXMoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IGlkeCA9IGZpbmRMYXN0SWR4TW9ub3Rvbm91cyhhcnJheSwgcHJlZGljYXRlKTtcbiAgICByZXR1cm4gaWR4ID09PSAtMSA/IHVuZGVmaW5lZCA6IGFycmF5W2lkeF07XG59XG4vKipcbiAqIEZpbmRzIHRoZSBsYXN0IGl0ZW0gd2hlcmUgcHJlZGljYXRlIGlzIHRydWUgdXNpbmcgYmluYXJ5IHNlYXJjaC5cbiAqIGBwcmVkaWNhdGVgIG11c3QgYmUgbW9ub3Rvbm91cywgaS5lLiBgYXJyLm1hcChwcmVkaWNhdGUpYCBtdXN0IGJlIGxpa2UgYFt0cnVlLCAuLi4sIHRydWUsIGZhbHNlLCAuLi4sIGZhbHNlXWAhXG4gKlxuICogQHJldHVybnMgYHN0YXJ0SWR4IC0gMWAgaWYgcHJlZGljYXRlIGlzIGZhbHNlIGZvciBhbGwgaXRlbXMsIG90aGVyd2lzZSB0aGUgaW5kZXggb2YgdGhlIGxhc3QgaXRlbSB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRMYXN0SWR4TW9ub3Rvbm91cyhhcnJheSwgcHJlZGljYXRlLCBzdGFydElkeCA9IDAsIGVuZElkeEV4ID0gYXJyYXkubGVuZ3RoKSB7XG4gICAgbGV0IGkgPSBzdGFydElkeDtcbiAgICBsZXQgaiA9IGVuZElkeEV4O1xuICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICBjb25zdCBrID0gTWF0aC5mbG9vcigoaSArIGopIC8gMik7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlba10pKSB7XG4gICAgICAgICAgICBpID0gayArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqID0gaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaSAtIDE7XG59XG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBpdGVtIHdoZXJlIHByZWRpY2F0ZSBpcyB0cnVlIHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gKiBgcHJlZGljYXRlYCBtdXN0IGJlIG1vbm90b25vdXMsIGkuZS4gYGFyci5tYXAocHJlZGljYXRlKWAgbXVzdCBiZSBsaWtlIGBbZmFsc2UsIC4uLiwgZmFsc2UsIHRydWUsIC4uLiwgdHJ1ZV1gIVxuICpcbiAqIEByZXR1cm5zIGB1bmRlZmluZWRgIGlmIG5vIGl0ZW0gbWF0Y2hlcywgb3RoZXJ3aXNlIHRoZSBmaXJzdCBpdGVtIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0TW9ub3Rvbm91cyhhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgY29uc3QgaWR4ID0gZmluZEZpcnN0SWR4TW9ub3Rvbm91c09yQXJyTGVuKGFycmF5LCBwcmVkaWNhdGUpO1xuICAgIHJldHVybiBpZHggPT09IGFycmF5Lmxlbmd0aCA/IHVuZGVmaW5lZCA6IGFycmF5W2lkeF07XG59XG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBpdGVtIHdoZXJlIHByZWRpY2F0ZSBpcyB0cnVlIHVzaW5nIGJpbmFyeSBzZWFyY2guXG4gKiBgcHJlZGljYXRlYCBtdXN0IGJlIG1vbm90b25vdXMsIGkuZS4gYGFyci5tYXAocHJlZGljYXRlKWAgbXVzdCBiZSBsaWtlIGBbZmFsc2UsIC4uLiwgZmFsc2UsIHRydWUsIC4uLiwgdHJ1ZV1gIVxuICpcbiAqIEByZXR1cm5zIGBlbmRJZHhFeGAgaWYgcHJlZGljYXRlIGlzIGZhbHNlIGZvciBhbGwgaXRlbXMsIG90aGVyd2lzZSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGl0ZW0gdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlyc3RJZHhNb25vdG9ub3VzT3JBcnJMZW4oYXJyYXksIHByZWRpY2F0ZSwgc3RhcnRJZHggPSAwLCBlbmRJZHhFeCA9IGFycmF5Lmxlbmd0aCkge1xuICAgIGxldCBpID0gc3RhcnRJZHg7XG4gICAgbGV0IGogPSBlbmRJZHhFeDtcbiAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgY29uc3QgayA9IE1hdGguZmxvb3IoKGkgKyBqKSAvIDIpO1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2tdKSkge1xuICAgICAgICAgICAgaiA9IGs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpID0gayArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG4vKipcbiAqIFVzZSB0aGlzIHdoZW5cbiAqICogWW91IGhhdmUgYSBzb3J0ZWQgYXJyYXlcbiAqICogWW91IHF1ZXJ5IHRoaXMgYXJyYXkgd2l0aCBhIG1vbm90b25vdXMgcHJlZGljYXRlIHRvIGZpbmQgdGhlIGxhc3QgaXRlbSB0aGF0IGhhcyBhIGNlcnRhaW4gcHJvcGVydHkuXG4gKiAqIFlvdSBxdWVyeSB0aGlzIGFycmF5IG11bHRpcGxlIHRpbWVzIHdpdGggbW9ub3Rvbm91cyBwcmVkaWNhdGVzIHRoYXQgZ2V0IHdlYWtlciBhbmQgd2Vha2VyLlxuICovXG5leHBvcnQgY2xhc3MgTW9ub3Rvbm91c0FycmF5IHtcbiAgICBjb25zdHJ1Y3RvcihfYXJyYXkpIHtcbiAgICAgICAgdGhpcy5fYXJyYXkgPSBfYXJyYXk7XG4gICAgICAgIHRoaXMuX2ZpbmRMYXN0TW9ub3Rvbm91c0xhc3RJZHggPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcHJlZGljYXRlIG11c3QgYmUgbW9ub3Rvbm91cywgaS5lLiBgYXJyLm1hcChwcmVkaWNhdGUpYCBtdXN0IGJlIGxpa2UgYFt0cnVlLCAuLi4sIHRydWUsIGZhbHNlLCAuLi4sIGZhbHNlXWAhXG4gICAgICogRm9yIHN1YnNlcXVlbnQgY2FsbHMsIGN1cnJlbnQgcHJlZGljYXRlIG11c3QgYmUgd2Vha2VyIHRoYW4gKG9yIGVxdWFsIHRvKSB0aGUgcHJldmlvdXMgcHJlZGljYXRlLCBpLmUuIG1vcmUgZW50cmllcyBtdXN0IGJlIGB0cnVlYC5cbiAgICAgKi9cbiAgICBmaW5kTGFzdE1vbm90b25vdXMocHJlZGljYXRlKSB7XG4gICAgICAgIGlmIChNb25vdG9ub3VzQXJyYXkuYXNzZXJ0SW52YXJpYW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZGaW5kTGFzdFByZWRpY2F0ZSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLl9hcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcHJldkZpbmRMYXN0UHJlZGljYXRlKGl0ZW0pICYmICFwcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTW9ub3Rvbm91c0FycmF5OiBjdXJyZW50IHByZWRpY2F0ZSBtdXN0IGJlIHdlYWtlciB0aGFuIChvciBlcXVhbCB0bykgdGhlIHByZXZpb3VzIHByZWRpY2F0ZS4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3ByZXZGaW5kTGFzdFByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHggPSBmaW5kTGFzdElkeE1vbm90b25vdXModGhpcy5fYXJyYXksIHByZWRpY2F0ZSwgdGhpcy5fZmluZExhc3RNb25vdG9ub3VzTGFzdElkeCk7XG4gICAgICAgIHRoaXMuX2ZpbmRMYXN0TW9ub3Rvbm91c0xhc3RJZHggPSBpZHggKyAxO1xuICAgICAgICByZXR1cm4gaWR4ID09PSAtMSA/IHVuZGVmaW5lZCA6IHRoaXMuX2FycmF5W2lkeF07XG4gICAgfVxufVxuTW9ub3Rvbm91c0FycmF5LmFzc2VydEludmFyaWFudHMgPSBmYWxzZTtcbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgaXRlbSB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBldmVyeSBvdGhlciBpdGVtLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRmlyc3RNYXgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxldCBtYXggPSBhcnJheVswXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaXRlbSwgbWF4KSA+IDApIHtcbiAgICAgICAgICAgIG1heCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBpdGVtIHRoYXQgaXMgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIGV2ZXJ5IG90aGVyIGl0ZW0uXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRMYXN0TWF4KGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgbWF4ID0gYXJyYXlbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpdGVtID0gYXJyYXlbaV07XG4gICAgICAgIGlmIChjb21wYXJhdG9yKGl0ZW0sIG1heCkgPj0gMCkge1xuICAgICAgICAgICAgbWF4ID0gaXRlbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBpdGVtIHRoYXQgaXMgZXF1YWwgdG8gb3IgbGVzcyB0aGFuIGV2ZXJ5IG90aGVyIGl0ZW0uXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdE1pbihhcnJheSwgY29tcGFyYXRvcikge1xuICAgIHJldHVybiBmaW5kRmlyc3RNYXgoYXJyYXksIChhLCBiKSA9PiAtY29tcGFyYXRvcihhLCBiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZE1heElkeChhcnJheSwgY29tcGFyYXRvcikge1xuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBsZXQgbWF4SWR4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgICAgaWYgKGNvbXBhcmF0b3IoaXRlbSwgYXJyYXlbbWF4SWR4XSkgPiAwKSB7XG4gICAgICAgICAgICBtYXhJZHggPSBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXhJZHg7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IG1hcHBlZCB2YWx1ZSBvZiB0aGUgYXJyYXkgd2hpY2ggaXMgbm90IHVuZGVmaW5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcEZpbmRGaXJzdChpdGVtcywgbWFwRm4pIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZCA9IG1hcEZuKHZhbHVlKTtcbiAgICAgICAgaWYgKG1hcHBlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFwcGVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IEJ1Z0luZGljYXRpbmdFcnJvciB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4vb2Zmc2V0UmFuZ2UuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuL3JhbmdlLmpzJztcbmltcG9ydCB7IGZpbmRGaXJzdElkeE1vbm90b25vdXNPckFyckxlbiwgZmluZExhc3RJZHhNb25vdG9ub3VzLCBmaW5kTGFzdE1vbm90b25vdXMgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXNGaW5kLmpzJztcbi8qKlxuICogQSByYW5nZSBvZiBsaW5lcyAoMS1iYXNlZCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBMaW5lUmFuZ2Uge1xuICAgIHN0YXRpYyBmcm9tUmFuZ2VJbmNsdXNpdmUocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2UocmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyICsgMSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBsaW5lUmFuZ2VzIEFuIGFycmF5IG9mIHNvcnRlZCBsaW5lIHJhbmdlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgam9pbk1hbnkobGluZVJhbmdlcykge1xuICAgICAgICBpZiAobGluZVJhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gbmV3IExpbmVSYW5nZVNldChsaW5lUmFuZ2VzWzBdLnNsaWNlKCkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5nZXRVbmlvbihuZXcgTGluZVJhbmdlU2V0KGxpbmVSYW5nZXNbaV0uc2xpY2UoKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQucmFuZ2VzO1xuICAgIH1cbiAgICBzdGF0aWMgam9pbihsaW5lUmFuZ2VzKSB7XG4gICAgICAgIGlmIChsaW5lUmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcignbGluZVJhbmdlcyBjYW5ub3QgYmUgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRMaW5lTnVtYmVyID0gbGluZVJhbmdlc1swXS5zdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBlbmRMaW5lTnVtYmVyRXhjbHVzaXZlID0gbGluZVJhbmdlc1swXS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGxpbmVSYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0TGluZU51bWJlciA9IE1hdGgubWluKHN0YXJ0TGluZU51bWJlciwgbGluZVJhbmdlc1tpXS5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICAgICAgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9IE1hdGgubWF4KGVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIGxpbmVSYW5nZXNbaV0uZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCBlbmRMaW5lTnVtYmVyRXhjbHVzaXZlKTtcbiAgICB9XG4gICAgc3RhdGljIG9mTGVuZ3RoKHN0YXJ0TGluZU51bWJlciwgbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlKHN0YXJ0TGluZU51bWJlciwgc3RhcnRMaW5lTnVtYmVyICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgc3RhdGljIGRlc2VyaWFsaXplKGxpbmVSYW5nZSkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZShsaW5lUmFuZ2VbMF0sIGxpbmVSYW5nZVsxXSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHN0YXJ0TGluZU51bWJlciwgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkge1xuICAgICAgICBpZiAoc3RhcnRMaW5lTnVtYmVyID4gZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcihgc3RhcnRMaW5lTnVtYmVyICR7c3RhcnRMaW5lTnVtYmVyfSBjYW5ub3QgYmUgYWZ0ZXIgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAke2VuZExpbmVOdW1iZXJFeGNsdXNpdmV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydExpbmVOdW1iZXIgPSBzdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9IGVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGlzIGxpbmUgcmFuZ2UgY29udGFpbnMgdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxuICAgICAqL1xuICAgIGNvbnRhaW5zKGxpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRMaW5lTnVtYmVyIDw9IGxpbmVOdW1iZXIgJiYgbGluZU51bWJlciA8IHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIGlmIHRoaXMgbGluZSByYW5nZSBpcyBlbXB0eS5cbiAgICAgKi9cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRMaW5lTnVtYmVyID09PSB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vdmVzIHRoaXMgbGluZSByYW5nZSBieSB0aGUgZ2l2ZW4gb2Zmc2V0IG9mIGxpbmUgbnVtYmVycy5cbiAgICAgKi9cbiAgICBkZWx0YShvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIgKyBvZmZzZXQsIHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSArIG9mZnNldCk7XG4gICAgfVxuICAgIGRlbHRhTGVuZ3RoKG9mZnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZSh0aGlzLnN0YXJ0TGluZU51bWJlciwgdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBsaW5lcyB0aGlzIGxpbmUgcmFuZ2Ugc3BhbnMuXG4gICAgICovXG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAtIHRoaXMuc3RhcnRMaW5lTnVtYmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbGluZSByYW5nZSB0aGF0IGNvbWJpbmVzIHRoaXMgYW5kIHRoZSBnaXZlbiBsaW5lIHJhbmdlLlxuICAgICAqL1xuICAgIGpvaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2UoTWF0aC5taW4odGhpcy5zdGFydExpbmVOdW1iZXIsIG90aGVyLnN0YXJ0TGluZU51bWJlciksIE1hdGgubWF4KHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgb3RoZXIuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSkpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGBbJHt0aGlzLnN0YXJ0TGluZU51bWJlcn0sJHt0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmV9KWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZXN1bHRpbmcgcmFuZ2UgaXMgZW1wdHkgaWYgdGhlIHJhbmdlcyBkbyBub3QgaW50ZXJzZWN0LCBidXQgdG91Y2guXG4gICAgICogSWYgdGhlIHJhbmdlcyBkb24ndCBldmVuIHRvdWNoLCB0aGUgcmVzdWx0IGlzIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBpbnRlcnNlY3Qob3RoZXIpIHtcbiAgICAgICAgY29uc3Qgc3RhcnRMaW5lTnVtYmVyID0gTWF0aC5tYXgodGhpcy5zdGFydExpbmVOdW1iZXIsIG90aGVyLnN0YXJ0TGluZU51bWJlcik7XG4gICAgICAgIGNvbnN0IGVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPSBNYXRoLm1pbih0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIG90aGVyLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xuICAgICAgICBpZiAoc3RhcnRMaW5lTnVtYmVyIDw9IGVuZExpbmVOdW1iZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlKHN0YXJ0TGluZU51bWJlciwgZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaW50ZXJzZWN0c1N0cmljdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydExpbmVOdW1iZXIgPCBvdGhlci5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICYmIG90aGVyLnN0YXJ0TGluZU51bWJlciA8IHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgb3ZlcmxhcE9yVG91Y2gob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRMaW5lTnVtYmVyIDw9IG90aGVyLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgJiYgb3RoZXIuc3RhcnRMaW5lTnVtYmVyIDw9IHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgZXF1YWxzKGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRMaW5lTnVtYmVyID09PSBiLnN0YXJ0TGluZU51bWJlciAmJiB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPT09IGIuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcbiAgICB9XG4gICAgdG9JbmNsdXNpdmVSYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZSh0aGlzLnN0YXJ0TGluZU51bWJlciwgMSwgdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2luZyB0aGlzIGZ1bmN0aW9uIGlzIGRpc2NvdXJhZ2VkIGJlY2F1c2UgaXQgbWlnaHQgbGVhZCB0byBidWdzOiBUaGUgZW5kIHBvc2l0aW9uIGlzIG5vdCBndWFyYW50ZWVkIHRvIGJlIGEgdmFsaWQgcG9zaXRpb24hXG4gICAgKi9cbiAgICB0b0V4Y2x1c2l2ZVJhbmdlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHRoaXMuc3RhcnRMaW5lTnVtYmVyLCAxLCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIDEpO1xuICAgIH1cbiAgICBtYXBUb0xpbmVBcnJheShmKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gdGhpcy5zdGFydExpbmVOdW1iZXI7IGxpbmVOdW1iZXIgPCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7IGxpbmVOdW1iZXIrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZihsaW5lTnVtYmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGZvciAobGV0IGxpbmVOdW1iZXIgPSB0aGlzLnN0YXJ0TGluZU51bWJlcjsgbGluZU51bWJlciA8IHRoaXMuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTsgbGluZU51bWJlcisrKSB7XG4gICAgICAgICAgICBmKGxpbmVOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSgpIHtcbiAgICAgICAgcmV0dXJuIFt0aGlzLnN0YXJ0TGluZU51bWJlciwgdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlXTtcbiAgICB9XG4gICAgaW5jbHVkZXMobGluZU51bWJlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydExpbmVOdW1iZXIgPD0gbGluZU51bWJlciAmJiBsaW5lTnVtYmVyIDwgdGhpcy5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGlzIDEtYmFzZWQgbGluZSByYW5nZSB0byBhIDAtYmFzZWQgb2Zmc2V0IHJhbmdlIChzdWJ0cmFjdHMgMSEpLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRvT2Zmc2V0UmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2UodGhpcy5zdGFydExpbmVOdW1iZXIgLSAxLCB0aGlzLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSAxKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTGluZVJhbmdlU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBTb3J0ZWQgYnkgc3RhcnQgbGluZSBudW1iZXIuXG4gICAgICogTm8gdHdvIGxpbmUgcmFuZ2VzIGFyZSB0b3VjaGluZyBvciBpbnRlcnNlY3RpbmcuXG4gICAgICovXG4gICAgX25vcm1hbGl6ZWRSYW5nZXMgPSBbXSkge1xuICAgICAgICB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzID0gX25vcm1hbGl6ZWRSYW5nZXM7XG4gICAgfVxuICAgIGdldCByYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzO1xuICAgIH1cbiAgICBhZGRSYW5nZShyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWRlYTogRmluZCBqb2luUmFuZ2Ugc3VjaCB0aGF0OlxuICAgICAgICAvLyByZXBsYWNlUmFuZ2UgPSBfbm9ybWFsaXplZFJhbmdlcy5yZXBsYWNlUmFuZ2Uoam9pblJhbmdlLCByYW5nZS5qb2luQWxsKGpvaW5SYW5nZS5tYXAoaWR4ID0+IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXNbaWR4XSkpKVxuICAgICAgICAvLyBpZHggb2YgZmlyc3QgZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2Ugb3IgdGhhdCBpcyBhZnRlciByYW5nZVxuICAgICAgICBjb25zdCBqb2luUmFuZ2VTdGFydElkeCA9IGZpbmRGaXJzdElkeE1vbm90b25vdXNPckFyckxlbih0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLCByID0+IHIuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA+PSByYW5nZS5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICAvLyBpZHggb2YgZWxlbWVudCBhZnRlciB7IGxhc3QgZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2Ugb3IgdGhhdCBpcyBiZWZvcmUgcmFuZ2UgfVxuICAgICAgICBjb25zdCBqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUgPSBmaW5kTGFzdElkeE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8PSByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSArIDE7XG4gICAgICAgIGlmIChqb2luUmFuZ2VTdGFydElkeCA9PT0gam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBlbGVtZW50IHRoYXQgdG91Y2hlcyByYW5nZSwgdGhlbiBqb2luUmFuZ2VTdGFydElkeCA9PT0gam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlIGFuZCB0aGF0IHZhbHVlIGlzIHRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCBhZnRlciByYW5nZVxuICAgICAgICAgICAgdGhpcy5fbm9ybWFsaXplZFJhbmdlcy5zcGxpY2Uoam9pblJhbmdlU3RhcnRJZHgsIDAsIHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqb2luUmFuZ2VTdGFydElkeCA9PT0gam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlIC0gMSkge1xuICAgICAgICAgICAgLy8gRWxzZSwgdGhlcmUgaXMgYW4gZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2UgYW5kIGluIHRoaXMgY2FzZSBpdCBpcyBib3RoIHRoZSBmaXJzdCBhbmQgbGFzdCBlbGVtZW50LiBUaHVzIHdlIGNhbiByZXBsYWNlIGl0XG4gICAgICAgICAgICBjb25zdCBqb2luUmFuZ2UgPSB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2pvaW5SYW5nZVN0YXJ0SWR4XTtcbiAgICAgICAgICAgIHRoaXMuX25vcm1hbGl6ZWRSYW5nZXNbam9pblJhbmdlU3RhcnRJZHhdID0gam9pblJhbmdlLmpvaW4ocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmlyc3QgYW5kIGxhc3QgZWxlbWVudCBhcmUgZGlmZmVyZW50IC0gd2UgbmVlZCB0byByZXBsYWNlIHRoZSBlbnRpcmUgcmFuZ2VcbiAgICAgICAgICAgIGNvbnN0IGpvaW5SYW5nZSA9IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXNbam9pblJhbmdlU3RhcnRJZHhdLmpvaW4odGhpcy5fbm9ybWFsaXplZFJhbmdlc1tqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUgLSAxXSkuam9pbihyYW5nZSk7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLnNwbGljZShqb2luUmFuZ2VTdGFydElkeCwgam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlIC0gam9pblJhbmdlU3RhcnRJZHgsIGpvaW5SYW5nZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29udGFpbnMobGluZU51bWJlcikge1xuICAgICAgICBjb25zdCByYW5nZVRoYXRTdGFydHNCZWZvcmVFbmQgPSBmaW5kTGFzdE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8PSBsaW5lTnVtYmVyKTtcbiAgICAgICAgcmV0dXJuICEhcmFuZ2VUaGF0U3RhcnRzQmVmb3JlRW5kICYmIHJhbmdlVGhhdFN0YXJ0c0JlZm9yZUVuZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID4gbGluZU51bWJlcjtcbiAgICB9XG4gICAgaW50ZXJzZWN0cyhyYW5nZSkge1xuICAgICAgICBjb25zdCByYW5nZVRoYXRTdGFydHNCZWZvcmVFbmQgPSBmaW5kTGFzdE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8IHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xuICAgICAgICByZXR1cm4gISFyYW5nZVRoYXRTdGFydHNCZWZvcmVFbmQgJiYgcmFuZ2VUaGF0U3RhcnRzQmVmb3JlRW5kLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPiByYW5nZS5zdGFydExpbmVOdW1iZXI7XG4gICAgfVxuICAgIGdldFVuaW9uKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci5fbm9ybWFsaXplZFJhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaTEgPSAwO1xuICAgICAgICBsZXQgaTIgPSAwO1xuICAgICAgICBsZXQgY3VycmVudCA9IG51bGw7XG4gICAgICAgIHdoaWxlIChpMSA8IHRoaXMuX25vcm1hbGl6ZWRSYW5nZXMubGVuZ3RoIHx8IGkyIDwgb3RoZXIuX25vcm1hbGl6ZWRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaTEgPCB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCAmJiBpMiA8IG90aGVyLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVSYW5nZTEgPSB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2kxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lUmFuZ2UyID0gb3RoZXIuX25vcm1hbGl6ZWRSYW5nZXNbaTJdO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lUmFuZ2UxLnN0YXJ0TGluZU51bWJlciA8IGxpbmVSYW5nZTIuc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQgPSBsaW5lUmFuZ2UxO1xuICAgICAgICAgICAgICAgICAgICBpMSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IGxpbmVSYW5nZTI7XG4gICAgICAgICAgICAgICAgICAgIGkyKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaTEgPCB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG5leHQgPSB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2kxXTtcbiAgICAgICAgICAgICAgICBpMSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV4dCA9IG90aGVyLl9ub3JtYWxpemVkUmFuZ2VzW2kyXTtcbiAgICAgICAgICAgICAgICBpMisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50LmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPj0gbmV4dC5zdGFydExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbWVyZ2VcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBMaW5lUmFuZ2UoY3VycmVudC5zdGFydExpbmVOdW1iZXIsIE1hdGgubWF4KGN1cnJlbnQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSwgbmV4dC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBwdXNoXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlU2V0KHJlc3VsdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnRyYWN0cyBhbGwgcmFuZ2VzIGluIHRoaXMgc2V0IGZyb20gYHJhbmdlYCBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHN1YnRyYWN0RnJvbShyYW5nZSkge1xuICAgICAgICAvLyBpZHggb2YgZmlyc3QgZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2Ugb3IgdGhhdCBpcyBhZnRlciByYW5nZVxuICAgICAgICBjb25zdCBqb2luUmFuZ2VTdGFydElkeCA9IGZpbmRGaXJzdElkeE1vbm90b25vdXNPckFyckxlbih0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLCByID0+IHIuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA+PSByYW5nZS5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICAvLyBpZHggb2YgZWxlbWVudCBhZnRlciB7IGxhc3QgZWxlbWVudCB0aGF0IHRvdWNoZXMgcmFuZ2Ugb3IgdGhhdCBpcyBiZWZvcmUgcmFuZ2UgfVxuICAgICAgICBjb25zdCBqb2luUmFuZ2VFbmRJZHhFeGNsdXNpdmUgPSBmaW5kTGFzdElkeE1vbm90b25vdXModGhpcy5fbm9ybWFsaXplZFJhbmdlcywgciA9PiByLnN0YXJ0TGluZU51bWJlciA8PSByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSArIDE7XG4gICAgICAgIGlmIChqb2luUmFuZ2VTdGFydElkeCA9PT0gam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZVNldChbcmFuZ2VdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IHN0YXJ0TGluZU51bWJlciA9IHJhbmdlLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IGpvaW5SYW5nZVN0YXJ0SWR4OyBpIDwgam9pblJhbmdlRW5kSWR4RXhjbHVzaXZlOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2ldO1xuICAgICAgICAgICAgaWYgKHIuc3RhcnRMaW5lTnVtYmVyID4gc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IExpbmVSYW5nZShzdGFydExpbmVOdW1iZXIsIHIuc3RhcnRMaW5lTnVtYmVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydExpbmVOdW1iZXIgPSByLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0TGluZU51bWJlciA8IHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lUmFuZ2Uoc3RhcnRMaW5lTnVtYmVyLCByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2VTZXQocmVzdWx0KTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLm1hcChyID0+IHIudG9TdHJpbmcoKSkuam9pbignLCAnKTtcbiAgICB9XG4gICAgZ2V0SW50ZXJzZWN0aW9uKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgaTEgPSAwO1xuICAgICAgICBsZXQgaTIgPSAwO1xuICAgICAgICB3aGlsZSAoaTEgPCB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCAmJiBpMiA8IG90aGVyLl9ub3JtYWxpemVkUmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcjEgPSB0aGlzLl9ub3JtYWxpemVkUmFuZ2VzW2kxXTtcbiAgICAgICAgICAgIGNvbnN0IHIyID0gb3RoZXIuX25vcm1hbGl6ZWRSYW5nZXNbaTJdO1xuICAgICAgICAgICAgY29uc3QgaSA9IHIxLmludGVyc2VjdChyMik7XG4gICAgICAgICAgICBpZiAoaSAmJiAhaS5pc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocjEuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IHIyLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICBpMSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaTIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IExpbmVSYW5nZVNldChyZXN1bHQpO1xuICAgIH1cbiAgICBnZXRXaXRoRGVsdGEodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2VTZXQodGhpcy5fbm9ybWFsaXplZFJhbmdlcy5tYXAociA9PiByLmRlbHRhKHZhbHVlKSkpO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi9yYW5nZS5qcyc7XG4vKipcbiAqIFJlcHJlc2VudHMgYSBub24tbmVnYXRpdmUgbGVuZ3RoIG9mIHRleHQgaW4gdGVybXMgb2YgbGluZSBhbmQgY29sdW1uIGNvdW50LlxuKi9cbmV4cG9ydCBjbGFzcyBUZXh0TGVuZ3RoIHtcbiAgICBzdGF0aWMgYmV0d2VlblBvc2l0aW9ucyhwb3NpdGlvbjEsIHBvc2l0aW9uMikge1xuICAgICAgICBpZiAocG9zaXRpb24xLmxpbmVOdW1iZXIgPT09IHBvc2l0aW9uMi5saW5lTnVtYmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRMZW5ndGgoMCwgcG9zaXRpb24yLmNvbHVtbiAtIHBvc2l0aW9uMS5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUZXh0TGVuZ3RoKHBvc2l0aW9uMi5saW5lTnVtYmVyIC0gcG9zaXRpb24xLmxpbmVOdW1iZXIsIHBvc2l0aW9uMi5jb2x1bW4gLSAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgb2ZSYW5nZShyYW5nZSkge1xuICAgICAgICByZXR1cm4gVGV4dExlbmd0aC5iZXR3ZWVuUG9zaXRpb25zKHJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKSwgcmFuZ2UuZ2V0RW5kUG9zaXRpb24oKSk7XG4gICAgfVxuICAgIHN0YXRpYyBvZlRleHQodGV4dCkge1xuICAgICAgICBsZXQgbGluZSA9IDA7XG4gICAgICAgIGxldCBjb2x1bW4gPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdGV4dCkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgbGluZSsrO1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRleHRMZW5ndGgobGluZSwgY29sdW1uKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IobGluZUNvdW50LCBjb2x1bW5Db3VudCkge1xuICAgICAgICB0aGlzLmxpbmVDb3VudCA9IGxpbmVDb3VudDtcbiAgICAgICAgdGhpcy5jb2x1bW5Db3VudCA9IGNvbHVtbkNvdW50O1xuICAgIH1cbiAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVDb3VudCAhPT0gb3RoZXIubGluZUNvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5saW5lQ291bnQgPiBvdGhlci5saW5lQ291bnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uQ291bnQgPj0gb3RoZXIuY29sdW1uQ291bnQ7XG4gICAgfVxuICAgIGNyZWF0ZVJhbmdlKHN0YXJ0UG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMubGluZUNvdW50ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0UG9zaXRpb24ubGluZU51bWJlciwgc3RhcnRQb3NpdGlvbi5jb2x1bW4sIHN0YXJ0UG9zaXRpb24ubGluZU51bWJlciwgc3RhcnRQb3NpdGlvbi5jb2x1bW4gKyB0aGlzLmNvbHVtbkNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnRQb3NpdGlvbi5saW5lTnVtYmVyLCBzdGFydFBvc2l0aW9uLmNvbHVtbiwgc3RhcnRQb3NpdGlvbi5saW5lTnVtYmVyICsgdGhpcy5saW5lQ291bnQsIHRoaXMuY29sdW1uQ291bnQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRUb1Bvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLmxpbmVDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb3NpdGlvbihwb3NpdGlvbi5saW5lTnVtYmVyLCBwb3NpdGlvbi5jb2x1bW4gKyB0aGlzLmNvbHVtbkNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24ocG9zaXRpb24ubGluZU51bWJlciArIHRoaXMubGluZUNvdW50LCB0aGlzLmNvbHVtbkNvdW50ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmxpbmVDb3VudH0sJHt0aGlzLmNvbHVtbkNvdW50fWA7XG4gICAgfVxufVxuVGV4dExlbmd0aC56ZXJvID0gbmV3IFRleHRMZW5ndGgoMCwgMCk7XG4iLCJpbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4vb2Zmc2V0UmFuZ2UuanMnO1xuaW1wb3J0IHsgVGV4dExlbmd0aCB9IGZyb20gJy4vdGV4dExlbmd0aC5qcyc7XG5leHBvcnQgY2xhc3MgUG9zaXRpb25PZmZzZXRUcmFuc2Zvcm1lciB7XG4gICAgY29uc3RydWN0b3IodGV4dCkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmxpbmVTdGFydE9mZnNldEJ5TGluZUlkeCA9IFtdO1xuICAgICAgICB0aGlzLmxpbmVTdGFydE9mZnNldEJ5TGluZUlkeC5wdXNoKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0ZXh0LmNoYXJBdChpKSA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVTdGFydE9mZnNldEJ5TGluZUlkeC5wdXNoKGkgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRPZmZzZXQocG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZVN0YXJ0T2Zmc2V0QnlMaW5lSWR4W3Bvc2l0aW9uLmxpbmVOdW1iZXIgLSAxXSArIHBvc2l0aW9uLmNvbHVtbiAtIDE7XG4gICAgfVxuICAgIGdldE9mZnNldFJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2UodGhpcy5nZXRPZmZzZXQocmFuZ2UuZ2V0U3RhcnRQb3NpdGlvbigpKSwgdGhpcy5nZXRPZmZzZXQocmFuZ2UuZ2V0RW5kUG9zaXRpb24oKSkpO1xuICAgIH1cbiAgICBnZXQgdGV4dExlbmd0aCgpIHtcbiAgICAgICAgY29uc3QgbGluZUlkeCA9IHRoaXMubGluZVN0YXJ0T2Zmc2V0QnlMaW5lSWR4Lmxlbmd0aCAtIDE7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dExlbmd0aChsaW5lSWR4LCB0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy5saW5lU3RhcnRPZmZzZXRCeUxpbmVJZHhbbGluZUlkeF0pO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgYXNzZXJ0Rm4sIGNoZWNrQWRqYWNlbnRJdGVtcyB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBCdWdJbmRpY2F0aW5nRXJyb3IgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFBvc2l0aW9uT2Zmc2V0VHJhbnNmb3JtZXIgfSBmcm9tICcuL3Bvc2l0aW9uVG9PZmZzZXQuanMnO1xuaW1wb3J0IHsgUmFuZ2UgfSBmcm9tICcuL3JhbmdlLmpzJztcbmltcG9ydCB7IFRleHRMZW5ndGggfSBmcm9tICcuL3RleHRMZW5ndGguanMnO1xuZXhwb3J0IGNsYXNzIFRleHRFZGl0IHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0cykge1xuICAgICAgICB0aGlzLmVkaXRzID0gZWRpdHM7XG4gICAgICAgIGFzc2VydEZuKCgpID0+IGNoZWNrQWRqYWNlbnRJdGVtcyhlZGl0cywgKGEsIGIpID0+IGEucmFuZ2UuZ2V0RW5kUG9zaXRpb24oKS5pc0JlZm9yZU9yRXF1YWwoYi5yYW5nZS5nZXRTdGFydFBvc2l0aW9uKCkpKSk7XG4gICAgfVxuICAgIGFwcGx5KHRleHQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9ICcnO1xuICAgICAgICBsZXQgbGFzdEVkaXRFbmQgPSBuZXcgUG9zaXRpb24oMSwgMSk7XG4gICAgICAgIGZvciAoY29uc3QgZWRpdCBvZiB0aGlzLmVkaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBlZGl0UmFuZ2UgPSBlZGl0LnJhbmdlO1xuICAgICAgICAgICAgY29uc3QgZWRpdFN0YXJ0ID0gZWRpdFJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRFbmQgPSBlZGl0UmFuZ2UuZ2V0RW5kUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSByYW5nZUZyb21Qb3NpdGlvbnMobGFzdEVkaXRFbmQsIGVkaXRTdGFydCk7XG4gICAgICAgICAgICBpZiAoIXIuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRleHQuZ2V0VmFsdWVPZlJhbmdlKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ICs9IGVkaXQudGV4dDtcbiAgICAgICAgICAgIGxhc3RFZGl0RW5kID0gZWRpdEVuZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gcmFuZ2VGcm9tUG9zaXRpb25zKGxhc3RFZGl0RW5kLCB0ZXh0LmVuZFBvc2l0aW9uRXhjbHVzaXZlKTtcbiAgICAgICAgaWYgKCFyLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRleHQuZ2V0VmFsdWVPZlJhbmdlKHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFwcGx5VG9TdHJpbmcoc3RyKSB7XG4gICAgICAgIGNvbnN0IHN0clRleHQgPSBuZXcgU3RyaW5nVGV4dChzdHIpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseShzdHJUZXh0KTtcbiAgICB9XG4gICAgZ2V0TmV3UmFuZ2VzKCkge1xuICAgICAgICBjb25zdCBuZXdSYW5nZXMgPSBbXTtcbiAgICAgICAgbGV0IHByZXZpb3VzRWRpdEVuZExpbmVOdW1iZXIgPSAwO1xuICAgICAgICBsZXQgbGluZU9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjb2x1bW5PZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXQgb2YgdGhpcy5lZGl0cykge1xuICAgICAgICAgICAgY29uc3QgdGV4dExlbmd0aCA9IFRleHRMZW5ndGgub2ZUZXh0KGVkaXQudGV4dCk7XG4gICAgICAgICAgICBjb25zdCBuZXdSYW5nZVN0YXJ0ID0gUG9zaXRpb24ubGlmdCh7XG4gICAgICAgICAgICAgICAgbGluZU51bWJlcjogZWRpdC5yYW5nZS5zdGFydExpbmVOdW1iZXIgKyBsaW5lT2Zmc2V0LFxuICAgICAgICAgICAgICAgIGNvbHVtbjogZWRpdC5yYW5nZS5zdGFydENvbHVtbiArIChlZGl0LnJhbmdlLnN0YXJ0TGluZU51bWJlciA9PT0gcHJldmlvdXNFZGl0RW5kTGluZU51bWJlciA/IGNvbHVtbk9mZnNldCA6IDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1JhbmdlID0gdGV4dExlbmd0aC5jcmVhdGVSYW5nZShuZXdSYW5nZVN0YXJ0KTtcbiAgICAgICAgICAgIG5ld1Jhbmdlcy5wdXNoKG5ld1JhbmdlKTtcbiAgICAgICAgICAgIGxpbmVPZmZzZXQgPSBuZXdSYW5nZS5lbmRMaW5lTnVtYmVyIC0gZWRpdC5yYW5nZS5lbmRMaW5lTnVtYmVyO1xuICAgICAgICAgICAgY29sdW1uT2Zmc2V0ID0gbmV3UmFuZ2UuZW5kQ29sdW1uIC0gZWRpdC5yYW5nZS5lbmRDb2x1bW47XG4gICAgICAgICAgICBwcmV2aW91c0VkaXRFbmRMaW5lTnVtYmVyID0gZWRpdC5yYW5nZS5lbmRMaW5lTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdSYW5nZXM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFNpbmdsZVRleHRFZGl0IHtcbiAgICBjb25zdHJ1Y3RvcihyYW5nZSwgdGV4dCkge1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcmFuZ2VGcm9tUG9zaXRpb25zKHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAoc3RhcnQubGluZU51bWJlciA9PT0gZW5kLmxpbmVOdW1iZXIgJiYgc3RhcnQuY29sdW1uID09PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICByZXR1cm4gUmFuZ2UuZnJvbVBvc2l0aW9ucyhlbmQsIGVuZCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzdGFydC5pc0JlZm9yZU9yRXF1YWwoZW5kKSkge1xuICAgICAgICB0aHJvdyBuZXcgQnVnSW5kaWNhdGluZ0Vycm9yKCdzdGFydCBtdXN0IGJlIGJlZm9yZSBlbmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSYW5nZShzdGFydC5saW5lTnVtYmVyLCBzdGFydC5jb2x1bW4sIGVuZC5saW5lTnVtYmVyLCBlbmQuY29sdW1uKTtcbn1cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFRleHQge1xuICAgIGdldCBlbmRQb3NpdGlvbkV4Y2x1c2l2ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoLmFkZFRvUG9zaXRpb24obmV3IFBvc2l0aW9uKDEsIDEpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgU3RyaW5nVGV4dCBleHRlbmRzIEFic3RyYWN0VGV4dCB7XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl90ID0gbmV3IFBvc2l0aW9uT2Zmc2V0VHJhbnNmb3JtZXIodGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIGdldFZhbHVlT2ZSYW5nZShyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdC5nZXRPZmZzZXRSYW5nZShyYW5nZSkuc3Vic3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdC50ZXh0TGVuZ3RoO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgQnVnSW5kaWNhdGluZ0Vycm9yIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vZXJyb3JzLmpzJztcbmltcG9ydCB7IExpbmVSYW5nZSB9IGZyb20gJy4uL2NvcmUvbGluZVJhbmdlLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBTaW5nbGVUZXh0RWRpdCB9IGZyb20gJy4uL2NvcmUvdGV4dEVkaXQuanMnO1xuLyoqXG4gKiBNYXBzIGEgbGluZSByYW5nZSBpbiB0aGUgb3JpZ2luYWwgdGV4dCBtb2RlbCB0byBhIGxpbmUgcmFuZ2UgaW4gdGhlIG1vZGlmaWVkIHRleHQgbW9kZWwuXG4gKi9cbmV4cG9ydCBjbGFzcyBMaW5lUmFuZ2VNYXBwaW5nIHtcbiAgICBzdGF0aWMgaW52ZXJzZShtYXBwaW5nLCBvcmlnaW5hbExpbmVDb3VudCwgbW9kaWZpZWRMaW5lQ291bnQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBsYXN0T3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gMTtcbiAgICAgICAgbGV0IGxhc3RNb2RpZmllZEVuZExpbmVOdW1iZXIgPSAxO1xuICAgICAgICBmb3IgKGNvbnN0IG0gb2YgbWFwcGluZykge1xuICAgICAgICAgICAgY29uc3QgciA9IG5ldyBMaW5lUmFuZ2VNYXBwaW5nKG5ldyBMaW5lUmFuZ2UobGFzdE9yaWdpbmFsRW5kTGluZU51bWJlciwgbS5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIpLCBuZXcgTGluZVJhbmdlKGxhc3RNb2RpZmllZEVuZExpbmVOdW1iZXIsIG0ubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyKSk7XG4gICAgICAgICAgICBpZiAoIXIubW9kaWZpZWQuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdE9yaWdpbmFsRW5kTGluZU51bWJlciA9IG0ub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcbiAgICAgICAgICAgIGxhc3RNb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IG5ldyBMaW5lUmFuZ2VNYXBwaW5nKG5ldyBMaW5lUmFuZ2UobGFzdE9yaWdpbmFsRW5kTGluZU51bWJlciwgb3JpZ2luYWxMaW5lQ291bnQgKyAxKSwgbmV3IExpbmVSYW5nZShsYXN0TW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBtb2RpZmllZExpbmVDb3VudCArIDEpKTtcbiAgICAgICAgaWYgKCFyLm1vZGlmaWVkLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBjbGlwKG1hcHBpbmcsIG9yaWdpbmFsUmFuZ2UsIG1vZGlmaWVkUmFuZ2UpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbSBvZiBtYXBwaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbCA9IG0ub3JpZ2luYWwuaW50ZXJzZWN0KG9yaWdpbmFsUmFuZ2UpO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWQgPSBtLm1vZGlmaWVkLmludGVyc2VjdChtb2RpZmllZFJhbmdlKTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbCAmJiAhb3JpZ2luYWwuaXNFbXB0eSAmJiBtb2RpZmllZCAmJiAhbW9kaWZpZWQuaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBMaW5lUmFuZ2VNYXBwaW5nKG9yaWdpbmFsLCBtb2RpZmllZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsUmFuZ2UsIG1vZGlmaWVkUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5vcmlnaW5hbCA9IG9yaWdpbmFsUmFuZ2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBtb2RpZmllZFJhbmdlO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGB7JHt0aGlzLm9yaWdpbmFsLnRvU3RyaW5nKCl9LT4ke3RoaXMubW9kaWZpZWQudG9TdHJpbmcoKX19YDtcbiAgICB9XG4gICAgZmxpcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lUmFuZ2VNYXBwaW5nKHRoaXMubW9kaWZpZWQsIHRoaXMub3JpZ2luYWwpO1xuICAgIH1cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZVJhbmdlTWFwcGluZyh0aGlzLm9yaWdpbmFsLmpvaW4ob3RoZXIub3JpZ2luYWwpLCB0aGlzLm1vZGlmaWVkLmpvaW4ob3RoZXIubW9kaWZpZWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgYXNzdW1lcyB0aGF0IHRoZSBMaW5lUmFuZ2VNYXBwaW5nIGRlc2NyaWJlcyBhIHZhbGlkIGRpZmYhXG4gICAgICogSS5lLiBpZiBvbmUgcmFuZ2UgaXMgZW1wdHksIHRoZSBvdGhlciByYW5nZSBjYW5ub3QgYmUgdGhlIGVudGlyZSBkb2N1bWVudC5cbiAgICAgKiBJdCBhdm9pZHMgdmFyaW91cyBwcm9ibGVtcyB3aGVuIHRoZSBsaW5lIHJhbmdlIHBvaW50cyB0byBub24tZXhpc3RpbmcgbGluZS1udW1iZXJzLlxuICAgICovXG4gICAgdG9SYW5nZU1hcHBpbmcoKSB7XG4gICAgICAgIGNvbnN0IG9yaWdJbmNsdXNpdmVSYW5nZSA9IHRoaXMub3JpZ2luYWwudG9JbmNsdXNpdmVSYW5nZSgpO1xuICAgICAgICBjb25zdCBtb2RJbmNsdXNpdmVSYW5nZSA9IHRoaXMubW9kaWZpZWQudG9JbmNsdXNpdmVSYW5nZSgpO1xuICAgICAgICBpZiAob3JpZ0luY2x1c2l2ZVJhbmdlICYmIG1vZEluY2x1c2l2ZVJhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlTWFwcGluZyhvcmlnSW5jbHVzaXZlUmFuZ2UsIG1vZEluY2x1c2l2ZVJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciA9PT0gMSB8fCB0aGlzLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgPT09IDEgJiYgdGhpcy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgPT09IDEpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgb25lIGxpbmUgcmFuZ2Ugc3RhcnRzIGF0IDEsIHRoZSBvdGhlciBvbmUgbXVzdCBzdGFydCBhdCAxIGFzIHdlbGwuXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJ1Z0luZGljYXRpbmdFcnJvcignbm90IGEgdmFsaWQgZGlmZicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQmVjYXVzZSBvbmUgcmFuZ2UgaXMgZW1wdHkgYW5kIGJvdGggcmFuZ2VzIHN0YXJ0IGF0IGxpbmUgMSwgbm9uZSBvZiB0aGUgcmFuZ2VzIGNhbiBjb3ZlciBhbGwgbGluZXMuXG4gICAgICAgICAgICAvLyBUaHVzLCBgZW5kTGluZU51bWJlckV4Y2x1c2l2ZWAgaXMgYSB2YWxpZCBsaW5lIG51bWJlci5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmFuZ2VNYXBwaW5nKG5ldyBSYW5nZSh0aGlzLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciwgMSwgdGhpcy5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCAxKSwgbmV3IFJhbmdlKHRoaXMubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyLCAxLCB0aGlzLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBhc3N1bWUgaGVyZSB0aGF0IGJvdGggc3RhcnRMaW5lTnVtYmVycyBhcmUgZ3JlYXRlciB0aGFuIDEuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlTWFwcGluZyhuZXcgUmFuZ2UodGhpcy5vcmlnaW5hbC5zdGFydExpbmVOdW1iZXIgLSAxLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgdGhpcy5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLCBuZXcgUmFuZ2UodGhpcy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgLSAxLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgdGhpcy5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMSwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogTWFwcyBhIGxpbmUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIHRleHQgbW9kZWwgdG8gYSBsaW5lIHJhbmdlIGluIHRoZSBtb2RpZmllZCB0ZXh0IG1vZGVsLlxuICogQWxzbyBjb250YWlucyBpbm5lciByYW5nZSBtYXBwaW5ncy5cbiAqL1xuZXhwb3J0IGNsYXNzIERldGFpbGVkTGluZVJhbmdlTWFwcGluZyBleHRlbmRzIExpbmVSYW5nZU1hcHBpbmcge1xuICAgIHN0YXRpYyBmcm9tUmFuZ2VNYXBwaW5ncyhyYW5nZU1hcHBpbmdzKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsUmFuZ2UgPSBMaW5lUmFuZ2Uuam9pbihyYW5nZU1hcHBpbmdzLm1hcChyID0+IExpbmVSYW5nZS5mcm9tUmFuZ2VJbmNsdXNpdmUoci5vcmlnaW5hbFJhbmdlKSkpO1xuICAgICAgICBjb25zdCBtb2RpZmllZFJhbmdlID0gTGluZVJhbmdlLmpvaW4ocmFuZ2VNYXBwaW5ncy5tYXAociA9PiBMaW5lUmFuZ2UuZnJvbVJhbmdlSW5jbHVzaXZlKHIubW9kaWZpZWRSYW5nZSkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcob3JpZ2luYWxSYW5nZSwgbW9kaWZpZWRSYW5nZSwgcmFuZ2VNYXBwaW5ncyk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsUmFuZ2UsIG1vZGlmaWVkUmFuZ2UsIGlubmVyQ2hhbmdlcykge1xuICAgICAgICBzdXBlcihvcmlnaW5hbFJhbmdlLCBtb2RpZmllZFJhbmdlKTtcbiAgICAgICAgdGhpcy5pbm5lckNoYW5nZXMgPSBpbm5lckNoYW5nZXM7XG4gICAgfVxuICAgIGZsaXAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcodGhpcy5tb2RpZmllZCwgdGhpcy5vcmlnaW5hbCwgKF9hID0gdGhpcy5pbm5lckNoYW5nZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoYyA9PiBjLmZsaXAoKSkpO1xuICAgIH1cbiAgICB3aXRoSW5uZXJDaGFuZ2VzRnJvbUxpbmVSYW5nZXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIFt0aGlzLnRvUmFuZ2VNYXBwaW5nKCldKTtcbiAgICB9XG59XG4vKipcbiAqIE1hcHMgYSByYW5nZSBpbiB0aGUgb3JpZ2luYWwgdGV4dCBtb2RlbCB0byBhIHJhbmdlIGluIHRoZSBtb2RpZmllZCB0ZXh0IG1vZGVsLlxuICovXG5leHBvcnQgY2xhc3MgUmFuZ2VNYXBwaW5nIHtcbiAgICBjb25zdHJ1Y3RvcihvcmlnaW5hbFJhbmdlLCBtb2RpZmllZFJhbmdlKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxSYW5nZSA9IG9yaWdpbmFsUmFuZ2U7XG4gICAgICAgIHRoaXMubW9kaWZpZWRSYW5nZSA9IG1vZGlmaWVkUmFuZ2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYHske3RoaXMub3JpZ2luYWxSYW5nZS50b1N0cmluZygpfS0+JHt0aGlzLm1vZGlmaWVkUmFuZ2UudG9TdHJpbmcoKX19YDtcbiAgICB9XG4gICAgZmxpcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYW5nZU1hcHBpbmcodGhpcy5tb2RpZmllZFJhbmdlLCB0aGlzLm9yaWdpbmFsUmFuZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlIHRleHQgZWRpdCB0aGF0IGRlc2NyaWJlcyB0aGUgY2hhbmdlIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBtb2RpZmllZCB0ZXh0LlxuICAgICovXG4gICAgdG9UZXh0RWRpdChtb2RpZmllZCkge1xuICAgICAgICBjb25zdCBuZXdUZXh0ID0gbW9kaWZpZWQuZ2V0VmFsdWVPZlJhbmdlKHRoaXMubW9kaWZpZWRSYW5nZSk7XG4gICAgICAgIHJldHVybiBuZXcgU2luZ2xlVGV4dEVkaXQodGhpcy5vcmlnaW5hbFJhbmdlLCBuZXdUZXh0KTtcbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IExjc0RpZmYgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9kaWZmL2RpZmYuanMnO1xuaW1wb3J0IHsgTGluZXNEaWZmIH0gZnJvbSAnLi9saW5lc0RpZmZDb21wdXRlci5qcyc7XG5pbXBvcnQgeyBSYW5nZU1hcHBpbmcsIERldGFpbGVkTGluZVJhbmdlTWFwcGluZyB9IGZyb20gJy4vcmFuZ2VNYXBwaW5nLmpzJztcbmltcG9ydCAqIGFzIHN0cmluZ3MgZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vc3RyaW5ncy5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgYXNzZXJ0Rm4sIGNoZWNrQWRqYWNlbnRJdGVtcyB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBMaW5lUmFuZ2UgfSBmcm9tICcuLi9jb3JlL2xpbmVSYW5nZS5qcyc7XG5jb25zdCBNSU5JTVVNX01BVENISU5HX0NIQVJBQ1RFUl9MRU5HVEggPSAzO1xuZXhwb3J0IGNsYXNzIExlZ2FjeUxpbmVzRGlmZkNvbXB1dGVyIHtcbiAgICBjb21wdXRlRGlmZihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZGlmZkNvbXB1dGVyID0gbmV3IERpZmZDb21wdXRlcihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCB7XG4gICAgICAgICAgICBtYXhDb21wdXRhdGlvblRpbWU6IG9wdGlvbnMubWF4Q29tcHV0YXRpb25UaW1lTXMsXG4gICAgICAgICAgICBzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZTogb3B0aW9ucy5pZ25vcmVUcmltV2hpdGVzcGFjZSxcbiAgICAgICAgICAgIHNob3VsZENvbXB1dGVDaGFyQ2hhbmdlczogdHJ1ZSxcbiAgICAgICAgICAgIHNob3VsZE1ha2VQcmV0dHlEaWZmOiB0cnVlLFxuICAgICAgICAgICAgc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlczogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRpZmZDb21wdXRlci5jb21wdXRlRGlmZigpO1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgICAgIGxldCBsYXN0Q2hhbmdlID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHJlc3VsdC5jaGFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgb3JpZ2luYWxSYW5nZTtcbiAgICAgICAgICAgIGlmIChjLm9yaWdpbmFsRW5kTGluZU51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIEluc2VydGlvblxuICAgICAgICAgICAgICAgIG9yaWdpbmFsUmFuZ2UgPSBuZXcgTGluZVJhbmdlKGMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIgKyAxLCBjLm9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbFJhbmdlID0gbmV3IExpbmVSYW5nZShjLm9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyLCBjLm9yaWdpbmFsRW5kTGluZU51bWJlciArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG1vZGlmaWVkUmFuZ2U7XG4gICAgICAgICAgICBpZiAoYy5tb2RpZmllZEVuZExpbmVOdW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBEZWxldGlvblxuICAgICAgICAgICAgICAgIG1vZGlmaWVkUmFuZ2UgPSBuZXcgTGluZVJhbmdlKGMubW9kaWZpZWRTdGFydExpbmVOdW1iZXIgKyAxLCBjLm1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllZFJhbmdlID0gbmV3IExpbmVSYW5nZShjLm1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBjLm1vZGlmaWVkRW5kTGluZU51bWJlciArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNoYW5nZSA9IG5ldyBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcob3JpZ2luYWxSYW5nZSwgbW9kaWZpZWRSYW5nZSwgKF9hID0gYy5jaGFyQ2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcChjID0+IG5ldyBSYW5nZU1hcHBpbmcobmV3IFJhbmdlKGMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIsIGMub3JpZ2luYWxTdGFydENvbHVtbiwgYy5vcmlnaW5hbEVuZExpbmVOdW1iZXIsIGMub3JpZ2luYWxFbmRDb2x1bW4pLCBuZXcgUmFuZ2UoYy5tb2RpZmllZFN0YXJ0TGluZU51bWJlciwgYy5tb2RpZmllZFN0YXJ0Q29sdW1uLCBjLm1vZGlmaWVkRW5kTGluZU51bWJlciwgYy5tb2RpZmllZEVuZENvbHVtbikpKSk7XG4gICAgICAgICAgICBpZiAobGFzdENoYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0Q2hhbmdlLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPT09IGNoYW5nZS5tb2RpZmllZC5zdGFydExpbmVOdW1iZXJcbiAgICAgICAgICAgICAgICAgICAgfHwgbGFzdENoYW5nZS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID09PSBjaGFuZ2Uub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGpvaW4gdG91Y2hpbmcgZGlmZnMuIFByb2JhYmx5IG1vdmluZyBkaWZmcyB1cC9kb3duIGluIHRoZSBhbGdvcml0aG0gY2F1c2VzIHRvdWNoaW5nIGRpZmZzLlxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2UgPSBuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKGxhc3RDaGFuZ2Uub3JpZ2luYWwuam9pbihjaGFuZ2Uub3JpZ2luYWwpLCBsYXN0Q2hhbmdlLm1vZGlmaWVkLmpvaW4oY2hhbmdlLm1vZGlmaWVkKSwgbGFzdENoYW5nZS5pbm5lckNoYW5nZXMgJiYgY2hhbmdlLmlubmVyQ2hhbmdlcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Q2hhbmdlLmlubmVyQ2hhbmdlcy5jb25jYXQoY2hhbmdlLmlubmVyQ2hhbmdlcykgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgbGFzdENoYW5nZSA9IGNoYW5nZTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnRGbigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tBZGphY2VudEl0ZW1zKGNoYW5nZXMsIChtMSwgbTIpID0+IG0yLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAtIG0xLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPT09IG0yLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciAtIG0xLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBoYXMgdG8gYmUgYW4gdW5jaGFuZ2VkIGxpbmUgaW4gYmV0d2VlbiAob3RoZXJ3aXNlIGJvdGggZGlmZnMgc2hvdWxkIGhhdmUgYmVlbiBqb2luZWQpXG4gICAgICAgICAgICAgICAgbTEub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IG0yLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAmJlxuICAgICAgICAgICAgICAgIG0xLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgPCBtMi5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lc0RpZmYoY2hhbmdlcywgW10sIHJlc3VsdC5xdWl0RWFybHkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbXB1dGVEaWZmKG9yaWdpbmFsU2VxdWVuY2UsIG1vZGlmaWVkU2VxdWVuY2UsIGNvbnRpbnVlUHJvY2Vzc2luZ1ByZWRpY2F0ZSwgcHJldHR5KSB7XG4gICAgY29uc3QgZGlmZkFsZ28gPSBuZXcgTGNzRGlmZihvcmlnaW5hbFNlcXVlbmNlLCBtb2RpZmllZFNlcXVlbmNlLCBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUpO1xuICAgIHJldHVybiBkaWZmQWxnby5Db21wdXRlRGlmZihwcmV0dHkpO1xufVxuY2xhc3MgTGluZVNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihsaW5lcykge1xuICAgICAgICBjb25zdCBzdGFydENvbHVtbnMgPSBbXTtcbiAgICAgICAgY29uc3QgZW5kQ29sdW1ucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uc1tpXSA9IGdldEZpcnN0Tm9uQmxhbmtDb2x1bW4obGluZXNbaV0sIDEpO1xuICAgICAgICAgICAgZW5kQ29sdW1uc1tpXSA9IGdldExhc3ROb25CbGFua0NvbHVtbihsaW5lc1tpXSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLl9zdGFydENvbHVtbnMgPSBzdGFydENvbHVtbnM7XG4gICAgICAgIHRoaXMuX2VuZENvbHVtbnMgPSBlbmRDb2x1bW5zO1xuICAgIH1cbiAgICBnZXRFbGVtZW50cygpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMubGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGVsZW1lbnRzW2ldID0gdGhpcy5saW5lc1tpXS5zdWJzdHJpbmcodGhpcy5fc3RhcnRDb2x1bW5zW2ldIC0gMSwgdGhpcy5fZW5kQ29sdW1uc1tpXSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICB9XG4gICAgZ2V0U3RyaWN0RWxlbWVudChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5lc1tpbmRleF07XG4gICAgfVxuICAgIGdldFN0YXJ0TGluZU51bWJlcihpKSB7XG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICB9XG4gICAgZ2V0RW5kTGluZU51bWJlcihpKSB7XG4gICAgICAgIHJldHVybiBpICsgMTtcbiAgICB9XG4gICAgY3JlYXRlQ2hhclNlcXVlbmNlKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICBjb25zdCBjaGFyQ29kZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbGluZU51bWJlcnMgPSBbXTtcbiAgICAgICAgY29uc3QgY29sdW1ucyA9IFtdO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSBzdGFydEluZGV4OyBpbmRleCA8PSBlbmRJbmRleDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSB0aGlzLmxpbmVzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29sdW1uID0gKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlID8gdGhpcy5fc3RhcnRDb2x1bW5zW2luZGV4XSA6IDEpO1xuICAgICAgICAgICAgY29uc3QgZW5kQ29sdW1uID0gKHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlID8gdGhpcy5fZW5kQ29sdW1uc1tpbmRleF0gOiBsaW5lQ29udGVudC5sZW5ndGggKyAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IHN0YXJ0Q29sdW1uOyBjb2wgPCBlbmRDb2x1bW47IGNvbCsrKSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGVzW2xlbl0gPSBsaW5lQ29udGVudC5jaGFyQ29kZUF0KGNvbCAtIDEpO1xuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXJzW2xlbl0gPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgY29sdW1uc1tsZW5dID0gY29sO1xuICAgICAgICAgICAgICAgIGxlbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFzaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSAmJiBpbmRleCA8IGVuZEluZGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIFxcbiBpZiB0cmltIHdoaXRlc3BhY2UgaXMgbm90IGlnbm9yZWRcbiAgICAgICAgICAgICAgICBjaGFyQ29kZXNbbGVuXSA9IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovO1xuICAgICAgICAgICAgICAgIGxpbmVOdW1iZXJzW2xlbl0gPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgY29sdW1uc1tsZW5dID0gbGluZUNvbnRlbnQubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICBsZW4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IENoYXJTZXF1ZW5jZShjaGFyQ29kZXMsIGxpbmVOdW1iZXJzLCBjb2x1bW5zKTtcbiAgICB9XG59XG5jbGFzcyBDaGFyU2VxdWVuY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNoYXJDb2RlcywgbGluZU51bWJlcnMsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5fY2hhckNvZGVzID0gY2hhckNvZGVzO1xuICAgICAgICB0aGlzLl9saW5lTnVtYmVycyA9IGxpbmVOdW1iZXJzO1xuICAgICAgICB0aGlzLl9jb2x1bW5zID0gY29sdW1ucztcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiAoJ1snICsgdGhpcy5fY2hhckNvZGVzLm1hcCgocywgaWR4KSA9PiAocyA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8gPyAnXFxcXG4nIDogU3RyaW5nLmZyb21DaGFyQ29kZShzKSkgKyBgLSgke3RoaXMuX2xpbmVOdW1iZXJzW2lkeF19LCR7dGhpcy5fY29sdW1uc1tpZHhdfSlgKS5qb2luKCcsICcpICsgJ10nKTtcbiAgICB9XG4gICAgX2Fzc2VydEluZGV4KGluZGV4LCBhcnIpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSBhcnIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgaW5kZXhgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXJDb2RlcztcbiAgICB9XG4gICAgZ2V0U3RhcnRMaW5lTnVtYmVyKGkpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPT09IHRoaXMuX2xpbmVOdW1iZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdGhlIHN0YXJ0IGxpbmUgbnVtYmVyIG9mIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGlzIHRoZSBlbmQgbGluZSBudW1iZXIgb2YgdGhlIGxhc3QgZWxlbWVudFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RW5kTGluZU51bWJlcihpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXNzZXJ0SW5kZXgoaSwgdGhpcy5fbGluZU51bWJlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbGluZU51bWJlcnNbaV07XG4gICAgfVxuICAgIGdldEVuZExpbmVOdW1iZXIoaSkge1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHRoZSBlbmQgbGluZSBudW1iZXIgb2YgdGhlIGVsZW1lbnQgYmVmb3JlIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICAgICAgICAvLyBpcyB0aGUgc3RhcnQgbGluZSBudW1iZXIgb2YgdGhlIGZpcnN0IGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFN0YXJ0TGluZU51bWJlcihpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXNzZXJ0SW5kZXgoaSwgdGhpcy5fbGluZU51bWJlcnMpO1xuICAgICAgICBpZiAodGhpcy5fY2hhckNvZGVzW2ldID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVOdW1iZXJzW2ldICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZU51bWJlcnNbaV07XG4gICAgfVxuICAgIGdldFN0YXJ0Q29sdW1uKGkpIHtcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPT09IHRoaXMuX2NvbHVtbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyB0aGUgc3RhcnQgY29sdW1uIG9mIHRoZSBlbGVtZW50IGFmdGVyIHRoZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGlzIHRoZSBlbmQgY29sdW1uIG9mIHRoZSBsYXN0IGVsZW1lbnRcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEVuZENvbHVtbihpIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXNzZXJ0SW5kZXgoaSwgdGhpcy5fY29sdW1ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zW2ldO1xuICAgIH1cbiAgICBnZXRFbmRDb2x1bW4oaSkge1xuICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHRoZSBlbmQgY29sdW1uIG9mIHRoZSBlbGVtZW50IGJlZm9yZSB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgLy8gaXMgdGhlIHN0YXJ0IGNvbHVtbiBvZiB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RhcnRDb2x1bW4oaSArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Fzc2VydEluZGV4KGksIHRoaXMuX2NvbHVtbnMpO1xuICAgICAgICBpZiAodGhpcy5fY2hhckNvZGVzW2ldID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLykge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnNbaV0gKyAxO1xuICAgIH1cbn1cbmNsYXNzIENoYXJDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbEVuZExpbmVOdW1iZXIsIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZFN0YXJ0TGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZENvbHVtbikge1xuICAgICAgICB0aGlzLm9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyID0gb3JpZ2luYWxTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydENvbHVtbiA9IG9yaWdpbmFsU3RhcnRDb2x1bW47XG4gICAgICAgIHRoaXMub3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gb3JpZ2luYWxFbmRMaW5lTnVtYmVyO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRW5kQ29sdW1uID0gb3JpZ2luYWxFbmRDb2x1bW47XG4gICAgICAgIHRoaXMubW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5tb2RpZmllZFN0YXJ0Q29sdW1uID0gbW9kaWZpZWRTdGFydENvbHVtbjtcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZEVuZExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMubW9kaWZpZWRFbmRDb2x1bW4gPSBtb2RpZmllZEVuZENvbHVtbjtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21EaWZmQ2hhbmdlKGRpZmZDaGFuZ2UsIG9yaWdpbmFsQ2hhclNlcXVlbmNlLCBtb2RpZmllZENoYXJTZXF1ZW5jZSkge1xuICAgICAgICBjb25zdCBvcmlnaW5hbFN0YXJ0TGluZU51bWJlciA9IG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFN0YXJ0Q29sdW1uID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0U3RhcnRDb2x1bW4oZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFbmRMaW5lTnVtYmVyID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0RW5kTGluZU51bWJlcihkaWZmQ2hhbmdlLm9yaWdpbmFsU3RhcnQgKyBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIC0gMSk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRW5kQ29sdW1uID0gb3JpZ2luYWxDaGFyU2VxdWVuY2UuZ2V0RW5kQ29sdW1uKGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGRpZmZDaGFuZ2Uub3JpZ2luYWxMZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0KTtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRTdGFydENvbHVtbiA9IG1vZGlmaWVkQ2hhclNlcXVlbmNlLmdldFN0YXJ0Q29sdW1uKGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkQ2hhclNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCBtb2RpZmllZEVuZENvbHVtbiA9IG1vZGlmaWVkQ2hhclNlcXVlbmNlLmdldEVuZENvbHVtbihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoIC0gMSk7XG4gICAgICAgIHJldHVybiBuZXcgQ2hhckNoYW5nZShvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRTdGFydExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kTGluZU51bWJlciwgbW9kaWZpZWRFbmRDb2x1bW4pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBvc3RQcm9jZXNzQ2hhckNoYW5nZXMocmF3Q2hhbmdlcykge1xuICAgIGlmIChyYXdDaGFuZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIHJldHVybiByYXdDaGFuZ2VzO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbcmF3Q2hhbmdlc1swXV07XG4gICAgbGV0IHByZXZDaGFuZ2UgPSByZXN1bHRbMF07XG4gICAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IHJhd0NoYW5nZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VyckNoYW5nZSA9IHJhd0NoYW5nZXNbaV07XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTWF0Y2hpbmdMZW5ndGggPSBjdXJyQ2hhbmdlLm9yaWdpbmFsU3RhcnQgLSAocHJldkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgcHJldkNoYW5nZS5vcmlnaW5hbExlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTWF0Y2hpbmdMZW5ndGggPSBjdXJyQ2hhbmdlLm1vZGlmaWVkU3RhcnQgLSAocHJldkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aCk7XG4gICAgICAgIC8vIEJvdGggb2YgdGhlIGFib3ZlIHNob3VsZCBiZSBlcXVhbCwgYnV0IHRoZSBjb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUgbWF5IHByZXZlbnQgdGhpcyBmcm9tIGJlaW5nIHRydWVcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdMZW5ndGggPSBNYXRoLm1pbihvcmlnaW5hbE1hdGNoaW5nTGVuZ3RoLCBtb2RpZmllZE1hdGNoaW5nTGVuZ3RoKTtcbiAgICAgICAgaWYgKG1hdGNoaW5nTGVuZ3RoIDwgTUlOSU1VTV9NQVRDSElOR19DSEFSQUNURVJfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBNZXJnZSB0aGUgY3VycmVudCBjaGFuZ2UgaW50byB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgICAgICBwcmV2Q2hhbmdlLm9yaWdpbmFsTGVuZ3RoID0gKGN1cnJDaGFuZ2Uub3JpZ2luYWxTdGFydCArIGN1cnJDaGFuZ2Uub3JpZ2luYWxMZW5ndGgpIC0gcHJldkNoYW5nZS5vcmlnaW5hbFN0YXJ0O1xuICAgICAgICAgICAgcHJldkNoYW5nZS5tb2RpZmllZExlbmd0aCA9IChjdXJyQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBjdXJyQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSAtIHByZXZDaGFuZ2UubW9kaWZpZWRTdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgY3VycmVudCBjaGFuZ2VcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJDaGFuZ2UpO1xuICAgICAgICAgICAgcHJldkNoYW5nZSA9IGN1cnJDaGFuZ2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIExpbmVDaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyLCBtb2RpZmllZEVuZExpbmVOdW1iZXIsIGNoYXJDaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMub3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbEVuZExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMubW9kaWZpZWRTdGFydExpbmVOdW1iZXIgPSBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgdGhpcy5tb2RpZmllZEVuZExpbmVOdW1iZXIgPSBtb2RpZmllZEVuZExpbmVOdW1iZXI7XG4gICAgICAgIHRoaXMuY2hhckNoYW5nZXMgPSBjaGFyQ2hhbmdlcztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21EaWZmUmVzdWx0KHNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlLCBkaWZmQ2hhbmdlLCBvcmlnaW5hbExpbmVTZXF1ZW5jZSwgbW9kaWZpZWRMaW5lU2VxdWVuY2UsIGNvbnRpbnVlQ2hhckRpZmYsIHNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcywgc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykge1xuICAgICAgICBsZXQgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBvcmlnaW5hbEVuZExpbmVOdW1iZXI7XG4gICAgICAgIGxldCBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgbGV0IG1vZGlmaWVkRW5kTGluZU51bWJlcjtcbiAgICAgICAgbGV0IGNoYXJDaGFuZ2VzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KSAtIDE7XG4gICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXIgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5nZXRTdGFydExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0KTtcbiAgICAgICAgICAgIG9yaWdpbmFsRW5kTGluZU51bWJlciA9IG9yaWdpbmFsTGluZVNlcXVlbmNlLmdldEVuZExpbmVOdW1iZXIoZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQpIC0gMTtcbiAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlciA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlciA9IG1vZGlmaWVkTGluZVNlcXVlbmNlLmdldFN0YXJ0TGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQpO1xuICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyID0gbW9kaWZpZWRMaW5lU2VxdWVuY2UuZ2V0RW5kTGluZU51bWJlcihkaWZmQ2hhbmdlLm1vZGlmaWVkU3RhcnQgKyBkaWZmQ2hhbmdlLm1vZGlmaWVkTGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyAmJiBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoID4gMCAmJiBkaWZmQ2hhbmdlLm9yaWdpbmFsTGVuZ3RoIDwgMjAgJiYgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCA+IDAgJiYgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCA8IDIwICYmIGNvbnRpbnVlQ2hhckRpZmYoKSkge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSBjaGFyYWN0ZXIgY2hhbmdlcyBmb3IgZGlmZiBjaHVua3Mgb2YgYXQgbW9zdCAyMCBsaW5lcy4uLlxuICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGFyU2VxdWVuY2UgPSBvcmlnaW5hbExpbmVTZXF1ZW5jZS5jcmVhdGVDaGFyU2VxdWVuY2Uoc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIGRpZmZDaGFuZ2Uub3JpZ2luYWxTdGFydCwgZGlmZkNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgZGlmZkNoYW5nZS5vcmlnaW5hbExlbmd0aCAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRDaGFyU2VxdWVuY2UgPSBtb2RpZmllZExpbmVTZXF1ZW5jZS5jcmVhdGVDaGFyU2VxdWVuY2Uoc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIGRpZmZDaGFuZ2UubW9kaWZpZWRTdGFydCwgZGlmZkNoYW5nZS5tb2RpZmllZFN0YXJ0ICsgZGlmZkNoYW5nZS5tb2RpZmllZExlbmd0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ2hhclNlcXVlbmNlLmdldEVsZW1lbnRzKCkubGVuZ3RoID4gMCAmJiBtb2RpZmllZENoYXJTZXF1ZW5jZS5nZXRFbGVtZW50cygpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgcmF3Q2hhbmdlcyA9IGNvbXB1dGVEaWZmKG9yaWdpbmFsQ2hhclNlcXVlbmNlLCBtb2RpZmllZENoYXJTZXF1ZW5jZSwgY29udGludWVDaGFyRGlmZiwgdHJ1ZSkuY2hhbmdlcztcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICByYXdDaGFuZ2VzID0gcG9zdFByb2Nlc3NDaGFyQ2hhbmdlcyhyYXdDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhckNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuZ3RoID0gcmF3Q2hhbmdlcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlcy5wdXNoKENoYXJDaGFuZ2UuY3JlYXRlRnJvbURpZmZDaGFuZ2UocmF3Q2hhbmdlc1tpXSwgb3JpZ2luYWxDaGFyU2VxdWVuY2UsIG1vZGlmaWVkQ2hhclNlcXVlbmNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTGluZUNoYW5nZShvcmlnaW5hbFN0YXJ0TGluZU51bWJlciwgb3JpZ2luYWxFbmRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0TGluZU51bWJlciwgbW9kaWZpZWRFbmRMaW5lTnVtYmVyLCBjaGFyQ2hhbmdlcyk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIERpZmZDb21wdXRlciB7XG4gICAgY29uc3RydWN0b3Iob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgb3B0cykge1xuICAgICAgICB0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyA9IG9wdHMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzO1xuICAgICAgICB0aGlzLnNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXMgPSBvcHRzLnNob3VsZFBvc3RQcm9jZXNzQ2hhckNoYW5nZXM7XG4gICAgICAgIHRoaXMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UgPSBvcHRzLnNob3VsZElnbm9yZVRyaW1XaGl0ZXNwYWNlO1xuICAgICAgICB0aGlzLnNob3VsZE1ha2VQcmV0dHlEaWZmID0gb3B0cy5zaG91bGRNYWtlUHJldHR5RGlmZjtcbiAgICAgICAgdGhpcy5vcmlnaW5hbExpbmVzID0gb3JpZ2luYWxMaW5lcztcbiAgICAgICAgdGhpcy5tb2RpZmllZExpbmVzID0gbW9kaWZpZWRMaW5lcztcbiAgICAgICAgdGhpcy5vcmlnaW5hbCA9IG5ldyBMaW5lU2VxdWVuY2Uob3JpZ2luYWxMaW5lcyk7XG4gICAgICAgIHRoaXMubW9kaWZpZWQgPSBuZXcgTGluZVNlcXVlbmNlKG1vZGlmaWVkTGluZXMpO1xuICAgICAgICB0aGlzLmNvbnRpbnVlTGluZURpZmYgPSBjcmVhdGVDb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUob3B0cy5tYXhDb21wdXRhdGlvblRpbWUpO1xuICAgICAgICB0aGlzLmNvbnRpbnVlQ2hhckRpZmYgPSBjcmVhdGVDb250aW51ZVByb2Nlc3NpbmdQcmVkaWNhdGUob3B0cy5tYXhDb21wdXRhdGlvblRpbWUgPT09IDAgPyAwIDogTWF0aC5taW4ob3B0cy5tYXhDb21wdXRhdGlvblRpbWUsIDUwMDApKTsgLy8gbmV2ZXIgcnVuIGFmdGVyIDVzIGZvciBjaGFyYWN0ZXIgY2hhbmdlcy4uLlxuICAgIH1cbiAgICBjb21wdXRlRGlmZigpIHtcbiAgICAgICAgaWYgKHRoaXMub3JpZ2luYWwubGluZXMubGVuZ3RoID09PSAxICYmIHRoaXMub3JpZ2luYWwubGluZXNbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSBvcmlnaW5hbCA9PiBmYXN0IHBhdGhcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGlmaWVkLmxpbmVzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1vZGlmaWVkLmxpbmVzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHF1aXRFYXJseTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZXM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcXVpdEVhcmx5OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxTdGFydExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVuZExpbmVOdW1iZXI6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZFN0YXJ0TGluZU51bWJlcjogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkRW5kTGluZU51bWJlcjogdGhpcy5tb2RpZmllZC5saW5lcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ2hhbmdlczogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1vZGlmaWVkLmxpbmVzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLm1vZGlmaWVkLmxpbmVzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gZW1wdHkgbW9kaWZpZWQgPT4gZmFzdCBwYXRoXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHF1aXRFYXJseTogZmFsc2UsXG4gICAgICAgICAgICAgICAgY2hhbmdlczogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsU3RhcnRMaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRMaW5lTnVtYmVyOiB0aGlzLm9yaWdpbmFsLmxpbmVzLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGlmaWVkU3RhcnRMaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRFbmRMaW5lTnVtYmVyOiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNoYW5nZXM6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaWZmUmVzdWx0ID0gY29tcHV0ZURpZmYodGhpcy5vcmlnaW5hbCwgdGhpcy5tb2RpZmllZCwgdGhpcy5jb250aW51ZUxpbmVEaWZmLCB0aGlzLnNob3VsZE1ha2VQcmV0dHlEaWZmKTtcbiAgICAgICAgY29uc3QgcmF3Q2hhbmdlcyA9IGRpZmZSZXN1bHQuY2hhbmdlcztcbiAgICAgICAgY29uc3QgcXVpdEVhcmx5ID0gZGlmZlJlc3VsdC5xdWl0RWFybHk7XG4gICAgICAgIC8vIFRoZSBkaWZmIGlzIGFsd2F5cyBjb21wdXRlZCB3aXRoIGlnbm9yaW5nIHRyaW0gd2hpdGVzcGFjZVxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgd2UgZ2V0IHRoZSBwcmV0dGllc3QgZGlmZlxuICAgICAgICBpZiAodGhpcy5zaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgY29uc3QgbGluZUNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW5ndGggPSByYXdDaGFuZ2VzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGluZUNoYW5nZXMucHVzaChMaW5lQ2hhbmdlLmNyZWF0ZUZyb21EaWZmUmVzdWx0KHRoaXMuc2hvdWxkSWdub3JlVHJpbVdoaXRlc3BhY2UsIHJhd0NoYW5nZXNbaV0sIHRoaXMub3JpZ2luYWwsIHRoaXMubW9kaWZpZWQsIHRoaXMuY29udGludWVDaGFyRGlmZiwgdGhpcy5zaG91bGRDb21wdXRlQ2hhckNoYW5nZXMsIHRoaXMuc2hvdWxkUG9zdFByb2Nlc3NDaGFyQ2hhbmdlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBxdWl0RWFybHk6IHF1aXRFYXJseSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VzOiBsaW5lQ2hhbmdlc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOZWVkIHRvIHBvc3QtcHJvY2VzcyBhbmQgaW50cm9kdWNlIGNoYW5nZXMgd2hlcmUgdGhlIHRyaW0gd2hpdGVzcGFjZSBpcyBkaWZmZXJlbnRcbiAgICAgICAgLy8gTm90ZSB0aGF0IHdlIGFyZSBsb29waW5nIHN0YXJ0aW5nIGF0IC0xIHRvIGFsc28gY292ZXIgdGhlIGxpbmVzIGJlZm9yZSB0aGUgZmlyc3QgY2hhbmdlXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgb3JpZ2luYWxMaW5lSW5kZXggPSAwO1xuICAgICAgICBsZXQgbW9kaWZpZWRMaW5lSW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gLTEgLyogISEhISAqLywgbGVuID0gcmF3Q2hhbmdlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV4dENoYW5nZSA9IChpICsgMSA8IGxlbiA/IHJhd0NoYW5nZXNbaSArIDFdIDogbnVsbCk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFN0b3AgPSAobmV4dENoYW5nZSA/IG5leHRDaGFuZ2Uub3JpZ2luYWxTdGFydCA6IHRoaXMub3JpZ2luYWxMaW5lcy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRTdG9wID0gKG5leHRDaGFuZ2UgPyBuZXh0Q2hhbmdlLm1vZGlmaWVkU3RhcnQgOiB0aGlzLm1vZGlmaWVkTGluZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbExpbmVJbmRleCA8IG9yaWdpbmFsU3RvcCAmJiBtb2RpZmllZExpbmVJbmRleCA8IG1vZGlmaWVkU3RvcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZSA9IHRoaXMub3JpZ2luYWxMaW5lc1tvcmlnaW5hbExpbmVJbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lID0gdGhpcy5tb2RpZmllZExpbmVzW21vZGlmaWVkTGluZUluZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxMaW5lICE9PSBtb2RpZmllZExpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgbGluZXMgZGlmZmVyIG9ubHkgaW4gdHJpbSB3aGl0ZXNwYWNlXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSBsZWFkaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG9yaWdpbmFsU3RhcnRDb2x1bW4gPSBnZXRGaXJzdE5vbkJsYW5rQ29sdW1uKG9yaWdpbmFsTGluZSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbW9kaWZpZWRTdGFydENvbHVtbiA9IGdldEZpcnN0Tm9uQmxhbmtDb2x1bW4obW9kaWZpZWRMaW5lLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChvcmlnaW5hbFN0YXJ0Q29sdW1uID4gMSAmJiBtb2RpZmllZFN0YXJ0Q29sdW1uID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsQ2hhciA9IG9yaWdpbmFsTGluZS5jaGFyQ29kZUF0KG9yaWdpbmFsU3RhcnRDb2x1bW4gLSAyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZENoYXIgPSBtb2RpZmllZExpbmUuY2hhckNvZGVBdChtb2RpZmllZFN0YXJ0Q29sdW1uIC0gMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ2hhciAhPT0gbW9kaWZpZWRDaGFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbFN0YXJ0Q29sdW1uLS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRTdGFydENvbHVtbi0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsU3RhcnRDb2x1bW4gPiAxIHx8IG1vZGlmaWVkU3RhcnRDb2x1bW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVzaFRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZUluZGV4ICsgMSwgMSwgb3JpZ2luYWxTdGFydENvbHVtbiwgbW9kaWZpZWRMaW5lSW5kZXggKyAxLCAxLCBtb2RpZmllZFN0YXJ0Q29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgb3JpZ2luYWxFbmRDb2x1bW4gPSBnZXRMYXN0Tm9uQmxhbmtDb2x1bW4ob3JpZ2luYWxMaW5lLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtb2RpZmllZEVuZENvbHVtbiA9IGdldExhc3ROb25CbGFua0NvbHVtbihtb2RpZmllZExpbmUsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxNYXhDb2x1bW4gPSBvcmlnaW5hbExpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTWF4Q29sdW1uID0gbW9kaWZpZWRMaW5lLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAob3JpZ2luYWxFbmRDb2x1bW4gPCBvcmlnaW5hbE1heENvbHVtbiAmJiBtb2RpZmllZEVuZENvbHVtbiA8IG1vZGlmaWVkTWF4Q29sdW1uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGFyID0gb3JpZ2luYWxMaW5lLmNoYXJDb2RlQXQob3JpZ2luYWxFbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZENoYXIgPSBvcmlnaW5hbExpbmUuY2hhckNvZGVBdChtb2RpZmllZEVuZENvbHVtbiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbENoYXIgIT09IG1vZGlmaWVkQ2hhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luYWxFbmRDb2x1bW4rKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RpZmllZEVuZENvbHVtbisrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsRW5kQ29sdW1uIDwgb3JpZ2luYWxNYXhDb2x1bW4gfHwgbW9kaWZpZWRFbmRDb2x1bW4gPCBtb2RpZmllZE1heENvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVJbmRleCArIDEsIG9yaWdpbmFsRW5kQ29sdW1uLCBvcmlnaW5hbE1heENvbHVtbiwgbW9kaWZpZWRMaW5lSW5kZXggKyAxLCBtb2RpZmllZEVuZENvbHVtbiwgbW9kaWZpZWRNYXhDb2x1bW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9yaWdpbmFsTGluZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgLy8gRW1pdCB0aGUgYWN0dWFsIGNoYW5nZVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKExpbmVDaGFuZ2UuY3JlYXRlRnJvbURpZmZSZXN1bHQodGhpcy5zaG91bGRJZ25vcmVUcmltV2hpdGVzcGFjZSwgbmV4dENoYW5nZSwgdGhpcy5vcmlnaW5hbCwgdGhpcy5tb2RpZmllZCwgdGhpcy5jb250aW51ZUNoYXJEaWZmLCB0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcywgdGhpcy5zaG91bGRQb3N0UHJvY2Vzc0NoYXJDaGFuZ2VzKSk7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMaW5lSW5kZXggKz0gbmV4dENoYW5nZS5vcmlnaW5hbExlbmd0aDtcbiAgICAgICAgICAgICAgICBtb2RpZmllZExpbmVJbmRleCArPSBuZXh0Q2hhbmdlLm1vZGlmaWVkTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBxdWl0RWFybHk6IHF1aXRFYXJseSxcbiAgICAgICAgICAgIGNoYW5nZXM6IHJlc3VsdFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcHVzaFRyaW1XaGl0ZXNwYWNlQ2hhckNoYW5nZShyZXN1bHQsIG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxFbmRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRTdGFydENvbHVtbiwgbW9kaWZpZWRFbmRDb2x1bW4pIHtcbiAgICAgICAgaWYgKHRoaXMuX21lcmdlVHJpbVdoaXRlc3BhY2VDaGFyQ2hhbmdlKHJlc3VsdCwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZEVuZENvbHVtbikpIHtcbiAgICAgICAgICAgIC8vIE1lcmdlZCBpbnRvIHByZXZpb3VzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoYXJDaGFuZ2VzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRDb21wdXRlQ2hhckNoYW5nZXMpIHtcbiAgICAgICAgICAgIGNoYXJDaGFuZ2VzID0gW25ldyBDaGFyQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKV07XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gobmV3IExpbmVDaGFuZ2Uob3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbExpbmVOdW1iZXIsIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRMaW5lTnVtYmVyLCBjaGFyQ2hhbmdlcykpO1xuICAgIH1cbiAgICBfbWVyZ2VUcmltV2hpdGVzcGFjZUNoYXJDaGFuZ2UocmVzdWx0LCBvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsU3RhcnRDb2x1bW4sIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkRW5kQ29sdW1uKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHJlc3VsdC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2Q2hhbmdlID0gcmVzdWx0W2xlbiAtIDFdO1xuICAgICAgICBpZiAocHJldkNoYW5nZS5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPT09IDAgfHwgcHJldkNoYW5nZS5tb2RpZmllZEVuZExpbmVOdW1iZXIgPT09IDApIHtcbiAgICAgICAgICAgIC8vIERvbid0IG1lcmdlIHdpdGggaW5zZXJ0cy9kZWxldGVzXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZDaGFuZ2Uub3JpZ2luYWxFbmRMaW5lTnVtYmVyID09PSBvcmlnaW5hbExpbmVOdW1iZXIgJiYgcHJldkNoYW5nZS5tb2RpZmllZEVuZExpbmVOdW1iZXIgPT09IG1vZGlmaWVkTGluZU51bWJlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ29tcHV0ZUNoYXJDaGFuZ2VzICYmIHByZXZDaGFuZ2UuY2hhckNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBwcmV2Q2hhbmdlLmNoYXJDaGFuZ2VzLnB1c2gobmV3IENoYXJDaGFuZ2Uob3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbFN0YXJ0Q29sdW1uLCBvcmlnaW5hbExpbmVOdW1iZXIsIG9yaWdpbmFsRW5kQ29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkU3RhcnRDb2x1bW4sIG1vZGlmaWVkTGluZU51bWJlciwgbW9kaWZpZWRFbmRDb2x1bW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2Q2hhbmdlLm9yaWdpbmFsRW5kTGluZU51bWJlciArIDEgPT09IG9yaWdpbmFsTGluZU51bWJlciAmJiBwcmV2Q2hhbmdlLm1vZGlmaWVkRW5kTGluZU51bWJlciArIDEgPT09IG1vZGlmaWVkTGluZU51bWJlcikge1xuICAgICAgICAgICAgcHJldkNoYW5nZS5vcmlnaW5hbEVuZExpbmVOdW1iZXIgPSBvcmlnaW5hbExpbmVOdW1iZXI7XG4gICAgICAgICAgICBwcmV2Q2hhbmdlLm1vZGlmaWVkRW5kTGluZU51bWJlciA9IG1vZGlmaWVkTGluZU51bWJlcjtcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3VsZENvbXB1dGVDaGFyQ2hhbmdlcyAmJiBwcmV2Q2hhbmdlLmNoYXJDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcHJldkNoYW5nZS5jaGFyQ2hhbmdlcy5wdXNoKG5ldyBDaGFyQ2hhbmdlKG9yaWdpbmFsTGluZU51bWJlciwgb3JpZ2luYWxTdGFydENvbHVtbiwgb3JpZ2luYWxMaW5lTnVtYmVyLCBvcmlnaW5hbEVuZENvbHVtbiwgbW9kaWZpZWRMaW5lTnVtYmVyLCBtb2RpZmllZFN0YXJ0Q29sdW1uLCBtb2RpZmllZExpbmVOdW1iZXIsIG1vZGlmaWVkRW5kQ29sdW1uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Rmlyc3ROb25CbGFua0NvbHVtbih0eHQsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHIgPSBzdHJpbmdzLmZpcnN0Tm9uV2hpdGVzcGFjZUluZGV4KHR4dCk7XG4gICAgaWYgKHIgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByICsgMTtcbn1cbmZ1bmN0aW9uIGdldExhc3ROb25CbGFua0NvbHVtbih0eHQsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGNvbnN0IHIgPSBzdHJpbmdzLmxhc3ROb25XaGl0ZXNwYWNlSW5kZXgodHh0KTtcbiAgICBpZiAociA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHIgKyAyO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udGludWVQcm9jZXNzaW5nUHJlZGljYXRlKG1heGltdW1SdW50aW1lKSB7XG4gICAgaWYgKG1heGltdW1SdW50aW1lID09PSAwKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lIDwgbWF4aW11bVJ1bnRpbWU7XG4gICAgfTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgZm9yRWFjaEFkamFjZW50IH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzLmpzJztcbmltcG9ydCB7IEJ1Z0luZGljYXRpbmdFcnJvciB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4uLy4uLy4uL2NvcmUvb2Zmc2V0UmFuZ2UuanMnO1xuZXhwb3J0IGNsYXNzIERpZmZBbGdvcml0aG1SZXN1bHQge1xuICAgIHN0YXRpYyB0cml2aWFsKHNlcTEsIHNlcTIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEaWZmQWxnb3JpdGhtUmVzdWx0KFtuZXcgU2VxdWVuY2VEaWZmKE9mZnNldFJhbmdlLm9mTGVuZ3RoKHNlcTEubGVuZ3RoKSwgT2Zmc2V0UmFuZ2Uub2ZMZW5ndGgoc2VxMi5sZW5ndGgpKV0sIGZhbHNlKTtcbiAgICB9XG4gICAgc3RhdGljIHRyaXZpYWxUaW1lZE91dChzZXExLCBzZXEyKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGlmZkFsZ29yaXRobVJlc3VsdChbbmV3IFNlcXVlbmNlRGlmZihPZmZzZXRSYW5nZS5vZkxlbmd0aChzZXExLmxlbmd0aCksIE9mZnNldFJhbmdlLm9mTGVuZ3RoKHNlcTIubGVuZ3RoKSldLCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGlmZnMsIFxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyBpZiB0aGUgdGltZSBvdXQgd2FzIHJlYWNoZWQuXG4gICAgICogSW4gdGhhdCBjYXNlLCB0aGUgZGlmZnMgbWlnaHQgYmUgYW4gYXBwcm94aW1hdGlvbiBhbmQgdGhlIHVzZXIgc2hvdWxkIGJlIGFza2VkIHRvIHJlcnVuIHRoZSBkaWZmIHdpdGggbW9yZSB0aW1lLlxuICAgICAqL1xuICAgIGhpdFRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5kaWZmcyA9IGRpZmZzO1xuICAgICAgICB0aGlzLmhpdFRpbWVvdXQgPSBoaXRUaW1lb3V0O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTZXF1ZW5jZURpZmYge1xuICAgIHN0YXRpYyBpbnZlcnQoc2VxdWVuY2VEaWZmcywgZG9jMUxlbmd0aCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yRWFjaEFkamFjZW50KHNlcXVlbmNlRGlmZnMsIChhLCBiKSA9PiB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChTZXF1ZW5jZURpZmYuZnJvbU9mZnNldFBhaXJzKGEgPyBhLmdldEVuZEV4Y2x1c2l2ZXMoKSA6IE9mZnNldFBhaXIuemVybywgYiA/IGIuZ2V0U3RhcnRzKCkgOiBuZXcgT2Zmc2V0UGFpcihkb2MxTGVuZ3RoLCAoYSA/IGEuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZSAtIGEuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSA6IDApICsgZG9jMUxlbmd0aCkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2Zmc2V0UGFpcnMoc3RhcnQsIGVuZEV4Y2x1c2l2ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlRGlmZihuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQub2Zmc2V0MSwgZW5kRXhjbHVzaXZlLm9mZnNldDEpLCBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQub2Zmc2V0MiwgZW5kRXhjbHVzaXZlLm9mZnNldDIpKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2VxMVJhbmdlLCBzZXEyUmFuZ2UpIHtcbiAgICAgICAgdGhpcy5zZXExUmFuZ2UgPSBzZXExUmFuZ2U7XG4gICAgICAgIHRoaXMuc2VxMlJhbmdlID0gc2VxMlJhbmdlO1xuICAgIH1cbiAgICBzd2FwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlRGlmZih0aGlzLnNlcTJSYW5nZSwgdGhpcy5zZXExUmFuZ2UpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuc2VxMVJhbmdlfSA8LT4gJHt0aGlzLnNlcTJSYW5nZX1gO1xuICAgIH1cbiAgICBqb2luKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKHRoaXMuc2VxMVJhbmdlLmpvaW4ob3RoZXIuc2VxMVJhbmdlKSwgdGhpcy5zZXEyUmFuZ2Uuam9pbihvdGhlci5zZXEyUmFuZ2UpKTtcbiAgICB9XG4gICAgZGVsdGEob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKHRoaXMuc2VxMVJhbmdlLmRlbHRhKG9mZnNldCksIHRoaXMuc2VxMlJhbmdlLmRlbHRhKG9mZnNldCkpO1xuICAgIH1cbiAgICBkZWx0YVN0YXJ0KG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlRGlmZih0aGlzLnNlcTFSYW5nZS5kZWx0YVN0YXJ0KG9mZnNldCksIHRoaXMuc2VxMlJhbmdlLmRlbHRhU3RhcnQob2Zmc2V0KSk7XG4gICAgfVxuICAgIGRlbHRhRW5kKG9mZnNldCkge1xuICAgICAgICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNlcXVlbmNlRGlmZih0aGlzLnNlcTFSYW5nZS5kZWx0YUVuZChvZmZzZXQpLCB0aGlzLnNlcTJSYW5nZS5kZWx0YUVuZChvZmZzZXQpKTtcbiAgICB9XG4gICAgaW50ZXJzZWN0KG90aGVyKSB7XG4gICAgICAgIGNvbnN0IGkxID0gdGhpcy5zZXExUmFuZ2UuaW50ZXJzZWN0KG90aGVyLnNlcTFSYW5nZSk7XG4gICAgICAgIGNvbnN0IGkyID0gdGhpcy5zZXEyUmFuZ2UuaW50ZXJzZWN0KG90aGVyLnNlcTJSYW5nZSk7XG4gICAgICAgIGlmICghaTEgfHwgIWkyKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2VxdWVuY2VEaWZmKGkxLCBpMik7XG4gICAgfVxuICAgIGdldFN0YXJ0cygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRQYWlyKHRoaXMuc2VxMVJhbmdlLnN0YXJ0LCB0aGlzLnNlcTJSYW5nZS5zdGFydCk7XG4gICAgfVxuICAgIGdldEVuZEV4Y2x1c2l2ZXMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UGFpcih0aGlzLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUsIHRoaXMuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE9mZnNldFBhaXIge1xuICAgIGNvbnN0cnVjdG9yKG9mZnNldDEsIG9mZnNldDIpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQxID0gb2Zmc2V0MTtcbiAgICAgICAgdGhpcy5vZmZzZXQyID0gb2Zmc2V0MjtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm9mZnNldDF9IDwtPiAke3RoaXMub2Zmc2V0Mn1gO1xuICAgIH1cbiAgICBkZWx0YShvZmZzZXQpIHtcbiAgICAgICAgaWYgKG9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRQYWlyKHRoaXMub2Zmc2V0MSArIG9mZnNldCwgdGhpcy5vZmZzZXQyICsgb2Zmc2V0KTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldDEgPT09IG90aGVyLm9mZnNldDEgJiYgdGhpcy5vZmZzZXQyID09PSBvdGhlci5vZmZzZXQyO1xuICAgIH1cbn1cbk9mZnNldFBhaXIuemVybyA9IG5ldyBPZmZzZXRQYWlyKDAsIDApO1xuT2Zmc2V0UGFpci5tYXggPSBuZXcgT2Zmc2V0UGFpcihOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpO1xuZXhwb3J0IGNsYXNzIEluZmluaXRlVGltZW91dCB7XG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuSW5maW5pdGVUaW1lb3V0Lmluc3RhbmNlID0gbmV3IEluZmluaXRlVGltZW91dCgpO1xuZXhwb3J0IGNsYXNzIERhdGVUaW1lb3V0IHtcbiAgICBjb25zdHJ1Y3Rvcih0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy52YWxpZCA9IHRydWU7XG4gICAgICAgIGlmICh0aW1lb3V0IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCdWdJbmRpY2F0aW5nRXJyb3IoJ3RpbWVvdXQgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlY29tbWVuZGF0aW9uOiBTZXQgYSBsb2ctcG9pbnQgYHt0aGlzLmRpc2FibGUoKX1gIGluIHRoZSBib2R5XG4gICAgaXNWYWxpZCgpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBEYXRlLm5vdygpIC0gdGhpcy5zdGFydFRpbWUgPCB0aGlzLnRpbWVvdXQ7XG4gICAgICAgIGlmICghdmFsaWQgJiYgdGhpcy52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZCA9IGZhbHNlOyAvLyB0aW1lb3V0IHJlYWNoZWRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kZWJ1Z2dlclxuICAgICAgICAgICAgZGVidWdnZXI7IC8vIFdBUk5JTkc6IE1vc3QgbGlrZWx5IGRlYnVnZ2luZyBjYXVzZWQgdGhlIHRpbWVvdXQuIENhbGwgYHRoaXMuZGlzYWJsZSgpYCB0byBjb250aW51ZSB3aXRob3V0IHRpbWluZyBvdXQuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsaWQ7XG4gICAgfVxufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgY2xhc3MgQXJyYXkyRCB7XG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmFycmF5ID0gW107XG4gICAgICAgIHRoaXMuYXJyYXkgPSBuZXcgQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgIH1cbiAgICBnZXQoeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJheVt4ICsgeSAqIHRoaXMud2lkdGhdO1xuICAgIH1cbiAgICBzZXQoeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5hcnJheVt4ICsgeSAqIHRoaXMud2lkdGhdID0gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU3BhY2UoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDMyIC8qIENoYXJDb2RlLlNwYWNlICovIHx8IGNoYXJDb2RlID09PSA5IC8qIENoYXJDb2RlLlRhYiAqLztcbn1cbmV4cG9ydCBjbGFzcyBMaW5lUmFuZ2VGcmFnbWVudCB7XG4gICAgc3RhdGljIGdldEtleShjaHIpIHtcbiAgICAgICAgbGV0IGtleSA9IHRoaXMuY2hyS2V5cy5nZXQoY2hyKTtcbiAgICAgICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBrZXkgPSB0aGlzLmNocktleXMuc2l6ZTtcbiAgICAgICAgICAgIHRoaXMuY2hyS2V5cy5zZXQoY2hyLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHJhbmdlLCBsaW5lcywgc291cmNlKSB7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5oaXN0b2dyYW0gPSBbXTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIC0gMTsgaSA8IHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgICAgICAgICBjb25zdCBjaHIgPSBsaW5lW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IExpbmVSYW5nZUZyYWdtZW50LmdldEtleShjaHIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlzdG9ncmFtW2tleV0gPSAodGhpcy5oaXN0b2dyYW1ba2V5XSB8fCAwKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb3VudGVyKys7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBMaW5lUmFuZ2VGcmFnbWVudC5nZXRLZXkoJ1xcbicpO1xuICAgICAgICAgICAgdGhpcy5oaXN0b2dyYW1ba2V5XSA9ICh0aGlzLmhpc3RvZ3JhbVtrZXldIHx8IDApICsgMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsQ291bnQgPSBjb3VudGVyO1xuICAgIH1cbiAgICBjb21wdXRlU2ltaWxhcml0eShvdGhlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgc3VtRGlmZmVyZW5jZXMgPSAwO1xuICAgICAgICBjb25zdCBtYXhMZW5ndGggPSBNYXRoLm1heCh0aGlzLmhpc3RvZ3JhbS5sZW5ndGgsIG90aGVyLmhpc3RvZ3JhbS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdW1EaWZmZXJlbmNlcyArPSBNYXRoLmFicygoKF9hID0gdGhpcy5oaXN0b2dyYW1baV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApIC0gKChfYiA9IG90aGVyLmhpc3RvZ3JhbVtpXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxIC0gKHN1bURpZmZlcmVuY2VzIC8gKHRoaXMudG90YWxDb3VudCArIG90aGVyLnRvdGFsQ291bnQpKTtcbiAgICB9XG59XG5MaW5lUmFuZ2VGcmFnbWVudC5jaHJLZXlzID0gbmV3IE1hcCgpO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4uLy4uLy4uL2NvcmUvb2Zmc2V0UmFuZ2UuanMnO1xuaW1wb3J0IHsgU2VxdWVuY2VEaWZmLCBJbmZpbml0ZVRpbWVvdXQsIERpZmZBbGdvcml0aG1SZXN1bHQgfSBmcm9tICcuL2RpZmZBbGdvcml0aG0uanMnO1xuaW1wb3J0IHsgQXJyYXkyRCB9IGZyb20gJy4uL3V0aWxzLmpzJztcbi8qKlxuICogQSBPKE1OKSBkaWZmaW5nIGFsZ29yaXRobSB0aGF0IHN1cHBvcnRzIGEgc2NvcmUgZnVuY3Rpb24uXG4gKiBUaGUgYWxnb3JpdGhtIGNhbiBiZSBpbXByb3ZlZCBieSBwcm9jZXNzaW5nIHRoZSAyZCBhcnJheSBkaWFnb25hbGx5LlxuKi9cbmV4cG9ydCBjbGFzcyBEeW5hbWljUHJvZ3JhbW1pbmdEaWZmaW5nIHtcbiAgICBjb21wdXRlKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCB0aW1lb3V0ID0gSW5maW5pdGVUaW1lb3V0Lmluc3RhbmNlLCBlcXVhbGl0eVNjb3JlKSB7XG4gICAgICAgIGlmIChzZXF1ZW5jZTEubGVuZ3RoID09PSAwIHx8IHNlcXVlbmNlMi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBEaWZmQWxnb3JpdGhtUmVzdWx0LnRyaXZpYWwoc2VxdWVuY2UxLCBzZXF1ZW5jZTIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBsY3NMZW5ndGhzLmdldChpLCBqKTogTGVuZ3RoIG9mIHRoZSBsb25nZXN0IGNvbW1vbiBzdWJzZXF1ZW5jZSBvZiBzZXF1ZW5jZTEuc3Vic3RyaW5nKDAsIGkgKyAxKSBhbmQgc2VxdWVuY2UyLnN1YnN0cmluZygwLCBqICsgMSkuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBsY3NMZW5ndGhzID0gbmV3IEFycmF5MkQoc2VxdWVuY2UxLmxlbmd0aCwgc2VxdWVuY2UyLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbnMgPSBuZXcgQXJyYXkyRChzZXF1ZW5jZTEubGVuZ3RoLCBzZXF1ZW5jZTIubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgbGVuZ3RocyA9IG5ldyBBcnJheTJEKHNlcXVlbmNlMS5sZW5ndGgsIHNlcXVlbmNlMi5sZW5ndGgpO1xuICAgICAgICAvLyA9PT09IEluaXRpYWxpemluZyBsY3NMZW5ndGhzID09PT1cbiAgICAgICAgZm9yIChsZXQgczEgPSAwOyBzMSA8IHNlcXVlbmNlMS5sZW5ndGg7IHMxKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHMyID0gMDsgczIgPCBzZXF1ZW5jZTIubGVuZ3RoOyBzMisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGlmZkFsZ29yaXRobVJlc3VsdC50cml2aWFsVGltZWRPdXQoc2VxdWVuY2UxLCBzZXF1ZW5jZTIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBob3Jpem9udGFsTGVuID0gczEgPT09IDAgPyAwIDogbGNzTGVuZ3Rocy5nZXQoczEgLSAxLCBzMik7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGljYWxMZW4gPSBzMiA9PT0gMCA/IDAgOiBsY3NMZW5ndGhzLmdldChzMSwgczIgLSAxKTtcbiAgICAgICAgICAgICAgICBsZXQgZXh0ZW5kZWRTZXFTY29yZTtcbiAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2UxLmdldEVsZW1lbnQoczEpID09PSBzZXF1ZW5jZTIuZ2V0RWxlbWVudChzMikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMxID09PSAwIHx8IHMyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFNlcVNjb3JlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkU2VxU2NvcmUgPSBsY3NMZW5ndGhzLmdldChzMSAtIDEsIHMyIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHMxID4gMCAmJiBzMiA+IDAgJiYgZGlyZWN0aW9ucy5nZXQoczEgLSAxLCBzMiAtIDEpID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQcmVmZXIgY29uc2VjdXRpdmUgZGlhZ29uYWxzXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFNlcVNjb3JlICs9IGxlbmd0aHMuZ2V0KHMxIC0gMSwgczIgLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFNlcVNjb3JlICs9IChlcXVhbGl0eVNjb3JlID8gZXF1YWxpdHlTY29yZShzMSwgczIpIDogMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFNlcVNjb3JlID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gTWF0aC5tYXgoaG9yaXpvbnRhbExlbiwgdmVydGljYWxMZW4sIGV4dGVuZGVkU2VxU2NvcmUpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gZXh0ZW5kZWRTZXFTY29yZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmVmZXIgZGlhZ29uYWxzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZMZW4gPSBzMSA+IDAgJiYgczIgPiAwID8gbGVuZ3Rocy5nZXQoczEgLSAxLCBzMiAtIDEpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3Rocy5zZXQoczEsIHMyLCBwcmV2TGVuICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuc2V0KHMxLCBzMiwgMyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlID09PSBob3Jpem9udGFsTGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aHMuc2V0KHMxLCBzMiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuc2V0KHMxLCBzMiwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1ZhbHVlID09PSB2ZXJ0aWNhbExlbikge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGhzLnNldChzMSwgczIsIDApO1xuICAgICAgICAgICAgICAgICAgICBkaXJlY3Rpb25zLnNldChzMSwgczIsIDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsY3NMZW5ndGhzLnNldChzMSwgczIsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyA9PT09IEJhY2t0cmFja2luZyA9PT09XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbGFzdEFsaWduaW5nUG9zUzEgPSBzZXF1ZW5jZTEubGVuZ3RoO1xuICAgICAgICBsZXQgbGFzdEFsaWduaW5nUG9zUzIgPSBzZXF1ZW5jZTIubGVuZ3RoO1xuICAgICAgICBmdW5jdGlvbiByZXBvcnREZWNyZWFzaW5nQWxpZ25pbmdQb3NpdGlvbnMoczEsIHMyKSB7XG4gICAgICAgICAgICBpZiAoczEgKyAxICE9PSBsYXN0QWxpZ25pbmdQb3NTMSB8fCBzMiArIDEgIT09IGxhc3RBbGlnbmluZ1Bvc1MyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFNlcXVlbmNlRGlmZihuZXcgT2Zmc2V0UmFuZ2UoczEgKyAxLCBsYXN0QWxpZ25pbmdQb3NTMSksIG5ldyBPZmZzZXRSYW5nZShzMiArIDEsIGxhc3RBbGlnbmluZ1Bvc1MyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEFsaWduaW5nUG9zUzEgPSBzMTtcbiAgICAgICAgICAgIGxhc3RBbGlnbmluZ1Bvc1MyID0gczI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHMxID0gc2VxdWVuY2UxLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBzMiA9IHNlcXVlbmNlMi5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoczEgPj0gMCAmJiBzMiA+PSAwKSB7XG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9ucy5nZXQoczEsIHMyKSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJlcG9ydERlY3JlYXNpbmdBbGlnbmluZ1Bvc2l0aW9ucyhzMSwgczIpO1xuICAgICAgICAgICAgICAgIHMxLS07XG4gICAgICAgICAgICAgICAgczItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zLmdldChzMSwgczIpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHMxLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzMi0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXBvcnREZWNyZWFzaW5nQWxpZ25pbmdQb3NpdGlvbnMoLTEsIC0xKTtcbiAgICAgICAgcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEaWZmQWxnb3JpdGhtUmVzdWx0KHJlc3VsdCwgZmFsc2UpO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgT2Zmc2V0UmFuZ2UgfSBmcm9tICcuLi8uLi8uLi9jb3JlL29mZnNldFJhbmdlLmpzJztcbmltcG9ydCB7IERpZmZBbGdvcml0aG1SZXN1bHQsIEluZmluaXRlVGltZW91dCwgU2VxdWVuY2VEaWZmIH0gZnJvbSAnLi9kaWZmQWxnb3JpdGhtLmpzJztcbi8qKlxuICogQW4gTyhORCkgZGlmZiBhbGdvcml0aG0gdGhhdCBoYXMgYSBxdWFkcmF0aWMgc3BhY2Ugd29yc3QtY2FzZSBjb21wbGV4aXR5LlxuKi9cbmV4cG9ydCBjbGFzcyBNeWVyc0RpZmZBbGdvcml0aG0ge1xuICAgIGNvbXB1dGUoc2VxMSwgc2VxMiwgdGltZW91dCA9IEluZmluaXRlVGltZW91dC5pbnN0YW5jZSkge1xuICAgICAgICAvLyBUaGVzZSBhcmUgY29tbW9uIHNwZWNpYWwgY2FzZXMuXG4gICAgICAgIC8vIFRoZSBlYXJseSByZXR1cm4gaW1wcm92ZXMgcGVyZm9ybWFuY2UgZHJhbWF0aWNhbGx5LlxuICAgICAgICBpZiAoc2VxMS5sZW5ndGggPT09IDAgfHwgc2VxMi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBEaWZmQWxnb3JpdGhtUmVzdWx0LnRyaXZpYWwoc2VxMSwgc2VxMik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VxWCA9IHNlcTE7IC8vIFRleHQgb24gdGhlIHggYXhpc1xuICAgICAgICBjb25zdCBzZXFZID0gc2VxMjsgLy8gVGV4dCBvbiB0aGUgeSBheGlzXG4gICAgICAgIGZ1bmN0aW9uIGdldFhBZnRlclNuYWtlKHgsIHkpIHtcbiAgICAgICAgICAgIHdoaWxlICh4IDwgc2VxWC5sZW5ndGggJiYgeSA8IHNlcVkubGVuZ3RoICYmIHNlcVguZ2V0RWxlbWVudCh4KSA9PT0gc2VxWS5nZXRFbGVtZW50KHkpKSB7XG4gICAgICAgICAgICAgICAgeCsrO1xuICAgICAgICAgICAgICAgIHkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICB9XG4gICAgICAgIGxldCBkID0gMDtcbiAgICAgICAgLy8gVltrXTogWCB2YWx1ZSBvZiBsb25nZXN0IGQtbGluZSB0aGF0IGVuZHMgaW4gZGlhZ29uYWwgay5cbiAgICAgICAgLy8gZC1saW5lOiBwYXRoIGZyb20gKDAsMCkgdG8gKHgseSkgdGhhdCB1c2VzIGV4YWN0bHkgZCBub24tZGlhZ29uYWxzLlxuICAgICAgICAvLyBkaWFnb25hbCBrOiBTZXQgb2YgcG9pbnRzICh4LHkpIHdpdGggeC15ID0gay5cbiAgICAgICAgLy8gaz0xIC0+ICgxLDApLCgyLDEpXG4gICAgICAgIGNvbnN0IFYgPSBuZXcgRmFzdEludDMyQXJyYXkoKTtcbiAgICAgICAgVi5zZXQoMCwgZ2V0WEFmdGVyU25ha2UoMCwgMCkpO1xuICAgICAgICBjb25zdCBwYXRocyA9IG5ldyBGYXN0QXJyYXlOZWdhdGl2ZUluZGljZXMoKTtcbiAgICAgICAgcGF0aHMuc2V0KDAsIFYuZ2V0KDApID09PSAwID8gbnVsbCA6IG5ldyBTbmFrZVBhdGgobnVsbCwgMCwgMCwgVi5nZXQoMCkpKTtcbiAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICBsb29wOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgZCsrO1xuICAgICAgICAgICAgaWYgKCF0aW1lb3V0LmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBEaWZmQWxnb3JpdGhtUmVzdWx0LnRyaXZpYWxUaW1lZE91dChzZXFYLCBzZXFZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBwYXBlciBoYXMgYGZvciAoayA9IC1kOyBrIDw9IGQ7IGsgKz0gMilgLCBidXQgd2UgY2FuIGlnbm9yZSBkaWFnb25hbHMgdGhhdCBjYW5ub3QgaW5mbHVlbmNlIHRoZSByZXN1bHQuXG4gICAgICAgICAgICBjb25zdCBsb3dlckJvdW5kID0gLU1hdGgubWluKGQsIHNlcVkubGVuZ3RoICsgKGQgJSAyKSk7XG4gICAgICAgICAgICBjb25zdCB1cHBlckJvdW5kID0gTWF0aC5taW4oZCwgc2VxWC5sZW5ndGggKyAoZCAlIDIpKTtcbiAgICAgICAgICAgIGZvciAoayA9IGxvd2VyQm91bmQ7IGsgPD0gdXBwZXJCb3VuZDsgayArPSAyKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSAwO1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgdGhlIFggdmFsdWVzIG9mIChkLTEpLWxpbmVzIHRvIGNvbXB1dGUgWCB2YWx1ZSBvZiB0aGUgbG9uZ2VzdCBkLWxpbmVzLlxuICAgICAgICAgICAgICAgIGNvbnN0IG1heFhvZkRMaW5lVG9wID0gayA9PT0gdXBwZXJCb3VuZCA/IC0xIDogVi5nZXQoayArIDEpOyAvLyBXZSB0YWtlIGEgdmVydGljYWwgbm9uLWRpYWdvbmFsIChhZGQgYSBzeW1ib2wgaW4gc2VxWClcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhYb2ZETGluZUxlZnQgPSBrID09PSBsb3dlckJvdW5kID8gLTEgOiBWLmdldChrIC0gMSkgKyAxOyAvLyBXZSB0YWtlIGEgaG9yaXpvbnRhbCBub24tZGlhZ29uYWwgKCsxIHgpIChkZWxldGUgYSBzeW1ib2wgaW4gc2VxWClcbiAgICAgICAgICAgICAgICBzdGVwKys7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IE1hdGgubWluKE1hdGgubWF4KG1heFhvZkRMaW5lVG9wLCBtYXhYb2ZETGluZUxlZnQpLCBzZXFYLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IHggLSBrO1xuICAgICAgICAgICAgICAgIHN0ZXArKztcbiAgICAgICAgICAgICAgICBpZiAoeCA+IHNlcVgubGVuZ3RoIHx8IHkgPiBzZXFZLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGRpYWdvbmFsIGlzIGlycmVsZXZhbnQgZm9yIHRoZSByZXN1bHQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IERvbid0IHBheSB0aGUgY29zdCBmb3IgdGhpcyBpbiB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdNYXhYID0gZ2V0WEFmdGVyU25ha2UoeCwgeSk7XG4gICAgICAgICAgICAgICAgVi5zZXQoaywgbmV3TWF4WCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdFBhdGggPSB4ID09PSBtYXhYb2ZETGluZVRvcCA/IHBhdGhzLmdldChrICsgMSkgOiBwYXRocy5nZXQoayAtIDEpO1xuICAgICAgICAgICAgICAgIHBhdGhzLnNldChrLCBuZXdNYXhYICE9PSB4ID8gbmV3IFNuYWtlUGF0aChsYXN0UGF0aCwgeCwgeSwgbmV3TWF4WCAtIHgpIDogbGFzdFBhdGgpO1xuICAgICAgICAgICAgICAgIGlmIChWLmdldChrKSA9PT0gc2VxWC5sZW5ndGggJiYgVi5nZXQoaykgLSBrID09PSBzZXFZLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBsb29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcGF0aCA9IHBhdGhzLmdldChrKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBsYXN0QWxpZ25pbmdQb3NTMSA9IHNlcVgubGVuZ3RoO1xuICAgICAgICBsZXQgbGFzdEFsaWduaW5nUG9zUzIgPSBzZXFZLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGVuZFggPSBwYXRoID8gcGF0aC54ICsgcGF0aC5sZW5ndGggOiAwO1xuICAgICAgICAgICAgY29uc3QgZW5kWSA9IHBhdGggPyBwYXRoLnkgKyBwYXRoLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICBpZiAoZW5kWCAhPT0gbGFzdEFsaWduaW5nUG9zUzEgfHwgZW5kWSAhPT0gbGFzdEFsaWduaW5nUG9zUzIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgU2VxdWVuY2VEaWZmKG5ldyBPZmZzZXRSYW5nZShlbmRYLCBsYXN0QWxpZ25pbmdQb3NTMSksIG5ldyBPZmZzZXRSYW5nZShlbmRZLCBsYXN0QWxpZ25pbmdQb3NTMikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEFsaWduaW5nUG9zUzEgPSBwYXRoLng7XG4gICAgICAgICAgICBsYXN0QWxpZ25pbmdQb3NTMiA9IHBhdGgueTtcbiAgICAgICAgICAgIHBhdGggPSBwYXRoLnByZXY7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEaWZmQWxnb3JpdGhtUmVzdWx0KHJlc3VsdCwgZmFsc2UpO1xuICAgIH1cbn1cbmNsYXNzIFNuYWtlUGF0aCB7XG4gICAgY29uc3RydWN0b3IocHJldiwgeCwgeSwgbGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJldiA9IHByZXY7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbn1cbi8qKlxuICogQW4gYXJyYXkgdGhhdCBzdXBwb3J0cyBmYXN0IG5lZ2F0aXZlIGluZGljZXMuXG4qL1xuY2xhc3MgRmFzdEludDMyQXJyYXkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBvc2l0aXZlQXJyID0gbmV3IEludDMyQXJyYXkoMTApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlQXJyID0gbmV3IEludDMyQXJyYXkoMTApO1xuICAgIH1cbiAgICBnZXQoaWR4KSB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZHggPSAtaWR4IC0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlQXJyW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGl2ZUFycltpZHhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChpZHgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZHggPSAtaWR4IC0gMTtcbiAgICAgICAgICAgIGlmIChpZHggPj0gdGhpcy5uZWdhdGl2ZUFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSB0aGlzLm5lZ2F0aXZlQXJyO1xuICAgICAgICAgICAgICAgIHRoaXMubmVnYXRpdmVBcnIgPSBuZXcgSW50MzJBcnJheShhcnIubGVuZ3RoICogMik7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWdhdGl2ZUFyci5zZXQoYXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubmVnYXRpdmVBcnJbaWR4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGlkeCA+PSB0aGlzLnBvc2l0aXZlQXJyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IHRoaXMucG9zaXRpdmVBcnI7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZUFyciA9IG5ldyBJbnQzMkFycmF5KGFyci5sZW5ndGggKiAyKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBvc2l0aXZlQXJyLnNldChhcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZUFycltpZHhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEFuIGFycmF5IHRoYXQgc3VwcG9ydHMgZmFzdCBuZWdhdGl2ZSBpbmRpY2VzLlxuKi9cbmNsYXNzIEZhc3RBcnJheU5lZ2F0aXZlSW5kaWNlcyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucG9zaXRpdmVBcnIgPSBbXTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZUFyciA9IFtdO1xuICAgIH1cbiAgICBnZXQoaWR4KSB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZHggPSAtaWR4IC0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlQXJyW2lkeF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGl2ZUFycltpZHhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldChpZHgsIHZhbHVlKSB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgICBpZHggPSAtaWR4IC0gMTtcbiAgICAgICAgICAgIHRoaXMubmVnYXRpdmVBcnJbaWR4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGl2ZUFycltpZHhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGZpbmRMYXN0SWR4TW9ub3Rvbm91cywgZmluZExhc3RNb25vdG9ub3VzLCBmaW5kRmlyc3RNb25vdG9ub3VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzRmluZC5qcyc7XG5pbXBvcnQgeyBPZmZzZXRSYW5nZSB9IGZyb20gJy4uLy4uL2NvcmUvb2Zmc2V0UmFuZ2UuanMnO1xuaW1wb3J0IHsgUG9zaXRpb24gfSBmcm9tICcuLi8uLi9jb3JlL3Bvc2l0aW9uLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBpc1NwYWNlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgTGluZXNTbGljZUNoYXJTZXF1ZW5jZSB7XG4gICAgY29uc3RydWN0b3IobGluZXMsIGxpbmVSYW5nZSwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcykge1xuICAgICAgICAvLyBUaGlzIHNsaWNlIGhhcyB0byBoYXZlIGxpbmVSYW5nZS5sZW5ndGggbWFueSBcXG4hIChvdGhlcndpc2UgZGlmZmluZyBhZ2FpbnN0IGFuIGVtcHR5IHNsaWNlIHdpbGwgYmUgcHJvYmxlbWF0aWMpXG4gICAgICAgIC8vIChVbmxlc3MgaXQgY292ZXJzIHRoZSBlbnRpcmUgZG9jdW1lbnQsIGluIHRoYXQgY2FzZSB0aGUgb3RoZXIgc2xpY2UgYWxzbyBoYXMgdG8gY292ZXIgdGhlIGVudGlyZSBkb2N1bWVudCBhbmRzIGl0J3Mgb2theSlcbiAgICAgICAgdGhpcy5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLmNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMgPSBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgICAgIHRoaXMuZmlyc3RDaGFyT2Zmc2V0QnlMaW5lID0gW107XG4gICAgICAgIC8vIFRvIGFjY291bnQgZm9yIHRyaW1taW5nXG4gICAgICAgIHRoaXMuYWRkaXRpb25hbE9mZnNldEJ5TGluZSA9IFtdO1xuICAgICAgICAvLyBJZiB0aGUgc2xpY2UgY292ZXJzIHRoZSBlbmQsIGJ1dCBkb2VzIG5vdCBzdGFydCBhdCB0aGUgYmVnaW5uaW5nLCB3ZSBpbmNsdWRlIGp1c3QgdGhlIFxcbiBvZiB0aGUgcHJldmlvdXMgbGluZS5cbiAgICAgICAgbGV0IHRyaW1GaXJzdExpbmVGdWxseSA9IGZhbHNlO1xuICAgICAgICBpZiAobGluZVJhbmdlLnN0YXJ0ID4gMCAmJiBsaW5lUmFuZ2UuZW5kRXhjbHVzaXZlID49IGxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbGluZVJhbmdlID0gbmV3IE9mZnNldFJhbmdlKGxpbmVSYW5nZS5zdGFydCAtIDEsIGxpbmVSYW5nZS5lbmRFeGNsdXNpdmUpO1xuICAgICAgICAgICAgdHJpbUZpcnN0TGluZUZ1bGx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmVSYW5nZSA9IGxpbmVSYW5nZTtcbiAgICAgICAgdGhpcy5maXJzdENoYXJPZmZzZXRCeUxpbmVbMF0gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5saW5lUmFuZ2Uuc3RhcnQ7IGkgPCB0aGlzLmxpbmVSYW5nZS5lbmRFeGNsdXNpdmU7IGkrKykge1xuICAgICAgICAgICAgbGV0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKHRyaW1GaXJzdExpbmVGdWxseSkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IGxpbmUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGxpbmUgPSAnJztcbiAgICAgICAgICAgICAgICB0cmltRmlyc3RMaW5lRnVsbHkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFN0YXJ0TGluZSA9IGxpbmUudHJpbVN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGluZS5sZW5ndGggLSB0cmltbWVkU3RhcnRMaW5lLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBsaW5lID0gdHJpbW1lZFN0YXJ0TGluZS50cmltRW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZGl0aW9uYWxPZmZzZXRCeUxpbmUucHVzaChvZmZzZXQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKGxpbmUuY2hhckNvZGVBdChpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb24ndCBhZGQgYW4gXFxuIHRoYXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGRvY3VtZW50LlxuICAgICAgICAgICAgaWYgKGkgPCBsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKCdcXG4nLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RDaGFyT2Zmc2V0QnlMaW5lW2kgLSB0aGlzLmxpbmVSYW5nZS5zdGFydCArIDFdID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVG8gYWNjb3VudCBmb3IgdGhlIGxhc3QgbGluZVxuICAgICAgICB0aGlzLmFkZGl0aW9uYWxPZmZzZXRCeUxpbmUucHVzaCgwKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgU2xpY2U6IFwiJHt0aGlzLnRleHR9XCJgO1xuICAgIH1cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dChuZXcgT2Zmc2V0UmFuZ2UoMCwgdGhpcy5sZW5ndGgpKTtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50cy5zbGljZShyYW5nZS5zdGFydCwgcmFuZ2UuZW5kRXhjbHVzaXZlKS5tYXAoZSA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKS5qb2luKCcnKTtcbiAgICB9XG4gICAgZ2V0RWxlbWVudChvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbb2Zmc2V0XTtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIH1cbiAgICBnZXRCb3VuZGFyeVNjb3JlKGxlbmd0aCkge1xuICAgICAgICAvLyAgIGEgICBiICAgYyAgICwgICAgICAgICAgIGQgICBlICAgZlxuICAgICAgICAvLyAxMSAgMCAgIDAgICAxMiAgMTUgIDYgICAxMyAgMCAgIDAgICAxMVxuICAgICAgICBjb25zdCBwcmV2Q2F0ZWdvcnkgPSBnZXRDYXRlZ29yeShsZW5ndGggPiAwID8gdGhpcy5lbGVtZW50c1tsZW5ndGggLSAxXSA6IC0xKTtcbiAgICAgICAgY29uc3QgbmV4dENhdGVnb3J5ID0gZ2V0Q2F0ZWdvcnkobGVuZ3RoIDwgdGhpcy5lbGVtZW50cy5sZW5ndGggPyB0aGlzLmVsZW1lbnRzW2xlbmd0aF0gOiAtMSk7XG4gICAgICAgIGlmIChwcmV2Q2F0ZWdvcnkgPT09IDcgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuTGluZUJyZWFrQ1IgKi8gJiYgbmV4dENhdGVnb3J5ID09PSA4IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LkxpbmVCcmVha0xGICovKSB7XG4gICAgICAgICAgICAvLyBkb24ndCBicmVhayBiZXR3ZWVuIFxcciBhbmQgXFxuXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkNhdGVnb3J5ID09PSA4IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LkxpbmVCcmVha0xGICovKSB7XG4gICAgICAgICAgICAvLyBwcmVmZXIgdGhlIGxpbmVicmVhayBiZWZvcmUgdGhlIGNoYW5nZVxuICAgICAgICAgICAgcmV0dXJuIDE1MDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2NvcmUgPSAwO1xuICAgICAgICBpZiAocHJldkNhdGVnb3J5ICE9PSBuZXh0Q2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIHNjb3JlICs9IDEwO1xuICAgICAgICAgICAgaWYgKHByZXZDYXRlZ29yeSA9PT0gMCAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5Xb3JkTG93ZXIgKi8gJiYgbmV4dENhdGVnb3J5ID09PSAxIC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LldvcmRVcHBlciAqLykge1xuICAgICAgICAgICAgICAgIHNjb3JlICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NvcmUgKz0gZ2V0Q2F0ZWdvcnlCb3VuZGFyeVNjb3JlKHByZXZDYXRlZ29yeSk7XG4gICAgICAgIHNjb3JlICs9IGdldENhdGVnb3J5Qm91bmRhcnlTY29yZShuZXh0Q2F0ZWdvcnkpO1xuICAgICAgICByZXR1cm4gc2NvcmU7XG4gICAgfVxuICAgIHRyYW5zbGF0ZU9mZnNldChvZmZzZXQpIHtcbiAgICAgICAgLy8gZmluZCBzbWFsbGVzdCBpLCBzbyB0aGF0IGxpbmVCcmVha09mZnNldHNbaV0gPD0gb2Zmc2V0IHVzaW5nIGJpbmFyeSBzZWFyY2hcbiAgICAgICAgaWYgKHRoaXMubGluZVJhbmdlLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lUmFuZ2Uuc3RhcnQgKyAxLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpID0gZmluZExhc3RJZHhNb25vdG9ub3VzKHRoaXMuZmlyc3RDaGFyT2Zmc2V0QnlMaW5lLCAodmFsdWUpID0+IHZhbHVlIDw9IG9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgUG9zaXRpb24odGhpcy5saW5lUmFuZ2Uuc3RhcnQgKyBpICsgMSwgb2Zmc2V0IC0gdGhpcy5maXJzdENoYXJPZmZzZXRCeUxpbmVbaV0gKyB0aGlzLmFkZGl0aW9uYWxPZmZzZXRCeUxpbmVbaV0gKyAxKTtcbiAgICB9XG4gICAgdHJhbnNsYXRlUmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlLmZyb21Qb3NpdGlvbnModGhpcy50cmFuc2xhdGVPZmZzZXQocmFuZ2Uuc3RhcnQpLCB0aGlzLnRyYW5zbGF0ZU9mZnNldChyYW5nZS5lbmRFeGNsdXNpdmUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIHdvcmQgdGhhdCBjb250YWlucyB0aGUgY2hhcmFjdGVyIGF0IHRoZSBnaXZlbiBvZmZzZXRcbiAgICAgKi9cbiAgICBmaW5kV29yZENvbnRhaW5pbmcob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCA+PSB0aGlzLmVsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzV29yZENoYXIodGhpcy5lbGVtZW50c1tvZmZzZXRdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBmaW5kIHN0YXJ0XG4gICAgICAgIGxldCBzdGFydCA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKHN0YXJ0ID4gMCAmJiBpc1dvcmRDaGFyKHRoaXMuZWxlbWVudHNbc3RhcnQgLSAxXSkpIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCBlbmRcbiAgICAgICAgbGV0IGVuZCA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKGVuZCA8IHRoaXMuZWxlbWVudHMubGVuZ3RoICYmIGlzV29yZENoYXIodGhpcy5lbGVtZW50c1tlbmRdKSkge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBPZmZzZXRSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgY291bnRMaW5lc0luKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZU9mZnNldChyYW5nZS5lbmRFeGNsdXNpdmUpLmxpbmVOdW1iZXIgLSB0aGlzLnRyYW5zbGF0ZU9mZnNldChyYW5nZS5zdGFydCkubGluZU51bWJlcjtcbiAgICB9XG4gICAgaXNTdHJvbmdseUVxdWFsKG9mZnNldDEsIG9mZnNldDIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHNbb2Zmc2V0MV0gPT09IHRoaXMuZWxlbWVudHNbb2Zmc2V0Ml07XG4gICAgfVxuICAgIGV4dGVuZFRvRnVsbExpbmVzKHJhbmdlKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gKF9hID0gZmluZExhc3RNb25vdG9ub3VzKHRoaXMuZmlyc3RDaGFyT2Zmc2V0QnlMaW5lLCB4ID0+IHggPD0gcmFuZ2Uuc3RhcnQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBjb25zdCBlbmQgPSAoX2IgPSBmaW5kRmlyc3RNb25vdG9ub3VzKHRoaXMuZmlyc3RDaGFyT2Zmc2V0QnlMaW5lLCB4ID0+IHJhbmdlLmVuZEV4Y2x1c2l2ZSA8PSB4KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBuZXcgT2Zmc2V0UmFuZ2Uoc3RhcnQsIGVuZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNXb3JkQ2hhcihjaGFyQ29kZSkge1xuICAgIHJldHVybiBjaGFyQ29kZSA+PSA5NyAvKiBDaGFyQ29kZS5hICovICYmIGNoYXJDb2RlIDw9IDEyMiAvKiBDaGFyQ29kZS56ICovXG4gICAgICAgIHx8IGNoYXJDb2RlID49IDY1IC8qIENoYXJDb2RlLkEgKi8gJiYgY2hhckNvZGUgPD0gOTAgLyogQ2hhckNvZGUuWiAqL1xuICAgICAgICB8fCBjaGFyQ29kZSA+PSA0OCAvKiBDaGFyQ29kZS5EaWdpdDAgKi8gJiYgY2hhckNvZGUgPD0gNTcgLyogQ2hhckNvZGUuRGlnaXQ5ICovO1xufVxuY29uc3Qgc2NvcmUgPSB7XG4gICAgWzAgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuV29yZExvd2VyICovXTogMCxcbiAgICBbMSAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5Xb3JkVXBwZXIgKi9dOiAwLFxuICAgIFsyIC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LldvcmROdW1iZXIgKi9dOiAwLFxuICAgIFszIC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LkVuZCAqL106IDEwLFxuICAgIFs0IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5Lk90aGVyICovXTogMixcbiAgICBbNSAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5TZXBhcmF0b3IgKi9dOiAzMCxcbiAgICBbNiAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5TcGFjZSAqL106IDMsXG4gICAgWzcgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuTGluZUJyZWFrQ1IgKi9dOiAxMCxcbiAgICBbOCAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5MaW5lQnJlYWtMRiAqL106IDEwLFxufTtcbmZ1bmN0aW9uIGdldENhdGVnb3J5Qm91bmRhcnlTY29yZShjYXRlZ29yeSkge1xuICAgIHJldHVybiBzY29yZVtjYXRlZ29yeV07XG59XG5mdW5jdGlvbiBnZXRDYXRlZ29yeShjaGFyQ29kZSkge1xuICAgIGlmIChjaGFyQ29kZSA9PT0gMTAgLyogQ2hhckNvZGUuTGluZUZlZWQgKi8pIHtcbiAgICAgICAgcmV0dXJuIDggLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuTGluZUJyZWFrTEYgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYXJDb2RlID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLykge1xuICAgICAgICByZXR1cm4gNyAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5MaW5lQnJlYWtDUiAqLztcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTcGFjZShjaGFyQ29kZSkpIHtcbiAgICAgICAgcmV0dXJuIDYgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuU3BhY2UgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYXJDb2RlID49IDk3IC8qIENoYXJDb2RlLmEgKi8gJiYgY2hhckNvZGUgPD0gMTIyIC8qIENoYXJDb2RlLnogKi8pIHtcbiAgICAgICAgcmV0dXJuIDAgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuV29yZExvd2VyICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFyQ29kZSA+PSA2NSAvKiBDaGFyQ29kZS5BICovICYmIGNoYXJDb2RlIDw9IDkwIC8qIENoYXJDb2RlLlogKi8pIHtcbiAgICAgICAgcmV0dXJuIDEgLyogQ2hhckJvdW5kYXJ5Q2F0ZWdvcnkuV29yZFVwcGVyICovO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFyQ29kZSA+PSA0OCAvKiBDaGFyQ29kZS5EaWdpdDAgKi8gJiYgY2hhckNvZGUgPD0gNTcgLyogQ2hhckNvZGUuRGlnaXQ5ICovKSB7XG4gICAgICAgIHJldHVybiAyIC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LldvcmROdW1iZXIgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYXJDb2RlID09PSAtMSkge1xuICAgICAgICByZXR1cm4gMyAvKiBDaGFyQm91bmRhcnlDYXRlZ29yeS5FbmQgKi87XG4gICAgfVxuICAgIGVsc2UgaWYgKGNoYXJDb2RlID09PSA0NCAvKiBDaGFyQ29kZS5Db21tYSAqLyB8fCBjaGFyQ29kZSA9PT0gNTkgLyogQ2hhckNvZGUuU2VtaWNvbG9uICovKSB7XG4gICAgICAgIHJldHVybiA1IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5LlNlcGFyYXRvciAqLztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiA0IC8qIENoYXJCb3VuZGFyeUNhdGVnb3J5Lk90aGVyICovO1xuICAgIH1cbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgU2VxdWVuY2VEaWZmIH0gZnJvbSAnLi9hbGdvcml0aG1zL2RpZmZBbGdvcml0aG0uanMnO1xuaW1wb3J0IHsgTGluZVJhbmdlTWFwcGluZyB9IGZyb20gJy4uL3JhbmdlTWFwcGluZy5qcyc7XG5pbXBvcnQgeyBwdXNoTWFueSwgY29tcGFyZUJ5LCBudW1iZXJDb21wYXJhdG9yLCByZXZlcnNlT3JkZXIgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xuaW1wb3J0IHsgTW9ub3Rvbm91c0FycmF5LCBmaW5kTGFzdE1vbm90b25vdXMgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXNGaW5kLmpzJztcbmltcG9ydCB7IFNldE1hcCB9IGZyb20gJy4uLy4uLy4uLy4uL2Jhc2UvY29tbW9uL21hcC5qcyc7XG5pbXBvcnQgeyBMaW5lUmFuZ2UsIExpbmVSYW5nZVNldCB9IGZyb20gJy4uLy4uL2NvcmUvbGluZVJhbmdlLmpzJztcbmltcG9ydCB7IE9mZnNldFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9vZmZzZXRSYW5nZS5qcyc7XG5pbXBvcnQgeyBMaW5lc1NsaWNlQ2hhclNlcXVlbmNlIH0gZnJvbSAnLi9saW5lc1NsaWNlQ2hhclNlcXVlbmNlLmpzJztcbmltcG9ydCB7IExpbmVSYW5nZUZyYWdtZW50LCBpc1NwYWNlIH0gZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBNeWVyc0RpZmZBbGdvcml0aG0gfSBmcm9tICcuL2FsZ29yaXRobXMvbXllcnNEaWZmQWxnb3JpdGhtLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlTW92ZWRMaW5lcyhjaGFuZ2VzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBoYXNoZWRPcmlnaW5hbExpbmVzLCBoYXNoZWRNb2RpZmllZExpbmVzLCB0aW1lb3V0KSB7XG4gICAgbGV0IHsgbW92ZXMsIGV4Y2x1ZGVkQ2hhbmdlcyB9ID0gY29tcHV0ZU1vdmVzRnJvbVNpbXBsZURlbGV0aW9uc1RvU2ltcGxlSW5zZXJ0aW9ucyhjaGFuZ2VzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCB0aW1lb3V0KTtcbiAgICBpZiAoIXRpbWVvdXQuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWRDaGFuZ2VzID0gY2hhbmdlcy5maWx0ZXIoYyA9PiAhZXhjbHVkZWRDaGFuZ2VzLmhhcyhjKSk7XG4gICAgY29uc3QgdW5jaGFuZ2VkTW92ZXMgPSBjb21wdXRlVW5jaGFuZ2VkTW92ZXMoZmlsdGVyZWRDaGFuZ2VzLCBoYXNoZWRPcmlnaW5hbExpbmVzLCBoYXNoZWRNb2RpZmllZExpbmVzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCB0aW1lb3V0KTtcbiAgICBwdXNoTWFueShtb3ZlcywgdW5jaGFuZ2VkTW92ZXMpO1xuICAgIG1vdmVzID0gam9pbkNsb3NlQ29uc2VjdXRpdmVNb3Zlcyhtb3Zlcyk7XG4gICAgLy8gSWdub3JlIHRvbyBzaG9ydCBtb3Zlc1xuICAgIG1vdmVzID0gbW92ZXMuZmlsdGVyKGN1cnJlbnQgPT4ge1xuICAgICAgICBjb25zdCBsaW5lcyA9IGN1cnJlbnQub3JpZ2luYWwudG9PZmZzZXRSYW5nZSgpLnNsaWNlKG9yaWdpbmFsTGluZXMpLm1hcChsID0+IGwudHJpbSgpKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUZXh0ID0gbGluZXMuam9pbignXFxuJyk7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbFRleHQubGVuZ3RoID49IDE1ICYmIGNvdW50V2hlcmUobGluZXMsIGwgPT4gbC5sZW5ndGggPj0gMikgPj0gMjtcbiAgICB9KTtcbiAgICBtb3ZlcyA9IHJlbW92ZU1vdmVzSW5TYW1lRGlmZihjaGFuZ2VzLCBtb3Zlcyk7XG4gICAgcmV0dXJuIG1vdmVzO1xufVxuZnVuY3Rpb24gY291bnRXaGVyZShhcnIsIHByZWRpY2F0ZSkge1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCB0IG9mIGFycikge1xuICAgICAgICBpZiAocHJlZGljYXRlKHQpKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVNb3Zlc0Zyb21TaW1wbGVEZWxldGlvbnNUb1NpbXBsZUluc2VydGlvbnMoY2hhbmdlcywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgdGltZW91dCkge1xuICAgIGNvbnN0IG1vdmVzID0gW107XG4gICAgY29uc3QgZGVsZXRpb25zID0gY2hhbmdlc1xuICAgICAgICAuZmlsdGVyKGMgPT4gYy5tb2RpZmllZC5pc0VtcHR5ICYmIGMub3JpZ2luYWwubGVuZ3RoID49IDMpXG4gICAgICAgIC5tYXAoZCA9PiBuZXcgTGluZVJhbmdlRnJhZ21lbnQoZC5vcmlnaW5hbCwgb3JpZ2luYWxMaW5lcywgZCkpO1xuICAgIGNvbnN0IGluc2VydGlvbnMgPSBuZXcgU2V0KGNoYW5nZXNcbiAgICAgICAgLmZpbHRlcihjID0+IGMub3JpZ2luYWwuaXNFbXB0eSAmJiBjLm1vZGlmaWVkLmxlbmd0aCA+PSAzKVxuICAgICAgICAubWFwKGQgPT4gbmV3IExpbmVSYW5nZUZyYWdtZW50KGQubW9kaWZpZWQsIG1vZGlmaWVkTGluZXMsIGQpKSk7XG4gICAgY29uc3QgZXhjbHVkZWRDaGFuZ2VzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgZGVsZXRpb24gb2YgZGVsZXRpb25zKSB7XG4gICAgICAgIGxldCBoaWdoZXN0U2ltaWxhcml0eSA9IC0xO1xuICAgICAgICBsZXQgYmVzdDtcbiAgICAgICAgZm9yIChjb25zdCBpbnNlcnRpb24gb2YgaW5zZXJ0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgc2ltaWxhcml0eSA9IGRlbGV0aW9uLmNvbXB1dGVTaW1pbGFyaXR5KGluc2VydGlvbik7XG4gICAgICAgICAgICBpZiAoc2ltaWxhcml0eSA+IGhpZ2hlc3RTaW1pbGFyaXR5KSB7XG4gICAgICAgICAgICAgICAgaGlnaGVzdFNpbWlsYXJpdHkgPSBzaW1pbGFyaXR5O1xuICAgICAgICAgICAgICAgIGJlc3QgPSBpbnNlcnRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpZ2hlc3RTaW1pbGFyaXR5ID4gMC45MCAmJiBiZXN0KSB7XG4gICAgICAgICAgICBpbnNlcnRpb25zLmRlbGV0ZShiZXN0KTtcbiAgICAgICAgICAgIG1vdmVzLnB1c2gobmV3IExpbmVSYW5nZU1hcHBpbmcoZGVsZXRpb24ucmFuZ2UsIGJlc3QucmFuZ2UpKTtcbiAgICAgICAgICAgIGV4Y2x1ZGVkQ2hhbmdlcy5hZGQoZGVsZXRpb24uc291cmNlKTtcbiAgICAgICAgICAgIGV4Y2x1ZGVkQ2hhbmdlcy5hZGQoYmVzdC5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGltZW91dC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1vdmVzLCBleGNsdWRlZENoYW5nZXMgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBtb3ZlcywgZXhjbHVkZWRDaGFuZ2VzIH07XG59XG5mdW5jdGlvbiBjb21wdXRlVW5jaGFuZ2VkTW92ZXMoY2hhbmdlcywgaGFzaGVkT3JpZ2luYWxMaW5lcywgaGFzaGVkTW9kaWZpZWRMaW5lcywgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgdGltZW91dCkge1xuICAgIGNvbnN0IG1vdmVzID0gW107XG4gICAgY29uc3Qgb3JpZ2luYWwzTGluZUhhc2hlcyA9IG5ldyBTZXRNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGNoYW5nZSBvZiBjaGFuZ2VzKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBjaGFuZ2Uub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyOyBpIDwgY2hhbmdlLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgLSAyOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGAke2hhc2hlZE9yaWdpbmFsTGluZXNbaSAtIDFdfToke2hhc2hlZE9yaWdpbmFsTGluZXNbaSArIDEgLSAxXX06JHtoYXNoZWRPcmlnaW5hbExpbmVzW2kgKyAyIC0gMV19YDtcbiAgICAgICAgICAgIG9yaWdpbmFsM0xpbmVIYXNoZXMuYWRkKGtleSwgeyByYW5nZTogbmV3IExpbmVSYW5nZShpLCBpICsgMykgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcG9zc2libGVNYXBwaW5ncyA9IFtdO1xuICAgIGNoYW5nZXMuc29ydChjb21wYXJlQnkoYyA9PiBjLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciwgbnVtYmVyQ29tcGFyYXRvcikpO1xuICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgbGV0IGxhc3RNYXBwaW5ncyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gY2hhbmdlLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcjsgaSA8IGNoYW5nZS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtoYXNoZWRNb2RpZmllZExpbmVzW2kgLSAxXX06JHtoYXNoZWRNb2RpZmllZExpbmVzW2kgKyAxIC0gMV19OiR7aGFzaGVkTW9kaWZpZWRMaW5lc1tpICsgMiAtIDFdfWA7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50TW9kaWZpZWRSYW5nZSA9IG5ldyBMaW5lUmFuZ2UoaSwgaSArIDMpO1xuICAgICAgICAgICAgY29uc3QgbmV4dE1hcHBpbmdzID0gW107XG4gICAgICAgICAgICBvcmlnaW5hbDNMaW5lSGFzaGVzLmZvckVhY2goa2V5LCAoeyByYW5nZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBsYXN0TWFwcGluZyBvZiBsYXN0TWFwcGluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lcyB0aGlzIG1hdGNoIGV4dGVuZCBzb21lIGxhc3QgbWF0Y2g/XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0TWFwcGluZy5vcmlnaW5hbExpbmVSYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgMSA9PT0gcmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1hcHBpbmcubW9kaWZpZWRMaW5lUmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSArIDEgPT09IGN1cnJlbnRNb2RpZmllZFJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RNYXBwaW5nLm9yaWdpbmFsTGluZVJhbmdlID0gbmV3IExpbmVSYW5nZShsYXN0TWFwcGluZy5vcmlnaW5hbExpbmVSYW5nZS5zdGFydExpbmVOdW1iZXIsIHJhbmdlLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1hcHBpbmcubW9kaWZpZWRMaW5lUmFuZ2UgPSBuZXcgTGluZVJhbmdlKGxhc3RNYXBwaW5nLm1vZGlmaWVkTGluZVJhbmdlLnN0YXJ0TGluZU51bWJlciwgY3VycmVudE1vZGlmaWVkUmFuZ2UuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0TWFwcGluZ3MucHVzaChsYXN0TWFwcGluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWFwcGluZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRMaW5lUmFuZ2U6IGN1cnJlbnRNb2RpZmllZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmVSYW5nZTogcmFuZ2UsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwb3NzaWJsZU1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgICAgICAgbmV4dE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RNYXBwaW5ncyA9IG5leHRNYXBwaW5ncztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRpbWVvdXQuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9zc2libGVNYXBwaW5ncy5zb3J0KHJldmVyc2VPcmRlcihjb21wYXJlQnkobSA9PiBtLm1vZGlmaWVkTGluZVJhbmdlLmxlbmd0aCwgbnVtYmVyQ29tcGFyYXRvcikpKTtcbiAgICBjb25zdCBtb2RpZmllZFNldCA9IG5ldyBMaW5lUmFuZ2VTZXQoKTtcbiAgICBjb25zdCBvcmlnaW5hbFNldCA9IG5ldyBMaW5lUmFuZ2VTZXQoKTtcbiAgICBmb3IgKGNvbnN0IG1hcHBpbmcgb2YgcG9zc2libGVNYXBwaW5ncykge1xuICAgICAgICBjb25zdCBkaWZmT3JpZ1RvTW9kID0gbWFwcGluZy5tb2RpZmllZExpbmVSYW5nZS5zdGFydExpbmVOdW1iZXIgLSBtYXBwaW5nLm9yaWdpbmFsTGluZVJhbmdlLnN0YXJ0TGluZU51bWJlcjtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRTZWN0aW9ucyA9IG1vZGlmaWVkU2V0LnN1YnRyYWN0RnJvbShtYXBwaW5nLm1vZGlmaWVkTGluZVJhbmdlKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxUcmFuc2xhdGVkU2VjdGlvbnMgPSBvcmlnaW5hbFNldC5zdWJ0cmFjdEZyb20obWFwcGluZy5vcmlnaW5hbExpbmVSYW5nZSkuZ2V0V2l0aERlbHRhKGRpZmZPcmlnVG9Nb2QpO1xuICAgICAgICBjb25zdCBtb2RpZmllZEludGVyc2VjdGVkU2VjdGlvbnMgPSBtb2RpZmllZFNlY3Rpb25zLmdldEludGVyc2VjdGlvbihvcmlnaW5hbFRyYW5zbGF0ZWRTZWN0aW9ucyk7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBtb2RpZmllZEludGVyc2VjdGVkU2VjdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICBpZiAocy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtb2RpZmllZExpbmVSYW5nZSA9IHM7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbExpbmVSYW5nZSA9IHMuZGVsdGEoLWRpZmZPcmlnVG9Nb2QpO1xuICAgICAgICAgICAgbW92ZXMucHVzaChuZXcgTGluZVJhbmdlTWFwcGluZyhvcmlnaW5hbExpbmVSYW5nZSwgbW9kaWZpZWRMaW5lUmFuZ2UpKTtcbiAgICAgICAgICAgIG1vZGlmaWVkU2V0LmFkZFJhbmdlKG1vZGlmaWVkTGluZVJhbmdlKTtcbiAgICAgICAgICAgIG9yaWdpbmFsU2V0LmFkZFJhbmdlKG9yaWdpbmFsTGluZVJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtb3Zlcy5zb3J0KGNvbXBhcmVCeShtID0+IG0ub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyLCBudW1iZXJDb21wYXJhdG9yKSk7XG4gICAgY29uc3QgbW9ub3Rvbm91c0NoYW5nZXMgPSBuZXcgTW9ub3Rvbm91c0FycmF5KGNoYW5nZXMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbW92ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbW92ZSA9IG1vdmVzW2ldO1xuICAgICAgICBjb25zdCBmaXJzdFRvdWNoaW5nQ2hhbmdlT3JpZyA9IG1vbm90b25vdXNDaGFuZ2VzLmZpbmRMYXN0TW9ub3Rvbm91cyhjID0+IGMub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIDw9IG1vdmUub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgZmlyc3RUb3VjaGluZ0NoYW5nZU1vZCA9IGZpbmRMYXN0TW9ub3Rvbm91cyhjaGFuZ2VzLCBjID0+IGMubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIDw9IG1vdmUubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgbGluZXNBYm92ZSA9IE1hdGgubWF4KG1vdmUub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIC0gZmlyc3RUb3VjaGluZ0NoYW5nZU9yaWcub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyLCBtb3ZlLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciAtIGZpcnN0VG91Y2hpbmdDaGFuZ2VNb2QubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgbGFzdFRvdWNoaW5nQ2hhbmdlT3JpZyA9IG1vbm90b25vdXNDaGFuZ2VzLmZpbmRMYXN0TW9ub3Rvbm91cyhjID0+IGMub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIDwgbW92ZS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKTtcbiAgICAgICAgY29uc3QgbGFzdFRvdWNoaW5nQ2hhbmdlTW9kID0gZmluZExhc3RNb25vdG9ub3VzKGNoYW5nZXMsIGMgPT4gYy5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgPCBtb3ZlLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUpO1xuICAgICAgICBjb25zdCBsaW5lc0JlbG93ID0gTWF0aC5tYXgobGFzdFRvdWNoaW5nQ2hhbmdlT3JpZy5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIC0gbW92ZS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCBsYXN0VG91Y2hpbmdDaGFuZ2VNb2QubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAtIG1vdmUubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSk7XG4gICAgICAgIGxldCBleHRlbmRUb1RvcDtcbiAgICAgICAgZm9yIChleHRlbmRUb1RvcCA9IDA7IGV4dGVuZFRvVG9wIDwgbGluZXNBYm92ZTsgZXh0ZW5kVG9Ub3ArKykge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ0xpbmUgPSBtb3ZlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAtIGV4dGVuZFRvVG9wIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IG1vZExpbmUgPSBtb3ZlLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciAtIGV4dGVuZFRvVG9wIC0gMTtcbiAgICAgICAgICAgIGlmIChvcmlnTGluZSA+IG9yaWdpbmFsTGluZXMubGVuZ3RoIHx8IG1vZExpbmUgPiBtb2RpZmllZExpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vZGlmaWVkU2V0LmNvbnRhaW5zKG1vZExpbmUpIHx8IG9yaWdpbmFsU2V0LmNvbnRhaW5zKG9yaWdMaW5lKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhcmVMaW5lc1NpbWlsYXIob3JpZ2luYWxMaW5lc1tvcmlnTGluZSAtIDFdLCBtb2RpZmllZExpbmVzW21vZExpbmUgLSAxXSwgdGltZW91dCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0ZW5kVG9Ub3AgPiAwKSB7XG4gICAgICAgICAgICBvcmlnaW5hbFNldC5hZGRSYW5nZShuZXcgTGluZVJhbmdlKG1vdmUub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIC0gZXh0ZW5kVG9Ub3AsIG1vdmUub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyKSk7XG4gICAgICAgICAgICBtb2RpZmllZFNldC5hZGRSYW5nZShuZXcgTGluZVJhbmdlKG1vdmUubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIC0gZXh0ZW5kVG9Ub3AsIG1vdmUubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGV4dGVuZFRvQm90dG9tO1xuICAgICAgICBmb3IgKGV4dGVuZFRvQm90dG9tID0gMDsgZXh0ZW5kVG9Cb3R0b20gPCBsaW5lc0JlbG93OyBleHRlbmRUb0JvdHRvbSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnTGluZSA9IG1vdmUub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSArIGV4dGVuZFRvQm90dG9tO1xuICAgICAgICAgICAgY29uc3QgbW9kTGluZSA9IG1vdmUubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSArIGV4dGVuZFRvQm90dG9tO1xuICAgICAgICAgICAgaWYgKG9yaWdMaW5lID4gb3JpZ2luYWxMaW5lcy5sZW5ndGggfHwgbW9kTGluZSA+IG1vZGlmaWVkTGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9kaWZpZWRTZXQuY29udGFpbnMobW9kTGluZSkgfHwgb3JpZ2luYWxTZXQuY29udGFpbnMob3JpZ0xpbmUpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFyZUxpbmVzU2ltaWxhcihvcmlnaW5hbExpbmVzW29yaWdMaW5lIC0gMV0sIG1vZGlmaWVkTGluZXNbbW9kTGluZSAtIDFdLCB0aW1lb3V0KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHRlbmRUb0JvdHRvbSA+IDApIHtcbiAgICAgICAgICAgIG9yaWdpbmFsU2V0LmFkZFJhbmdlKG5ldyBMaW5lUmFuZ2UobW92ZS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCBtb3ZlLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgKyBleHRlbmRUb0JvdHRvbSkpO1xuICAgICAgICAgICAgbW9kaWZpZWRTZXQuYWRkUmFuZ2UobmV3IExpbmVSYW5nZShtb3ZlLm1vZGlmaWVkLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUsIG1vdmUubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSArIGV4dGVuZFRvQm90dG9tKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVuZFRvVG9wID4gMCB8fCBleHRlbmRUb0JvdHRvbSA+IDApIHtcbiAgICAgICAgICAgIG1vdmVzW2ldID0gbmV3IExpbmVSYW5nZU1hcHBpbmcobmV3IExpbmVSYW5nZShtb3ZlLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAtIGV4dGVuZFRvVG9wLCBtb3ZlLm9yaWdpbmFsLmVuZExpbmVOdW1iZXJFeGNsdXNpdmUgKyBleHRlbmRUb0JvdHRvbSksIG5ldyBMaW5lUmFuZ2UobW92ZS5tb2RpZmllZC5zdGFydExpbmVOdW1iZXIgLSBleHRlbmRUb1RvcCwgbW92ZS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICsgZXh0ZW5kVG9Cb3R0b20pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbW92ZXM7XG59XG5mdW5jdGlvbiBhcmVMaW5lc1NpbWlsYXIobGluZTEsIGxpbmUyLCB0aW1lb3V0KSB7XG4gICAgaWYgKGxpbmUxLnRyaW0oKSA9PT0gbGluZTIudHJpbSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAobGluZTEubGVuZ3RoID4gMzAwICYmIGxpbmUyLmxlbmd0aCA+IDMwMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG15ZXJzRGlmZmluZ0FsZ29yaXRobSA9IG5ldyBNeWVyc0RpZmZBbGdvcml0aG0oKTtcbiAgICBjb25zdCByZXN1bHQgPSBteWVyc0RpZmZpbmdBbGdvcml0aG0uY29tcHV0ZShuZXcgTGluZXNTbGljZUNoYXJTZXF1ZW5jZShbbGluZTFdLCBuZXcgT2Zmc2V0UmFuZ2UoMCwgMSksIGZhbHNlKSwgbmV3IExpbmVzU2xpY2VDaGFyU2VxdWVuY2UoW2xpbmUyXSwgbmV3IE9mZnNldFJhbmdlKDAsIDEpLCBmYWxzZSksIHRpbWVvdXQpO1xuICAgIGxldCBjb21tb25Ob25TcGFjZUNoYXJDb3VudCA9IDA7XG4gICAgY29uc3QgaW52ZXJ0ZWQgPSBTZXF1ZW5jZURpZmYuaW52ZXJ0KHJlc3VsdC5kaWZmcywgbGluZTEubGVuZ3RoKTtcbiAgICBmb3IgKGNvbnN0IHNlcSBvZiBpbnZlcnRlZCkge1xuICAgICAgICBzZXEuc2VxMVJhbmdlLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICAgIGlmICghaXNTcGFjZShsaW5lMS5jaGFyQ29kZUF0KGlkeCkpKSB7XG4gICAgICAgICAgICAgICAgY29tbW9uTm9uU3BhY2VDaGFyQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvdW50Tm9uV3NDaGFycyhzdHIpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lMS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFpc1NwYWNlKHN0ci5jaGFyQ29kZUF0KGkpKSkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICBjb25zdCBsb25nZXJMaW5lTGVuZ3RoID0gY291bnROb25Xc0NoYXJzKGxpbmUxLmxlbmd0aCA+IGxpbmUyLmxlbmd0aCA/IGxpbmUxIDogbGluZTIpO1xuICAgIGNvbnN0IHIgPSBjb21tb25Ob25TcGFjZUNoYXJDb3VudCAvIGxvbmdlckxpbmVMZW5ndGggPiAwLjYgJiYgbG9uZ2VyTGluZUxlbmd0aCA+IDEwO1xuICAgIHJldHVybiByO1xufVxuZnVuY3Rpb24gam9pbkNsb3NlQ29uc2VjdXRpdmVNb3Zlcyhtb3Zlcykge1xuICAgIGlmIChtb3Zlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG1vdmVzO1xuICAgIH1cbiAgICBtb3Zlcy5zb3J0KGNvbXBhcmVCeShtID0+IG0ub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyLCBudW1iZXJDb21wYXJhdG9yKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gW21vdmVzWzBdXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1vdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxhc3QgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gbW92ZXNbaV07XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsRGlzdCA9IGN1cnJlbnQub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIC0gbGFzdC5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlO1xuICAgICAgICBjb25zdCBtb2RpZmllZERpc3QgPSBjdXJyZW50Lm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciAtIGxhc3QubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZTtcbiAgICAgICAgY29uc3QgY3VycmVudE1vdmVBZnRlckxhc3QgPSBvcmlnaW5hbERpc3QgPj0gMCAmJiBtb2RpZmllZERpc3QgPj0gMDtcbiAgICAgICAgaWYgKGN1cnJlbnRNb3ZlQWZ0ZXJMYXN0ICYmIG9yaWdpbmFsRGlzdCArIG1vZGlmaWVkRGlzdCA8PSAyKSB7XG4gICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gbGFzdC5qb2luKGN1cnJlbnQpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZW1vdmVNb3Zlc0luU2FtZURpZmYoY2hhbmdlcywgbW92ZXMpIHtcbiAgICBjb25zdCBjaGFuZ2VzTW9ub3Rvbm91cyA9IG5ldyBNb25vdG9ub3VzQXJyYXkoY2hhbmdlcyk7XG4gICAgbW92ZXMgPSBtb3Zlcy5maWx0ZXIobSA9PiB7XG4gICAgICAgIGNvbnN0IGRpZmZCZWZvcmVFbmRPZk1vdmVPcmlnaW5hbCA9IGNoYW5nZXNNb25vdG9ub3VzLmZpbmRMYXN0TW9ub3Rvbm91cyhjID0+IGMub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIDwgbS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKVxuICAgICAgICAgICAgfHwgbmV3IExpbmVSYW5nZU1hcHBpbmcobmV3IExpbmVSYW5nZSgxLCAxKSwgbmV3IExpbmVSYW5nZSgxLCAxKSk7XG4gICAgICAgIGNvbnN0IGRpZmZCZWZvcmVFbmRPZk1vdmVNb2RpZmllZCA9IGZpbmRMYXN0TW9ub3Rvbm91cyhjaGFuZ2VzLCBjID0+IGMubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIDwgbS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKTtcbiAgICAgICAgY29uc3QgZGlmZmVyZW50RGlmZnMgPSBkaWZmQmVmb3JlRW5kT2ZNb3ZlT3JpZ2luYWwgIT09IGRpZmZCZWZvcmVFbmRPZk1vdmVNb2RpZmllZDtcbiAgICAgICAgcmV0dXJuIGRpZmZlcmVudERpZmZzO1xuICAgIH0pO1xuICAgIHJldHVybiBtb3Zlcztcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgZm9yRWFjaFdpdGhOZWlnaGJvcnMgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hcnJheXMuanMnO1xuaW1wb3J0IHsgT2Zmc2V0UmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL29mZnNldFJhbmdlLmpzJztcbmltcG9ydCB7IE9mZnNldFBhaXIsIFNlcXVlbmNlRGlmZiB9IGZyb20gJy4vYWxnb3JpdGhtcy9kaWZmQWxnb3JpdGhtLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBvcHRpbWl6ZVNlcXVlbmNlRGlmZnMoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcXVlbmNlRGlmZnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gc2VxdWVuY2VEaWZmcztcbiAgICByZXN1bHQgPSBqb2luU2VxdWVuY2VEaWZmc0J5U2hpZnRpbmcoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHJlc3VsdCk7XG4gICAgLy8gU29tZXRpbWVzLCBjYWxsaW5nIHRoaXMgZnVuY3Rpb24gdHdpY2UgaW1wcm92ZXMgdGhlIHJlc3VsdC5cbiAgICAvLyBVbmNvbW1lbnQgdGhlIHNlY29uZCBpbnZvY2F0aW9uIGFuZCBydW4gdGhlIHRlc3RzIHRvIHNlZSB0aGUgZGlmZmVyZW5jZS5cbiAgICByZXN1bHQgPSBqb2luU2VxdWVuY2VEaWZmc0J5U2hpZnRpbmcoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHJlc3VsdCk7XG4gICAgcmVzdWx0ID0gc2hpZnRTZXF1ZW5jZURpZmZzKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZml4ZXMgaXNzdWVzIGxpa2UgdGhpczpcbiAqIGBgYFxuICogaW1wb3J0IHsgQmF6LCBCYXIgfSBmcm9tIFwiZm9vXCI7XG4gKiBgYGBcbiAqIDwtPlxuICogYGBgXG4gKiBpbXBvcnQgeyBCYXosIEJhciwgRm9vIH0gZnJvbSBcImZvb1wiO1xuICogYGBgXG4gKiBDb21wdXRlZCBkaWZmOiBbIHtBZGQgXCIsXCIgYWZ0ZXIgQmFyfSwge0FkZCBcIkZvbyBcIiBhZnRlciBzcGFjZX0gfVxuICogSW1wcm92ZWQgZGlmZjogW3tBZGQgXCIsIEZvb1wiIGFmdGVyIEJhcn1dXG4gKi9cbmZ1bmN0aW9uIGpvaW5TZXF1ZW5jZURpZmZzQnlTaGlmdGluZyhzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgc2VxdWVuY2VEaWZmcykge1xuICAgIGlmIChzZXF1ZW5jZURpZmZzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gc2VxdWVuY2VEaWZmcztcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgcmVzdWx0LnB1c2goc2VxdWVuY2VEaWZmc1swXSk7XG4gICAgLy8gRmlyc3QgbW92ZSB0aGVtIGFsbCB0byB0aGUgbGVmdCBhcyBtdWNoIGFzIHBvc3NpYmxlIGFuZCBqb2luIHRoZW0gaWYgcG9zc2libGVcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHNlcXVlbmNlRGlmZnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcHJldlJlc3VsdCA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIGxldCBjdXIgPSBzZXF1ZW5jZURpZmZzW2ldO1xuICAgICAgICBpZiAoY3VyLnNlcTFSYW5nZS5pc0VtcHR5IHx8IGN1ci5zZXEyUmFuZ2UuaXNFbXB0eSkge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY3VyLnNlcTFSYW5nZS5zdGFydCAtIHByZXZSZXN1bHQuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZTtcbiAgICAgICAgICAgIGxldCBkO1xuICAgICAgICAgICAgZm9yIChkID0gMTsgZCA8PSBsZW5ndGg7IGQrKykge1xuICAgICAgICAgICAgICAgIGlmIChzZXF1ZW5jZTEuZ2V0RWxlbWVudChjdXIuc2VxMVJhbmdlLnN0YXJ0IC0gZCkgIT09IHNlcXVlbmNlMS5nZXRFbGVtZW50KGN1ci5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlIC0gZCkgfHxcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2UyLmdldEVsZW1lbnQoY3VyLnNlcTJSYW5nZS5zdGFydCAtIGQpICE9PSBzZXF1ZW5jZTIuZ2V0RWxlbWVudChjdXIuc2VxMlJhbmdlLmVuZEV4Y2x1c2l2ZSAtIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGQtLTtcbiAgICAgICAgICAgIGlmIChkID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBwcmV2aW91cyBhbmQgY3VycmVudCBkaWZmXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSA9IG5ldyBTZXF1ZW5jZURpZmYobmV3IE9mZnNldFJhbmdlKHByZXZSZXN1bHQuc2VxMVJhbmdlLnN0YXJ0LCBjdXIuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSAtIGxlbmd0aCksIG5ldyBPZmZzZXRSYW5nZShwcmV2UmVzdWx0LnNlcTJSYW5nZS5zdGFydCwgY3VyLnNlcTJSYW5nZS5lbmRFeGNsdXNpdmUgLSBsZW5ndGgpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1ciA9IGN1ci5kZWx0YSgtZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY3VyKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0MiA9IFtdO1xuICAgIC8vIFRoZW4gbW92ZSB0aGVtIGFsbCB0byB0aGUgcmlnaHQgYW5kIGpvaW4gdGhlbSBhZ2FpbiBpZiBwb3NzaWJsZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBjb25zdCBuZXh0UmVzdWx0ID0gcmVzdWx0W2kgKyAxXTtcbiAgICAgICAgbGV0IGN1ciA9IHJlc3VsdFtpXTtcbiAgICAgICAgaWYgKGN1ci5zZXExUmFuZ2UuaXNFbXB0eSB8fCBjdXIuc2VxMlJhbmdlLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG5leHRSZXN1bHQuc2VxMVJhbmdlLnN0YXJ0IC0gY3VyLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmU7XG4gICAgICAgICAgICBsZXQgZDtcbiAgICAgICAgICAgIGZvciAoZCA9IDA7IGQgPCBsZW5ndGg7IGQrKykge1xuICAgICAgICAgICAgICAgIGlmICghc2VxdWVuY2UxLmlzU3Ryb25nbHlFcXVhbChjdXIuc2VxMVJhbmdlLnN0YXJ0ICsgZCwgY3VyLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUgKyBkKSB8fFxuICAgICAgICAgICAgICAgICAgICAhc2VxdWVuY2UyLmlzU3Ryb25nbHlFcXVhbChjdXIuc2VxMlJhbmdlLnN0YXJ0ICsgZCwgY3VyLnNlcTJSYW5nZS5lbmRFeGNsdXNpdmUgKyBkKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gTWVyZ2UgcHJldmlvdXMgYW5kIGN1cnJlbnQgZGlmZiwgd3JpdGUgdG8gcmVzdWx0IVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpICsgMV0gPSBuZXcgU2VxdWVuY2VEaWZmKG5ldyBPZmZzZXRSYW5nZShjdXIuc2VxMVJhbmdlLnN0YXJ0ICsgbGVuZ3RoLCBuZXh0UmVzdWx0LnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUpLCBuZXcgT2Zmc2V0UmFuZ2UoY3VyLnNlcTJSYW5nZS5zdGFydCArIGxlbmd0aCwgbmV4dFJlc3VsdC5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlKSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZCA+IDApIHtcbiAgICAgICAgICAgICAgICBjdXIgPSBjdXIuZGVsdGEoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Mi5wdXNoKGN1cik7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXN1bHQyLnB1c2gocmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQyO1xufVxuLy8gYWxpZ24gY2hhcmFjdGVyIGxldmVsIGRpZmZzIGF0IHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuLy8gaW1wb3J0IHsgSUJhciB9IGZyb20gXCJmb29cIjtcbi8vIGltcG9ydCB7IElbQXJyLCBJXUJhciB9IGZyb20gXCJmb29cIjtcbi8vIC0+XG4vLyBpbXBvcnQgeyBbSUFyciwgXUlCYXIgfSBmcm9tIFwiZm9vXCI7XG4vLyBpbXBvcnQgeyBJVHJhbnNhY3Rpb24sIG9ic2VydmFibGVWYWx1ZSwgdHJhbnNhY3Rpb24gfSBmcm9tICd2cy9iYXNlL2NvbW1vbi9vYnNlcnZhYmxlJztcbi8vIGltcG9ydCB7IElUcmFuc2FjdGlvbiwgb2JzZXJ2YWJsZVtGcm9tRXZlbnQsIG9ic2VydmFibGVdVmFsdWUsIHRyYW5zYWN0aW9uIH0gZnJvbSAndnMvYmFzZS9jb21tb24vb2JzZXJ2YWJsZSc7XG4vLyAtPlxuLy8gaW1wb3J0IHsgSVRyYW5zYWN0aW9uLCBbb2JzZXJ2YWJsZUZyb21FdmVudCwgXW9ic2VydmFibGVWYWx1ZSwgdHJhbnNhY3Rpb24gfSBmcm9tICd2cy9iYXNlL2NvbW1vbi9vYnNlcnZhYmxlJztcbi8vIGNvbGxlY3RCcmFja2V0cyhsZXZlbCArIDEsIGxldmVsUGVyQnJhY2tldFR5cGUpO1xuLy8gY29sbGVjdEJyYWNrZXRzKGxldmVsICsgMSwgbGV2ZWxQZXJCcmFja2V0WyArIDEsIGxldmVsUGVyQnJhY2tldF1UeXBlKTtcbi8vIC0+XG4vLyBjb2xsZWN0QnJhY2tldHMobGV2ZWwgKyAxLCBbbGV2ZWxQZXJCcmFja2V0ICsgMSwgXWxldmVsUGVyQnJhY2tldFR5cGUpO1xuZnVuY3Rpb24gc2hpZnRTZXF1ZW5jZURpZmZzKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCBzZXF1ZW5jZURpZmZzKSB7XG4gICAgaWYgKCFzZXF1ZW5jZTEuZ2V0Qm91bmRhcnlTY29yZSB8fCAhc2VxdWVuY2UyLmdldEJvdW5kYXJ5U2NvcmUpIHtcbiAgICAgICAgcmV0dXJuIHNlcXVlbmNlRGlmZnM7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxdWVuY2VEaWZmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2RGlmZiA9IChpID4gMCA/IHNlcXVlbmNlRGlmZnNbaSAtIDFdIDogdW5kZWZpbmVkKTtcbiAgICAgICAgY29uc3QgZGlmZiA9IHNlcXVlbmNlRGlmZnNbaV07XG4gICAgICAgIGNvbnN0IG5leHREaWZmID0gKGkgKyAxIDwgc2VxdWVuY2VEaWZmcy5sZW5ndGggPyBzZXF1ZW5jZURpZmZzW2kgKyAxXSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IHNlcTFWYWxpZFJhbmdlID0gbmV3IE9mZnNldFJhbmdlKHByZXZEaWZmID8gcHJldkRpZmYuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSArIDEgOiAwLCBuZXh0RGlmZiA/IG5leHREaWZmLnNlcTFSYW5nZS5zdGFydCAtIDEgOiBzZXF1ZW5jZTEubGVuZ3RoKTtcbiAgICAgICAgY29uc3Qgc2VxMlZhbGlkUmFuZ2UgPSBuZXcgT2Zmc2V0UmFuZ2UocHJldkRpZmYgPyBwcmV2RGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgMSA6IDAsIG5leHREaWZmID8gbmV4dERpZmYuc2VxMlJhbmdlLnN0YXJ0IC0gMSA6IHNlcXVlbmNlMi5sZW5ndGgpO1xuICAgICAgICBpZiAoZGlmZi5zZXExUmFuZ2UuaXNFbXB0eSkge1xuICAgICAgICAgICAgc2VxdWVuY2VEaWZmc1tpXSA9IHNoaWZ0RGlmZlRvQmV0dGVyUG9zaXRpb24oZGlmZiwgc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcTFWYWxpZFJhbmdlLCBzZXEyVmFsaWRSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlmZi5zZXEyUmFuZ2UuaXNFbXB0eSkge1xuICAgICAgICAgICAgc2VxdWVuY2VEaWZmc1tpXSA9IHNoaWZ0RGlmZlRvQmV0dGVyUG9zaXRpb24oZGlmZi5zd2FwKCksIHNlcXVlbmNlMiwgc2VxdWVuY2UxLCBzZXEyVmFsaWRSYW5nZSwgc2VxMVZhbGlkUmFuZ2UpLnN3YXAoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VxdWVuY2VEaWZmcztcbn1cbmZ1bmN0aW9uIHNoaWZ0RGlmZlRvQmV0dGVyUG9zaXRpb24oZGlmZiwgc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcTFWYWxpZFJhbmdlLCBzZXEyVmFsaWRSYW5nZSkge1xuICAgIGNvbnN0IG1heFNoaWZ0TGltaXQgPSAxMDA7IC8vIFRvIHByZXZlbnQgcGVyZm9ybWFuY2UgaXNzdWVzXG4gICAgLy8gZG9uJ3QgdG91Y2ggcHJldmlvdXMgb3IgbmV4dCFcbiAgICBsZXQgZGVsdGFCZWZvcmUgPSAxO1xuICAgIHdoaWxlIChkaWZmLnNlcTFSYW5nZS5zdGFydCAtIGRlbHRhQmVmb3JlID49IHNlcTFWYWxpZFJhbmdlLnN0YXJ0ICYmXG4gICAgICAgIGRpZmYuc2VxMlJhbmdlLnN0YXJ0IC0gZGVsdGFCZWZvcmUgPj0gc2VxMlZhbGlkUmFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgc2VxdWVuY2UyLmlzU3Ryb25nbHlFcXVhbChkaWZmLnNlcTJSYW5nZS5zdGFydCAtIGRlbHRhQmVmb3JlLCBkaWZmLnNlcTJSYW5nZS5lbmRFeGNsdXNpdmUgLSBkZWx0YUJlZm9yZSkgJiYgZGVsdGFCZWZvcmUgPCBtYXhTaGlmdExpbWl0KSB7XG4gICAgICAgIGRlbHRhQmVmb3JlKys7XG4gICAgfVxuICAgIGRlbHRhQmVmb3JlLS07XG4gICAgbGV0IGRlbHRhQWZ0ZXIgPSAwO1xuICAgIHdoaWxlIChkaWZmLnNlcTFSYW5nZS5zdGFydCArIGRlbHRhQWZ0ZXIgPCBzZXExVmFsaWRSYW5nZS5lbmRFeGNsdXNpdmUgJiZcbiAgICAgICAgZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgZGVsdGFBZnRlciA8IHNlcTJWYWxpZFJhbmdlLmVuZEV4Y2x1c2l2ZSAmJlxuICAgICAgICBzZXF1ZW5jZTIuaXNTdHJvbmdseUVxdWFsKGRpZmYuc2VxMlJhbmdlLnN0YXJ0ICsgZGVsdGFBZnRlciwgZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgZGVsdGFBZnRlcikgJiYgZGVsdGFBZnRlciA8IG1heFNoaWZ0TGltaXQpIHtcbiAgICAgICAgZGVsdGFBZnRlcisrO1xuICAgIH1cbiAgICBpZiAoZGVsdGFCZWZvcmUgPT09IDAgJiYgZGVsdGFBZnRlciA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZGlmZjtcbiAgICB9XG4gICAgLy8gVmlzdWFsaXplIGBbc2VxdWVuY2UxLnRleHQsIGRpZmYuc2VxMVJhbmdlLnN0YXJ0ICsgZGVsdGFBZnRlcl1gXG4gICAgLy8gYW5kIGBbc2VxdWVuY2UyLnRleHQsIGRpZmYuc2VxMlJhbmdlLnN0YXJ0ICsgZGVsdGFBZnRlciwgZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgZGVsdGFBZnRlcl1gXG4gICAgbGV0IGJlc3REZWx0YSA9IDA7XG4gICAgbGV0IGJlc3RTY29yZSA9IC0xO1xuICAgIC8vIGZpbmQgYmVzdCBzY29yZWQgZGVsdGFcbiAgICBmb3IgKGxldCBkZWx0YSA9IC1kZWx0YUJlZm9yZTsgZGVsdGEgPD0gZGVsdGFBZnRlcjsgZGVsdGErKykge1xuICAgICAgICBjb25zdCBzZXEyT2Zmc2V0U3RhcnQgPSBkaWZmLnNlcTJSYW5nZS5zdGFydCArIGRlbHRhO1xuICAgICAgICBjb25zdCBzZXEyT2Zmc2V0RW5kRXhjbHVzaXZlID0gZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlICsgZGVsdGE7XG4gICAgICAgIGNvbnN0IHNlcTFPZmZzZXQgPSBkaWZmLnNlcTFSYW5nZS5zdGFydCArIGRlbHRhO1xuICAgICAgICBjb25zdCBzY29yZSA9IHNlcXVlbmNlMS5nZXRCb3VuZGFyeVNjb3JlKHNlcTFPZmZzZXQpICsgc2VxdWVuY2UyLmdldEJvdW5kYXJ5U2NvcmUoc2VxMk9mZnNldFN0YXJ0KSArIHNlcXVlbmNlMi5nZXRCb3VuZGFyeVNjb3JlKHNlcTJPZmZzZXRFbmRFeGNsdXNpdmUpO1xuICAgICAgICBpZiAoc2NvcmUgPiBiZXN0U2NvcmUpIHtcbiAgICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgICAgYmVzdERlbHRhID0gZGVsdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmYuZGVsdGEoYmVzdERlbHRhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVTaG9ydE1hdGNoZXMoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcXVlbmNlRGlmZnMpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHMgb2Ygc2VxdWVuY2VEaWZmcykge1xuICAgICAgICBjb25zdCBsYXN0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzLnNlcTFSYW5nZS5zdGFydCAtIGxhc3Quc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSA8PSAyIHx8IHMuc2VxMlJhbmdlLnN0YXJ0IC0gbGFzdC5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlIDw9IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBuZXcgU2VxdWVuY2VEaWZmKGxhc3Quc2VxMVJhbmdlLmpvaW4ocy5zZXExUmFuZ2UpLCBsYXN0LnNlcTJSYW5nZS5qb2luKHMuc2VxMlJhbmdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZERpZmZzVG9FbnRpcmVXb3JkSWZBcHByb3ByaWF0ZShzZXF1ZW5jZTEsIHNlcXVlbmNlMiwgc2VxdWVuY2VEaWZmcykge1xuICAgIGNvbnN0IGVxdWFsTWFwcGluZ3MgPSBTZXF1ZW5jZURpZmYuaW52ZXJ0KHNlcXVlbmNlRGlmZnMsIHNlcXVlbmNlMS5sZW5ndGgpO1xuICAgIGNvbnN0IGFkZGl0aW9uYWwgPSBbXTtcbiAgICBsZXQgbGFzdFBvaW50ID0gbmV3IE9mZnNldFBhaXIoMCwgMCk7XG4gICAgZnVuY3Rpb24gc2NhbldvcmQocGFpciwgZXF1YWxNYXBwaW5nKSB7XG4gICAgICAgIGlmIChwYWlyLm9mZnNldDEgPCBsYXN0UG9pbnQub2Zmc2V0MSB8fCBwYWlyLm9mZnNldDIgPCBsYXN0UG9pbnQub2Zmc2V0Mikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHcxID0gc2VxdWVuY2UxLmZpbmRXb3JkQ29udGFpbmluZyhwYWlyLm9mZnNldDEpO1xuICAgICAgICBjb25zdCB3MiA9IHNlcXVlbmNlMi5maW5kV29yZENvbnRhaW5pbmcocGFpci5vZmZzZXQyKTtcbiAgICAgICAgaWYgKCF3MSB8fCAhdzIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdyA9IG5ldyBTZXF1ZW5jZURpZmYodzEsIHcyKTtcbiAgICAgICAgY29uc3QgZXF1YWxQYXJ0ID0gdy5pbnRlcnNlY3QoZXF1YWxNYXBwaW5nKTtcbiAgICAgICAgbGV0IGVxdWFsQ2hhcnMxID0gZXF1YWxQYXJ0LnNlcTFSYW5nZS5sZW5ndGg7XG4gICAgICAgIGxldCBlcXVhbENoYXJzMiA9IGVxdWFsUGFydC5zZXEyUmFuZ2UubGVuZ3RoO1xuICAgICAgICAvLyBUaGUgd29yZHMgZG8gbm90IHRvdWNoIHByZXZpb3VzIGVxdWFscyBtYXBwaW5ncywgYXMgd2Ugd291bGQgaGF2ZSBwcm9jZXNzZWQgdGhlbSBhbHJlYWR5LlxuICAgICAgICAvLyBCdXQgdGhleSBtaWdodCB0b3VjaCB0aGUgbmV4dCBvbmVzLlxuICAgICAgICB3aGlsZSAoZXF1YWxNYXBwaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gZXF1YWxNYXBwaW5nc1swXTtcbiAgICAgICAgICAgIGNvbnN0IGludGVyc2VjdHMgPSBuZXh0LnNlcTFSYW5nZS5pbnRlcnNlY3RzKHcuc2VxMVJhbmdlKSB8fCBuZXh0LnNlcTJSYW5nZS5pbnRlcnNlY3RzKHcuc2VxMlJhbmdlKTtcbiAgICAgICAgICAgIGlmICghaW50ZXJzZWN0cykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdjEgPSBzZXF1ZW5jZTEuZmluZFdvcmRDb250YWluaW5nKG5leHQuc2VxMVJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IHYyID0gc2VxdWVuY2UyLmZpbmRXb3JkQ29udGFpbmluZyhuZXh0LnNlcTJSYW5nZS5zdGFydCk7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZXJlIGlzIGFuIGludGVyc2VjdGlvbiwgd2Uga25vdyB0aGF0IHRoZSB3b3JkcyBhcmUgbm90IGVtcHR5LlxuICAgICAgICAgICAgY29uc3QgdiA9IG5ldyBTZXF1ZW5jZURpZmYodjEsIHYyKTtcbiAgICAgICAgICAgIGNvbnN0IGVxdWFsUGFydCA9IHYuaW50ZXJzZWN0KG5leHQpO1xuICAgICAgICAgICAgZXF1YWxDaGFyczEgKz0gZXF1YWxQYXJ0LnNlcTFSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICBlcXVhbENoYXJzMiArPSBlcXVhbFBhcnQuc2VxMlJhbmdlLmxlbmd0aDtcbiAgICAgICAgICAgIHcgPSB3LmpvaW4odik7XG4gICAgICAgICAgICBpZiAody5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlID49IG5leHQuc2VxMVJhbmdlLmVuZEV4Y2x1c2l2ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JkIGV4dGVuZHMgYmV5b25kIHRoZSBuZXh0IGVxdWFsIG1hcHBpbmcuXG4gICAgICAgICAgICAgICAgZXF1YWxNYXBwaW5ncy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVxdWFsQ2hhcnMxICsgZXF1YWxDaGFyczIgPCAody5zZXExUmFuZ2UubGVuZ3RoICsgdy5zZXEyUmFuZ2UubGVuZ3RoKSAqIDIgLyAzKSB7XG4gICAgICAgICAgICBhZGRpdGlvbmFsLnB1c2godyk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBvaW50ID0gdy5nZXRFbmRFeGNsdXNpdmVzKCk7XG4gICAgfVxuICAgIHdoaWxlIChlcXVhbE1hcHBpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGVxdWFsTWFwcGluZ3Muc2hpZnQoKTtcbiAgICAgICAgaWYgKG5leHQuc2VxMVJhbmdlLmlzRW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNjYW5Xb3JkKG5leHQuZ2V0U3RhcnRzKCksIG5leHQpO1xuICAgICAgICAvLyBUaGUgZXF1YWwgcGFydHMgYXJlIG5vdCBlbXB0eSwgc28gLTEgZ2l2ZXMgdXMgYSBjaGFyYWN0ZXIgdGhhdCBpcyBlcXVhbCBpbiBib3RoIHBhcnRzLlxuICAgICAgICBzY2FuV29yZChuZXh0LmdldEVuZEV4Y2x1c2l2ZXMoKS5kZWx0YSgtMSksIG5leHQpO1xuICAgIH1cbiAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVNlcXVlbmNlRGlmZnMoc2VxdWVuY2VEaWZmcywgYWRkaXRpb25hbCk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmZ1bmN0aW9uIG1lcmdlU2VxdWVuY2VEaWZmcyhzZXF1ZW5jZURpZmZzMSwgc2VxdWVuY2VEaWZmczIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoc2VxdWVuY2VEaWZmczEubGVuZ3RoID4gMCB8fCBzZXF1ZW5jZURpZmZzMi5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHNkMSA9IHNlcXVlbmNlRGlmZnMxWzBdO1xuICAgICAgICBjb25zdCBzZDIgPSBzZXF1ZW5jZURpZmZzMlswXTtcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIGlmIChzZDEgJiYgKCFzZDIgfHwgc2QxLnNlcTFSYW5nZS5zdGFydCA8IHNkMi5zZXExUmFuZ2Uuc3RhcnQpKSB7XG4gICAgICAgICAgICBuZXh0ID0gc2VxdWVuY2VEaWZmczEuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHQgPSBzZXF1ZW5jZURpZmZzMi5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID4gMCAmJiByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUgPj0gbmV4dC5zZXExUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdLmpvaW4obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVZlcnlTaG9ydE1hdGNoaW5nTGluZXNCZXR3ZWVuRGlmZnMoc2VxdWVuY2UxLCBfc2VxdWVuY2UyLCBzZXF1ZW5jZURpZmZzKSB7XG4gICAgbGV0IGRpZmZzID0gc2VxdWVuY2VEaWZmcztcbiAgICBpZiAoZGlmZnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkaWZmcztcbiAgICB9XG4gICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgIGxldCBzaG91bGRSZXBlYXQ7XG4gICAgZG8ge1xuICAgICAgICBzaG91bGRSZXBlYXQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW1xuICAgICAgICAgICAgZGlmZnNbMF1cbiAgICAgICAgXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyID0gZGlmZnNbaV07XG4gICAgICAgICAgICBjb25zdCBsYXN0UmVzdWx0ID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZEpvaW5EaWZmcyhiZWZvcmUsIGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5jaGFuZ2VkUmFuZ2UgPSBuZXcgT2Zmc2V0UmFuZ2UobGFzdFJlc3VsdC5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlLCBjdXIuc2VxMVJhbmdlLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmNoYW5nZWRUZXh0ID0gc2VxdWVuY2UxLmdldFRleHQodW5jaGFuZ2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZFRleHRXaXRob3V0V3MgPSB1bmNoYW5nZWRUZXh0LnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHVuY2hhbmdlZFRleHRXaXRob3V0V3MubGVuZ3RoIDw9IDRcbiAgICAgICAgICAgICAgICAgICAgJiYgKGJlZm9yZS5zZXExUmFuZ2UubGVuZ3RoICsgYmVmb3JlLnNlcTJSYW5nZS5sZW5ndGggPiA1IHx8IGFmdGVyLnNlcTFSYW5nZS5sZW5ndGggKyBhZnRlci5zZXEyUmFuZ2UubGVuZ3RoID4gNSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEpvaW4gPSBzaG91bGRKb2luRGlmZnMobGFzdFJlc3VsdCwgY3VyKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRKb2luKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5qb2luKGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpZmZzID0gcmVzdWx0O1xuICAgIH0gd2hpbGUgKGNvdW50ZXIrKyA8IDEwICYmIHNob3VsZFJlcGVhdCk7XG4gICAgcmV0dXJuIGRpZmZzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVZlcnlTaG9ydE1hdGNoaW5nVGV4dEJldHdlZW5Mb25nRGlmZnMoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHNlcXVlbmNlRGlmZnMpIHtcbiAgICBsZXQgZGlmZnMgPSBzZXF1ZW5jZURpZmZzO1xuICAgIGlmIChkaWZmcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGRpZmZzO1xuICAgIH1cbiAgICBsZXQgY291bnRlciA9IDA7XG4gICAgbGV0IHNob3VsZFJlcGVhdDtcbiAgICBkbyB7XG4gICAgICAgIHNob3VsZFJlcGVhdCA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXG4gICAgICAgICAgICBkaWZmc1swXVxuICAgICAgICBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGRpZmZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXIgPSBkaWZmc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RSZXN1bHQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgZnVuY3Rpb24gc2hvdWxkSm9pbkRpZmZzKGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bmNoYW5nZWRSYW5nZSA9IG5ldyBPZmZzZXRSYW5nZShsYXN0UmVzdWx0LnNlcTFSYW5nZS5lbmRFeGNsdXNpdmUsIGN1ci5zZXExUmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZExpbmVDb3VudCA9IHNlcXVlbmNlMS5jb3VudExpbmVzSW4odW5jaGFuZ2VkUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGlmICh1bmNoYW5nZWRMaW5lQ291bnQgPiA1IHx8IHVuY2hhbmdlZFJhbmdlLmxlbmd0aCA+IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHVuY2hhbmdlZFRleHQgPSBzZXF1ZW5jZTEuZ2V0VGV4dCh1bmNoYW5nZWRSYW5nZSkudHJpbSgpO1xuICAgICAgICAgICAgICAgIGlmICh1bmNoYW5nZWRUZXh0Lmxlbmd0aCA+IDIwIHx8IHVuY2hhbmdlZFRleHQuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLykubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZUxpbmVDb3VudDEgPSBzZXF1ZW5jZTEuY291bnRMaW5lc0luKGJlZm9yZS5zZXExUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZVNlcTFMZW5ndGggPSBiZWZvcmUuc2VxMVJhbmdlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVMaW5lQ291bnQyID0gc2VxdWVuY2UyLmNvdW50TGluZXNJbihiZWZvcmUuc2VxMlJhbmdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVTZXEyTGVuZ3RoID0gYmVmb3JlLnNlcTJSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJMaW5lQ291bnQxID0gc2VxdWVuY2UxLmNvdW50TGluZXNJbihhZnRlci5zZXExUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyU2VxMUxlbmd0aCA9IGFmdGVyLnNlcTFSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJMaW5lQ291bnQyID0gc2VxdWVuY2UyLmNvdW50TGluZXNJbihhZnRlci5zZXEyUmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyU2VxMkxlbmd0aCA9IGFmdGVyLnNlcTJSYW5nZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogTWF5YmUgYSBuZXVyYWwgbmV0IGNhbiBiZSB1c2VkIHRvIGRlcml2ZSB0aGUgcmVzdWx0IGZyb20gdGhlc2UgbnVtYmVyc1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heCA9IDIgKiA0MCArIDUwO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhcCh2KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbih2LCBtYXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5wb3coTWF0aC5wb3coY2FwKGJlZm9yZUxpbmVDb3VudDEgKiA0MCArIGJlZm9yZVNlcTFMZW5ndGgpLCAxLjUpICsgTWF0aC5wb3coY2FwKGJlZm9yZUxpbmVDb3VudDIgKiA0MCArIGJlZm9yZVNlcTJMZW5ndGgpLCAxLjUpLCAxLjUpXG4gICAgICAgICAgICAgICAgICAgICsgTWF0aC5wb3coTWF0aC5wb3coY2FwKGFmdGVyTGluZUNvdW50MSAqIDQwICsgYWZ0ZXJTZXExTGVuZ3RoKSwgMS41KSArIE1hdGgucG93KGNhcChhZnRlckxpbmVDb3VudDIgKiA0MCArIGFmdGVyU2VxMkxlbmd0aCksIDEuNSksIDEuNSkgPiAoKG1heCAqKiAxLjUpICoqIDEuNSkgKiAxLjMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEpvaW4gPSBzaG91bGRKb2luRGlmZnMobGFzdFJlc3VsdCwgY3VyKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRKb2luKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkUmVwZWF0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXS5qb2luKGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRpZmZzID0gcmVzdWx0O1xuICAgIH0gd2hpbGUgKGNvdW50ZXIrKyA8IDEwICYmIHNob3VsZFJlcGVhdCk7XG4gICAgY29uc3QgbmV3RGlmZnMgPSBbXTtcbiAgICAvLyBSZW1vdmUgc2hvcnQgc3VmZml4ZXMvcHJlZml4ZXNcbiAgICBmb3JFYWNoV2l0aE5laWdoYm9ycyhkaWZmcywgKHByZXYsIGN1ciwgbmV4dCkgPT4ge1xuICAgICAgICBsZXQgbmV3RGlmZiA9IGN1cjtcbiAgICAgICAgZnVuY3Rpb24gc2hvdWxkTWFya0FzQ2hhbmdlZCh0ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5sZW5ndGggPiAwICYmIHRleHQudHJpbSgpLmxlbmd0aCA8PSAzICYmIGN1ci5zZXExUmFuZ2UubGVuZ3RoICsgY3VyLnNlcTJSYW5nZS5sZW5ndGggPiAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVsbFJhbmdlMSA9IHNlcXVlbmNlMS5leHRlbmRUb0Z1bGxMaW5lcyhjdXIuc2VxMVJhbmdlKTtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc2VxdWVuY2UxLmdldFRleHQobmV3IE9mZnNldFJhbmdlKGZ1bGxSYW5nZTEuc3RhcnQsIGN1ci5zZXExUmFuZ2Uuc3RhcnQpKTtcbiAgICAgICAgaWYgKHNob3VsZE1hcmtBc0NoYW5nZWQocHJlZml4KSkge1xuICAgICAgICAgICAgbmV3RGlmZiA9IG5ld0RpZmYuZGVsdGFTdGFydCgtcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VmZml4ID0gc2VxdWVuY2UxLmdldFRleHQobmV3IE9mZnNldFJhbmdlKGN1ci5zZXExUmFuZ2UuZW5kRXhjbHVzaXZlLCBmdWxsUmFuZ2UxLmVuZEV4Y2x1c2l2ZSkpO1xuICAgICAgICBpZiAoc2hvdWxkTWFya0FzQ2hhbmdlZChzdWZmaXgpKSB7XG4gICAgICAgICAgICBuZXdEaWZmID0gbmV3RGlmZi5kZWx0YUVuZChzdWZmaXgubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdmFpbGFibGVTcGFjZSA9IFNlcXVlbmNlRGlmZi5mcm9tT2Zmc2V0UGFpcnMocHJldiA/IHByZXYuZ2V0RW5kRXhjbHVzaXZlcygpIDogT2Zmc2V0UGFpci56ZXJvLCBuZXh0ID8gbmV4dC5nZXRTdGFydHMoKSA6IE9mZnNldFBhaXIubWF4KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3RGlmZi5pbnRlcnNlY3QoYXZhaWxhYmxlU3BhY2UpO1xuICAgICAgICBpZiAobmV3RGlmZnMubGVuZ3RoID4gMCAmJiByZXN1bHQuZ2V0U3RhcnRzKCkuZXF1YWxzKG5ld0RpZmZzW25ld0RpZmZzLmxlbmd0aCAtIDFdLmdldEVuZEV4Y2x1c2l2ZXMoKSkpIHtcbiAgICAgICAgICAgIG5ld0RpZmZzW25ld0RpZmZzLmxlbmd0aCAtIDFdID0gbmV3RGlmZnNbbmV3RGlmZnMubGVuZ3RoIC0gMV0uam9pbihyZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3RGlmZnMucHVzaChyZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0RpZmZzO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5leHBvcnQgY2xhc3MgTGluZVNlcXVlbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmltbWVkSGFzaCwgbGluZXMpIHtcbiAgICAgICAgdGhpcy50cmltbWVkSGFzaCA9IHRyaW1tZWRIYXNoO1xuICAgICAgICB0aGlzLmxpbmVzID0gbGluZXM7XG4gICAgfVxuICAgIGdldEVsZW1lbnQob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaW1tZWRIYXNoW29mZnNldF07XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRyaW1tZWRIYXNoLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0Qm91bmRhcnlTY29yZShsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaW5kZW50YXRpb25CZWZvcmUgPSBsZW5ndGggPT09IDAgPyAwIDogZ2V0SW5kZW50YXRpb24odGhpcy5saW5lc1tsZW5ndGggLSAxXSk7XG4gICAgICAgIGNvbnN0IGluZGVudGF0aW9uQWZ0ZXIgPSBsZW5ndGggPT09IHRoaXMubGluZXMubGVuZ3RoID8gMCA6IGdldEluZGVudGF0aW9uKHRoaXMubGluZXNbbGVuZ3RoXSk7XG4gICAgICAgIHJldHVybiAxMDAwIC0gKGluZGVudGF0aW9uQmVmb3JlICsgaW5kZW50YXRpb25BZnRlcik7XG4gICAgfVxuICAgIGdldFRleHQocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGluZXMuc2xpY2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZEV4Y2x1c2l2ZSkuam9pbignXFxuJyk7XG4gICAgfVxuICAgIGlzU3Ryb25nbHlFcXVhbChvZmZzZXQxLCBvZmZzZXQyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVzW29mZnNldDFdID09PSB0aGlzLmxpbmVzW29mZnNldDJdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uKHN0cikge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHN0ci5sZW5ndGggJiYgKHN0ci5jaGFyQ29kZUF0KGkpID09PSAzMiAvKiBDaGFyQ29kZS5TcGFjZSAqLyB8fCBzdHIuY2hhckNvZGVBdChpKSA9PT0gOSAvKiBDaGFyQ29kZS5UYWIgKi8pKSB7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IGVxdWFscywgZ3JvdXBBZGphY2VudEJ5IH0gZnJvbSAnLi4vLi4vLi4vLi4vYmFzZS9jb21tb24vYXJyYXlzLmpzJztcbmltcG9ydCB7IGFzc2VydEZuLCBjaGVja0FkamFjZW50SXRlbXMgfSBmcm9tICcuLi8uLi8uLi8uLi9iYXNlL2NvbW1vbi9hc3NlcnQuanMnO1xuaW1wb3J0IHsgTGluZVJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9saW5lUmFuZ2UuanMnO1xuaW1wb3J0IHsgT2Zmc2V0UmFuZ2UgfSBmcm9tICcuLi8uLi9jb3JlL29mZnNldFJhbmdlLmpzJztcbmltcG9ydCB7IFJhbmdlIH0gZnJvbSAnLi4vLi4vY29yZS9yYW5nZS5qcyc7XG5pbXBvcnQgeyBEYXRlVGltZW91dCwgSW5maW5pdGVUaW1lb3V0LCBTZXF1ZW5jZURpZmYgfSBmcm9tICcuL2FsZ29yaXRobXMvZGlmZkFsZ29yaXRobS5qcyc7XG5pbXBvcnQgeyBEeW5hbWljUHJvZ3JhbW1pbmdEaWZmaW5nIH0gZnJvbSAnLi9hbGdvcml0aG1zL2R5bmFtaWNQcm9ncmFtbWluZ0RpZmZpbmcuanMnO1xuaW1wb3J0IHsgTXllcnNEaWZmQWxnb3JpdGhtIH0gZnJvbSAnLi9hbGdvcml0aG1zL215ZXJzRGlmZkFsZ29yaXRobS5qcyc7XG5pbXBvcnQgeyBjb21wdXRlTW92ZWRMaW5lcyB9IGZyb20gJy4vY29tcHV0ZU1vdmVkTGluZXMuanMnO1xuaW1wb3J0IHsgZXh0ZW5kRGlmZnNUb0VudGlyZVdvcmRJZkFwcHJvcHJpYXRlLCBvcHRpbWl6ZVNlcXVlbmNlRGlmZnMsIHJlbW92ZVNob3J0TWF0Y2hlcywgcmVtb3ZlVmVyeVNob3J0TWF0Y2hpbmdMaW5lc0JldHdlZW5EaWZmcywgcmVtb3ZlVmVyeVNob3J0TWF0Y2hpbmdUZXh0QmV0d2VlbkxvbmdEaWZmcyB9IGZyb20gJy4vaGV1cmlzdGljU2VxdWVuY2VPcHRpbWl6YXRpb25zLmpzJztcbmltcG9ydCB7IExpbmVTZXF1ZW5jZSB9IGZyb20gJy4vbGluZVNlcXVlbmNlLmpzJztcbmltcG9ydCB7IExpbmVzU2xpY2VDaGFyU2VxdWVuY2UgfSBmcm9tICcuL2xpbmVzU2xpY2VDaGFyU2VxdWVuY2UuanMnO1xuaW1wb3J0IHsgTGluZXNEaWZmLCBNb3ZlZFRleHQgfSBmcm9tICcuLi9saW5lc0RpZmZDb21wdXRlci5qcyc7XG5pbXBvcnQgeyBEZXRhaWxlZExpbmVSYW5nZU1hcHBpbmcsIFJhbmdlTWFwcGluZyB9IGZyb20gJy4uL3JhbmdlTWFwcGluZy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvZ3JhbW1pbmdEaWZmaW5nID0gbmV3IER5bmFtaWNQcm9ncmFtbWluZ0RpZmZpbmcoKTtcbiAgICAgICAgdGhpcy5teWVyc0RpZmZpbmdBbGdvcml0aG0gPSBuZXcgTXllcnNEaWZmQWxnb3JpdGhtKCk7XG4gICAgfVxuICAgIGNvbXB1dGVEaWZmKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9yaWdpbmFsTGluZXMubGVuZ3RoIDw9IDEgJiYgZXF1YWxzKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIChhLCBiKSA9PiBhID09PSBiKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaW5lc0RpZmYoW10sIFtdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yaWdpbmFsTGluZXMubGVuZ3RoID09PSAxICYmIG9yaWdpbmFsTGluZXNbMF0ubGVuZ3RoID09PSAwIHx8IG1vZGlmaWVkTGluZXMubGVuZ3RoID09PSAxICYmIG1vZGlmaWVkTGluZXNbMF0ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmVzRGlmZihbXG4gICAgICAgICAgICAgICAgbmV3IERldGFpbGVkTGluZVJhbmdlTWFwcGluZyhuZXcgTGluZVJhbmdlKDEsIG9yaWdpbmFsTGluZXMubGVuZ3RoICsgMSksIG5ldyBMaW5lUmFuZ2UoMSwgbW9kaWZpZWRMaW5lcy5sZW5ndGggKyAxKSwgW1xuICAgICAgICAgICAgICAgICAgICBuZXcgUmFuZ2VNYXBwaW5nKG5ldyBSYW5nZSgxLCAxLCBvcmlnaW5hbExpbmVzLmxlbmd0aCwgb3JpZ2luYWxMaW5lc1tvcmlnaW5hbExpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aCArIDEpLCBuZXcgUmFuZ2UoMSwgMSwgbW9kaWZpZWRMaW5lcy5sZW5ndGgsIG1vZGlmaWVkTGluZXNbbW9kaWZpZWRMaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggKyAxKSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSwgW10sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lb3V0ID0gb3B0aW9ucy5tYXhDb21wdXRhdGlvblRpbWVNcyA9PT0gMCA/IEluZmluaXRlVGltZW91dC5pbnN0YW5jZSA6IG5ldyBEYXRlVGltZW91dChvcHRpb25zLm1heENvbXB1dGF0aW9uVGltZU1zKTtcbiAgICAgICAgY29uc3QgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcyA9ICFvcHRpb25zLmlnbm9yZVRyaW1XaGl0ZXNwYWNlO1xuICAgICAgICBjb25zdCBwZXJmZWN0SGFzaGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmdW5jdGlvbiBnZXRPckNyZWF0ZUhhc2godGV4dCkge1xuICAgICAgICAgICAgbGV0IGhhc2ggPSBwZXJmZWN0SGFzaGVzLmdldCh0ZXh0KTtcbiAgICAgICAgICAgIGlmIChoYXNoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBoYXNoID0gcGVyZmVjdEhhc2hlcy5zaXplO1xuICAgICAgICAgICAgICAgIHBlcmZlY3RIYXNoZXMuc2V0KHRleHQsIGhhc2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3JpZ2luYWxMaW5lc0hhc2hlcyA9IG9yaWdpbmFsTGluZXMubWFwKChsKSA9PiBnZXRPckNyZWF0ZUhhc2gobC50cmltKCkpKTtcbiAgICAgICAgY29uc3QgbW9kaWZpZWRMaW5lc0hhc2hlcyA9IG1vZGlmaWVkTGluZXMubWFwKChsKSA9PiBnZXRPckNyZWF0ZUhhc2gobC50cmltKCkpKTtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2UxID0gbmV3IExpbmVTZXF1ZW5jZShvcmlnaW5hbExpbmVzSGFzaGVzLCBvcmlnaW5hbExpbmVzKTtcbiAgICAgICAgY29uc3Qgc2VxdWVuY2UyID0gbmV3IExpbmVTZXF1ZW5jZShtb2RpZmllZExpbmVzSGFzaGVzLCBtb2RpZmllZExpbmVzKTtcbiAgICAgICAgY29uc3QgbGluZUFsaWdubWVudFJlc3VsdCA9ICgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2VxdWVuY2UxLmxlbmd0aCArIHNlcXVlbmNlMi5sZW5ndGggPCAxNzAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHRoZSBpbXByb3ZlZCBhbGdvcml0aG0gZm9yIHNtYWxsIGZpbGVzXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHluYW1pY1Byb2dyYW1taW5nRGlmZmluZy5jb21wdXRlKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCB0aW1lb3V0LCAob2Zmc2V0MSwgb2Zmc2V0MikgPT4gb3JpZ2luYWxMaW5lc1tvZmZzZXQxXSA9PT0gbW9kaWZpZWRMaW5lc1tvZmZzZXQyXVxuICAgICAgICAgICAgICAgICAgICA/IG1vZGlmaWVkTGluZXNbb2Zmc2V0Ml0ubGVuZ3RoID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICA/IDAuMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxICsgTWF0aC5sb2coMSArIG1vZGlmaWVkTGluZXNbb2Zmc2V0Ml0ubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICA6IDAuOTkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXllcnNEaWZmaW5nQWxnb3JpdGhtLmNvbXB1dGUoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIHRpbWVvdXQpO1xuICAgICAgICB9KSgpO1xuICAgICAgICBsZXQgbGluZUFsaWdubWVudHMgPSBsaW5lQWxpZ25tZW50UmVzdWx0LmRpZmZzO1xuICAgICAgICBsZXQgaGl0VGltZW91dCA9IGxpbmVBbGlnbm1lbnRSZXN1bHQuaGl0VGltZW91dDtcbiAgICAgICAgbGluZUFsaWdubWVudHMgPSBvcHRpbWl6ZVNlcXVlbmNlRGlmZnMoc2VxdWVuY2UxLCBzZXF1ZW5jZTIsIGxpbmVBbGlnbm1lbnRzKTtcbiAgICAgICAgbGluZUFsaWdubWVudHMgPSByZW1vdmVWZXJ5U2hvcnRNYXRjaGluZ0xpbmVzQmV0d2VlbkRpZmZzKHNlcXVlbmNlMSwgc2VxdWVuY2UyLCBsaW5lQWxpZ25tZW50cyk7XG4gICAgICAgIGNvbnN0IGFsaWdubWVudHMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2NhbkZvcldoaXRlc3BhY2VDaGFuZ2VzID0gKGVxdWFsTGluZXNDb3VudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlcXVhbExpbmVzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlcTFPZmZzZXQgPSBzZXExTGFzdFN0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXEyT2Zmc2V0ID0gc2VxMkxhc3RTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgaWYgKG9yaWdpbmFsTGluZXNbc2VxMU9mZnNldF0gIT09IG1vZGlmaWVkTGluZXNbc2VxMk9mZnNldF0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBiZWNhdXNlIG9mIHdoaXRlc3BhY2UgY2hhbmdlcywgZGlmZiB0aGVzZSBsaW5lc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJEaWZmcyA9IHRoaXMucmVmaW5lRGlmZihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBuZXcgU2VxdWVuY2VEaWZmKG5ldyBPZmZzZXRSYW5nZShzZXExT2Zmc2V0LCBzZXExT2Zmc2V0ICsgMSksIG5ldyBPZmZzZXRSYW5nZShzZXEyT2Zmc2V0LCBzZXEyT2Zmc2V0ICsgMSkpLCB0aW1lb3V0LCBjb25zaWRlcldoaXRlc3BhY2VDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhIG9mIGNoYXJhY3RlckRpZmZzLm1hcHBpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnRzLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJhY3RlckRpZmZzLmhpdFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhpdFRpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgc2VxMUxhc3RTdGFydCA9IDA7XG4gICAgICAgIGxldCBzZXEyTGFzdFN0YXJ0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBkaWZmIG9mIGxpbmVBbGlnbm1lbnRzKSB7XG4gICAgICAgICAgICBhc3NlcnRGbigoKSA9PiBkaWZmLnNlcTFSYW5nZS5zdGFydCAtIHNlcTFMYXN0U3RhcnQgPT09IGRpZmYuc2VxMlJhbmdlLnN0YXJ0IC0gc2VxMkxhc3RTdGFydCk7XG4gICAgICAgICAgICBjb25zdCBlcXVhbExpbmVzQ291bnQgPSBkaWZmLnNlcTFSYW5nZS5zdGFydCAtIHNlcTFMYXN0U3RhcnQ7XG4gICAgICAgICAgICBzY2FuRm9yV2hpdGVzcGFjZUNoYW5nZXMoZXF1YWxMaW5lc0NvdW50KTtcbiAgICAgICAgICAgIHNlcTFMYXN0U3RhcnQgPSBkaWZmLnNlcTFSYW5nZS5lbmRFeGNsdXNpdmU7XG4gICAgICAgICAgICBzZXEyTGFzdFN0YXJ0ID0gZGlmZi5zZXEyUmFuZ2UuZW5kRXhjbHVzaXZlO1xuICAgICAgICAgICAgY29uc3QgY2hhcmFjdGVyRGlmZnMgPSB0aGlzLnJlZmluZURpZmYob3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcywgZGlmZiwgdGltZW91dCwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcyk7XG4gICAgICAgICAgICBpZiAoY2hhcmFjdGVyRGlmZnMuaGl0VGltZW91dCkge1xuICAgICAgICAgICAgICAgIGhpdFRpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBhIG9mIGNoYXJhY3RlckRpZmZzLm1hcHBpbmdzKSB7XG4gICAgICAgICAgICAgICAgYWxpZ25tZW50cy5wdXNoKGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjYW5Gb3JXaGl0ZXNwYWNlQ2hhbmdlcyhvcmlnaW5hbExpbmVzLmxlbmd0aCAtIHNlcTFMYXN0U3RhcnQpO1xuICAgICAgICBjb25zdCBjaGFuZ2VzID0gbGluZVJhbmdlTWFwcGluZ0Zyb21SYW5nZU1hcHBpbmdzKGFsaWdubWVudHMsIG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMpO1xuICAgICAgICBsZXQgbW92ZXMgPSBbXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY29tcHV0ZU1vdmVzKSB7XG4gICAgICAgICAgICBtb3ZlcyA9IHRoaXMuY29tcHV0ZU1vdmVzKGNoYW5nZXMsIG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIG9yaWdpbmFsTGluZXNIYXNoZXMsIG1vZGlmaWVkTGluZXNIYXNoZXMsIHRpbWVvdXQsIGNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgcmFuZ2VzIGFyZSB2YWxpZFxuICAgICAgICBhc3NlcnRGbigoKSA9PiB7XG4gICAgICAgICAgICBmdW5jdGlvbiB2YWxpZGF0ZVBvc2l0aW9uKHBvcywgbGluZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zLmxpbmVOdW1iZXIgPCAxIHx8IHBvcy5saW5lTnVtYmVyID4gbGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IGxpbmVzW3Bvcy5saW5lTnVtYmVyIC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKHBvcy5jb2x1bW4gPCAxIHx8IHBvcy5jb2x1bW4gPiBsaW5lLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2UocmFuZ2UsIGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLnN0YXJ0TGluZU51bWJlciA8IDEgfHwgcmFuZ2Uuc3RhcnRMaW5lTnVtYmVyID4gbGluZXMubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlIDwgMSB8fCByYW5nZS5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlID4gbGluZXMubGVuZ3RoICsgMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWMuaW5uZXJDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpYyBvZiBjLmlubmVyQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWxpZCA9IHZhbGlkYXRlUG9zaXRpb24oaWMubW9kaWZpZWRSYW5nZS5nZXRTdGFydFBvc2l0aW9uKCksIG1vZGlmaWVkTGluZXMpICYmIHZhbGlkYXRlUG9zaXRpb24oaWMubW9kaWZpZWRSYW5nZS5nZXRFbmRQb3NpdGlvbigpLCBtb2RpZmllZExpbmVzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVQb3NpdGlvbihpYy5vcmlnaW5hbFJhbmdlLmdldFN0YXJ0UG9zaXRpb24oKSwgb3JpZ2luYWxMaW5lcykgJiYgdmFsaWRhdGVQb3NpdGlvbihpYy5vcmlnaW5hbFJhbmdlLmdldEVuZFBvc2l0aW9uKCksIG9yaWdpbmFsTGluZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVJhbmdlKGMubW9kaWZpZWQsIG1vZGlmaWVkTGluZXMpIHx8ICF2YWxpZGF0ZVJhbmdlKGMub3JpZ2luYWwsIG9yaWdpbmFsTGluZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgTGluZXNEaWZmKGNoYW5nZXMsIG1vdmVzLCBoaXRUaW1lb3V0KTtcbiAgICB9XG4gICAgY29tcHV0ZU1vdmVzKGNoYW5nZXMsIG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIGhhc2hlZE9yaWdpbmFsTGluZXMsIGhhc2hlZE1vZGlmaWVkTGluZXMsIHRpbWVvdXQsIGNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMpIHtcbiAgICAgICAgY29uc3QgbW92ZXMgPSBjb21wdXRlTW92ZWRMaW5lcyhjaGFuZ2VzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBoYXNoZWRPcmlnaW5hbExpbmVzLCBoYXNoZWRNb2RpZmllZExpbmVzLCB0aW1lb3V0KTtcbiAgICAgICAgY29uc3QgbW92ZXNXaXRoRGlmZnMgPSBtb3Zlcy5tYXAobSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlQ2hhbmdlcyA9IHRoaXMucmVmaW5lRGlmZihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBuZXcgU2VxdWVuY2VEaWZmKG0ub3JpZ2luYWwudG9PZmZzZXRSYW5nZSgpLCBtLm1vZGlmaWVkLnRvT2Zmc2V0UmFuZ2UoKSksIHRpbWVvdXQsIGNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMpO1xuICAgICAgICAgICAgY29uc3QgbWFwcGluZ3MgPSBsaW5lUmFuZ2VNYXBwaW5nRnJvbVJhbmdlTWFwcGluZ3MobW92ZUNoYW5nZXMubWFwcGluZ3MsIG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb3ZlZFRleHQobSwgbWFwcGluZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1vdmVzV2l0aERpZmZzO1xuICAgIH1cbiAgICByZWZpbmVEaWZmKG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMsIGRpZmYsIHRpbWVvdXQsIGNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMpIHtcbiAgICAgICAgY29uc3Qgc2xpY2UxID0gbmV3IExpbmVzU2xpY2VDaGFyU2VxdWVuY2Uob3JpZ2luYWxMaW5lcywgZGlmZi5zZXExUmFuZ2UsIGNvbnNpZGVyV2hpdGVzcGFjZUNoYW5nZXMpO1xuICAgICAgICBjb25zdCBzbGljZTIgPSBuZXcgTGluZXNTbGljZUNoYXJTZXF1ZW5jZShtb2RpZmllZExpbmVzLCBkaWZmLnNlcTJSYW5nZSwgY29uc2lkZXJXaGl0ZXNwYWNlQ2hhbmdlcyk7XG4gICAgICAgIGNvbnN0IGRpZmZSZXN1bHQgPSBzbGljZTEubGVuZ3RoICsgc2xpY2UyLmxlbmd0aCA8IDUwMFxuICAgICAgICAgICAgPyB0aGlzLmR5bmFtaWNQcm9ncmFtbWluZ0RpZmZpbmcuY29tcHV0ZShzbGljZTEsIHNsaWNlMiwgdGltZW91dClcbiAgICAgICAgICAgIDogdGhpcy5teWVyc0RpZmZpbmdBbGdvcml0aG0uY29tcHV0ZShzbGljZTEsIHNsaWNlMiwgdGltZW91dCk7XG4gICAgICAgIGxldCBkaWZmcyA9IGRpZmZSZXN1bHQuZGlmZnM7XG4gICAgICAgIGRpZmZzID0gb3B0aW1pemVTZXF1ZW5jZURpZmZzKHNsaWNlMSwgc2xpY2UyLCBkaWZmcyk7XG4gICAgICAgIGRpZmZzID0gZXh0ZW5kRGlmZnNUb0VudGlyZVdvcmRJZkFwcHJvcHJpYXRlKHNsaWNlMSwgc2xpY2UyLCBkaWZmcyk7XG4gICAgICAgIGRpZmZzID0gcmVtb3ZlU2hvcnRNYXRjaGVzKHNsaWNlMSwgc2xpY2UyLCBkaWZmcyk7XG4gICAgICAgIGRpZmZzID0gcmVtb3ZlVmVyeVNob3J0TWF0Y2hpbmdUZXh0QmV0d2VlbkxvbmdEaWZmcyhzbGljZTEsIHNsaWNlMiwgZGlmZnMpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkaWZmcy5tYXAoKGQpID0+IG5ldyBSYW5nZU1hcHBpbmcoc2xpY2UxLnRyYW5zbGF0ZVJhbmdlKGQuc2VxMVJhbmdlKSwgc2xpY2UyLnRyYW5zbGF0ZVJhbmdlKGQuc2VxMlJhbmdlKSkpO1xuICAgICAgICAvLyBBc3NlcnQ6IHJlc3VsdCBhcHBsaWVkIG9uIG9yaWdpbmFsIHNob3VsZCBiZSB0aGUgc2FtZSBhcyBkaWZmIGFwcGxpZWQgdG8gb3JpZ2luYWxcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1hcHBpbmdzOiByZXN1bHQsXG4gICAgICAgICAgICBoaXRUaW1lb3V0OiBkaWZmUmVzdWx0LmhpdFRpbWVvdXQsXG4gICAgICAgIH07XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGxpbmVSYW5nZU1hcHBpbmdGcm9tUmFuZ2VNYXBwaW5ncyhhbGlnbm1lbnRzLCBvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBkb250QXNzZXJ0U3RhcnRMaW5lID0gZmFsc2UpIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBnIG9mIGdyb3VwQWRqYWNlbnRCeShhbGlnbm1lbnRzLm1hcChhID0+IGdldExpbmVSYW5nZU1hcHBpbmcoYSwgb3JpZ2luYWxMaW5lcywgbW9kaWZpZWRMaW5lcykpLCAoYTEsIGEyKSA9PiBhMS5vcmlnaW5hbC5vdmVybGFwT3JUb3VjaChhMi5vcmlnaW5hbClcbiAgICAgICAgfHwgYTEubW9kaWZpZWQub3ZlcmxhcE9yVG91Y2goYTIubW9kaWZpZWQpKSkge1xuICAgICAgICBjb25zdCBmaXJzdCA9IGdbMF07XG4gICAgICAgIGNvbnN0IGxhc3QgPSBnW2cubGVuZ3RoIC0gMV07XG4gICAgICAgIGNoYW5nZXMucHVzaChuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKGZpcnN0Lm9yaWdpbmFsLmpvaW4obGFzdC5vcmlnaW5hbCksIGZpcnN0Lm1vZGlmaWVkLmpvaW4obGFzdC5tb2RpZmllZCksIGcubWFwKGEgPT4gYS5pbm5lckNoYW5nZXNbMF0pKSk7XG4gICAgfVxuICAgIGFzc2VydEZuKCgpID0+IHtcbiAgICAgICAgaWYgKCFkb250QXNzZXJ0U3RhcnRMaW5lICYmIGNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGNoYW5nZXNbMF0ubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyICE9PSBjaGFuZ2VzWzBdLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RpZmllZExpbmVzLmxlbmd0aCAtIGNoYW5nZXNbY2hhbmdlcy5sZW5ndGggLSAxXS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlICE9PSBvcmlnaW5hbExpbmVzLmxlbmd0aCAtIGNoYW5nZXNbY2hhbmdlcy5sZW5ndGggLSAxXS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGVja0FkamFjZW50SXRlbXMoY2hhbmdlcywgKG0xLCBtMikgPT4gbTIub3JpZ2luYWwuc3RhcnRMaW5lTnVtYmVyIC0gbTEub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA9PT0gbTIubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyIC0gbTEubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSAmJlxuICAgICAgICAgICAgLy8gVGhlcmUgaGFzIHRvIGJlIGFuIHVuY2hhbmdlZCBsaW5lIGluIGJldHdlZW4gKG90aGVyd2lzZSBib3RoIGRpZmZzIHNob3VsZCBoYXZlIGJlZW4gam9pbmVkKVxuICAgICAgICAgICAgbTEub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IG0yLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciAmJlxuICAgICAgICAgICAgbTEubW9kaWZpZWQuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSA8IG0yLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoYW5nZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGluZVJhbmdlTWFwcGluZyhyYW5nZU1hcHBpbmcsIG9yaWdpbmFsTGluZXMsIG1vZGlmaWVkTGluZXMpIHtcbiAgICBsZXQgbGluZVN0YXJ0RGVsdGEgPSAwO1xuICAgIGxldCBsaW5lRW5kRGVsdGEgPSAwO1xuICAgIC8vIHJhbmdlTWFwcGluZyBkZXNjcmliZXMgdGhlIGVkaXQgdGhhdCByZXBsYWNlcyBgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2VgIHdpdGggYG5ld1RleHQgOj0gZ2V0VGV4dChtb2RpZmllZExpbmVzLCByYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZSlgLlxuICAgIC8vIG9yaWdpbmFsOiBdeHh4IFxcbiA8LSB0aGlzIGxpbmUgaXMgbm90IG1vZGlmaWVkXG4gICAgLy8gbW9kaWZpZWQ6IF14eCAgXFxuXG4gICAgaWYgKHJhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLmVuZENvbHVtbiA9PT0gMSAmJiByYW5nZU1hcHBpbmcub3JpZ2luYWxSYW5nZS5lbmRDb2x1bW4gPT09IDFcbiAgICAgICAgJiYgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyICsgbGluZVN0YXJ0RGVsdGEgPD0gcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2UuZW5kTGluZU51bWJlclxuICAgICAgICAmJiByYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZS5zdGFydExpbmVOdW1iZXIgKyBsaW5lU3RhcnREZWx0YSA8PSByYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZS5lbmRMaW5lTnVtYmVyKSB7XG4gICAgICAgIC8vIFdlIGNhbiBvbmx5IGRvIHRoaXMgaWYgdGhlIHJhbmdlIGlzIG5vdCBlbXB0eSB5ZXRcbiAgICAgICAgbGluZUVuZERlbHRhID0gLTE7XG4gICAgfVxuICAgIC8vIG9yaWdpbmFsOiB4eHhbIFxcbiA8LSB0aGlzIGxpbmUgaXMgbm90IG1vZGlmaWVkXG4gICAgLy8gbW9kaWZpZWQ6IHh4eFsgXFxuXG4gICAgaWYgKHJhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLnN0YXJ0Q29sdW1uIC0gMSA+PSBtb2RpZmllZExpbmVzW3JhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLnN0YXJ0TGluZU51bWJlciAtIDFdLmxlbmd0aFxuICAgICAgICAmJiByYW5nZU1hcHBpbmcub3JpZ2luYWxSYW5nZS5zdGFydENvbHVtbiAtIDEgPj0gb3JpZ2luYWxMaW5lc1tyYW5nZU1hcHBpbmcub3JpZ2luYWxSYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5sZW5ndGhcbiAgICAgICAgJiYgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDw9IHJhbmdlTWFwcGluZy5vcmlnaW5hbFJhbmdlLmVuZExpbmVOdW1iZXIgKyBsaW5lRW5kRGVsdGFcbiAgICAgICAgJiYgcmFuZ2VNYXBwaW5nLm1vZGlmaWVkUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyIDw9IHJhbmdlTWFwcGluZy5tb2RpZmllZFJhbmdlLmVuZExpbmVOdW1iZXIgKyBsaW5lRW5kRGVsdGEpIHtcbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgZG8gdGhpcyBpZiB0aGUgcmFuZ2UgaXMgbm90IGVtcHR5IHlldFxuICAgICAgICBsaW5lU3RhcnREZWx0YSA9IDE7XG4gICAgfVxuICAgIGNvbnN0IG9yaWdpbmFsTGluZVJhbmdlID0gbmV3IExpbmVSYW5nZShyYW5nZU1hcHBpbmcub3JpZ2luYWxSYW5nZS5zdGFydExpbmVOdW1iZXIgKyBsaW5lU3RhcnREZWx0YSwgcmFuZ2VNYXBwaW5nLm9yaWdpbmFsUmFuZ2UuZW5kTGluZU51bWJlciArIDEgKyBsaW5lRW5kRGVsdGEpO1xuICAgIGNvbnN0IG1vZGlmaWVkTGluZVJhbmdlID0gbmV3IExpbmVSYW5nZShyYW5nZU1hcHBpbmcubW9kaWZpZWRSYW5nZS5zdGFydExpbmVOdW1iZXIgKyBsaW5lU3RhcnREZWx0YSwgcmFuZ2VNYXBwaW5nLm1vZGlmaWVkUmFuZ2UuZW5kTGluZU51bWJlciArIDEgKyBsaW5lRW5kRGVsdGEpO1xuICAgIHJldHVybiBuZXcgRGV0YWlsZWRMaW5lUmFuZ2VNYXBwaW5nKG9yaWdpbmFsTGluZVJhbmdlLCBtb2RpZmllZExpbmVSYW5nZSwgW3JhbmdlTWFwcGluZ10pO1xufVxuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBMZWdhY3lMaW5lc0RpZmZDb21wdXRlciB9IGZyb20gJy4vbGVnYWN5TGluZXNEaWZmQ29tcHV0ZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyIH0gZnJvbSAnLi9kZWZhdWx0TGluZXNEaWZmQ29tcHV0ZXIvZGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyLmpzJztcbmV4cG9ydCBjb25zdCBsaW5lc0RpZmZDb21wdXRlcnMgPSB7XG4gICAgZ2V0TGVnYWN5OiAoKSA9PiBuZXcgTGVnYWN5TGluZXNEaWZmQ29tcHV0ZXIoKSxcbiAgICBnZXREZWZhdWx0OiAoKSA9PiBuZXcgRGVmYXVsdExpbmVzRGlmZkNvbXB1dGVyKCksXG59O1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiByb3VuZEZsb2F0KG51bWJlciwgZGVjaW1hbFBvaW50cykge1xuICAgIGNvbnN0IGRlY2ltYWwgPSBNYXRoLnBvdygxMCwgZGVjaW1hbFBvaW50cyk7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyICogZGVjaW1hbCkgLyBkZWNpbWFsO1xufVxuZXhwb3J0IGNsYXNzIFJHQkEge1xuICAgIGNvbnN0cnVjdG9yKHIsIGcsIGIsIGEgPSAxKSB7XG4gICAgICAgIHRoaXMuX3JnYmFCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yID0gTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCByKSkgfCAwO1xuICAgICAgICB0aGlzLmcgPSBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIGcpKSB8IDA7XG4gICAgICAgIHRoaXMuYiA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgYikpIHwgMDtcbiAgICAgICAgdGhpcy5hID0gcm91bmRGbG9hdChNYXRoLm1heChNYXRoLm1pbigxLCBhKSwgMCksIDMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuciA9PT0gYi5yICYmIGEuZyA9PT0gYi5nICYmIGEuYiA9PT0gYi5iICYmIGEuYSA9PT0gYi5hO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBIU0xBIHtcbiAgICBjb25zdHJ1Y3RvcihoLCBzLCBsLCBhKSB7XG4gICAgICAgIHRoaXMuX2hzbGFCcmFuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oID0gTWF0aC5tYXgoTWF0aC5taW4oMzYwLCBoKSwgMCkgfCAwO1xuICAgICAgICB0aGlzLnMgPSByb3VuZEZsb2F0KE1hdGgubWF4KE1hdGgubWluKDEsIHMpLCAwKSwgMyk7XG4gICAgICAgIHRoaXMubCA9IHJvdW5kRmxvYXQoTWF0aC5tYXgoTWF0aC5taW4oMSwgbCksIDApLCAzKTtcbiAgICAgICAgdGhpcy5hID0gcm91bmRGbG9hdChNYXRoLm1heChNYXRoLm1pbigxLCBhKSwgMCksIDMpO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGEuaCA9PT0gYi5oICYmIGEucyA9PT0gYi5zICYmIGEubCA9PT0gYi5sICYmIGEuYSA9PT0gYi5hO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBSR0IgY29sb3IgdmFsdWUgdG8gSFNMLiBDb252ZXJzaW9uIGZvcm11bGFcbiAgICAgKiBhZGFwdGVkIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXG4gICAgICogQXNzdW1lcyByLCBnLCBhbmQgYiBhcmUgY29udGFpbmVkIGluIHRoZSBzZXQgWzAsIDI1NV0gYW5kXG4gICAgICogcmV0dXJucyBoIGluIHRoZSBzZXQgWzAsIDM2MF0sIHMsIGFuZCBsIGluIHRoZSBzZXQgWzAsIDFdLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tUkdCQShyZ2JhKSB7XG4gICAgICAgIGNvbnN0IHIgPSByZ2JhLnIgLyAyNTU7XG4gICAgICAgIGNvbnN0IGcgPSByZ2JhLmcgLyAyNTU7XG4gICAgICAgIGNvbnN0IGIgPSByZ2JhLmIgLyAyNTU7XG4gICAgICAgIGNvbnN0IGEgPSByZ2JhLmE7XG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgICAgbGV0IGggPSAwO1xuICAgICAgICBsZXQgcyA9IDA7XG4gICAgICAgIGNvbnN0IGwgPSAobWluICsgbWF4KSAvIDI7XG4gICAgICAgIGNvbnN0IGNocm9tYSA9IG1heCAtIG1pbjtcbiAgICAgICAgaWYgKGNocm9tYSA+IDApIHtcbiAgICAgICAgICAgIHMgPSBNYXRoLm1pbigobCA8PSAwLjUgPyBjaHJvbWEgLyAoMiAqIGwpIDogY2hyb21hIC8gKDIgLSAoMiAqIGwpKSksIDEpO1xuICAgICAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gY2hyb21hICsgKGcgPCBiID8gNiA6IDApO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICAgICAgICAgIGggPSAoYiAtIHIpIC8gY2hyb21hICsgMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgICAgICAgICBoID0gKHIgLSBnKSAvIGNocm9tYSArIDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaCAqPSA2MDtcbiAgICAgICAgICAgIGggPSBNYXRoLnJvdW5kKGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSFNMQShoLCBzLCBsLCBhKTtcbiAgICB9XG4gICAgc3RhdGljIF9odWUycmdiKHAsIHEsIHQpIHtcbiAgICAgICAgaWYgKHQgPCAwKSB7XG4gICAgICAgICAgICB0ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPiAxKSB7XG4gICAgICAgICAgICB0IC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPCAxIC8gNikge1xuICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPCAxIC8gMikge1xuICAgICAgICAgICAgcmV0dXJuIHE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPCAyIC8gMykge1xuICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhbiBIU0wgY29sb3IgdmFsdWUgdG8gUkdCLiBDb252ZXJzaW9uIGZvcm11bGFcbiAgICAgKiBhZGFwdGVkIGZyb20gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IU0xfY29sb3Jfc3BhY2UuXG4gICAgICogQXNzdW1lcyBoIGluIHRoZSBzZXQgWzAsIDM2MF0gcywgYW5kIGwgYXJlIGNvbnRhaW5lZCBpbiB0aGUgc2V0IFswLCAxXSBhbmRcbiAgICAgKiByZXR1cm5zIHIsIGcsIGFuZCBiIGluIHRoZSBzZXQgWzAsIDI1NV0uXG4gICAgICovXG4gICAgc3RhdGljIHRvUkdCQShoc2xhKSB7XG4gICAgICAgIGNvbnN0IGggPSBoc2xhLmggLyAzNjA7XG4gICAgICAgIGNvbnN0IHsgcywgbCwgYSB9ID0gaHNsYTtcbiAgICAgICAgbGV0IHIsIGcsIGI7XG4gICAgICAgIGlmIChzID09PSAwKSB7XG4gICAgICAgICAgICByID0gZyA9IGIgPSBsOyAvLyBhY2hyb21hdGljXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICAgICAgICAgIGNvbnN0IHAgPSAyICogbCAtIHE7XG4gICAgICAgICAgICByID0gSFNMQS5faHVlMnJnYihwLCBxLCBoICsgMSAvIDMpO1xuICAgICAgICAgICAgZyA9IEhTTEEuX2h1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICAgICAgICBiID0gSFNMQS5faHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUkdCQShNYXRoLnJvdW5kKHIgKiAyNTUpLCBNYXRoLnJvdW5kKGcgKiAyNTUpLCBNYXRoLnJvdW5kKGIgKiAyNTUpLCBhKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgSFNWQSB7XG4gICAgY29uc3RydWN0b3IoaCwgcywgdiwgYSkge1xuICAgICAgICB0aGlzLl9oc3ZhQnJhbmQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaCA9IE1hdGgubWF4KE1hdGgubWluKDM2MCwgaCksIDApIHwgMDtcbiAgICAgICAgdGhpcy5zID0gcm91bmRGbG9hdChNYXRoLm1heChNYXRoLm1pbigxLCBzKSwgMCksIDMpO1xuICAgICAgICB0aGlzLnYgPSByb3VuZEZsb2F0KE1hdGgubWF4KE1hdGgubWluKDEsIHYpLCAwKSwgMyk7XG4gICAgICAgIHRoaXMuYSA9IHJvdW5kRmxvYXQoTWF0aC5tYXgoTWF0aC5taW4oMSwgYSksIDApLCAzKTtcbiAgICB9XG4gICAgc3RhdGljIGVxdWFscyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmggPT09IGIuaCAmJiBhLnMgPT09IGIucyAmJiBhLnYgPT09IGIudiAmJiBhLmEgPT09IGIuYTtcbiAgICB9XG4gICAgLy8gZnJvbSBodHRwOi8vd3d3LnJhcGlkdGFibGVzLmNvbS9jb252ZXJ0L2NvbG9yL3JnYi10by1oc3YuaHRtXG4gICAgc3RhdGljIGZyb21SR0JBKHJnYmEpIHtcbiAgICAgICAgY29uc3QgciA9IHJnYmEuciAvIDI1NTtcbiAgICAgICAgY29uc3QgZyA9IHJnYmEuZyAvIDI1NTtcbiAgICAgICAgY29uc3QgYiA9IHJnYmEuYiAvIDI1NTtcbiAgICAgICAgY29uc3QgY21heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgICAgICBjb25zdCBjbWluID0gTWF0aC5taW4ociwgZywgYik7XG4gICAgICAgIGNvbnN0IGRlbHRhID0gY21heCAtIGNtaW47XG4gICAgICAgIGNvbnN0IHMgPSBjbWF4ID09PSAwID8gMCA6IChkZWx0YSAvIGNtYXgpO1xuICAgICAgICBsZXQgbTtcbiAgICAgICAgaWYgKGRlbHRhID09PSAwKSB7XG4gICAgICAgICAgICBtID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbWF4ID09PSByKSB7XG4gICAgICAgICAgICBtID0gKCgoKGcgLSBiKSAvIGRlbHRhKSAlIDYpICsgNikgJSA2O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNtYXggPT09IGcpIHtcbiAgICAgICAgICAgIG0gPSAoKGIgLSByKSAvIGRlbHRhKSArIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtID0gKChyIC0gZykgLyBkZWx0YSkgKyA0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSFNWQShNYXRoLnJvdW5kKG0gKiA2MCksIHMsIGNtYXgsIHJnYmEuYSk7XG4gICAgfVxuICAgIC8vIGZyb20gaHR0cDovL3d3dy5yYXBpZHRhYmxlcy5jb20vY29udmVydC9jb2xvci9oc3YtdG8tcmdiLmh0bVxuICAgIHN0YXRpYyB0b1JHQkEoaHN2YSkge1xuICAgICAgICBjb25zdCB7IGgsIHMsIHYsIGEgfSA9IGhzdmE7XG4gICAgICAgIGNvbnN0IGMgPSB2ICogcztcbiAgICAgICAgY29uc3QgeCA9IGMgKiAoMSAtIE1hdGguYWJzKChoIC8gNjApICUgMiAtIDEpKTtcbiAgICAgICAgY29uc3QgbSA9IHYgLSBjO1xuICAgICAgICBsZXQgW3IsIGcsIGJdID0gWzAsIDAsIDBdO1xuICAgICAgICBpZiAoaCA8IDYwKSB7XG4gICAgICAgICAgICByID0gYztcbiAgICAgICAgICAgIGcgPSB4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGggPCAxMjApIHtcbiAgICAgICAgICAgIHIgPSB4O1xuICAgICAgICAgICAgZyA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaCA8IDE4MCkge1xuICAgICAgICAgICAgZyA9IGM7XG4gICAgICAgICAgICBiID0geDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoIDwgMjQwKSB7XG4gICAgICAgICAgICBnID0geDtcbiAgICAgICAgICAgIGIgPSBjO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGggPCAzMDApIHtcbiAgICAgICAgICAgIHIgPSB4O1xuICAgICAgICAgICAgYiA9IGM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaCA8PSAzNjApIHtcbiAgICAgICAgICAgIHIgPSBjO1xuICAgICAgICAgICAgYiA9IHg7XG4gICAgICAgIH1cbiAgICAgICAgciA9IE1hdGgucm91bmQoKHIgKyBtKSAqIDI1NSk7XG4gICAgICAgIGcgPSBNYXRoLnJvdW5kKChnICsgbSkgKiAyNTUpO1xuICAgICAgICBiID0gTWF0aC5yb3VuZCgoYiArIG0pICogMjU1KTtcbiAgICAgICAgcmV0dXJuIG5ldyBSR0JBKHIsIGcsIGIsIGEpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb2xvciB7XG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHJldHVybiBDb2xvci5Gb3JtYXQuQ1NTLnBhcnNlSGV4KGhleCkgfHwgQ29sb3IucmVkO1xuICAgIH1cbiAgICBzdGF0aWMgZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgaWYgKCFhICYmICFiKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYS5lcXVhbHMoYik7XG4gICAgfVxuICAgIGdldCBoc2xhKCkge1xuICAgICAgICBpZiAodGhpcy5faHNsYSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hzbGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gSFNMQS5mcm9tUkdCQSh0aGlzLnJnYmEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBoc3ZhKCkge1xuICAgICAgICBpZiAodGhpcy5faHN2YSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hzdmE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEhTVkEuZnJvbVJHQkEodGhpcy5yZ2JhKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYXJnKSB7XG4gICAgICAgIGlmICghYXJnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbG9yIG5lZWRzIGEgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBSR0JBKSB7XG4gICAgICAgICAgICB0aGlzLnJnYmEgPSBhcmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgSFNMQSkge1xuICAgICAgICAgICAgdGhpcy5faHNsYSA9IGFyZztcbiAgICAgICAgICAgIHRoaXMucmdiYSA9IEhTTEEudG9SR0JBKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgSFNWQSkge1xuICAgICAgICAgICAgdGhpcy5faHN2YSA9IGFyZztcbiAgICAgICAgICAgIHRoaXMucmdiYSA9IEhTVkEudG9SR0JBKGFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29sb3IgY3RvciBhcmd1bWVudCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICByZXR1cm4gISFvdGhlciAmJiBSR0JBLmVxdWFscyh0aGlzLnJnYmEsIG90aGVyLnJnYmEpICYmIEhTTEEuZXF1YWxzKHRoaXMuaHNsYSwgb3RoZXIuaHNsYSkgJiYgSFNWQS5lcXVhbHModGhpcy5oc3ZhLCBvdGhlci5oc3ZhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogaHR0cDovL3d3dy53My5vcmcvVFIvV0NBRzIwLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBpbiB0aGUgc2V0IFswLCAxXS4gTyA9PiBEYXJrZXN0IEJsYWNrLiAxID0+IExpZ2h0ZXN0IHdoaXRlLlxuICAgICAqL1xuICAgIGdldFJlbGF0aXZlTHVtaW5hbmNlKCkge1xuICAgICAgICBjb25zdCBSID0gQ29sb3IuX3JlbGF0aXZlTHVtaW5hbmNlRm9yQ29tcG9uZW50KHRoaXMucmdiYS5yKTtcbiAgICAgICAgY29uc3QgRyA9IENvbG9yLl9yZWxhdGl2ZUx1bWluYW5jZUZvckNvbXBvbmVudCh0aGlzLnJnYmEuZyk7XG4gICAgICAgIGNvbnN0IEIgPSBDb2xvci5fcmVsYXRpdmVMdW1pbmFuY2VGb3JDb21wb25lbnQodGhpcy5yZ2JhLmIpO1xuICAgICAgICBjb25zdCBsdW1pbmFuY2UgPSAwLjIxMjYgKiBSICsgMC43MTUyICogRyArIDAuMDcyMiAqIEI7XG4gICAgICAgIHJldHVybiByb3VuZEZsb2F0KGx1bWluYW5jZSwgNCk7XG4gICAgfVxuICAgIHN0YXRpYyBfcmVsYXRpdmVMdW1pbmFuY2VGb3JDb21wb25lbnQoY29sb3IpIHtcbiAgICAgICAgY29uc3QgYyA9IGNvbG9yIC8gMjU1O1xuICAgICAgICByZXR1cm4gKGMgPD0gMC4wMzkyOCkgPyBjIC8gMTIuOTIgOiBNYXRoLnBvdygoKGMgKyAwLjA1NSkgLyAxLjA1NSksIDIuNCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXHRodHRwOi8vMjR3YXlzLm9yZy8yMDEwL2NhbGN1bGF0aW5nLWNvbG9yLWNvbnRyYXN0XG4gICAgICogIFJldHVybiAndHJ1ZScgaWYgbGlnaHRlciBjb2xvciBvdGhlcndpc2UgJ2ZhbHNlJ1xuICAgICAqL1xuICAgIGlzTGlnaHRlcigpIHtcbiAgICAgICAgY29uc3QgeWlxID0gKHRoaXMucmdiYS5yICogMjk5ICsgdGhpcy5yZ2JhLmcgKiA1ODcgKyB0aGlzLnJnYmEuYiAqIDExNCkgLyAxMDAwO1xuICAgICAgICByZXR1cm4geWlxID49IDEyODtcbiAgICB9XG4gICAgaXNMaWdodGVyVGhhbihhbm90aGVyKSB7XG4gICAgICAgIGNvbnN0IGx1bTEgPSB0aGlzLmdldFJlbGF0aXZlTHVtaW5hbmNlKCk7XG4gICAgICAgIGNvbnN0IGx1bTIgPSBhbm90aGVyLmdldFJlbGF0aXZlTHVtaW5hbmNlKCk7XG4gICAgICAgIHJldHVybiBsdW0xID4gbHVtMjtcbiAgICB9XG4gICAgaXNEYXJrZXJUaGFuKGFub3RoZXIpIHtcbiAgICAgICAgY29uc3QgbHVtMSA9IHRoaXMuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcbiAgICAgICAgY29uc3QgbHVtMiA9IGFub3RoZXIuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcbiAgICAgICAgcmV0dXJuIGx1bTEgPCBsdW0yO1xuICAgIH1cbiAgICBsaWdodGVuKGZhY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ldyBIU0xBKHRoaXMuaHNsYS5oLCB0aGlzLmhzbGEucywgdGhpcy5oc2xhLmwgKyB0aGlzLmhzbGEubCAqIGZhY3RvciwgdGhpcy5oc2xhLmEpKTtcbiAgICB9XG4gICAgZGFya2VuKGZhY3Rvcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ldyBIU0xBKHRoaXMuaHNsYS5oLCB0aGlzLmhzbGEucywgdGhpcy5oc2xhLmwgLSB0aGlzLmhzbGEubCAqIGZhY3RvciwgdGhpcy5oc2xhLmEpKTtcbiAgICB9XG4gICAgdHJhbnNwYXJlbnQoZmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IHsgciwgZywgYiwgYSB9ID0gdGhpcy5yZ2JhO1xuICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ldyBSR0JBKHIsIGcsIGIsIGEgKiBmYWN0b3IpKTtcbiAgICB9XG4gICAgaXNUcmFuc3BhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmdiYS5hID09PSAwO1xuICAgIH1cbiAgICBpc09wYXF1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmdiYS5hID09PSAxO1xuICAgIH1cbiAgICBvcHBvc2l0ZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXcgUkdCQSgyNTUgLSB0aGlzLnJnYmEuciwgMjU1IC0gdGhpcy5yZ2JhLmcsIDI1NSAtIHRoaXMucmdiYS5iLCB0aGlzLnJnYmEuYSkpO1xuICAgIH1cbiAgICBtYWtlT3BhcXVlKG9wYXF1ZUJhY2tncm91bmQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGFxdWUoKSB8fCBvcGFxdWVCYWNrZ3JvdW5kLnJnYmEuYSAhPT0gMSkge1xuICAgICAgICAgICAgLy8gb25seSBhbGxvdyB0byBibGVuZCBvbnRvIGEgbm9uLW9wYXF1ZSBjb2xvciBvbnRvIGEgb3BhcXVlIGNvbG9yXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHIsIGcsIGIsIGEgfSA9IHRoaXMucmdiYTtcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIyMjg1NDgvZmluZGluZy1lcXVpdmFsZW50LWNvbG9yLXdpdGgtb3BhY2l0eVxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ldyBSR0JBKG9wYXF1ZUJhY2tncm91bmQucmdiYS5yIC0gYSAqIChvcGFxdWVCYWNrZ3JvdW5kLnJnYmEuciAtIHIpLCBvcGFxdWVCYWNrZ3JvdW5kLnJnYmEuZyAtIGEgKiAob3BhcXVlQmFja2dyb3VuZC5yZ2JhLmcgLSBnKSwgb3BhcXVlQmFja2dyb3VuZC5yZ2JhLmIgLSBhICogKG9wYXF1ZUJhY2tncm91bmQucmdiYS5iIC0gYiksIDEpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9TdHJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvU3RyaW5nID0gQ29sb3IuRm9ybWF0LkNTUy5mb3JtYXQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvU3RyaW5nO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0TGlnaHRlckNvbG9yKG9mLCByZWxhdGl2ZSwgZmFjdG9yKSB7XG4gICAgICAgIGlmIChvZi5pc0xpZ2h0ZXJUaGFuKHJlbGF0aXZlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9mO1xuICAgICAgICB9XG4gICAgICAgIGZhY3RvciA9IGZhY3RvciA/IGZhY3RvciA6IDAuNTtcbiAgICAgICAgY29uc3QgbHVtMSA9IG9mLmdldFJlbGF0aXZlTHVtaW5hbmNlKCk7XG4gICAgICAgIGNvbnN0IGx1bTIgPSByZWxhdGl2ZS5nZXRSZWxhdGl2ZUx1bWluYW5jZSgpO1xuICAgICAgICBmYWN0b3IgPSBmYWN0b3IgKiAobHVtMiAtIGx1bTEpIC8gbHVtMjtcbiAgICAgICAgcmV0dXJuIG9mLmxpZ2h0ZW4oZmFjdG9yKTtcbiAgICB9XG4gICAgc3RhdGljIGdldERhcmtlckNvbG9yKG9mLCByZWxhdGl2ZSwgZmFjdG9yKSB7XG4gICAgICAgIGlmIChvZi5pc0RhcmtlclRoYW4ocmVsYXRpdmUpKSB7XG4gICAgICAgICAgICByZXR1cm4gb2Y7XG4gICAgICAgIH1cbiAgICAgICAgZmFjdG9yID0gZmFjdG9yID8gZmFjdG9yIDogMC41O1xuICAgICAgICBjb25zdCBsdW0xID0gb2YuZ2V0UmVsYXRpdmVMdW1pbmFuY2UoKTtcbiAgICAgICAgY29uc3QgbHVtMiA9IHJlbGF0aXZlLmdldFJlbGF0aXZlTHVtaW5hbmNlKCk7XG4gICAgICAgIGZhY3RvciA9IGZhY3RvciAqIChsdW0xIC0gbHVtMikgLyBsdW0xO1xuICAgICAgICByZXR1cm4gb2YuZGFya2VuKGZhY3Rvcik7XG4gICAgfVxufVxuQ29sb3Iud2hpdGUgPSBuZXcgQ29sb3IobmV3IFJHQkEoMjU1LCAyNTUsIDI1NSwgMSkpO1xuQ29sb3IuYmxhY2sgPSBuZXcgQ29sb3IobmV3IFJHQkEoMCwgMCwgMCwgMSkpO1xuQ29sb3IucmVkID0gbmV3IENvbG9yKG5ldyBSR0JBKDI1NSwgMCwgMCwgMSkpO1xuQ29sb3IuYmx1ZSA9IG5ldyBDb2xvcihuZXcgUkdCQSgwLCAwLCAyNTUsIDEpKTtcbkNvbG9yLmdyZWVuID0gbmV3IENvbG9yKG5ldyBSR0JBKDAsIDI1NSwgMCwgMSkpO1xuQ29sb3IuY3lhbiA9IG5ldyBDb2xvcihuZXcgUkdCQSgwLCAyNTUsIDI1NSwgMSkpO1xuQ29sb3IubGlnaHRncmV5ID0gbmV3IENvbG9yKG5ldyBSR0JBKDIxMSwgMjExLCAyMTEsIDEpKTtcbkNvbG9yLnRyYW5zcGFyZW50ID0gbmV3IENvbG9yKG5ldyBSR0JBKDAsIDAsIDAsIDApKTtcbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICBsZXQgRm9ybWF0O1xuICAgIChmdW5jdGlvbiAoRm9ybWF0KSB7XG4gICAgICAgIGxldCBDU1M7XG4gICAgICAgIChmdW5jdGlvbiAoQ1NTKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRSR0IoY29sb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29sb3IucmdiYS5hID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgcmdiKCR7Y29sb3IucmdiYS5yfSwgJHtjb2xvci5yZ2JhLmd9LCAke2NvbG9yLnJnYmEuYn0pYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbG9yLkZvcm1hdC5DU1MuZm9ybWF0UkdCQShjb2xvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDU1MuZm9ybWF0UkdCID0gZm9ybWF0UkdCO1xuICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0UkdCQShjb2xvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBgcmdiYSgke2NvbG9yLnJnYmEucn0sICR7Y29sb3IucmdiYS5nfSwgJHtjb2xvci5yZ2JhLmJ9LCAkeysoY29sb3IucmdiYS5hKS50b0ZpeGVkKDIpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ1NTLmZvcm1hdFJHQkEgPSBmb3JtYXRSR0JBO1xuICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0SFNMKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yLmhzbGEuYSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYGhzbCgke2NvbG9yLmhzbGEuaH0sICR7KGNvbG9yLmhzbGEucyAqIDEwMCkudG9GaXhlZCgyKX0lLCAkeyhjb2xvci5oc2xhLmwgKiAxMDApLnRvRml4ZWQoMil9JSlgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gQ29sb3IuRm9ybWF0LkNTUy5mb3JtYXRIU0xBKGNvbG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENTUy5mb3JtYXRIU0wgPSBmb3JtYXRIU0w7XG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRIU0xBKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBoc2xhKCR7Y29sb3IuaHNsYS5ofSwgJHsoY29sb3IuaHNsYS5zICogMTAwKS50b0ZpeGVkKDIpfSUsICR7KGNvbG9yLmhzbGEubCAqIDEwMCkudG9GaXhlZCgyKX0lLCAke2NvbG9yLmhzbGEuYS50b0ZpeGVkKDIpfSlgO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ1NTLmZvcm1hdEhTTEEgPSBmb3JtYXRIU0xBO1xuICAgICAgICAgICAgZnVuY3Rpb24gX3RvVHdvRGlnaXRIZXgobikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBuLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gci5sZW5ndGggIT09IDIgPyAnMCcgKyByIDogcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9ybWF0cyB0aGUgY29sb3IgYXMgI1JSR0dCQlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRIZXgoY29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYCMke190b1R3b0RpZ2l0SGV4KGNvbG9yLnJnYmEucil9JHtfdG9Ud29EaWdpdEhleChjb2xvci5yZ2JhLmcpfSR7X3RvVHdvRGlnaXRIZXgoY29sb3IucmdiYS5iKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ1NTLmZvcm1hdEhleCA9IGZvcm1hdEhleDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9ybWF0cyB0aGUgY29sb3IgYXMgI1JSR0dCQkFBXG4gICAgICAgICAgICAgKiBJZiAnY29tcGFjdCcgaXMgc2V0LCBjb2xvcnMgd2l0aG91dCB0cmFuc3BhcmFuY3kgd2lsbCBiZSBwcmludGVkIGFzICNSUkdHQkJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gZm9ybWF0SGV4QShjb2xvciwgY29tcGFjdCA9IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhY3QgJiYgY29sb3IucmdiYS5hID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb2xvci5Gb3JtYXQuQ1NTLmZvcm1hdEhleChjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBgIyR7X3RvVHdvRGlnaXRIZXgoY29sb3IucmdiYS5yKX0ke190b1R3b0RpZ2l0SGV4KGNvbG9yLnJnYmEuZyl9JHtfdG9Ud29EaWdpdEhleChjb2xvci5yZ2JhLmIpfSR7X3RvVHdvRGlnaXRIZXgoTWF0aC5yb3VuZChjb2xvci5yZ2JhLmEgKiAyNTUpKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ1NTLmZvcm1hdEhleEEgPSBmb3JtYXRIZXhBO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZGVmYXVsdCBmb3JtYXQgd2lsbCB1c2UgSEVYIGlmIG9wYXF1ZSBhbmQgUkdCQSBvdGhlcndpc2UuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZvcm1hdChjb2xvcikge1xuICAgICAgICAgICAgICAgIGlmIChjb2xvci5pc09wYXF1ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBDb2xvci5Gb3JtYXQuQ1NTLmZvcm1hdEhleChjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBDb2xvci5Gb3JtYXQuQ1NTLmZvcm1hdFJHQkEoY29sb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQ1NTLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29udmVydHMgYW4gSGV4IGNvbG9yIHZhbHVlIHRvIGEgQ29sb3IuXG4gICAgICAgICAgICAgKiByZXR1cm5zIHIsIGcsIGFuZCBiIGFyZSBjb250YWluZWQgaW4gdGhlIHNldCBbMCwgMjU1XVxuICAgICAgICAgICAgICogQHBhcmFtIGhleCBzdHJpbmcgKCNSR0IsICNSR0JBLCAjUlJHR0JCIG9yICNSUkdHQkJBQSkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlSGV4KGhleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGhleC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGNvbG9yXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGV4LmNoYXJDb2RlQXQoMCkgIT09IDM1IC8qIENoYXJDb2RlLkhhc2ggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9lcyBub3QgYmVnaW4gd2l0aCBhICNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gI1JSR0dCQiBmb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IDE2ICogX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMSkpICsgX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMikpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnID0gMTYgKiBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgzKSkgKyBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCg0KSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSAxNiAqIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDUpKSArIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDYpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXcgUkdCQShyLCBnLCBiLCAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPT09IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gI1JSR0dCQkFBIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gMTYgKiBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgxKSkgKyBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgyKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGcgPSAxNiAqIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDMpKSArIF9wYXJzZUhleERpZ2l0KGhleC5jaGFyQ29kZUF0KDQpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYiA9IDE2ICogX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoNSkpICsgX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoNikpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gMTYgKiBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCg3KSkgKyBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCg4KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3IFJHQkEociwgZywgYiwgYSAvIDI1NSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICNSR0IgZm9ybWF0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgxKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGcgPSBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgyKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGIgPSBfcGFyc2VIZXhEaWdpdChoZXguY2hhckNvZGVBdCgzKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3IFJHQkEoMTYgKiByICsgciwgMTYgKiBnICsgZywgMTYgKiBiICsgYikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vICNSR0JBIGZvcm1hdFxuICAgICAgICAgICAgICAgICAgICBjb25zdCByID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMikpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBiID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoMykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gX3BhcnNlSGV4RGlnaXQoaGV4LmNoYXJDb2RlQXQoNCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ldyBSR0JBKDE2ICogciArIHIsIDE2ICogZyArIGcsIDE2ICogYiArIGIsICgxNiAqIGEgKyBhKSAvIDI1NSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGNvbG9yXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBDU1MucGFyc2VIZXggPSBwYXJzZUhleDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIF9wYXJzZUhleERpZ2l0KGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ4IC8qIENoYXJDb2RlLkRpZ2l0MCAqLzogcmV0dXJuIDA7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDkgLyogQ2hhckNvZGUuRGlnaXQxICovOiByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MCAvKiBDaGFyQ29kZS5EaWdpdDIgKi86IHJldHVybiAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDUxIC8qIENoYXJDb2RlLkRpZ2l0MyAqLzogcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTIgLyogQ2hhckNvZGUuRGlnaXQ0ICovOiByZXR1cm4gNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1MyAvKiBDaGFyQ29kZS5EaWdpdDUgKi86IHJldHVybiA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU0IC8qIENoYXJDb2RlLkRpZ2l0NiAqLzogcmV0dXJuIDY7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTUgLyogQ2hhckNvZGUuRGlnaXQ3ICovOiByZXR1cm4gNztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1NiAvKiBDaGFyQ29kZS5EaWdpdDggKi86IHJldHVybiA4O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU3IC8qIENoYXJDb2RlLkRpZ2l0OSAqLzogcmV0dXJuIDk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTcgLyogQ2hhckNvZGUuYSAqLzogcmV0dXJuIDEwO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDY1IC8qIENoYXJDb2RlLkEgKi86IHJldHVybiAxMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5OCAvKiBDaGFyQ29kZS5iICovOiByZXR1cm4gMTE7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjYgLyogQ2hhckNvZGUuQiAqLzogcmV0dXJuIDExO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDk5IC8qIENoYXJDb2RlLmMgKi86IHJldHVybiAxMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2NyAvKiBDaGFyQ29kZS5DICovOiByZXR1cm4gMTI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAwIC8qIENoYXJDb2RlLmQgKi86IHJldHVybiAxMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OCAvKiBDaGFyQ29kZS5EICovOiByZXR1cm4gMTM7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAxIC8qIENoYXJDb2RlLmUgKi86IHJldHVybiAxNDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OSAvKiBDaGFyQ29kZS5FICovOiByZXR1cm4gMTQ7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTAyIC8qIENoYXJDb2RlLmYgKi86IHJldHVybiAxNTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3MCAvKiBDaGFyQ29kZS5GICovOiByZXR1cm4gMTU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KShDU1MgPSBGb3JtYXQuQ1NTIHx8IChGb3JtYXQuQ1NTID0ge30pKTtcbiAgICB9KShGb3JtYXQgPSBDb2xvci5Gb3JtYXQgfHwgKENvbG9yLkZvcm1hdCA9IHt9KSk7XG59KShDb2xvciB8fCAoQ29sb3IgPSB7fSkpO1xuIiwiLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5pbXBvcnQgeyBDb2xvciwgSFNMQSB9IGZyb20gJy4uLy4uLy4uL2Jhc2UvY29tbW9uL2NvbG9yLmpzJztcbmZ1bmN0aW9uIF9wYXJzZUNhcHR1cmVHcm91cHMoY2FwdHVyZUdyb3Vwcykge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2FwdHVyZUdyb3VwIG9mIGNhcHR1cmVHcm91cHMpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkTnVtYmVyID0gTnVtYmVyKGNhcHR1cmVHcm91cCk7XG4gICAgICAgIGlmIChwYXJzZWROdW1iZXIgfHwgcGFyc2VkTnVtYmVyID09PSAwICYmIGNhcHR1cmVHcm91cC5yZXBsYWNlKC9cXHMvZywgJycpICE9PSAnJykge1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VkTnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gX3RvSUNvbG9yKHIsIGcsIGIsIGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWQ6IHIgLyAyNTUsXG4gICAgICAgIGJsdWU6IGIgLyAyNTUsXG4gICAgICAgIGdyZWVuOiBnIC8gMjU1LFxuICAgICAgICBhbHBoYTogYVxuICAgIH07XG59XG5mdW5jdGlvbiBfZmluZFJhbmdlKG1vZGVsLCBtYXRjaCkge1xuICAgIGNvbnN0IGluZGV4ID0gbWF0Y2guaW5kZXg7XG4gICAgY29uc3QgbGVuZ3RoID0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgIGlmICghaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFBvc2l0aW9uID0gbW9kZWwucG9zaXRpb25BdChpbmRleCk7XG4gICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgIHN0YXJ0TGluZU51bWJlcjogc3RhcnRQb3NpdGlvbi5saW5lTnVtYmVyLFxuICAgICAgICBzdGFydENvbHVtbjogc3RhcnRQb3NpdGlvbi5jb2x1bW4sXG4gICAgICAgIGVuZExpbmVOdW1iZXI6IHN0YXJ0UG9zaXRpb24ubGluZU51bWJlcixcbiAgICAgICAgZW5kQ29sdW1uOiBzdGFydFBvc2l0aW9uLmNvbHVtbiArIGxlbmd0aFxuICAgIH07XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gX2ZpbmRIZXhDb2xvckluZm9ybWF0aW9uKHJhbmdlLCBoZXhWYWx1ZSkge1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRIZXhDb2xvciA9IENvbG9yLkZvcm1hdC5DU1MucGFyc2VIZXgoaGV4VmFsdWUpO1xuICAgIGlmICghcGFyc2VkSGV4Q29sb3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByYW5nZTogcmFuZ2UsXG4gICAgICAgIGNvbG9yOiBfdG9JQ29sb3IocGFyc2VkSGV4Q29sb3IucmdiYS5yLCBwYXJzZWRIZXhDb2xvci5yZ2JhLmcsIHBhcnNlZEhleENvbG9yLnJnYmEuYiwgcGFyc2VkSGV4Q29sb3IucmdiYS5hKVxuICAgIH07XG59XG5mdW5jdGlvbiBfZmluZFJHQkNvbG9ySW5mb3JtYXRpb24ocmFuZ2UsIG1hdGNoZXMsIGlzQWxwaGEpIHtcbiAgICBpZiAoIXJhbmdlIHx8IG1hdGNoZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBtYXRjaGVzWzBdO1xuICAgIGNvbnN0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC52YWx1ZXMoKTtcbiAgICBjb25zdCBwYXJzZWRSZWdleCA9IF9wYXJzZUNhcHR1cmVHcm91cHMoY2FwdHVyZUdyb3Vwcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICBjb2xvcjogX3RvSUNvbG9yKHBhcnNlZFJlZ2V4WzBdLCBwYXJzZWRSZWdleFsxXSwgcGFyc2VkUmVnZXhbMl0sIGlzQWxwaGEgPyBwYXJzZWRSZWdleFszXSA6IDEpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIF9maW5kSFNMQ29sb3JJbmZvcm1hdGlvbihyYW5nZSwgbWF0Y2hlcywgaXNBbHBoYSkge1xuICAgIGlmICghcmFuZ2UgfHwgbWF0Y2hlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaCA9IG1hdGNoZXNbMF07XG4gICAgY29uc3QgY2FwdHVyZUdyb3VwcyA9IG1hdGNoLnZhbHVlcygpO1xuICAgIGNvbnN0IHBhcnNlZFJlZ2V4ID0gX3BhcnNlQ2FwdHVyZUdyb3VwcyhjYXB0dXJlR3JvdXBzKTtcbiAgICBjb25zdCBjb2xvckVxdWl2YWxlbnQgPSBuZXcgQ29sb3IobmV3IEhTTEEocGFyc2VkUmVnZXhbMF0sIHBhcnNlZFJlZ2V4WzFdIC8gMTAwLCBwYXJzZWRSZWdleFsyXSAvIDEwMCwgaXNBbHBoYSA/IHBhcnNlZFJlZ2V4WzNdIDogMSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgY29sb3I6IF90b0lDb2xvcihjb2xvckVxdWl2YWxlbnQucmdiYS5yLCBjb2xvckVxdWl2YWxlbnQucmdiYS5nLCBjb2xvckVxdWl2YWxlbnQucmdiYS5iLCBjb2xvckVxdWl2YWxlbnQucmdiYS5hKVxuICAgIH07XG59XG5mdW5jdGlvbiBfZmluZE1hdGNoZXMobW9kZWwsIHJlZ2V4KSB7XG4gICAgaWYgKHR5cGVvZiBtb2RlbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5tb2RlbC5tYXRjaEFsbChyZWdleCldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLmZpbmRNYXRjaGVzKHJlZ2V4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlQ29sb3JzKG1vZGVsKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgLy8gRWFybHkgdmFsaWRhdGlvbiBmb3IgUkdCIGFuZCBIU0xcbiAgICBjb25zdCBpbml0aWFsVmFsaWRhdGlvblJlZ2V4ID0gL1xcYihyZ2J8cmdiYXxoc2x8aHNsYSkoXFwoWzAtOVxccywuXFwlXSpcXCkpfCgjKShbQS1GYS1mMC05XXszfSlcXGJ8KCMpKFtBLUZhLWYwLTldezR9KVxcYnwoIykoW0EtRmEtZjAtOV17Nn0pXFxifCgjKShbQS1GYS1mMC05XXs4fSlcXGIvZ207XG4gICAgY29uc3QgaW5pdGlhbFZhbGlkYXRpb25NYXRjaGVzID0gX2ZpbmRNYXRjaGVzKG1vZGVsLCBpbml0aWFsVmFsaWRhdGlvblJlZ2V4KTtcbiAgICAvLyBQb3RlbnRpYWwgY29sb3JzIGhhdmUgYmVlbiBmb3VuZCwgdmFsaWRhdGUgdGhlIHBhcmFtZXRlcnNcbiAgICBpZiAoaW5pdGlhbFZhbGlkYXRpb25NYXRjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yIChjb25zdCBpbml0aWFsTWF0Y2ggb2YgaW5pdGlhbFZhbGlkYXRpb25NYXRjaGVzKSB7XG4gICAgICAgICAgICBjb25zdCBpbml0aWFsQ2FwdHVyZUdyb3VwcyA9IGluaXRpYWxNYXRjaC5maWx0ZXIoY2FwdHVyZUdyb3VwID0+IGNhcHR1cmVHcm91cCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yU2NoZW1lID0gaW5pdGlhbENhcHR1cmVHcm91cHNbMV07XG4gICAgICAgICAgICBjb25zdCBjb2xvclBhcmFtZXRlcnMgPSBpbml0aWFsQ2FwdHVyZUdyb3Vwc1syXTtcbiAgICAgICAgICAgIGlmICghY29sb3JQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29sb3JJbmZvcm1hdGlvbjtcbiAgICAgICAgICAgIGlmIChjb2xvclNjaGVtZSA9PT0gJ3JnYicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleFBhcmFtZXRlcnMgPSAvXlxcKFxccyooMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV17Mn18WzEtOV1bMC05XXxbMC05XSlcXHMqLFxccyooMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV17Mn18WzEtOV1bMC05XXxbMC05XSlcXHMqLFxccyooMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV17Mn18WzEtOV1bMC05XXxbMC05XSlcXHMqXFwpJC9nbTtcbiAgICAgICAgICAgICAgICBjb2xvckluZm9ybWF0aW9uID0gX2ZpbmRSR0JDb2xvckluZm9ybWF0aW9uKF9maW5kUmFuZ2UobW9kZWwsIGluaXRpYWxNYXRjaCksIF9maW5kTWF0Y2hlcyhjb2xvclBhcmFtZXRlcnMsIHJlZ2V4UGFyYW1ldGVycyksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yU2NoZW1lID09PSAncmdiYScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleFBhcmFtZXRlcnMgPSAvXlxcKFxccyooMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV17Mn18WzEtOV1bMC05XXxbMC05XSlcXHMqLFxccyooMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV17Mn18WzEtOV1bMC05XXxbMC05XSlcXHMqLFxccyooMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV17Mn18WzEtOV1bMC05XXxbMC05XSlcXHMqLFxccyooMFsuXVswLTldK3xbLl1bMC05XSt8WzAxXVsuXXxbMDFdKVxccypcXCkkL2dtO1xuICAgICAgICAgICAgICAgIGNvbG9ySW5mb3JtYXRpb24gPSBfZmluZFJHQkNvbG9ySW5mb3JtYXRpb24oX2ZpbmRSYW5nZShtb2RlbCwgaW5pdGlhbE1hdGNoKSwgX2ZpbmRNYXRjaGVzKGNvbG9yUGFyYW1ldGVycywgcmVnZXhQYXJhbWV0ZXJzKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvclNjaGVtZSA9PT0gJ2hzbCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleFBhcmFtZXRlcnMgPSAvXlxcKFxccyooMzZbMF18M1swLTVdWzAtOV18WzEyXVswLTldWzAtOV18WzEtOV0/WzAtOV0pXFxzKixcXHMqKDEwMHxcXGR7MSwyfVsuXVxcZCp8XFxkezEsMn0pJVxccyosXFxzKigxMDB8XFxkezEsMn1bLl1cXGQqfFxcZHsxLDJ9KSVcXHMqXFwpJC9nbTtcbiAgICAgICAgICAgICAgICBjb2xvckluZm9ybWF0aW9uID0gX2ZpbmRIU0xDb2xvckluZm9ybWF0aW9uKF9maW5kUmFuZ2UobW9kZWwsIGluaXRpYWxNYXRjaCksIF9maW5kTWF0Y2hlcyhjb2xvclBhcmFtZXRlcnMsIHJlZ2V4UGFyYW1ldGVycyksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbG9yU2NoZW1lID09PSAnaHNsYScpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleFBhcmFtZXRlcnMgPSAvXlxcKFxccyooMzZbMF18M1swLTVdWzAtOV18WzEyXVswLTldWzAtOV18WzEtOV0/WzAtOV0pXFxzKixcXHMqKDEwMHxcXGR7MSwyfVsuXVxcZCp8XFxkezEsMn0pJVxccyosXFxzKigxMDB8XFxkezEsMn1bLl1cXGQqfFxcZHsxLDJ9KSVcXHMqLFxccyooMFsuXVswLTldK3xbLl1bMC05XSt8WzAxXVsuXXxbMDFdKVxccypcXCkkL2dtO1xuICAgICAgICAgICAgICAgIGNvbG9ySW5mb3JtYXRpb24gPSBfZmluZEhTTENvbG9ySW5mb3JtYXRpb24oX2ZpbmRSYW5nZShtb2RlbCwgaW5pdGlhbE1hdGNoKSwgX2ZpbmRNYXRjaGVzKGNvbG9yUGFyYW1ldGVycywgcmVnZXhQYXJhbWV0ZXJzKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2xvclNjaGVtZSA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgY29sb3JJbmZvcm1hdGlvbiA9IF9maW5kSGV4Q29sb3JJbmZvcm1hdGlvbihfZmluZFJhbmdlKG1vZGVsLCBpbml0aWFsTWF0Y2gpLCBjb2xvclNjaGVtZSArIGNvbG9yUGFyYW1ldGVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sb3JJbmZvcm1hdGlvbikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNvbG9ySW5mb3JtYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGRlZmF1bHQgZG9jdW1lbnQgY29sb3JzIGluIHRoZSBwcm92aWRlZCBkb2N1bWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZURlZmF1bHREb2N1bWVudENvbG9ycyhtb2RlbCkge1xuICAgIGlmICghbW9kZWwgfHwgdHlwZW9mIG1vZGVsLmdldFZhbHVlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBtb2RlbC5wb3NpdGlvbkF0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVua25vd24gY2FsbGVyIVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBjb21wdXRlQ29sb3JzKG1vZGVsKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuY29uc3QgbWFya1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXFxcXGJNQVJLOlxcXFxzKiguKikkJywgJ2QnKTtcbmNvbnN0IHRyaW1EYXNoZXNSZWdleCA9IC9eLSt8LSskL2c7XG4vKipcbiAqIEZpbmQgc2VjdGlvbiBoZWFkZXJzIGluIHRoZSBtb2RlbC5cbiAqXG4gKiBAcGFyYW0gbW9kZWwgdGhlIHRleHQgbW9kZWwgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zIHRvIHNlYXJjaCB3aXRoXG4gKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzZWN0aW9uIGhlYWRlcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRTZWN0aW9uSGVhZGVycyhtb2RlbCwgb3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgaGVhZGVycyA9IFtdO1xuICAgIGlmIChvcHRpb25zLmZpbmRSZWdpb25TZWN0aW9uSGVhZGVycyAmJiAoKF9hID0gb3B0aW9ucy5mb2xkaW5nUnVsZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXJrZXJzKSkge1xuICAgICAgICBjb25zdCByZWdpb25IZWFkZXJzID0gY29sbGVjdFJlZ2lvbkhlYWRlcnMobW9kZWwsIG9wdGlvbnMpO1xuICAgICAgICBoZWFkZXJzID0gaGVhZGVycy5jb25jYXQocmVnaW9uSGVhZGVycyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZpbmRNYXJrU2VjdGlvbkhlYWRlcnMpIHtcbiAgICAgICAgY29uc3QgbWFya0hlYWRlcnMgPSBjb2xsZWN0TWFya0hlYWRlcnMobW9kZWwpO1xuICAgICAgICBoZWFkZXJzID0gaGVhZGVycy5jb25jYXQobWFya0hlYWRlcnMpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGNvbGxlY3RSZWdpb25IZWFkZXJzKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVnaW9uSGVhZGVycyA9IFtdO1xuICAgIGNvbnN0IGVuZExpbmVOdW1iZXIgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcbiAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gMTsgbGluZU51bWJlciA8PSBlbmRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBsaW5lQ29udGVudC5tYXRjaChvcHRpb25zLmZvbGRpbmdSdWxlcy5tYXJrZXJzLnN0YXJ0KTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgc3RhcnRMaW5lTnVtYmVyOiBsaW5lTnVtYmVyLCBzdGFydENvbHVtbjogbWF0Y2hbMF0ubGVuZ3RoICsgMSwgZW5kTGluZU51bWJlcjogbGluZU51bWJlciwgZW5kQ29sdW1uOiBsaW5lQ29udGVudC5sZW5ndGggKyAxIH07XG4gICAgICAgICAgICBpZiAocmFuZ2UuZW5kQ29sdW1uID4gcmFuZ2Uuc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWN0aW9uSGVhZGVyID0ge1xuICAgICAgICAgICAgICAgICAgICByYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZ2V0SGVhZGVyVGV4dChsaW5lQ29udGVudC5zdWJzdHJpbmcobWF0Y2hbMF0ubGVuZ3RoKSksXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZEJlSW5Db21tZW50czogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChzZWN0aW9uSGVhZGVyLnRleHQgfHwgc2VjdGlvbkhlYWRlci5oYXNTZXBhcmF0b3JMaW5lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZ2lvbkhlYWRlcnMucHVzaChzZWN0aW9uSGVhZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZ2lvbkhlYWRlcnM7XG59XG5mdW5jdGlvbiBjb2xsZWN0TWFya0hlYWRlcnMobW9kZWwpIHtcbiAgICBjb25zdCBtYXJrSGVhZGVycyA9IFtdO1xuICAgIGNvbnN0IGVuZExpbmVOdW1iZXIgPSBtb2RlbC5nZXRMaW5lQ291bnQoKTtcbiAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gMTsgbGluZU51bWJlciA8PSBlbmRMaW5lTnVtYmVyOyBsaW5lTnVtYmVyKyspIHtcbiAgICAgICAgY29uc3QgbGluZUNvbnRlbnQgPSBtb2RlbC5nZXRMaW5lQ29udGVudChsaW5lTnVtYmVyKTtcbiAgICAgICAgYWRkTWFya0hlYWRlcklmRm91bmQobGluZUNvbnRlbnQsIGxpbmVOdW1iZXIsIG1hcmtIZWFkZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtIZWFkZXJzO1xufVxuZnVuY3Rpb24gYWRkTWFya0hlYWRlcklmRm91bmQobGluZUNvbnRlbnQsIGxpbmVOdW1iZXIsIHNlY3Rpb25IZWFkZXJzKSB7XG4gICAgbWFya1JlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgY29uc3QgbWF0Y2ggPSBtYXJrUmVnZXguZXhlYyhsaW5lQ29udGVudCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IGNvbHVtbiA9IG1hdGNoLmluZGljZXNbMV1bMF0gKyAxO1xuICAgICAgICBjb25zdCBlbmRDb2x1bW4gPSBtYXRjaC5pbmRpY2VzWzFdWzFdICsgMTtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0TGluZU51bWJlcjogbGluZU51bWJlciwgc3RhcnRDb2x1bW46IGNvbHVtbiwgZW5kTGluZU51bWJlcjogbGluZU51bWJlciwgZW5kQ29sdW1uOiBlbmRDb2x1bW4gfTtcbiAgICAgICAgaWYgKHJhbmdlLmVuZENvbHVtbiA+IHJhbmdlLnN0YXJ0Q29sdW1uKSB7XG4gICAgICAgICAgICBjb25zdCBzZWN0aW9uSGVhZGVyID0ge1xuICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIC4uLmdldEhlYWRlclRleHQobWF0Y2hbMV0pLFxuICAgICAgICAgICAgICAgIHNob3VsZEJlSW5Db21tZW50czogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChzZWN0aW9uSGVhZGVyLnRleHQgfHwgc2VjdGlvbkhlYWRlci5oYXNTZXBhcmF0b3JMaW5lKSB7XG4gICAgICAgICAgICAgICAgc2VjdGlvbkhlYWRlcnMucHVzaChzZWN0aW9uSGVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEhlYWRlclRleHQodGV4dCkge1xuICAgIHRleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICBjb25zdCBoYXNTZXBhcmF0b3JMaW5lID0gdGV4dC5zdGFydHNXaXRoKCctJyk7XG4gICAgdGV4dCA9IHRleHQucmVwbGFjZSh0cmltRGFzaGVzUmVnZXgsICcnKTtcbiAgICByZXR1cm4geyB0ZXh0LCBoYXNTZXBhcmF0b3JMaW5lIH07XG59XG4iLCIvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IHN0cmluZ0RpZmYgfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9kaWZmL2RpZmYuanMnO1xuaW1wb3J0IHsgVVJJIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vdXJpLmpzJztcbmltcG9ydCB7IFBvc2l0aW9uIH0gZnJvbSAnLi4vY29yZS9wb3NpdGlvbi5qcyc7XG5pbXBvcnQgeyBSYW5nZSB9IGZyb20gJy4uL2NvcmUvcmFuZ2UuanMnO1xuaW1wb3J0IHsgTWlycm9yVGV4dE1vZGVsIGFzIEJhc2VNaXJyb3JNb2RlbCB9IGZyb20gJy4uL21vZGVsL21pcnJvclRleHRNb2RlbC5qcyc7XG5pbXBvcnQgeyBlbnN1cmVWYWxpZFdvcmREZWZpbml0aW9uLCBnZXRXb3JkQXRUZXh0IH0gZnJvbSAnLi4vY29yZS93b3JkSGVscGVyLmpzJztcbmltcG9ydCB7IGNvbXB1dGVMaW5rcyB9IGZyb20gJy4uL2xhbmd1YWdlcy9saW5rQ29tcHV0ZXIuanMnO1xuaW1wb3J0IHsgQmFzaWNJbnBsYWNlUmVwbGFjZSB9IGZyb20gJy4uL2xhbmd1YWdlcy9zdXBwb3J0cy9pbnBsYWNlUmVwbGFjZVN1cHBvcnQuanMnO1xuaW1wb3J0IHsgY3JlYXRlTW9uYWNvQmFzZUFQSSB9IGZyb20gJy4vZWRpdG9yQmFzZUFwaS5qcyc7XG5pbXBvcnQgeyBTdG9wV2F0Y2ggfSBmcm9tICcuLi8uLi8uLi9iYXNlL2NvbW1vbi9zdG9wd2F0Y2guanMnO1xuaW1wb3J0IHsgVW5pY29kZVRleHRNb2RlbEhpZ2hsaWdodGVyIH0gZnJvbSAnLi91bmljb2RlVGV4dE1vZGVsSGlnaGxpZ2h0ZXIuanMnO1xuaW1wb3J0IHsgbGluZXNEaWZmQ29tcHV0ZXJzIH0gZnJvbSAnLi4vZGlmZi9saW5lc0RpZmZDb21wdXRlcnMuanMnO1xuaW1wb3J0IHsgY3JlYXRlUHJveHlPYmplY3QsIGdldEFsbE1ldGhvZE5hbWVzIH0gZnJvbSAnLi4vLi4vLi4vYmFzZS9jb21tb24vb2JqZWN0cy5qcyc7XG5pbXBvcnQgeyBjb21wdXRlRGVmYXVsdERvY3VtZW50Q29sb3JzIH0gZnJvbSAnLi4vbGFuZ3VhZ2VzL2RlZmF1bHREb2N1bWVudENvbG9yc0NvbXB1dGVyLmpzJztcbmltcG9ydCB7IGZpbmRTZWN0aW9uSGVhZGVycyB9IGZyb20gJy4vZmluZFNlY3Rpb25IZWFkZXJzLmpzJztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIE1pcnJvck1vZGVsIGV4dGVuZHMgQmFzZU1pcnJvck1vZGVsIHtcbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgZW9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW9sO1xuICAgIH1cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGV4dCgpO1xuICAgIH1cbiAgICBmaW5kTWF0Y2hlcyhyZWdleCkge1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSB0aGlzLl9saW5lc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFRvQWRkID0gdGhpcy5vZmZzZXRBdChuZXcgUG9zaXRpb24oaSArIDEsIDEpKTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yT3Zlck1hdGNoZXMgPSBsaW5lLm1hdGNoQWxsKHJlZ2V4KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgaXRlcmF0b3JPdmVyTWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaC5pbmRleCB8fCBtYXRjaC5pbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaC5pbmRleCA9IG1hdGNoLmluZGV4ICsgb2Zmc2V0VG9BZGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuICAgIGdldExpbmVzQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzLnNsaWNlKDApO1xuICAgIH1cbiAgICBnZXRMaW5lQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lcy5sZW5ndGg7XG4gICAgfVxuICAgIGdldExpbmVDb250ZW50KGxpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVzW2xpbmVOdW1iZXIgLSAxXTtcbiAgICB9XG4gICAgZ2V0V29yZEF0UG9zaXRpb24ocG9zaXRpb24sIHdvcmREZWZpbml0aW9uKSB7XG4gICAgICAgIGNvbnN0IHdvcmRBdFRleHQgPSBnZXRXb3JkQXRUZXh0KHBvc2l0aW9uLmNvbHVtbiwgZW5zdXJlVmFsaWRXb3JkRGVmaW5pdGlvbih3b3JkRGVmaW5pdGlvbiksIHRoaXMuX2xpbmVzW3Bvc2l0aW9uLmxpbmVOdW1iZXIgLSAxXSwgMCk7XG4gICAgICAgIGlmICh3b3JkQXRUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJhbmdlKHBvc2l0aW9uLmxpbmVOdW1iZXIsIHdvcmRBdFRleHQuc3RhcnRDb2x1bW4sIHBvc2l0aW9uLmxpbmVOdW1iZXIsIHdvcmRBdFRleHQuZW5kQ29sdW1uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd29yZHMod29yZERlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSB0aGlzLl9saW5lcztcbiAgICAgICAgY29uc3Qgd29yZGVuaXplID0gdGhpcy5fd29yZGVuaXplLmJpbmQodGhpcyk7XG4gICAgICAgIGxldCBsaW5lTnVtYmVyID0gMDtcbiAgICAgICAgbGV0IGxpbmVUZXh0ID0gJyc7XG4gICAgICAgIGxldCB3b3JkUmFuZ2VzSWR4ID0gMDtcbiAgICAgICAgbGV0IHdvcmRSYW5nZXMgPSBbXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAod29yZFJhbmdlc0lkeCA8IHdvcmRSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGxpbmVUZXh0LnN1YnN0cmluZyh3b3JkUmFuZ2VzW3dvcmRSYW5nZXNJZHhdLnN0YXJ0LCB3b3JkUmFuZ2VzW3dvcmRSYW5nZXNJZHhdLmVuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JkUmFuZ2VzSWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lTnVtYmVyIDwgbGluZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVRleHQgPSBsaW5lc1tsaW5lTnVtYmVyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JkUmFuZ2VzID0gd29yZGVuaXplKGxpbmVUZXh0LCB3b3JkRGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29yZFJhbmdlc0lkeCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlciArPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldExpbmVXb3JkcyhsaW5lTnVtYmVyLCB3b3JkRGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdO1xuICAgICAgICBjb25zdCByYW5nZXMgPSB0aGlzLl93b3JkZW5pemUoY29udGVudCwgd29yZERlZmluaXRpb24pO1xuICAgICAgICBjb25zdCB3b3JkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHJhbmdlIG9mIHJhbmdlcykge1xuICAgICAgICAgICAgd29yZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgd29yZDogY29udGVudC5zdWJzdHJpbmcocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCksXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHJhbmdlLnN0YXJ0ICsgMSxcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IHJhbmdlLmVuZCArIDFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3b3JkcztcbiAgICB9XG4gICAgX3dvcmRlbml6ZShjb250ZW50LCB3b3JkRGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICB3b3JkRGVmaW5pdGlvbi5sYXN0SW5kZXggPSAwOyAvLyByZXNldCBsYXN0SW5kZXgganVzdCB0byBiZSBzdXJlXG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHdvcmREZWZpbml0aW9uLmV4ZWMoY29udGVudCkpIHtcbiAgICAgICAgICAgIGlmIChtYXRjaFswXS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpdCBkaWQgbWF0Y2ggdGhlIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBzdGFydDogbWF0Y2guaW5kZXgsIGVuZDogbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2V0VmFsdWVJblJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHJhbmdlID0gdGhpcy5fdmFsaWRhdGVSYW5nZShyYW5nZSk7XG4gICAgICAgIGlmIChyYW5nZS5zdGFydExpbmVOdW1iZXIgPT09IHJhbmdlLmVuZExpbmVOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9saW5lc1tyYW5nZS5zdGFydExpbmVOdW1iZXIgLSAxXS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnRDb2x1bW4gLSAxLCByYW5nZS5lbmRDb2x1bW4gLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW5lRW5kaW5nID0gdGhpcy5fZW9sO1xuICAgICAgICBjb25zdCBzdGFydExpbmVJbmRleCA9IHJhbmdlLnN0YXJ0TGluZU51bWJlciAtIDE7XG4gICAgICAgIGNvbnN0IGVuZExpbmVJbmRleCA9IHJhbmdlLmVuZExpbmVOdW1iZXIgLSAxO1xuICAgICAgICBjb25zdCByZXN1bHRMaW5lcyA9IFtdO1xuICAgICAgICByZXN1bHRMaW5lcy5wdXNoKHRoaXMuX2xpbmVzW3N0YXJ0TGluZUluZGV4XS5zdWJzdHJpbmcocmFuZ2Uuc3RhcnRDb2x1bW4gLSAxKSk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmVJbmRleCArIDE7IGkgPCBlbmRMaW5lSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0TGluZXMucHVzaCh0aGlzLl9saW5lc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TGluZXMucHVzaCh0aGlzLl9saW5lc1tlbmRMaW5lSW5kZXhdLnN1YnN0cmluZygwLCByYW5nZS5lbmRDb2x1bW4gLSAxKSk7XG4gICAgICAgIHJldHVybiByZXN1bHRMaW5lcy5qb2luKGxpbmVFbmRpbmcpO1xuICAgIH1cbiAgICBvZmZzZXRBdChwb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbiA9IHRoaXMuX3ZhbGlkYXRlUG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB0aGlzLl9lbnN1cmVMaW5lU3RhcnRzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lU3RhcnRzLmdldFByZWZpeFN1bShwb3NpdGlvbi5saW5lTnVtYmVyIC0gMikgKyAocG9zaXRpb24uY29sdW1uIC0gMSk7XG4gICAgfVxuICAgIHBvc2l0aW9uQXQob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IE1hdGguZmxvb3Iob2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoMCwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fZW5zdXJlTGluZVN0YXJ0cygpO1xuICAgICAgICBjb25zdCBvdXQgPSB0aGlzLl9saW5lU3RhcnRzLmdldEluZGV4T2Yob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbGluZUxlbmd0aCA9IHRoaXMuX2xpbmVzW291dC5pbmRleF0ubGVuZ3RoO1xuICAgICAgICAvLyBFbnN1cmUgd2UgcmV0dXJuIGEgdmFsaWQgcG9zaXRpb25cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxpbmVOdW1iZXI6IDEgKyBvdXQuaW5kZXgsXG4gICAgICAgICAgICBjb2x1bW46IDEgKyBNYXRoLm1pbihvdXQucmVtYWluZGVyLCBsaW5lTGVuZ3RoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBfdmFsaWRhdGVSYW5nZShyYW5nZSkge1xuICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuX3ZhbGlkYXRlUG9zaXRpb24oeyBsaW5lTnVtYmVyOiByYW5nZS5zdGFydExpbmVOdW1iZXIsIGNvbHVtbjogcmFuZ2Uuc3RhcnRDb2x1bW4gfSk7XG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX3ZhbGlkYXRlUG9zaXRpb24oeyBsaW5lTnVtYmVyOiByYW5nZS5lbmRMaW5lTnVtYmVyLCBjb2x1bW46IHJhbmdlLmVuZENvbHVtbiB9KTtcbiAgICAgICAgaWYgKHN0YXJ0LmxpbmVOdW1iZXIgIT09IHJhbmdlLnN0YXJ0TGluZU51bWJlclxuICAgICAgICAgICAgfHwgc3RhcnQuY29sdW1uICE9PSByYW5nZS5zdGFydENvbHVtblxuICAgICAgICAgICAgfHwgZW5kLmxpbmVOdW1iZXIgIT09IHJhbmdlLmVuZExpbmVOdW1iZXJcbiAgICAgICAgICAgIHx8IGVuZC5jb2x1bW4gIT09IHJhbmdlLmVuZENvbHVtbikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGFydExpbmVOdW1iZXI6IHN0YXJ0LmxpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHN0YXJ0LmNvbHVtbixcbiAgICAgICAgICAgICAgICBlbmRMaW5lTnVtYmVyOiBlbmQubGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBlbmRDb2x1bW46IGVuZC5jb2x1bW5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH1cbiAgICBfdmFsaWRhdGVQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgICBpZiAoIVBvc2l0aW9uLmlzSVBvc2l0aW9uKHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9zaXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBsaW5lTnVtYmVyLCBjb2x1bW4gfSA9IHBvc2l0aW9uO1xuICAgICAgICBsZXQgaGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBpZiAobGluZU51bWJlciA8IDEpIHtcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSAxO1xuICAgICAgICAgICAgY29sdW1uID0gMTtcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbmVOdW1iZXIgPiB0aGlzLl9saW5lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpbmVOdW1iZXIgPSB0aGlzLl9saW5lcy5sZW5ndGg7XG4gICAgICAgICAgICBjb2x1bW4gPSB0aGlzLl9saW5lc1tsaW5lTnVtYmVyIC0gMV0ubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF4Q2hhcmFjdGVyID0gdGhpcy5fbGluZXNbbGluZU51bWJlciAtIDFdLmxlbmd0aCArIDE7XG4gICAgICAgICAgICBpZiAoY29sdW1uIDwgMSkge1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IDE7XG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb2x1bW4gPiBtYXhDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb2x1bW4gPSBtYXhDaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gcG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBsaW5lTnVtYmVyLCBjb2x1bW4gfTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBjbGFzcyBFZGl0b3JTaW1wbGVXb3JrZXIge1xuICAgIGNvbnN0cnVjdG9yKGhvc3QsIGZvcmVpZ25Nb2R1bGVGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuX2hvc3QgPSBob3N0O1xuICAgICAgICB0aGlzLl9tb2RlbHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9mb3JlaWduTW9kdWxlRmFjdG9yeSA9IGZvcmVpZ25Nb2R1bGVGYWN0b3J5O1xuICAgICAgICB0aGlzLl9mb3JlaWduTW9kdWxlID0gbnVsbDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5fbW9kZWxzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgX2dldE1vZGVsKHVyaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZWxzW3VyaV07XG4gICAgfVxuICAgIF9nZXRNb2RlbHMoKSB7XG4gICAgICAgIGNvbnN0IGFsbCA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9tb2RlbHMpLmZvckVhY2goKGtleSkgPT4gYWxsLnB1c2godGhpcy5fbW9kZWxzW2tleV0pKTtcbiAgICAgICAgcmV0dXJuIGFsbDtcbiAgICB9XG4gICAgYWNjZXB0TmV3TW9kZWwoZGF0YSkge1xuICAgICAgICB0aGlzLl9tb2RlbHNbZGF0YS51cmxdID0gbmV3IE1pcnJvck1vZGVsKFVSSS5wYXJzZShkYXRhLnVybCksIGRhdGEubGluZXMsIGRhdGEuRU9MLCBkYXRhLnZlcnNpb25JZCk7XG4gICAgfVxuICAgIGFjY2VwdE1vZGVsQ2hhbmdlZChzdHJVUkwsIGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9tb2RlbHNbc3RyVVJMXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fbW9kZWxzW3N0clVSTF07XG4gICAgICAgIG1vZGVsLm9uRXZlbnRzKGUpO1xuICAgIH1cbiAgICBhY2NlcHRSZW1vdmVkTW9kZWwoc3RyVVJMKSB7XG4gICAgICAgIGlmICghdGhpcy5fbW9kZWxzW3N0clVSTF0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fbW9kZWxzW3N0clVSTF07XG4gICAgfVxuICAgIGFzeW5jIGNvbXB1dGVVbmljb2RlSGlnaGxpZ2h0cyh1cmwsIG9wdGlvbnMsIHJhbmdlKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwodXJsKTtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmFuZ2VzOiBbXSwgaGFzTW9yZTogZmFsc2UsIGFtYmlndW91c0NoYXJhY3RlckNvdW50OiAwLCBpbnZpc2libGVDaGFyYWN0ZXJDb3VudDogMCwgbm9uQmFzaWNBc2NpaUNoYXJhY3RlckNvdW50OiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVuaWNvZGVUZXh0TW9kZWxIaWdobGlnaHRlci5jb21wdXRlVW5pY29kZUhpZ2hsaWdodHMobW9kZWwsIG9wdGlvbnMsIHJhbmdlKTtcbiAgICB9XG4gICAgYXN5bmMgZmluZFNlY3Rpb25IZWFkZXJzKHVybCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKHVybCk7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluZFNlY3Rpb25IZWFkZXJzKG1vZGVsLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gLS0tLSBCRUdJTiBkaWZmIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXN5bmMgY29tcHV0ZURpZmYob3JpZ2luYWxVcmwsIG1vZGlmaWVkVXJsLCBvcHRpb25zLCBhbGdvcml0aG0pIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSB0aGlzLl9nZXRNb2RlbChvcmlnaW5hbFVybCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkID0gdGhpcy5fZ2V0TW9kZWwobW9kaWZpZWRVcmwpO1xuICAgICAgICBpZiAoIW9yaWdpbmFsIHx8ICFtb2RpZmllZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRWRpdG9yU2ltcGxlV29ya2VyLmNvbXB1dGVEaWZmKG9yaWdpbmFsLCBtb2RpZmllZCwgb3B0aW9ucywgYWxnb3JpdGhtKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGNvbXB1dGVEaWZmKG9yaWdpbmFsVGV4dE1vZGVsLCBtb2RpZmllZFRleHRNb2RlbCwgb3B0aW9ucywgYWxnb3JpdGhtKSB7XG4gICAgICAgIGNvbnN0IGRpZmZBbGdvcml0aG0gPSBhbGdvcml0aG0gPT09ICdhZHZhbmNlZCcgPyBsaW5lc0RpZmZDb21wdXRlcnMuZ2V0RGVmYXVsdCgpIDogbGluZXNEaWZmQ29tcHV0ZXJzLmdldExlZ2FjeSgpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbExpbmVzID0gb3JpZ2luYWxUZXh0TW9kZWwuZ2V0TGluZXNDb250ZW50KCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZXMgPSBtb2RpZmllZFRleHRNb2RlbC5nZXRMaW5lc0NvbnRlbnQoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGlmZkFsZ29yaXRobS5jb21wdXRlRGlmZihvcmlnaW5hbExpbmVzLCBtb2RpZmllZExpbmVzLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgaWRlbnRpY2FsID0gKHJlc3VsdC5jaGFuZ2VzLmxlbmd0aCA+IDAgPyBmYWxzZSA6IHRoaXMuX21vZGVsc0FyZUlkZW50aWNhbChvcmlnaW5hbFRleHRNb2RlbCwgbW9kaWZpZWRUZXh0TW9kZWwpKTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZUNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICAgICAgcmV0dXJuIGNoYW5nZXMubWFwKG0gPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKFttLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlciwgbS5vcmlnaW5hbC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCBtLm1vZGlmaWVkLnN0YXJ0TGluZU51bWJlciwgbS5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLCAoX2EgPSBtLmlubmVyQ2hhbmdlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcChtID0+IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ub3JpZ2luYWxSYW5nZS5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm9yaWdpbmFsUmFuZ2Uuc3RhcnRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm9yaWdpbmFsUmFuZ2UuZW5kTGluZU51bWJlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIG0ub3JpZ2luYWxSYW5nZS5lbmRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm1vZGlmaWVkUmFuZ2Uuc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgbS5tb2RpZmllZFJhbmdlLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgICAgbS5tb2RpZmllZFJhbmdlLmVuZExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtLm1vZGlmaWVkUmFuZ2UuZW5kQ29sdW1uLFxuICAgICAgICAgICAgICAgICAgICBdKV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkZW50aWNhbCxcbiAgICAgICAgICAgIHF1aXRFYXJseTogcmVzdWx0LmhpdFRpbWVvdXQsXG4gICAgICAgICAgICBjaGFuZ2VzOiBnZXRMaW5lQ2hhbmdlcyhyZXN1bHQuY2hhbmdlcyksXG4gICAgICAgICAgICBtb3ZlczogcmVzdWx0Lm1vdmVzLm1hcChtID0+IChbXG4gICAgICAgICAgICAgICAgbS5saW5lUmFuZ2VNYXBwaW5nLm9yaWdpbmFsLnN0YXJ0TGluZU51bWJlcixcbiAgICAgICAgICAgICAgICBtLmxpbmVSYW5nZU1hcHBpbmcub3JpZ2luYWwuZW5kTGluZU51bWJlckV4Y2x1c2l2ZSxcbiAgICAgICAgICAgICAgICBtLmxpbmVSYW5nZU1hcHBpbmcubW9kaWZpZWQuc3RhcnRMaW5lTnVtYmVyLFxuICAgICAgICAgICAgICAgIG0ubGluZVJhbmdlTWFwcGluZy5tb2RpZmllZC5lbmRMaW5lTnVtYmVyRXhjbHVzaXZlLFxuICAgICAgICAgICAgICAgIGdldExpbmVDaGFuZ2VzKG0uY2hhbmdlcylcbiAgICAgICAgICAgIF0pKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIF9tb2RlbHNBcmVJZGVudGljYWwob3JpZ2luYWwsIG1vZGlmaWVkKSB7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsTGluZUNvdW50ID0gb3JpZ2luYWwuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZUNvdW50ID0gbW9kaWZpZWQuZ2V0TGluZUNvdW50KCk7XG4gICAgICAgIGlmIChvcmlnaW5hbExpbmVDb3VudCAhPT0gbW9kaWZpZWRMaW5lQ291bnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBsaW5lID0gMTsgbGluZSA8PSBvcmlnaW5hbExpbmVDb3VudDsgbGluZSsrKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5nZXRMaW5lQ29udGVudChsaW5lKTtcbiAgICAgICAgICAgIGNvbnN0IG1vZGlmaWVkTGluZSA9IG1vZGlmaWVkLmdldExpbmVDb250ZW50KGxpbmUpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsTGluZSAhPT0gbW9kaWZpZWRMaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyBjb21wdXRlTW9yZU1pbmltYWxFZGl0cyhtb2RlbFVybCwgZWRpdHMsIHByZXR0eSkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVkaXRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgbGFzdEVvbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZWRpdHMgPSBlZGl0cy5zbGljZSgwKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICBpZiAoYS5yYW5nZSAmJiBiLnJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFJhbmdlLmNvbXBhcmVSYW5nZXNVc2luZ1N0YXJ0cyhhLnJhbmdlLCBiLnJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVvbCBvbmx5IGNoYW5nZXMgc2hvdWxkIGdvIHRvIHRoZSBlbmRcbiAgICAgICAgICAgIGNvbnN0IGFSbmcgPSBhLnJhbmdlID8gMCA6IDE7XG4gICAgICAgICAgICBjb25zdCBiUm5nID0gYi5yYW5nZSA/IDAgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIGFSbmcgLSBiUm5nO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgZWRpdHNcbiAgICAgICAgbGV0IHdyaXRlSW5kZXggPSAwO1xuICAgICAgICBmb3IgKGxldCByZWFkSW5kZXggPSAxOyByZWFkSW5kZXggPCBlZGl0cy5sZW5ndGg7IHJlYWRJbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoUmFuZ2UuZ2V0RW5kUG9zaXRpb24oZWRpdHNbd3JpdGVJbmRleF0ucmFuZ2UpLmVxdWFscyhSYW5nZS5nZXRTdGFydFBvc2l0aW9uKGVkaXRzW3JlYWRJbmRleF0ucmFuZ2UpKSkge1xuICAgICAgICAgICAgICAgIGVkaXRzW3dyaXRlSW5kZXhdLnJhbmdlID0gUmFuZ2UuZnJvbVBvc2l0aW9ucyhSYW5nZS5nZXRTdGFydFBvc2l0aW9uKGVkaXRzW3dyaXRlSW5kZXhdLnJhbmdlKSwgUmFuZ2UuZ2V0RW5kUG9zaXRpb24oZWRpdHNbcmVhZEluZGV4XS5yYW5nZSkpO1xuICAgICAgICAgICAgICAgIGVkaXRzW3dyaXRlSW5kZXhdLnRleHQgKz0gZWRpdHNbcmVhZEluZGV4XS50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JpdGVJbmRleCsrO1xuICAgICAgICAgICAgICAgIGVkaXRzW3dyaXRlSW5kZXhdID0gZWRpdHNbcmVhZEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlZGl0cy5sZW5ndGggPSB3cml0ZUluZGV4ICsgMTtcbiAgICAgICAgZm9yIChsZXQgeyByYW5nZSwgdGV4dCwgZW9sIH0gb2YgZWRpdHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW9sID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGxhc3RFb2wgPSBlb2w7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoUmFuZ2UuaXNFbXB0eShyYW5nZSkgJiYgIXRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBlbXB0eSBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsID0gbW9kZWwuZ2V0VmFsdWVJblJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbnxcXG58XFxyL2csIG1vZGVsLmVvbCk7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWwgPT09IHRleHQpIHtcbiAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgZGlmZiB3b24ndCB0YWtlIHRvbyBsb25nXG4gICAgICAgICAgICBpZiAoTWF0aC5tYXgodGV4dC5sZW5ndGgsIG9yaWdpbmFsLmxlbmd0aCkgPiBFZGl0b3JTaW1wbGVXb3JrZXIuX2RpZmZMaW1pdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgcmFuZ2UsIHRleHQgfSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb21wdXRlIGRpZmYgYmV0d2VlbiBvcmlnaW5hbCBhbmQgZWRpdC50ZXh0XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gc3RyaW5nRGlmZihvcmlnaW5hbCwgdGV4dCwgcHJldHR5KTtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRPZmZzZXQgPSBtb2RlbC5vZmZzZXRBdChSYW5nZS5saWZ0KHJhbmdlKS5nZXRTdGFydFBvc2l0aW9uKCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbW9kZWwucG9zaXRpb25BdChlZGl0T2Zmc2V0ICsgY2hhbmdlLm9yaWdpbmFsU3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IG1vZGVsLnBvc2l0aW9uQXQoZWRpdE9mZnNldCArIGNoYW5nZS5vcmlnaW5hbFN0YXJ0ICsgY2hhbmdlLm9yaWdpbmFsTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdFZGl0ID0ge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0ZXh0LnN1YnN0cihjaGFuZ2UubW9kaWZpZWRTdGFydCwgY2hhbmdlLm1vZGlmaWVkTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHsgc3RhcnRMaW5lTnVtYmVyOiBzdGFydC5saW5lTnVtYmVyLCBzdGFydENvbHVtbjogc3RhcnQuY29sdW1uLCBlbmRMaW5lTnVtYmVyOiBlbmQubGluZU51bWJlciwgZW5kQ29sdW1uOiBlbmQuY29sdW1uIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5nZXRWYWx1ZUluUmFuZ2UobmV3RWRpdC5yYW5nZSkgIT09IG5ld0VkaXQudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXdFZGl0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsYXN0RW9sID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBlb2w6IGxhc3RFb2wsIHRleHQ6ICcnLCByYW5nZTogeyBzdGFydExpbmVOdW1iZXI6IDAsIHN0YXJ0Q29sdW1uOiAwLCBlbmRMaW5lTnVtYmVyOiAwLCBlbmRDb2x1bW46IDAgfSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyAtLS0tIEVORCBtaW5pbWFsIGVkaXRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXB1dGVMaW5rcyhtb2RlbFVybCkge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXB1dGVMaW5rcyhtb2RlbCk7XG4gICAgfVxuICAgIC8vIC0tLSBCRUdJTiBkZWZhdWx0IGRvY3VtZW50IGNvbG9ycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFzeW5jIGNvbXB1dGVEZWZhdWx0RG9jdW1lbnRDb2xvcnMobW9kZWxVcmwpIHtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0aGlzLl9nZXRNb2RlbChtb2RlbFVybCk7XG4gICAgICAgIGlmICghbW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wdXRlRGVmYXVsdERvY3VtZW50Q29sb3JzKG1vZGVsKTtcbiAgICB9XG4gICAgYXN5bmMgdGV4dHVhbFN1Z2dlc3QobW9kZWxVcmxzLCBsZWFkaW5nV29yZCwgd29yZERlZiwgd29yZERlZkZsYWdzKSB7XG4gICAgICAgIGNvbnN0IHN3ID0gbmV3IFN0b3BXYXRjaCgpO1xuICAgICAgICBjb25zdCB3b3JkRGVmUmVnRXhwID0gbmV3IFJlZ0V4cCh3b3JkRGVmLCB3b3JkRGVmRmxhZ3MpO1xuICAgICAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgICAgICBvdXRlcjogZm9yIChjb25zdCB1cmwgb2YgbW9kZWxVcmxzKSB7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKHVybCk7XG4gICAgICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdvcmQgb2YgbW9kZWwud29yZHMod29yZERlZlJlZ0V4cCkpIHtcbiAgICAgICAgICAgICAgICBpZiAod29yZCA9PT0gbGVhZGluZ1dvcmQgfHwgIWlzTmFOKE51bWJlcih3b3JkKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlZW4uYWRkKHdvcmQpO1xuICAgICAgICAgICAgICAgIGlmIChzZWVuLnNpemUgPiBFZGl0b3JTaW1wbGVXb3JrZXIuX3N1Z2dlc3Rpb25zTGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHdvcmRzOiBBcnJheS5mcm9tKHNlZW4pLCBkdXJhdGlvbjogc3cuZWxhcHNlZCgpIH07XG4gICAgfVxuICAgIC8vIC0tLS0gRU5EIHN1Z2dlc3QgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyNyZWdpb24gLS0gd29yZCByYW5nZXMgLS1cbiAgICBhc3luYyBjb21wdXRlV29yZFJhbmdlcyhtb2RlbFVybCwgcmFuZ2UsIHdvcmREZWYsIHdvcmREZWZGbGFncykge1xuICAgICAgICBjb25zdCBtb2RlbCA9IHRoaXMuX2dldE1vZGVsKG1vZGVsVXJsKTtcbiAgICAgICAgaWYgKCFtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd29yZERlZlJlZ0V4cCA9IG5ldyBSZWdFeHAod29yZERlZiwgd29yZERlZkZsYWdzKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbGluZSA9IHJhbmdlLnN0YXJ0TGluZU51bWJlcjsgbGluZSA8IHJhbmdlLmVuZExpbmVOdW1iZXI7IGxpbmUrKykge1xuICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBtb2RlbC5nZXRMaW5lV29yZHMobGluZSwgd29yZERlZlJlZ0V4cCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHdvcmQgb2Ygd29yZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKE51bWJlcih3b3JkLndvcmQpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGFycmF5ID0gcmVzdWx0W3dvcmQud29yZF07XG4gICAgICAgICAgICAgICAgaWYgKCFhcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBhcnJheSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbd29yZC53b3JkXSA9IGFycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcnJheS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiBsaW5lLFxuICAgICAgICAgICAgICAgICAgICBzdGFydENvbHVtbjogd29yZC5zdGFydENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgZW5kTGluZU51bWJlcjogbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kQ29sdW1uOiB3b3JkLmVuZENvbHVtblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vI2VuZHJlZ2lvblxuICAgIGFzeW5jIG5hdmlnYXRlVmFsdWVTZXQobW9kZWxVcmwsIHJhbmdlLCB1cCwgd29yZERlZiwgd29yZERlZkZsYWdzKSB7XG4gICAgICAgIGNvbnN0IG1vZGVsID0gdGhpcy5fZ2V0TW9kZWwobW9kZWxVcmwpO1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JkRGVmUmVnRXhwID0gbmV3IFJlZ0V4cCh3b3JkRGVmLCB3b3JkRGVmRmxhZ3MpO1xuICAgICAgICBpZiAocmFuZ2Uuc3RhcnRDb2x1bW4gPT09IHJhbmdlLmVuZENvbHVtbikge1xuICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnRMaW5lTnVtYmVyOiByYW5nZS5zdGFydExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgc3RhcnRDb2x1bW46IHJhbmdlLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgICAgIGVuZExpbmVOdW1iZXI6IHJhbmdlLmVuZExpbmVOdW1iZXIsXG4gICAgICAgICAgICAgICAgZW5kQ29sdW1uOiByYW5nZS5lbmRDb2x1bW4gKyAxXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvblRleHQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2UocmFuZ2UpO1xuICAgICAgICBjb25zdCB3b3JkUmFuZ2UgPSBtb2RlbC5nZXRXb3JkQXRQb3NpdGlvbih7IGxpbmVOdW1iZXI6IHJhbmdlLnN0YXJ0TGluZU51bWJlciwgY29sdW1uOiByYW5nZS5zdGFydENvbHVtbiB9LCB3b3JkRGVmUmVnRXhwKTtcbiAgICAgICAgaWYgKCF3b3JkUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmQgPSBtb2RlbC5nZXRWYWx1ZUluUmFuZ2Uod29yZFJhbmdlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQmFzaWNJbnBsYWNlUmVwbGFjZS5JTlNUQU5DRS5uYXZpZ2F0ZVZhbHVlU2V0KHJhbmdlLCBzZWxlY3Rpb25UZXh0LCB3b3JkUmFuZ2UsIHdvcmQsIHVwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gLS0tLSBCRUdJTiBmb3JlaWduIG1vZHVsZSBzdXBwb3J0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgbG9hZEZvcmVpZ25Nb2R1bGUobW9kdWxlSWQsIGNyZWF0ZURhdGEsIGZvcmVpZ25Ib3N0TWV0aG9kcykge1xuICAgICAgICBjb25zdCBwcm94eU1ldGhvZFJlcXVlc3QgPSAobWV0aG9kLCBhcmdzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faG9zdC5maHIobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZm9yZWlnbkhvc3QgPSBjcmVhdGVQcm94eU9iamVjdChmb3JlaWduSG9zdE1ldGhvZHMsIHByb3h5TWV0aG9kUmVxdWVzdCk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGhvc3Q6IGZvcmVpZ25Ib3N0LFxuICAgICAgICAgICAgZ2V0TWlycm9yTW9kZWxzOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldE1vZGVscygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5fZm9yZWlnbk1vZHVsZUZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZvcmVpZ25Nb2R1bGUgPSB0aGlzLl9mb3JlaWduTW9kdWxlRmFjdG9yeShjdHgsIGNyZWF0ZURhdGEpO1xuICAgICAgICAgICAgLy8gc3RhdGljIGZvcmVpbmcgbW9kdWxlXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGdldEFsbE1ldGhvZE5hbWVzKHRoaXMuX2ZvcmVpZ25Nb2R1bGUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFU00tY29tbWVudC1iZWdpblxuICAgICAgICAvLyBcdFx0cmV0dXJuIG5ldyBQcm9taXNlPGFueT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAvLyBcdFx0XHRyZXF1aXJlKFttb2R1bGVJZF0sIChmb3JlaWduTW9kdWxlOiB7IGNyZWF0ZTogSUZvcmVpZ25Nb2R1bGVGYWN0b3J5IH0pID0+IHtcbiAgICAgICAgLy8gXHRcdFx0XHR0aGlzLl9mb3JlaWduTW9kdWxlID0gZm9yZWlnbk1vZHVsZS5jcmVhdGUoY3R4LCBjcmVhdGVEYXRhKTtcbiAgICAgICAgLy8gXG4gICAgICAgIC8vIFx0XHRcdFx0cmVzb2x2ZShnZXRBbGxNZXRob2ROYW1lcyh0aGlzLl9mb3JlaWduTW9kdWxlKSk7XG4gICAgICAgIC8vIFxuICAgICAgICAvLyBcdFx0XHR9LCByZWplY3QpO1xuICAgICAgICAvLyBcdFx0fSk7XG4gICAgICAgIC8vIEVTTS1jb21tZW50LWVuZFxuICAgICAgICAvLyBFU00tdW5jb21tZW50LWJlZ2luXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdXNhZ2VgKSk7XG4gICAgICAgIC8vIEVTTS11bmNvbW1lbnQtZW5kXG4gICAgfVxuICAgIC8vIGZvcmVpZ24gbWV0aG9kIHJlcXVlc3RcbiAgICBmbXIobWV0aG9kLCBhcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5fZm9yZWlnbk1vZHVsZSB8fCB0eXBlb2YgdGhpcy5fZm9yZWlnbk1vZHVsZVttZXRob2RdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdNaXNzaW5nIHJlcXVlc3RIYW5kbGVyIG9yIG1ldGhvZDogJyArIG1ldGhvZCkpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2ZvcmVpZ25Nb2R1bGVbbWV0aG9kXS5hcHBseSh0aGlzLl9mb3JlaWduTW9kdWxlLCBhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIC0tLS0gRU5EIGRpZmYgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIC0tLS0gQkVHSU4gbWluaW1hbCBlZGl0cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbkVkaXRvclNpbXBsZVdvcmtlci5fZGlmZkxpbWl0ID0gMTAwMDAwO1xuLy8gLS0tLSBCRUdJTiBzdWdnZXN0IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5FZGl0b3JTaW1wbGVXb3JrZXIuX3N1Z2dlc3Rpb25zTGltaXQgPSAxMDAwMDtcbi8qKlxuICogQ2FsbGVkIG9uIHRoZSB3b3JrZXIgc2lkZVxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoaG9zdCkge1xuICAgIHJldHVybiBuZXcgRWRpdG9yU2ltcGxlV29ya2VyKGhvc3QsIG51bGwpO1xufVxuaWYgKHR5cGVvZiBpbXBvcnRTY3JpcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gUnVubmluZyBpbiBhIHdlYiB3b3JrZXJcbiAgICBnbG9iYWxUaGlzLm1vbmFjbyA9IGNyZWF0ZU1vbmFjb0Jhc2VBUEkoKTtcbn1cbiIsIi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiAgQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuaW1wb3J0IHsgU2ltcGxlV29ya2VyU2VydmVyIH0gZnJvbSAnLi4vYmFzZS9jb21tb24vd29ya2VyL3NpbXBsZVdvcmtlci5qcyc7XG5pbXBvcnQgeyBFZGl0b3JTaW1wbGVXb3JrZXIgfSBmcm9tICcuL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JTaW1wbGVXb3JrZXIuanMnO1xubGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZShmb3JlaWduTW9kdWxlKSB7XG4gICAgaWYgKGluaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIGNvbnN0IHNpbXBsZVdvcmtlciA9IG5ldyBTaW1wbGVXb3JrZXJTZXJ2ZXIoKG1zZykgPT4ge1xuICAgICAgICBnbG9iYWxUaGlzLnBvc3RNZXNzYWdlKG1zZyk7XG4gICAgfSwgKGhvc3QpID0+IG5ldyBFZGl0b3JTaW1wbGVXb3JrZXIoaG9zdCwgZm9yZWlnbk1vZHVsZSkpO1xuICAgIGdsb2JhbFRoaXMub25tZXNzYWdlID0gKGUpID0+IHtcbiAgICAgICAgc2ltcGxlV29ya2VyLm9ubWVzc2FnZShlLmRhdGEpO1xuICAgIH07XG59XG5nbG9iYWxUaGlzLm9ubWVzc2FnZSA9IChlKSA9PiB7XG4gICAgLy8gSWdub3JlIGZpcnN0IG1lc3NhZ2UgaW4gdGhpcyBjYXNlIGFuZCBpbml0aWFsaXplIGlmIG5vdCB5ZXQgaW5pdGlhbGl6ZWRcbiAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICAgIGluaXRpYWxpemUobnVsbCk7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///49\n")},606:module=>{eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjA2LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2FuZGJveC8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanM/ZjI4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///606\n")}},__webpack_module_cache__={};function __webpack_require__(g){var I=__webpack_module_cache__[g];if(void 0!==I)return I.exports;var C=__webpack_module_cache__[g]={exports:{}};return __webpack_modules__[g](C,C.exports,__webpack_require__),C.exports}var __webpack_exports__=__webpack_require__(49)})();